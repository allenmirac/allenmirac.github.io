<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Makefile 学习</title>
      <link href="/2024/01/21/makefile-xue-xi/"/>
      <url>/2024/01/21/makefile-xue-xi/</url>
      
        <content type="html"><![CDATA[<h1 id="Makefile-学习"><a href="#Makefile-学习" class="headerlink" title="Makefile 学习"></a>Makefile 学习</h1><h1 id="C语言的编译过程"><a href="#C语言的编译过程" class="headerlink" title="C语言的编译过程"></a>C语言的编译过程</h1><h2 id="预处理（Preprocessing）"><a href="#预处理（Preprocessing）" class="headerlink" title="预处理（Preprocessing）"></a>预处理（Preprocessing）</h2><p>-E是让编译器在<strong>预处理之后</strong>就退出，不进行后续编译过程；-o是指定输出文件名。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">gcc <span class="token parameter variable">-E</span> hello.c <span class="token parameter variable">-o</span> hello.i<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="编译（Compilation）"><a href="#编译（Compilation）" class="headerlink" title="编译（Compilation）"></a>编译（Compilation）</h2><p><img src="https://s2.loli.net/2024/01/13/qWfwmgaBdeONbnZ.png"></p><p>这里的编译不是指程序从源文件到二进制程序的全部过程，而是指将经过预处理文件（test.i）之后的程序转换成特定汇编（test.s）代码的过程。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">gcc <span class="token parameter variable">-S</span> hello.i <span class="token parameter variable">-o</span> hello.s<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h2><p>汇编过程将上一步的汇编代码转换成机器码，这一步产生的文件叫做目标文件，是二进制格式。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">gcc <span class="token parameter variable">-c</span> hello.s <span class="token parameter variable">-o</span> hello.o<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p>链接过程使用链接器将该目标文件与其他目标文件、库文件、启动文件等链接起来生成可执行文件。附加的目标文件包括静态连接库和动态连接库。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">gcc hello.o <span class="token parameter variable">-o</span> hello<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>生成可执行程序过程为成四个步骤：</p><p>1、由.c文件到.i文件，这个过程叫预处理。<br>2、由.i文件到.s文件，这个过程叫编译。<br>3、由.s文件到.o文件，这个过程叫汇编。<br>4、由.o文件到可执行文件，这个过程叫链接。</p><h2 id="静态库"><a href="#静态库" class="headerlink" title="静态库"></a>静态库</h2><p>在编译的过程中，会被直接载入到可执行文件中，将多个文件组成一个库，实现复用，以lib开头，以.a结尾，使用ar命令</p><h2 id="动态库"><a href="#动态库" class="headerlink" title="动态库"></a>动态库</h2><p>在程序编译时并不会被连接到目标代码中，而是在程序运行是才被载入。这就带来了一个明显的好处：不同的应用程序如果调用相同的库，那么在内存里<strong>只需要有一份该共享库的实例</strong>，减小了各个模块之间的耦合程度，也减小了可执行文件的体积。</p><h1 id="MakeFile"><a href="#MakeFile" class="headerlink" title="MakeFile"></a>MakeFile</h1><h2 id="基本格式"><a href="#基本格式" class="headerlink" title="基本格式"></a>基本格式</h2><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token target symbol">target ...</span> <span class="token punctuation">:</span> prerequisites ...    command    ...    ...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>make debug执行下面的命令</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token target symbol">debug</span><span class="token punctuation">:</span>echo hello<span class="token builtin-target builtin">.PHONY</span><span class="token punctuation">:</span> clean <span class="token comment"># 伪目标</span><span class="token target symbol">clean</span><span class="token punctuation">:</span>rm *.o<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">cpp <span class="token operator">:=</span> src/main.cppobj <span class="token operator">:=</span> obj/main.o<span class="token target symbol"><span class="token variable">$</span>&#123;obj&#125;</span><span class="token punctuation">:</span> <span class="token variable">$</span><span class="token punctuation">&#123;</span>cpp<span class="token punctuation">&#125;</span>g++ -c <span class="token variable">$</span><span class="token punctuation">&#123;</span>cpp<span class="token punctuation">&#125;</span> -o <span class="token variable">$</span><span class="token punctuation">&#123;</span>obj<span class="token punctuation">&#125;</span><span class="token comment"># $@ target的名称</span><span class="token comment"># $&lt; 第一个依赖文件</span><span class="token comment"># $^ 所有的依赖文件</span><span class="token target symbol">compile</span><span class="token punctuation">:</span> <span class="token variable">$</span><span class="token punctuation">&#123;</span>obj<span class="token punctuation">&#125;</span><span class="token target symbol">clean</span><span class="token punctuation">:</span>rm -rf obj<span class="token comment"># Windows下使用del obj</span><span class="token builtin-target builtin">.PHONY</span><span class="token punctuation">:</span> clean debug<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="运算符号"><a href="#运算符号" class="headerlink" title="运算符号"></a>运算符号</h2><p>:&#x3D;：赋值后不可改变</p><p>&#x3D; ：可以改变</p><p>?&#x3D;：在变量尚未设置时才将其设置为值</p><p>+&#x3D;：添加</p><p>\：续行符</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>shell：把执行操作系统命令后的输出作为函数返回，本质上就是执行shell命令。</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">cpp_srcs <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">&#123;</span>shell find src -name *.cpp<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>subst、patsubst</p><p>格式：源字符串都是<code>&lt;text&gt;</code>的内容</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">subst</span> &lt;from>,&lt;to>,&lt;text><span class="token punctuation">)</span><span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">patsubst</span> &lt;pattern>,&lt;replacement>,&lt;text><span class="token punctuation">)</span> <span class="token comment"># pattern中的%和replacement中的%相同</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>foreach</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">foreach</span> &lt;var>,&lt;list>,&lt;text><span class="token punctuation">)</span><span class="token comment"># eg</span>names <span class="token operator">:=</span> a b c dfiles <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">foreach</span> n,<span class="token variable">$</span><span class="token punctuation">(</span>names<span class="token punctuation">)</span>,<span class="token variable">$</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span>.o<span class="token punctuation">)</span><span class="token comment"># $(file) := a.o b.o c.o d.o </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>dir</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">dir</span> &lt;names...><span class="token punctuation">)</span> <span class="token comment">#取目录函数</span><span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">dir</span> src/foo.c hacks<span class="token punctuation">)</span> <span class="token comment"># 返回值是 src/ ./</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>notdir、filter</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">notdir</span> &lt;names...><span class="token punctuation">)</span> <span class="token comment"># 取文件函数</span><span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">notdir</span> src/foo.c hacks<span class="token punctuation">)</span> <span class="token comment"># 返回值是 foo.c hacks</span><span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">filter</span> &lt;pattern...>,&lt;text><span class="token punctuation">)</span> <span class="token comment"># 过滤出text中符合pattern的字符串</span>sources <span class="token operator">:=</span> foo.c bar.c baz.s ugh.h<span class="token target symbol">foo</span><span class="token punctuation">:</span> <span class="token variable">$</span><span class="token punctuation">(</span>sources<span class="token punctuation">)</span>cc <span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">filter</span> %.c %.s,<span class="token variable">$</span><span class="token punctuation">(</span>sources<span class="token punctuation">)</span><span class="token punctuation">)</span> -o foo <span class="token comment"># $(filter %.c %.s,$(sources)) 返回的值是 foo.c bar.c baz.s</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="编译带有头文件的项目"><a href="#编译带有头文件的项目" class="headerlink" title="编译带有头文件的项目"></a>编译带有头文件的项目</h2><p>Makefile示例（1）：</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">cpp_srcs <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">shell</span> find src -name *.cpp<span class="token punctuation">)</span>cpp_objs <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">patsubst</span> src/%.cpp,objs/%.o,<span class="token variable">$</span><span class="token punctuation">(</span>cpp_srcs<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment"># 你的头文件所在文件夹路径（建议绝对路径）</span>include_paths <span class="token operator">:=</span> I_flag        <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span>include_paths<span class="token punctuation">:</span>%<span class="token operator">=</span>-I%<span class="token punctuation">)</span><span class="token target symbol">objs/%.o</span> <span class="token punctuation">:</span> src/%.cpp<span class="token operator">@</span>mkdir -p <span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">dir</span> <span class="token variable">$@</span><span class="token punctuation">)</span><span class="token operator">@</span>g++ -c <span class="token variable">$^</span> -o <span class="token variable">$@</span> <span class="token variable">$</span><span class="token punctuation">(</span>I_flag<span class="token punctuation">)</span><span class="token target symbol">workspace/exec</span> <span class="token punctuation">:</span> <span class="token variable">$</span><span class="token punctuation">(</span>cpp_objs<span class="token punctuation">)</span><span class="token operator">@</span>mkdir -p <span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">dir</span> <span class="token variable">$@</span><span class="token punctuation">)</span><span class="token operator">@</span>g++ <span class="token variable">$^</span> -o <span class="token variable">$@</span> <span class="token target symbol">run</span> <span class="token punctuation">:</span> workspace/exec<span class="token operator">@</span>./<span class="token variable">$&lt;</span><span class="token target symbol">debug</span> <span class="token punctuation">:</span><span class="token operator">@</span>echo <span class="token variable">$</span><span class="token punctuation">(</span>I_flag<span class="token punctuation">)</span><span class="token target symbol">clean</span> <span class="token punctuation">:</span><span class="token operator">@</span>rm -rf objs<span class="token builtin-target builtin">.PHONY</span> <span class="token punctuation">:</span> debug run<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Makefile示例（2）：</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token comment"># Compiler</span>CXX <span class="token operator">:=</span> g++<span class="token comment"># cpp sources</span>cpp_srcs <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">&#123;</span>shell find src -name *.cpp<span class="token punctuation">&#125;</span><span class="token comment"># $(warning cpp_srcs is $&#123;cpp_srcs&#125;)</span><span class="token comment"># cpp objects</span>cpp_objs <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">&#123;</span>patsubst src/%.cpp,objs/%.o,<span class="token variable">$</span><span class="token punctuation">&#123;</span>cpp_srcs<span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment"># $(warning cpp_objs is $&#123;cpp_objs&#125;)</span><span class="token comment"># cpp include path</span>include_path <span class="token operator">:=</span> /home/mirac/Desktop/Retest/<span class="token keyword">include</span>I_flags <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">&#123;</span>include_path<span class="token punctuation">:</span>%<span class="token operator">=</span>-I%<span class="token punctuation">&#125;</span><span class="token comment"># $&#123;warning I_flags is $&#123;I_flags&#125;&#125;</span><span class="token comment"># compile option</span>Compile_option <span class="token operator">:=</span> -g -O3 -wCompile_option <span class="token operator">+=</span> <span class="token variable">$</span><span class="token punctuation">&#123;</span>I_flags<span class="token punctuation">&#125;</span><span class="token comment"># $(warning Compile_option is $&#123;Compile_option&#125;)</span><span class="token target symbol">objs/%.o</span> <span class="token punctuation">:</span> src/%.cpp<span class="token operator">@</span>mkdir -p <span class="token variable">$</span><span class="token punctuation">&#123;</span>dir <span class="token variable">$@</span><span class="token punctuation">&#125;</span><span class="token operator">@</span><span class="token variable">$</span><span class="token punctuation">&#123;</span>CXX<span class="token punctuation">&#125;</span> -o <span class="token variable">$@</span> -c <span class="token variable">$^</span>  <span class="token variable">$</span><span class="token punctuation">&#123;</span>Compile_option<span class="token punctuation">&#125;</span><span class="token target symbol">workspace/testJson</span><span class="token punctuation">:</span> <span class="token variable">$</span><span class="token punctuation">&#123;</span>cpp_objs<span class="token punctuation">&#125;</span><span class="token operator">@</span><span class="token variable">$</span><span class="token punctuation">&#123;</span>CXX<span class="token punctuation">&#125;</span> -o <span class="token variable">$@</span>  <span class="token variable">$^</span> <span class="token target symbol">run</span> <span class="token punctuation">:</span> workspace/testJson<span class="token operator">@</span>./<span class="token variable">$&lt;</span><span class="token target symbol">debug</span><span class="token punctuation">:</span>echo <span class="token variable">$</span><span class="token punctuation">&#123;</span>cpp_srcs<span class="token punctuation">&#125;</span>echo <span class="token variable">$</span><span class="token punctuation">&#123;</span>cpp_objs<span class="token punctuation">&#125;</span>echo <span class="token variable">$</span><span class="token punctuation">&#123;</span>I_flags<span class="token punctuation">&#125;</span><span class="token comment"># @echo $&#123;CC&#125; -o $@ -c $^  $&#123;Compile_option&#125;</span><span class="token target symbol">clean</span> <span class="token punctuation">:</span> <span class="token operator">@</span>rm -r objs<span class="token operator">@</span>rm -r workspace/*<span class="token builtin-target builtin">.PHONY</span><span class="token punctuation">:</span> clean debug<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++指针复习</title>
      <link href="/2024/01/19/c-de-zhi-zhen-fu-xi/"/>
      <url>/2024/01/19/c-de-zhi-zhen-fu-xi/</url>
      
        <content type="html"><![CDATA[<h2 id="const修饰指针"><a href="#const修饰指针" class="headerlink" title="const修饰指针"></a>const修饰指针</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;using namespace std;class Rectangle&#123;  public:  Rectangle(int length, int width)&#123;chang&#x3D;length; kuan&#x3D;width;&#125;    void SetLength(int length)&#123; chang&#x3D;length;&#125;    int GetLength() const&#123; return chang;&#125;  private:    int chang;    int kuan;&#125;;int main()&#123;  &#x2F;&#x2F; int a&#x3D;123;  &#x2F;&#x2F; const int *p&#x3D;&amp;a;&#x2F;&#x2F;const 修饰*，p可以改  &#x2F;&#x2F; cout&lt;&lt;*p&lt;&lt;endl;  &#x2F;&#x2F; int b&#x3D;567;  &#x2F;&#x2F; p&#x3D;&amp;b;  &#x2F;&#x2F; cout&lt;&lt;*p&lt;&lt;endl;  &#x2F;&#x2F; int const *p1&#x3D;&amp;a;  &#x2F;&#x2F; int * const p2&#x3D;&amp;b;const 修饰p2，*p2可以改  &#x2F;&#x2F; *p2&#x3D;789;  &#x2F;&#x2F; &#x2F;&#x2F; p2&#x3D;&amp;a;  &#x2F;&#x2F; cout&lt;&lt;*p2&lt;&lt;endl;  Rectangle *rec&#x3D;new Rectangle(123, 456);  Rectangle *rec1&#x3D;new Rectangle(789, 456);  cout&lt;&lt;rec-&gt;GetLength()&lt;&lt;endl;  const Rectangle * pRec&#x3D;rec;  cout&lt;&lt;pRec-&gt;GetLength()&lt;&lt;endl;  pRec&#x3D;rec1;&#x2F;&#x2F;同p  cout&lt;&lt;pRec-&gt;GetLength()&lt;&lt;endl;&#x2F;&#x2F;只能调用const方法  Rectangle * const pRec1&#x3D;rec;&#x2F;&#x2F;同p2  cout&lt;&lt;pRec1-&gt;GetLength()&lt;&lt;endl;  Rectangle *pPrec0&#x3D;rec;  pPrec0-&gt;SetLength(789);&#x2F;&#x2F;非const方法也可以调用  cout&lt;&lt;pRec-&gt;GetLength()&lt;&lt;endl;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="一维数组指针的区别"><a href="#一维数组指针的区别" class="headerlink" title="一维数组指针的区别"></a>一维数组指针的区别</h2><p>a代表首地址，在sizeof和&amp;a时当成了数组整体</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;using namespace std;#define sz(type) cout&lt;&lt;sizeof(type)&lt;&lt;endl;int main()&#123;  int a[3]&#x3D;&#123;12,13,14&#125;;  sz(a);  cout&lt;&lt;a&lt;&lt;endl;  cout&lt;&lt;&amp;a&lt;&lt;endl;  cout&lt;&lt;&amp;a[0]&lt;&lt;endl;  &#x2F;*  12  0x9ffdb4  0x9ffdb4  0x9ffdb4  *&#x2F;  cout&lt;&lt;endl;  cout&lt;&lt;a&lt;&lt;&quot; &quot;&lt;&lt;a+1&lt;&lt;&quot; &quot;&lt;&lt;a+2&lt;&lt;endl;            &#x2F;&#x2F;a &#x3D; &amp;a[0] !&#x3D; &amp;a  cout&lt;&lt;&amp;a&lt;&lt;&quot; &quot;&lt;&lt;&amp;a+1&lt;&lt;&quot; &quot;&lt;&lt;&amp;a+2&lt;&lt;endl;  cout&lt;&lt;&amp;a[0]&lt;&lt;&quot; &quot;&lt;&lt;&amp;a[0]+1&lt;&lt;&quot; &quot;&lt;&lt;&amp;a[0]+2&lt;&lt;endl;  &#x2F;*  0x9ffdb4 0x9ffdb8 0x9ffdbc  &#x2F;&#x2F;步长是4，一个int  0x9ffdb4 0x9ffdc0 0x9ffdcc  &#x2F;&#x2F;步长是12，三个int，也就是数组长度  0x9ffdb4 0x9ffdb8 0x9ffdbc  &#x2F;&#x2F;步长是4，一个int  *&#x2F;  return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="二维数组指针的区别"><a href="#二维数组指针的区别" class="headerlink" title="二维数组指针的区别"></a>二维数组指针的区别</h2><p>注意与一维指针类比区别开来。</p><p>指针有减法和比较运算，没有加法运算。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;using namespace std;#define sz(type) cout&lt;&lt;sizeof(type)&lt;&lt;endl;int main()&#123;  int a[2][3]&#x3D;&#123;    &#123;12,13,14&#125;,    &#123;112,113,114&#125;  &#125;;  sz(a);  sz(a[0]);  sz(a[0][0]);  cout&lt;&lt;a&lt;&lt;endl;  cout&lt;&lt;&amp;a[0]&lt;&lt;endl;  cout&lt;&lt;a[0]&lt;&lt;endl;  cout&lt;&lt;&amp;a[0][0]&lt;&lt;endl;    cout&lt;&lt;endl;&#x2F;&#x2F;步长是三个元素的数组的长度  cout&lt;&lt;&quot;a: &quot;&lt;&lt;a&lt;&lt;&quot; &quot;&lt;&lt;a+1&lt;&lt;endl;           &#x2F;&#x2F;a &#x3D; &amp;a[0]  cout&lt;&lt;&quot;&amp;a[0]:&quot;&lt;&lt;&amp;a[0]&lt;&lt;&quot; &quot;&lt;&lt;&amp;a[0]+1&lt;&lt;endl;  cout&lt;&lt;endl;&#x2F;&#x2F;步长是一个int  cout&lt;&lt;&quot;a[0]: &quot;&lt;&lt;a[0]&lt;&lt;&quot; &quot;&lt;&lt;a[0]+1&lt;&lt;endl;  &#x2F;&#x2F;a[0] &#x3D; &amp;a[0][0]  cout&lt;&lt;&quot;&amp;a[0][0]: &quot;&lt;&lt;&amp;a[0][0]&lt;&lt;&quot; &quot;&lt;&lt;&amp;a[0][0]+1&lt;&lt;endl;  cout&lt;&lt;endl;  cout&lt;&lt;&quot;&amp;a: &quot;&lt;&lt;&amp;a&lt;&lt;&quot; &quot;&lt;&lt;&amp;a+1&lt;&lt;endl;&#x2F;&#x2F;步长是二维数组的长度  return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="指针作为函数的参数"><a href="#指针作为函数的参数" class="headerlink" title="指针作为函数的参数"></a>指针作为函数的参数</h2><p>使用swap（交换两个变量的值）作为演示，实现Swap的四种方法。当数组名作为<strong>函数的参数</strong>来传递的时候，他的高贵的数组结构特性已经失去了，成了一个地地道道的只拥有4个字节的平民。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;using namespace std;#define SWAP(a, b, temp) (temp&#x3D;a, a&#x3D;b, b&#x3D;temp);void func(int *x, int *y)&#123;  int z&#x3D;*x;  *x&#x3D;*y;  *y&#x3D;z;&#125;void func1(int &amp;x, int &amp;y)&#123;  cout&lt;&lt;x&lt;&lt;&quot; &quot;&lt;&lt;y&lt;&lt;endl;   int z&#x3D;x;  x&#x3D;y;  y&#x3D;z;&#125;template&lt;class T&gt;void Swap(T &amp;a, T&amp;b)&#123;  T temp&#x3D;a;  a&#x3D;b;  b&#x3D;temp;&#125;int main()&#123;  float a&#x3D;12.1, b&#x3D;13.2;  cout&lt;&lt;a&lt;&lt;&quot; &quot;&lt;&lt;b&lt;&lt;endl;  &#x2F;&#x2F; int c&#x3D;a;  &#x2F;&#x2F; a&#x3D;b;  &#x2F;&#x2F; b&#x3D;c;  float c;  Swap(a, b);  cout&lt;&lt;a&lt;&lt;&quot; &quot;&lt;&lt;b&lt;&lt;endl;  return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="指针作为返回值"><a href="#指针作为返回值" class="headerlink" title="指针作为返回值"></a>指针作为返回值</h2><p>要作为返回值，必须保证调用后返回的指针不会销毁，否则就是野指针。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;using namespace std;int a[3];&#x2F;&#x2F;全局变量默认初始化为0int * func()&#123;  return a;&#125;int main()&#123;  int a&#x3D;1;  cout&lt;&lt;func()[0]&lt;&lt;&quot; &quot;&lt;&lt;func()[1]&lt;&lt;endl;  return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="字符数组指针"><a href="#字符数组指针" class="headerlink" title="字符数组指针"></a>字符数组指针</h2><p>1、str和p是不相同的！！</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;cstring&gt;int main() &#123;  char str[3]&#x3D;&quot;ab&quot;;  char *p&#x3D;str;&#x2F;&#x2F;此处可以修改str，因为str只是字符数组（使用了字符串字面量来初始化str），但是并不是常量  size_t length &#x3D; std::strlen(str);&#x2F;&#x2F;遇到&#39;\0&#39;才会停止计数  &#x2F;&#x2F; 例如 char a[3]&#x3D;&#123;&#39;a&#39;, &#39;b&#39;, &#39;c&#39;&#125;, 使用strlen后的长度不是3!!!  printf(&quot;%c-%s-%ld-%ld\n&quot;, *str, str, sizeof(str), strlen(str));  &#x2F;&#x2F; sizeof(str) 返回的是数组占用的内存大小，而 strlen(str) 返回的是字符串的长度。  printf(&quot;%c-%s-%ld-%ld\n&quot;, *p, p, sizeof(p), strlen(p));  &#x2F;&#x2F; sizeof(p) 返回的是int型指针占用的内存大小，而 strlen(p) 返回的是字符串的长度。  *p&#x3D;&#39;A&#39;;  *(p+1)&#x3D;&#39;B&#39;;  std::cout&lt;&lt;*str&lt;&lt;*(str+1)&lt;&lt;std::endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2、此处会有一个warning，因为“ab”是存储在常量区域的，不能修改，在使用时需要使用const来申明</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;cstring&gt;int main() &#123;  char *p&#x3D;&quot;ab&quot;;&#x2F;&#x2F; 先在常量区保存好&quot;ab&quot;，然后在栈区建立一个char *  &#x2F;&#x2F;   const char *p&#x3D;&quot;ab&quot;;  printf(&quot;%c-%s-%ld-%ld\n&quot;, *p, p, sizeof(p), strlen(p));  &#x2F;&#x2F; sizeof(p) 返回的是int型指针占用的内存大小，而 strlen(p) 返回的是字符串的长度。  *p&#x3D;&#39;A&#39;;  *(p+1)&#x3D;&#39;B&#39;;  std::cout&lt;&lt;*p&lt;&lt;*(p+1)&lt;&lt;std::endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>3、此处会显示error: assignment of read-only location ‘* p’</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;cstring&gt;int main() &#123;  const char *p&#x3D;&quot;ab&quot;;  printf(&quot;%c-%s-%ld-%ld\n&quot;, *p, p, sizeof(p), strlen(p));  &#x2F;&#x2F; sizeof(p) 返回的是int型指针占用的内存大小，而 strlen(p) 返回的是字符串的长度。  *p&#x3D;&#39;A&#39;;  *(p+1)&#x3D;&#39;B&#39;;  std::cout&lt;&lt;*p&lt;&lt;*(p+1)&lt;&lt;std::endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>4、字符数组指针的初始化</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;int main() &#123;  char a&#x3D;&#39;a&#39;;  char b&#x3D;&#39;b&#39;;  char *p&#x3D;&amp;a;  char c[]&#x3D;&#123;a, b, &#39;c&#39;&#125;;  printf(&quot;%p--%p--%c--%c\n&quot;, &amp;a, &amp;b, a, b);  printf(&quot;%p--%p--%c--%c\n&quot;, c, c+1, *c, *(c+1));  char *p2[]&#x3D;&#123;&amp;a, p, c&#125;;  for(int i&#x3D;0; i&lt;3; i++)&#123;    printf(&quot;%p--%p--%c\n&quot;, &amp;p2[i], p2[i], *p2[i]);  &#125;  return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><p>主要要把指针括起来</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;using namespace std;void func()&#123;  cout&lt;&lt;&quot;func&quot;&lt;&lt;endl;&#125;int add(int a, int b)&#123;  return a+b;&#125;int main()&#123;  int a&#x3D;123;  int *p&#x3D;&amp;a;  printf(&quot;%p--%p\n&quot;, &amp;a, p);  &#x2F;&#x2F;无参  void (*pFunc)()&#x3D;&amp;func;&#x2F;&#x2F;要不要&amp;，都可  printf(&quot;%p--%p\n&quot;, func, pFunc);  &#x2F;&#x2F;带参  int (*pFunc1)(int, int)&#x3D;&amp;add;  printf(&quot;%p--%p\n&quot;, add, pFunc1);  return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="函数指针数组"><a href="#函数指针数组" class="headerlink" title="函数指针数组"></a>函数指针数组</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;using namespace std;void func()&#123;  cout&lt;&lt;&quot;func&quot;&lt;&lt;endl;&#125;int add(int a, int b)&#123;  return a+b;&#125;int sub(int a, int b)&#123;  return a - b;&#125; int mul(int a, int b)&#123;  return a*b;&#125;int div11(int a, int b)&#123;  return a&#x2F;b;&#125;int main()&#123;  int a&#x3D;1;  int b&#x3D;2;  int *p&#x3D;&amp;a;  printf(&quot;%p--%p\n&quot;, &amp;a, p);  int (*pFunc[4])(int, int)&#x3D;&#123;add, sub, mul, div11&#125;;  for(int i&#x3D;0; i&lt;4; i++)&#123;    cout&lt;&lt;(*pFunc[i])(a, b)&lt;&lt;endl;  &#125;  return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="函数指针深度辨析"><a href="#函数指针深度辨析" class="headerlink" title="函数指针深度辨析"></a>函数指针深度辨析</h2><p>！！！！！！！！！！！！！</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;using namespace std;void func()&#123;  cout&lt;&lt;&quot;func&quot;&lt;&lt;endl;&#125;int add(int a, int b)&#123;  return a+b;&#125;int main()&#123;  void (*pFunc)()&#x3D;&amp;func;  printf(&quot;%p\n&quot;, &amp;pFunc);  printf(&quot;%p\n&quot;, pFunc);  printf(&quot;%p\n&quot;, *pFunc);  printf(&quot;%p\n&quot;, **pFunc);  printf(&quot;%p\n&quot;, ***pFunc);  printf(&quot;----------\n&quot;);  printf(&quot;%p\n&quot;, &amp;func);  printf(&quot;%p\n&quot;, func);  printf(&quot;%p\n&quot;, *func);  printf(&quot;%p\n&quot;, **func);  printf(&quot;%p\n&quot;, ***func);  return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="结构体内存对齐"><a href="#结构体内存对齐" class="headerlink" title="结构体内存对齐"></a>结构体内存对齐</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;using namespace std;#define sz(type) cout&lt;&lt;sizeof(type)&lt;&lt;endl;struct stu&#123;  char c;  short a;  int *b;&#125;;&#x2F;&#x2F;8struct stu1&#123;  char c;  int *b;  short a;&#125;;&#x2F;&#x2F;12struct stu2&#123;  double a;  char b;  int *c;&#125;;&#x2F;&#x2F;16struct stu3&#123;  char b;  double a;  int *c;&#125;;&#x2F;&#x2F;24int main()&#123;  sz(stu);  sz(stu1);  sz(stu2);  sz(stu3);  return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="结构体指针"><a href="#结构体指针" class="headerlink" title="结构体指针"></a>结构体指针</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;struct Stu&#123;  int a;  char c[13];&#125;;int main()&#123;  Stu s;  s.a&#x3D;12;  strcpy(s.c, &quot;121&quot;);  cout&lt;&lt;sizeof(s)&lt;&lt;endl;  cout&lt;&lt;s.a&lt;&lt;&quot;--&quot;&lt;&lt;s.c&lt;&lt;endl;  Stu *pStu&#x3D;(Stu *)malloc(sizeof(Stu));  pStu-&gt;a&#x3D;11;  strcpy(pStu-&gt;c,&quot;qwe&quot;);  cout&lt;&lt;pStu-&gt;a&lt;&lt;&quot;---&quot;&lt;&lt;pStu-&gt;c&lt;&lt;endl;  return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>统计项目代码行数</title>
      <link href="/2023/06/22/tong-ji-xiang-mu-dai-ma-xing-shu/"/>
      <url>/2023/06/22/tong-ji-xiang-mu-dai-ma-xing-shu/</url>
      
        <content type="html"><![CDATA[<h1 id="Ubuntu用户"><a href="#Ubuntu用户" class="headerlink" title="Ubuntu用户"></a>Ubuntu用户</h1><p>使用cloc在ubuntu内统计代码行数</p><ol><li>安装cloc工具</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> cloc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="2"><li>进入需要统计的目录内，然后执行</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cloc <span class="token builtin class-name">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="3"><li>然后就会显示文件目录中的文件数(files)、空白行数(blank)、注释行数(comment)和代码行数(code)。</li></ol><h1 id="Windows-用户"><a href="#Windows-用户" class="headerlink" title="Windows 用户"></a>Windows 用户</h1><p>也是使用cloc工具</p><ol><li>下载最新cloc.exe工具，官网地址：<a href="http://cloc.sourceforge.net/">http://cloc.sourceforge.net/</a></li></ol><p><img src="https://s2.loli.net/2023/06/22/Plp519xOn8NyDBS.png"></p><p><img src="https://s2.loli.net/2023/06/22/f2RycgumFT16pIS.png"></p><p><img src="https://s2.loli.net/2023/06/22/r32Wm6QleJzScDP.png"></p><ol start="2"><li><p>下载完成后，将cloc-1.64.exe名称修改为cloc.exe，放在需要统计代码的文件夹所在目录</p><p><img src="https://s2.loli.net/2023/06/22/gdZl8Fko7QmuNHJ.png"></p><p>打开终端，输入命令<code>&gt;cloc.exe Project</code>(Project即要统计代码行数的文件名)</p></li><li><p>显示结果<img src="https://s2.loli.net/2023/06/22/BsDR8yoI9OaYrwT.png"></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程不安全版本的单例模式（详解）</title>
      <link href="/2023/06/22/xian-cheng-bu-an-quan-ban-ben-de-dan-li-mo-shi-xiang-jie/"/>
      <url>/2023/06/22/xian-cheng-bu-an-quan-ban-ben-de-dan-li-mo-shi-xiang-jie/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="出发点"><a href="#出发点" class="headerlink" title="出发点"></a>出发点</h1><p>保证一个类仅有一个实例，并提供一个该实例的全局访问点。 ——《设计模式》GoF</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h2 id="单例分为两种实现方法："><a href="#单例分为两种实现方法：" class="headerlink" title="单例分为两种实现方法："></a>单例分为两种实现方法：</h2><ul><li><h3 id="懒汉"><a href="#懒汉" class="headerlink" title="懒汉"></a>懒汉</h3></li><li><p>第一次用到类实例的时候才会去实例化，上述就是懒汉实现。</p></li><li><h3 id="饿汉"><a href="#饿汉" class="headerlink" title="饿汉"></a>饿汉</h3></li><li><p>单例类定义的时候就进行了实例化。</p></li></ul><p><strong>懒汉模式的实现：</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Singleton&#123;public:    static Singleton* getInstance()&#123;        &#x2F;&#x2F; 先检查对象是否存在        if (m_instance &#x3D;&#x3D; nullptr) &#123;            m_instance &#x3D; new Singleton();        &#125;        return m_instance;    &#125;private:    Singleton(); &#x2F;&#x2F;私有构造函数，不允许使用者自己生成对象    &#x2F;&#x2F;关键点就是将Singleton()设置为私有的    Singleton(const Singleton&amp; other);    static Singleton* m_instance; &#x2F;&#x2F;静态成员变量 &#125;;Singleton* Singleton::m_instance&#x3D;nullptr; &#x2F;&#x2F;静态成员需要先类外初始化<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>饿汉的实现：</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class singleton &#123;private:    singleton() &#123;&#125;    static singleton *p;public:    static singleton *instance();&#125;;singleton *singleton::p &#x3D; new singleton();singleton* singleton::instance() &#123;    return p;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h1><p>这是一个非常简单的实现，将构造函数声明为<strong>private</strong>或<strong>protect</strong>防止被<strong>外部函数实例化</strong>，内部有一个静态的类指针保存唯一的实例，<strong>实例的实现由一个public方法来实现</strong>，该方法返回该类的唯一实例。</p><p>当然这个代码只适合在单线程下，当多线程时，是不安全的。考虑两个线程同时首次调用instance方法且同时检测到p是nullptr，则<strong>两个线程会同时构造一个实例给p，这将违反了单例的准则。</strong></p><h2 id="多线程下的分析："><a href="#多线程下的分析：" class="headerlink" title="多线程下的分析："></a><strong>多线程下的分析：</strong></h2><p>正常情况下，如果线程A调用完了getInstance()之后，将m_instance初始化了，线程B再去调用getInstance()就不会在创建一个新的实例了，直接使用之前A创建好的实例；然而存在这一种情况，当线程A正在执行getInstance()，但是还没有创建好m_instance，此时B线程调用getInstance()，m_instance是nullptr，会new一个实例。A一个实例，B一个实例，这样就可能导致程序错误，同时，还会发生内存泄漏。</p><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>使用多线程加锁、双重检查锁模式、memory barrier指令、静态局部变量、Atomic、pthread_once等方法</p>]]></content>
      
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>时间戳的简单含义</title>
      <link href="/2023/06/22/shi-jian-chuo-de-jian-dan-han-yi/"/>
      <url>/2023/06/22/shi-jian-chuo-de-jian-dan-han-yi/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>时间戳（timestamp），是计算机里存储和表示时间的基本方式。</p><p>以1970年1月1日0时0分0秒作为基准</p><p>计算当前时刻与这个基准时刻的秒数&#x2F;毫秒&#x2F;微妙之差</p><p>得到的这个数字就叫做时间差</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>什么是持久层框架</title>
      <link href="/2023/06/22/shi-me-shi-chi-jiu-ceng-kuang-jia/"/>
      <url>/2023/06/22/shi-me-shi-chi-jiu-ceng-kuang-jia/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="什么是持久层"><a href="#什么是持久层" class="headerlink" title="什么是持久层?"></a>什么是<a href="https://so.csdn.net/so/search?q=%E6%8C%81%E4%B9%85%E5%B1%82&spm=1001.2101.3001.7020">持久层</a>?</h1><p>持久是相对于瞬时来说的，*** 持久层，可以理解成数据 保存在 数据库或者 硬盘一类可以保存很长时间的设备里面，不像放在内存中那样断电就消失了，也就是把数据存在持久化设备上*** ，你想一下 <a href="https://so.csdn.net/so/search?q=%E5%86%85%E5%AD%98&spm=1001.2101.3001.7020">内存</a>中的数据 断电就没有了，硬盘的数据 是否会像内存中的数据一样断电消失么？</p><h1 id="为什么要使用持久化框架"><a href="#为什么要使用持久化框架" class="headerlink" title="为什么要使用持久化框架?"></a>为什么要使用持久化框架?</h1><p>企业应用中*** 数据很重要(各种订单数据、客户数据、库存数据之类的)，他们的数据就是财富，比应用程序本身更重要，** 所以需要把数据<strong>持久化</strong>。持久化可以通过很多方式，写文件和数据库都可以。只是现在企业一般都会选择把数据持久化到数据库中，因为可以很方便的查询统计分析，但数据库的数据最终还是会写到磁盘上的。Java 程序员为了操作数据库，** 最开始是使用JDBC*** 来进行的，但是这种方式*** 开发效率低** ，要写一堆重复代码，加上关系数据库和对象本身存在所谓的阻抗不匹配情况，所以** 为了提高开发效率，有人发明了 ORM 即 对象关系映射框架*** (Hibernate是其中的佼佼者)，对于 Java 程序员来说，就可以通过操纵对象来操纵数据库了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序之希尔排序</title>
      <link href="/2023/06/22/pai-xu-zhi-xi-er-pai-xu/"/>
      <url>/2023/06/22/pai-xu-zhi-xi-er-pai-xu/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">ShellSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> gap <span class="token operator">=</span> n<span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>gap <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>gap <span class="token operator">=</span> gap <span class="token operator">/</span> <span class="token number">3</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">/*排序元素的间隔        只不过间隔不断变小*/</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n <span class="token operator">-</span> gap<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> end <span class="token operator">=</span> i<span class="token punctuation">;</span><span class="token keyword">int</span> tmp <span class="token operator">=</span> a<span class="token punctuation">[</span>end <span class="token operator">+</span> gap<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>end <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">//插入排序，不过是对间隔为gap的几个元素进行插入排序</span><span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>end<span class="token punctuation">]</span> <span class="token operator">></span> tmp<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>a<span class="token punctuation">[</span>end <span class="token operator">+</span> gap<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>end<span class="token punctuation">]</span><span class="token punctuation">;</span>end <span class="token operator">-=</span> gap<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token punctuation">&#123;</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">/*遇到一个大于tmp的元素，            或者是end&lt;0的时候（因为有时候该元素已经是正确的位置）*/</span>a<span class="token punctuation">[</span>end <span class="token operator">+</span> gap<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 法学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UTF-8编码</title>
      <link href="/2023/06/22/utf8-bian-ma/"/>
      <url>/2023/06/22/utf8-bian-ma/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>UTF-8就是在互联网上使用最Unicode的实现方式，其他实现方式还包括UTF-16和UTF-32。不过在互联网上基本不用。重复一遍，这里的关系是，UTF-8是Unicode的实现方式之一。</p><p>世界上存在着多种编码方式，同一个二进制数字可以被解释成不同的符号。因此，要想打开一个文本文件，就必须知道它的编码方式，否则用错误的编码方式解读，就会出现乱码。为什么电子邮件常常出现乱码？就是因为发信人和收信人使用的编码方式不一样。</p><p>可以想象，如果有一种编码，将世界上所有的符号都纳入其中。每一个符号都给予一个独一无二的编码，那么乱码问题就会消失。这就是Unicode，就像它的名字都表示的，这是一种所有符号的编码。</p><p>而Unicode里面UTF-8最大的一个特点，就是它是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。它同样包含全世界所有国家用到的字符，是国际编码了，通用性强，主要用以解决国际上字符的一种多字节编码，对英文使用八位（即一个字节），中文使用24位（即三个字节）。</p>]]></content>
      
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL小小知识点：超键，候选键，主键，外键基本概念</title>
      <link href="/2023/06/22/sql-xiao-xiao-zhi-shi-dian-chao-jian-hou-xuan-jian-zhu-jian-wai-jian-ji-ben-gai-nian/"/>
      <url>/2023/06/22/sql-xiao-xiao-zhi-shi-dian-chao-jian-hou-xuan-jian-zhu-jian-wai-jian-ji-ben-gai-nian/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="超键"><a href="#超键" class="headerlink" title="超键"></a>超键</h1><p><strong>定义</strong>：在关系模式中，可以<strong>唯一标识</strong>一个元组的<strong>属性集</strong>称为<strong>超键（Super Key）</strong>。</p><p>举个栗子：student(Sno, Sname, Sage, Ssex)</p><p>在这个结构中，只有包含Sno的属性集合才能是超键，因为如果不包含Sno，可能会出现同名，同姓的人，也可能出现同岁的人，所以在上面的关系模式中只有通过学号才能找到某个特定的学生。</p><p>因此上述关系模式中只有包含学号的属性集才能称之为超键：</p><p>例如：(Sno), (Sno, Sname), (Sno, Sname, Sage)等</p><h1 id="候选键"><a href="#候选键" class="headerlink" title="候选键"></a>候选键</h1><p><strong>定义</strong>：在关系模式中，能<strong>唯一标识元组</strong>并且<strong>不含多余属性的属性集</strong>称为<strong>候选键（Candidate Key）</strong>。</p><p>例如在上面提到的例子中，student(Sno, Sname, Sage, Ssex)</p><p>如果没有重名的学生，Sname也可以当成是候选键，这里可以看出候<strong>选键是一种特殊的超键，即把超键中多余的属性删除就可以叫做候选键。</strong></p><p>所以上述关系中（Sno）（Sname）可以叫做候选键。</p><h1 id="主键"><a href="#主键" class="headerlink" title="主键"></a>主键</h1><p>定义：在关系模式中的<strong>若干个候选键</strong>中，随意指定一个作为关键字，此关键字即为<strong>主键（Primary Key）</strong>。</p><p>分析：student(Sno, Sname, Sage, Ssex)</p><p>　　主键很好理解，<strong>就在在候选键的基础上任意选择一个作为主键（理解这点就明白了什么可以当主键了）</strong>，同时衍生出<strong>复合主键</strong>和<strong>联合主键</strong> ，假设我们没有学号字段，如果可以通过姓名，年龄，性别一同找到某个特定的学生，那么就称(name, age, sex)为复合主键，全部由主键构成的称为联合主键。</p><p>　　因此上述关系模式中，姓名，和年龄也能唯一确定学生，那么主键有：</p><p>　　例：(Sno), (Sname)，复合主键（Sname，Sage）</p><h1 id="外键"><a href="#外键" class="headerlink" title="外键"></a>外键</h1><p>定义：可以把一张表的数据与另一张表关联起来，这种列称为**<code>外键</code>（Foreign Key）**。</p><p>分析：student(Sno, Sname, Sage, Ssex,SCredit), score(Sno, Tno, Sco)</p><p>　　外键是建立在两个关系模式中的，从上述定义中可用知道，某关系模式中主键一定是其候选键，那对于另一关系，只要原关系的主键只表示普通属性，那它就是另一属性的外键，上表中Sno就是score的外键，他把两个表关联起来了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>QT连接Mysql后的简单操作（增删改查）</title>
      <link href="/2023/06/22/qt-lian-jie-mysql-hou-de-jian-dan-cao-zuo-zeng-shan-gai-cha/"/>
      <url>/2023/06/22/qt-lian-jie-mysql-hou-de-jian-dan-cao-zuo-zeng-shan-gai-cha/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h1><p>首先要连接自己在电脑上安装的MySql的数据库（这个是最难也是最重要的一步，万事起步难），连接上了之后的Sql语句就会就会非常简单了，连接数据库可以参考这篇博客（注意在连接时会有可能会有很多报错信息，但是只要按照这个操作来，一步一步操作应该没有问题。） </p><p><a href="https://blog.csdn.net/qq_38832450/article/details/110452117">Qt编译MySQL数据库驱动_焕小谢的博客-CSDN博客_qt编译mysql驱动</a></p><p>注意在操作完这些操作后不要直接点构建，</p><p><img src="https://img-blog.csdnimg.cn/ff8480a26a9d41a68a8cc1141003af75.png"></p><p><img src="https://img-blog.csdnimg.cn/eb55c56339f749a28cc2965a0b817e68.png"></p><p>要点重新构建所有项目（我因为这个问题弄了好久😭😭😭）。</p><h1 id="增删改查（MySql）"><a href="#增删改查（MySql）" class="headerlink" title="增删改查（MySql）"></a>增删改查（MySql）</h1><p>首先在xxx.pro文件中加入sql模块。</p><p><img src="https://img-blog.csdnimg.cn/1711a48b7b8c47c3805b9219e761cc0a.png"></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &quot;widget.h&quot;#include &quot;ui_widget.h&quot;#include &lt;QDebug&gt;#include &lt;QSqlDatabase&gt;#include &lt;QStringList&gt;#include &lt;QSqlError&gt;#include &lt;QSqlQuery&gt;#include &lt;QMessageBox&gt;Widget::Widget(QWidget *parent)    : QWidget(parent)    , ui(new Ui::Widget)&#123;    ui-&gt;setupUi(this);    &#x2F;&#x2F; 1. 添加一个数据库实例    QStringList ls &#x3D; QSqlDatabase::drivers();    qDebug() &lt;&lt; ls;    QSqlDatabase db &#x3D; QSqlDatabase::addDatabase(&quot;QMYSQL&quot;);    &#x2F;&#x2F; 2. 得到实例对象之后需要初始化连接信息    &#x2F;&#x2F;    -- 服务器的IP, 端口, 数据库名, 用户名, 密码    db.setHostName(&quot;localhost&quot;);    db.setPort(3306);   &#x2F;&#x2F; 如果使用的是默认端口, 可以不调用该函数    db.setDatabaseName(&quot;student&quot;);&#x2F;&#x2F;这是我自己建的表的名字，要看自己在DBMS上面建了什么表。    db.setUserName(&quot;root&quot;);&#x2F;&#x2F;root用户    db.setPassword(&quot;123456&quot;);&#x2F;&#x2F;密码    &#x2F;&#x2F; 3. 连接数据库    bool bl &#x3D; db.open();    if(!bl)    &#123;        qDebug() &lt;&lt; db.lastError().text();        return;    &#125;    else    &#123;&#x2F;&#x2F;        qDebug() &lt;&lt; &quot;数据库连接成功了...&quot;;        QMessageBox::information(this, &quot;succeed&quot;, &quot;hahah&quot;);    &#125;    QSqlQuery query;    &#x2F;&#x2F; 4. 插入数据&#x2F;&#x2F;    QString sql &#x3D; &quot;insert into dept values(23, &#39;火影忍者&#39;, &#39;东京&#39;)&quot;;&#x2F;&#x2F;    QString sql &#x3D; &quot;select * from student&quot;;    &#x2F;&#x2F; 开启事务&#x2F;&#x2F;    db.transaction();&#x2F;&#x2F;    bool flag &#x3D; query.exec(sql);&#x2F;&#x2F;    if(flag)&#x2F;&#x2F;    &#123;&#x2F;&#x2F;       db.commit();&#x2F;&#x2F;    &#125;&#x2F;&#x2F;    else&#x2F;&#x2F;    &#123;&#x2F;&#x2F;       db.rollback();&#x2F;&#x2F;    &#125;&#x2F;&#x2F;    &#x2F;&#x2F; 5. 查询数据表 - dept&#x2F;&#x2F;    query.exec(&quot;select * from score&quot;);    &#x2F;&#x2F; 遍历结果集    while(query.next())    &#123;        &#x2F;&#x2F; 从当前记录中取出各个字段的值&#x2F;&#x2F;        qDebug() &lt;&lt; query.value(0).toString()&#x2F;&#x2F;                &lt;&lt; query.value(1).toString()&#x2F;&#x2F;                &lt;&lt; query.value(&quot;dname&quot;).toString()&#x2F;&#x2F;                &lt;&lt; query.value(&quot;loc&quot;).toString();        QString sno &#x3D; query.value(0).toString();        QString cno &#x3D; query.value(1).toString();        QString tno &#x3D; query.value(2).toString();        double grade &#x3D; query.value(3).toDouble();        qDebug()&lt;&lt;sno&lt;&lt;&quot; &quot;&lt;&lt;cno&lt;&lt;&quot; &quot;&lt;&lt;tno&lt;&lt;&quot; &quot;&lt;&lt;grade;    &#125;    db.close();&#125;Widget::~Widget()&#123;    delete ui;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>增删改查其实就利用这个模板来操作了，这个时候就要看你的MqSql的功底了。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">query.exec(&quot;insert into student values(......)&quot;);&#x2F;&#x2F;增query.exec(&quot;DELETE FROM table_name [WHERE Clause]&quot;);&#x2F;&#x2F;删除query.exec(&quot;UPDATE table_name SET field1&#x3D;new-value1, field2&#x3D;new-value2[WHERE Clause]&quot;);&#x2F;&#x2F;更新query.exec(&quot;select * from score&quot;);&#x2F;&#x2F;查询<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> QT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Qt:_QWidget::paintEngine:_Should_no_longer_be_called</title>
      <link href="/2023/06/22/qtqwidgetpaintengineshouldnolongerbecalled/"/>
      <url>/2023/06/22/qtqwidgetpaintengineshouldnolongerbecalled/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p><strong>目录</strong></p><p><a href="#%E7%94%B1%E6%9D%A5">由来</a></p><p><a href="#%E6%B3%A8%E6%84%8F%E4%B8%8B%E9%9D%A2%E6%88%91%E7%9A%84%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B%EF%BC%9A%C2%A0">注意下面我的创建过程： </a></p><p><a href="#%E4%B8%8B%E9%9D%A2%E6%98%AF%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%EF%BC%9A">下面是解决方法：</a></p><p><a href="#%C2%A0%E4%BA%A7%E7%94%9F%E8%BF%99%E4%B8%AA%E9%94%99%E8%AF%AF%E7%9A%84%E5%8E%9F%E5%9B%A0%EF%BC%9A"> 产生这个错误的原因：</a></p><h2 id="由来"><a href="#由来" class="headerlink" title="由来"></a>由来</h2><p>今天在QT Creater使用QPainter的时候出现了这个错误，在引用输出窗口还有这么一些错误</p><p><img src="https://img-blog.csdnimg.cn/d4c9c9eaba8d46789d0896411d73845e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5aSc54yr56iL5bqP54y_,size_18,color_FFFFFF,t_70,g_se,x_16"></p><p>之前在使用其他类的时候，直接在widget.h中的MainWindow中写都可以运行像这样</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &quot;mainwindow.h&quot;#include &quot;ui_mainwindow.h&quot;#include &lt;QDialog&gt;#include &lt;QStatusBar&gt;#include &lt;QMessageBox&gt;#include &lt;QColorDialog&gt;#include &lt;QDebug&gt;#include &lt;QFileDialog&gt;#include &lt;QString&gt;#include &lt;QFontDialog&gt;MainWindow::MainWindow(QWidget *parent) :    QMainWindow(parent),    ui(new Ui::MainWindow)&#123;    ui-&gt;setupUi(this);    QStatusBar *staBar &#x3D; statusBar();    setStatusBar(staBar);&#x2F;&#x2F;only one set, not only one add;    ui-&gt;actionNew-&gt;setIcon(QIcon(&quot;D:&#x2F;图片&#x2F;三体智子高清4k动漫壁纸_彼岸图网.jpg&quot;));    connect(ui-&gt;actionNew, &amp;QAction::triggered, [&#x3D;]()&#123;&#x2F;&#x2F;        mo tai duihuakuang&#x2F;&#x2F;        QDialog log(this);&#x2F;&#x2F;模态        QDialog *log &#x3D; new QDialog(this);&#x2F;&#x2F;new在堆区的        log-&gt;resize(200, 100);        log-&gt;show();&#x2F;&#x2F;非模态        log-&gt;setAttribute(Qt::WA_DeleteOnClose);&#x2F;&#x2F;非模态的时候才需要设置这个属性，因为非模态是new在堆区的&#x2F;&#x2F;        log.exec();&#x2F;&#x2F;模态，把窗口阻塞了&#x2F;&#x2F;        fei motai dui hua kuang    &#125;);&#x2F;&#x2F;    QMessageBox::critical(this, &quot;ha&quot;, &quot;错误&quot;);&#x2F;&#x2F;    QColorDialog color &#x3D; QColorDialog::getColor(QColor(255, 0, 0));&#x2F;&#x2F;    qDebug()&lt;&lt;&quot;r&#x3D;&quot;&lt;&lt;color.red()&lt;&lt;&quot; &quot;&lt;&lt;&quot;g&#x3D;&quot;&lt;&lt;color.green();&#x2F;&#x2F;    QString str &#x3D; QFileDialog::getOpenFileName(this, &quot;open&quot;,&#x2F;&#x2F;                                 &quot;D:\OneDrive文档\OneDrive - officeapp.org\Desktop&quot;, &quot;*.txt&quot;);&#x2F;&#x2F;    qDebug()&lt;&lt;str;&#x2F;&#x2F;    bool flag;&#x2F;&#x2F;    QFont font &#x3D; QFontDialog::getFont(&amp;flag, QFont(&quot;华文彩文&quot;, 36));&#125;MainWindow::~MainWindow()&#123;    delete ui;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="注意下面我的创建过程："><a href="#注意下面我的创建过程：" class="headerlink" title="注意下面我的创建过程："></a><strong>注意下面我的创建过程：</strong></h2><p><img src="https://img-blog.csdnimg.cn/df90169dccb34d2c98305119b73c16fd.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5aSc54yr56iL5bqP54y_,size_20,color_FFFFFF,t_70,g_se,x_16"></p><p><img src="https://img-blog.csdnimg.cn/790e51f20a0747b7b0383ad851bf85e4.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5aSc54yr56iL5bqP54y_,size_20,color_FFFFFF,t_70,g_se,x_16"></p><p><img src="https://img-blog.csdnimg.cn/3549f541aa1c4b829ec037504a448ea8.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5aSc54yr56iL5bqP54y_,size_20,color_FFFFFF,t_70,g_se,x_16"></p><p><img src="https://img-blog.csdnimg.cn/c64d24b5f45a4ab9a435e4f4ca2caac0.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5aSc54yr56iL5bqP54y_,size_20,color_FFFFFF,t_70,g_se,x_16"></p><p>** 注意这一步**：</p><p><img src="https://img-blog.csdnimg.cn/57fac6cc320a41da80e11097ec5aad22.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5aSc54yr56iL5bqP54y_,size_20,color_FFFFFF,t_70,g_se,x_16"></p><p> 然后我在QWidget.cpp中写了下面的代码</p><p><img src="https://img-blog.csdnimg.cn/0cf0563fb3424b9497d8a7eb9c94d29c.png"></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &quot;ui_widget.h&quot;#include &lt;ui_widget.h&gt;Widget::Widget(QWidget *parent) :    QWidget(parent),    ui(new Ui::Widget)&#123;    ui-&gt;setupUi(this);    QPainterPath path;    path.addRect(20, 20, 60, 60);&#x2F;&#x2F;    path.moveTo(0, 0);&#x2F;&#x2F;    path.cubicTo(99, 0,  50, 50,  99, 99);&#x2F;&#x2F;    path.cubicTo(0, 99,  50, 50,  0, 0);    QPainter painter(this);    painter.fillRect(0, 0, 100, 100, Qt::white);    painter.setPen(QPen(QColor(79, 106, 25), 1, Qt::SolidLine,                        Qt::FlatCap, Qt::MiterJoin));    painter.setBrush(QColor(122, 163, 39));    painter.drawPath(path);&#125;Widget::~Widget()&#123;    delete ui;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 然后就出现了上面的错误。</p><h2 id="下面是解决方法："><a href="#下面是解决方法：" class="headerlink" title="下面是解决方法："></a><strong>下面是解决方法：</strong></h2><p><strong>首先在QWidget.h中加入这个函数的申明</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void paintEvent(QPaintEvent *);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p> 然后再QWidget.cpp中定义这个函数，此时就可以使用QPainter类了</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &quot;widget.h&quot;#include &quot;ui_widget.h&quot;Widget::Widget(QWidget *parent) :    QWidget(parent),    ui(new Ui::Widget)&#123;    ui-&gt;setupUi(this);&#125;void Widget::paintEvent(QPaintEvent *)&#123;    QPainterPath path;    path.addRect(20, 20, 60, 60);    path.moveTo(0, 0);    path.cubicTo(99, 0,  50, 50,  99, 99);    path.cubicTo(0, 99,  50, 50,  0, 0);    QPainter painter(this);    painter.fillRect(0, 0, 100, 100, Qt::white);    painter.setPen(QPen(QColor(79, 106, 25), 1, Qt::SolidLine,                        Qt::FlatCap, Qt::MiterJoin));    painter.setBrush(QColor(122, 163, 39));    painter.drawPath(path);&#125;Widget::~Widget()&#123;    delete ui;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>**运行结果如下： **</p><p><img src="https://img-blog.csdnimg.cn/0ef6cebd17a440108de64de391623118.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5aSc54yr56iL5bqP54y_,size_12,color_FFFFFF,t_70,g_se,x_16"></p><h2 id="产生这个错误的原因："><a href="#产生这个错误的原因：" class="headerlink" title="产生这个错误的原因："></a>产生这个错误的原因：</h2><p>在这里很好地解释了这一点：<br><a href="https://forum.qt.io/topic/64693/unable-to-paint-on-qt-widget-shows-error-paintengine-should-no-longer-be-called/3">https://forum.qt.io/topic/64693/unable-to-paint-on-qt-widget-shows-error-paintengine-should-no-longer-be-called/3</a></p><p>简而言之：不要尝试直接从输入事件处理程序进行绘制，而是在您的小部件中重载 paintEvent 方法并在那里创建 QPainter。仅使用输入事件来修改内部数据模型，并在paintEvent 中使用QPainter 将其显示在输出路径上。</p>]]></content>
      
      
      
        <tags>
            
            <tag> QT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>QT_Creater工程文件介绍</title>
      <link href="/2023/06/22/qtcreater-gong-cheng-wen-jian-jie-shao/"/>
      <url>/2023/06/22/qtcreater-gong-cheng-wen-jian-jie-shao/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="Qt-Creator工程管理"><a href="#Qt-Creator工程管理" class="headerlink" title="Qt Creator工程管理"></a>Qt Creator工程管理</h1><p>Qt Creator以<strong>工程项目的方式</strong>对<a href="https://so.csdn.net/so/search?q=%E6%BA%90%E7%A0%81&spm=1001.2101.3001.7020">源码</a>进行管理</p><p>一个Qt Craetor工程包含不同类型的文件</p><ul><li>.pro项目描述文件+ .pro.user用户配置描述文件+ .h头文件+ .cpp源文件+ .ui界面描述文件+ .qrc资源文件（图片，视频，等）</li></ul><h1 id="pro项目描述文件"><a href="#pro项目描述文件" class="headerlink" title=".pro项目描述文件"></a>.pro项目描述文件</h1><p>实质上是Makefile文件</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#-------------------------------------------------</span><span class="token comment">#</span><span class="token comment"># Project created by QtCreator 2022-04-08T19:06:19</span><span class="token comment">#</span><span class="token comment">#-------------------------------------------------</span>QT       <span class="token operator">+=</span> core gui              <span class="token comment"># 模块声明 core模块 gui模块</span>greaterThan<span class="token punctuation">(</span>QT_MAJOR_VERSION, <span class="token number">4</span><span class="token punctuation">)</span>: QT <span class="token operator">+=</span> widgets    <span class="token comment"># 如果使用QT版本大于4，那么需要告诉QT，还需要widgets模块</span>TARGET <span class="token operator">=</span> test1                    <span class="token comment"># 可执行文件名</span>TEMPLATE <span class="token operator">=</span> app                    <span class="token comment"># test1是一个app，可执行程序</span>SOURCES <span class="token operator">+=</span> main.cpp<span class="token punctuation">\</span>                <span class="token comment"># 源文件</span>        mainwindow.cppHEADERS  <span class="token operator">+=</span> mainwindow.h            <span class="token comment"># 头文件</span>FORMS    <span class="token operator">+=</span> mainwindow.ui            <span class="token comment">#界面描述文件.ui</span>RESOURCES <span class="token operator">+=</span> <span class="token punctuation">\</span>                        <span class="token comment"># 资源文件</span>    image.qrcCONFIG <span class="token operator">+=</span> <span class="token punctuation">\</span>                        <span class="token comment">#设定项目的配置信息和编译选项，这里是添加了c++11标准</span>    c++11<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h1><p>1、Qt Creator在打开项目文件的<strong>同时会生成.pro.user文件</strong></p><p>2、.pro.user文件包含一些与Qt相关的本地配置信息</p><p>3、<strong>当需要在不同计算机之间移动项目源码时，建议删除.pro.user文件</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> QT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Qt5_的类_QPoint，QPointF（相关的方法，不会的都在）</title>
      <link href="/2023/06/22/qt5-de-lei-qpointqpointf-xiang-guan-de-fang-fa-bu-hui-de-du-zai/"/>
      <url>/2023/06/22/qt5-de-lei-qpointqpointf-xiang-guan-de-fang-fa-bu-hui-de-du-zai/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="QPoint"><a href="#QPoint" class="headerlink" title="QPoint"></a>QPoint</h1><p><a href="https://doc.qt.io/qt-5/qpoint.html">QPoint官网链接</a></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>QPoint 类使用整数精度来定义平面中的一个点</p><h2 id="包含的成员"><a href="#包含的成员" class="headerlink" title="包含的成员"></a>包含的成员</h2><p><img src="https://img-blog.csdnimg.cn/0043bcf801d74b6c952319df2648a945.png"></p><p>我觉得你可能<strong>看不懂</strong>的成员使用的方法：</p><p>1、dotProduct(const QPoint &amp;, const QPoint &amp;):int，参数是两个点的坐标，return 他们两点之间的点积，即进行向量的点乘运算，即x1<em>x2+y1</em>y2。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">QPoint p<span class="token punctuation">(</span> <span class="token number">3</span>, <span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">;</span>QPoint q<span class="token punctuation">(</span>-1, <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>int lengthSquared <span class="token operator">=</span> QPoint::dotProduct<span class="token punctuation">(</span>p, q<span class="token punctuation">)</span><span class="token punctuation">;</span>   // lengthSquared becomes <span class="token number">25</span>// -3+28<span class="token operator">=</span><span class="token number">25</span>，可以用来计算两条直线之间的角度<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>2、isNull()const : bool，如果 x 和 y 坐标都设置为 0，则返回 true，否则返回 false。</p><p>3、manhattanLength() const : int ，曼哈顿长度，返回的是他们的曼哈顿距离d(i,j)&#x3D;|xi-xj|+|yi-yj|。</p><p>4、rx()，ry()，则是对一个点的x，y坐标单独拿出来进行更改</p><p>5、transPosed(): const QPoint，交换一个点的x，y坐标（exchanged）。</p><h1 id="QPointF"><a href="#QPointF" class="headerlink" title="QPointF"></a>QPointF</h1><h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><p>第一眼看上去以为是一个新的类，结果发现就是Float QPoint（哈哈😁），用法的话相信你认真看完前面的QPoint后，这一个类的使用也会恍然大悟。QPointF在浮点精度上表征平面上的点，绝大部分操作都是与QPoint相类似的，细微的差别在于运算符重载以及提供了QPoint与QPointF的相互转换。</p><h2 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h2><p><img src="https://img-blog.csdnimg.cn/292ce357d1b04be7843cc413ca582df2.png"></p><p>看完这张图你就会发现QPointF的用法和QPoint基本一样的，里面的很多方法和QPoint一样都是对运算符的重载。</p><p>几个要注意的函数：</p><p>1、toPoint() const由浮点精度转化为整数精度</p><p>2、构造函数那里QPointF(const QPoint&amp; point)由是为了从整数精度转化为浮点精度。</p>]]></content>
      
      
      
        <tags>
            
            <tag> QT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python_字典中get（）的使用</title>
      <link href="/2023/06/22/python-zi-dian-zhong-get-de-shi-yong/"/>
      <url>/2023/06/22/python-zi-dian-zhong-get-de-shi-yong/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>当我们使用字典中不存在的键值时，会导致python显示Traceback，指出存在键值错误（KeyError），这时，可以使用方法get()在指定的键值不存在时，显示返回一个默认值，从而避免这样的错误。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">a<span class="token operator">=</span><span class="token punctuation">&#123;</span>    <span class="token string">"jason"</span><span class="token punctuation">:</span><span class="token string">"c"</span><span class="token punctuation">,</span>    <span class="token string">"sarah"</span><span class="token punctuation">:</span><span class="token string">"c++"</span><span class="token punctuation">,</span>    <span class="token string">"aaa"</span><span class="token punctuation">:</span><span class="token string">"python"</span><span class="token punctuation">,</span>    <span class="token string">"bbb"</span><span class="token punctuation">:</span><span class="token string">"javasripe"</span><span class="token punctuation">&#125;</span><span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token string">"jason"</span><span class="token punctuation">]</span><span class="token punctuation">)</span>b<span class="token operator">=</span>a<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">"ccc"</span><span class="token punctuation">,</span> <span class="token string">"Do not have this person."</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出结果：</p><p><img src="https://img-blog.csdnimg.cn/73148b5a36e948c68ad0f09512de3643.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5aSc54yr56iL5bqP54y_,size_17,color_FFFFFF,t_70,g_se,x_16"></p><p>这时我们就可以发现这种错误。</p><p>如果指定的键值可能不存在时，就应该考虑这种方法，不应该使用方括号表示法。</p>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Liskov_Substitution_principle（继承，里氏替换原则）</title>
      <link href="/2023/06/22/liskovsubstitutionprinciple-ji-cheng-li-shi-ti-huan-yuan-ze/"/>
      <url>/2023/06/22/liskovsubstitutionprinciple-ji-cheng-li-shi-ti-huan-yuan-ze/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>在面向对象的程序设计中，<strong>里氏替换原则</strong>（Liskov Substitution principle）是对子类型的特别定义。它由芭芭拉·利斯科夫（Barbara Liskov）在1987年在一次会议上名为“数据的抽象与层次”的演说中首先提出。</p><p>里氏替换原则的内容可以描述为：“派生类（子类）对象可以在程序中代替其基类（超类）对象。”在实际开发中，我们经常会用子类对象去替换掉一个父类对象，这是面向对象编程中一个常见的行为。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token builtin">object</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""人"""</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> name<span class="token punctuation">,</span> age<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>_name <span class="token operator">=</span> name        self<span class="token punctuation">.</span>_age <span class="token operator">=</span> age    <span class="token decorator annotation punctuation">@property</span>    <span class="token keyword">def</span> <span class="token function">name</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>_name    <span class="token decorator annotation punctuation">@property</span>    <span class="token keyword">def</span> <span class="token function">age</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>_age    <span class="token decorator annotation punctuation">@age<span class="token punctuation">.</span>setter</span>    <span class="token keyword">def</span> <span class="token function">age</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> age<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>_age <span class="token operator">=</span> age    <span class="token keyword">def</span> <span class="token function">play</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'%s正在愉快的玩耍.'</span> <span class="token operator">%</span> self<span class="token punctuation">.</span>_name<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">watch_av</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>_age <span class="token operator">>=</span> <span class="token number">18</span><span class="token punctuation">:</span>            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'%s正在观看爱情动作片.'</span> <span class="token operator">%</span> self<span class="token punctuation">.</span>_name<span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'%s只能观看《熊出没》.'</span> <span class="token operator">%</span> self<span class="token punctuation">.</span>_name<span class="token punctuation">)</span><span class="token keyword">class</span> <span class="token class-name">Student</span><span class="token punctuation">(</span>Person<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""学生"""</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> name<span class="token punctuation">,</span> age<span class="token punctuation">,</span> grade<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token builtin">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span>name<span class="token punctuation">,</span> age<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>_grade <span class="token operator">=</span> grade    <span class="token decorator annotation punctuation">@property</span>    <span class="token keyword">def</span> <span class="token function">grade</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>_grade    <span class="token decorator annotation punctuation">@grade<span class="token punctuation">.</span>setter</span>    <span class="token keyword">def</span> <span class="token function">grade</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> grade<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>_grade <span class="token operator">=</span> grade    <span class="token keyword">def</span> <span class="token function">study</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> course<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'%s的%s正在学习%s.'</span> <span class="token operator">%</span> <span class="token punctuation">(</span>self<span class="token punctuation">.</span>_grade<span class="token punctuation">,</span> self<span class="token punctuation">.</span>_name<span class="token punctuation">,</span> course<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">class</span> <span class="token class-name">Teacher</span><span class="token punctuation">(</span>Person<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""老师"""</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> name<span class="token punctuation">,</span> age<span class="token punctuation">,</span> title<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token builtin">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span>name<span class="token punctuation">,</span> age<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>_title <span class="token operator">=</span> title    <span class="token decorator annotation punctuation">@property</span>    <span class="token keyword">def</span> <span class="token function">title</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>_title    <span class="token decorator annotation punctuation">@title<span class="token punctuation">.</span>setter</span>    <span class="token keyword">def</span> <span class="token function">title</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> title<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>_title <span class="token operator">=</span> title    <span class="token keyword">def</span> <span class="token function">teach</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> course<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'%s%s正在讲%s.'</span> <span class="token operator">%</span> <span class="token punctuation">(</span>self<span class="token punctuation">.</span>_name<span class="token punctuation">,</span> self<span class="token punctuation">.</span>_title<span class="token punctuation">,</span> course<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    stu <span class="token operator">=</span> Student<span class="token punctuation">(</span><span class="token string">'王大锤'</span><span class="token punctuation">,</span> <span class="token number">15</span><span class="token punctuation">,</span> <span class="token string">'初三'</span><span class="token punctuation">)</span>    stu<span class="token punctuation">.</span>study<span class="token punctuation">(</span><span class="token string">'数学'</span><span class="token punctuation">)</span>    stu<span class="token punctuation">.</span>watch_av<span class="token punctuation">(</span><span class="token punctuation">)</span>    t <span class="token operator">=</span> Teacher<span class="token punctuation">(</span><span class="token string">'骆昊'</span><span class="token punctuation">,</span> <span class="token number">38</span><span class="token punctuation">,</span> <span class="token string">'砖家'</span><span class="token punctuation">)</span>    t<span class="token punctuation">.</span>teach<span class="token punctuation">(</span><span class="token string">'Python程序设计'</span><span class="token punctuation">)</span>    t<span class="token punctuation">.</span>watch_av<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    main<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里就是一个继承关系，使用了@property包装器来包装getter和setter方法，可以让属性的访问既方便又安全，下面是@property的用法解释。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">Typical use <span class="token keyword">is</span> to define a managed attribute x<span class="token punctuation">:</span><span class="token keyword">class</span> <span class="token class-name">C</span><span class="token punctuation">(</span><span class="token builtin">object</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">getx</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">return</span> self<span class="token punctuation">.</span>_x    <span class="token keyword">def</span> <span class="token function">setx</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">:</span> self<span class="token punctuation">.</span>_x <span class="token operator">=</span> value    <span class="token keyword">def</span> <span class="token function">delx</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">del</span> self<span class="token punctuation">.</span>_x x <span class="token operator">=</span> <span class="token builtin">property</span><span class="token punctuation">(</span>getx<span class="token punctuation">,</span> setx<span class="token punctuation">,</span> delx<span class="token punctuation">,</span> <span class="token string">"I'm the 'x' property."</span><span class="token punctuation">)</span>Decorators make defining new properties <span class="token keyword">or</span> modifying existing ones easy<span class="token punctuation">:</span><span class="token keyword">class</span> <span class="token class-name">C</span><span class="token punctuation">(</span><span class="token builtin">object</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token decorator annotation punctuation">@property</span> <span class="token keyword">def</span> <span class="token function">x</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token string">"I am the 'x' property."</span> <span class="token keyword">return</span> self<span class="token punctuation">.</span>_x    <span class="token decorator annotation punctuation">@x<span class="token punctuation">.</span>setter</span> <span class="token keyword">def</span> <span class="token function">x</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>_x <span class="token operator">=</span> value    <span class="token decorator annotation punctuation">@x<span class="token punctuation">.</span>deleter</span> <span class="token keyword">def</span> <span class="token function">x</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">del</span> self<span class="token punctuation">.</span>_x<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>dbms_output.put_line的用法（Oracle）</title>
      <link href="/2023/06/22/dbmsoutputputline-de-yong-fa-oracle/"/>
      <url>/2023/06/22/dbmsoutputputline-de-yong-fa-oracle/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="dbms-output-put-line的用法"><a href="#dbms-output-put-line的用法" class="headerlink" title="dbms_output.put_line的用法"></a><strong>dbms_output.put_line的用法</strong></h1><h1 id="涉及到的知识点如下："><a href="#涉及到的知识点如下：" class="headerlink" title="涉及到的知识点如下："></a>涉及到的知识点如下：</h1><h2 id="1、enable："><a href="#1、enable：" class="headerlink" title="1、enable："></a>1、enable：</h2><p>在serveroutput on的情况下，用来使dbms_output生效(默认即打开)</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">set serveroutput on --将output 服务打开<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="2、disable："><a href="#2、disable：" class="headerlink" title="2、disable："></a>2、disable：</h2><p>在serveroutput on的情况下，用来使dbms_output失效</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">set serveroutput off --将output 服务关闭<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/5ccf8ce979664cd9ac2103cc09e0058e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5aSc54yr56iL5bqP54y_,size_20,color_FFFFFF,t_70,g_se,x_16"></p><h2 id="3、put："><a href="#3、put：" class="headerlink" title="3、put："></a>3、put：</h2><p>将内容写到内存，等到put_line时一起输出，new_line的时候也可以输出。</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">begin  dbms_output.put_line(&#39;hello world1111111&#39;);  dbms_output.new_line();  dbms_output.put(&#39;Hello, Lao An &#39;);  dbms_output.put(&#39;Hello, Lao An &#39;);  dbms_output.new_line();  dbms_output.put_line(&#39;Hello, Lao An &#39;);end;&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出：</p><p><img src="https://img-blog.csdnimg.cn/76f3c865dc57456f8a525932af924bac.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5aSc54yr56iL5bqP54y_,size_15,color_FFFFFF,t_70,g_se,x_16"></p><h2 id="4、put-line："><a href="#4、put-line：" class="headerlink" title="4、put_line："></a>4、put_line：</h2><p>不用多说了，输出字符，并刷新buffer，前提是set severoutput on；</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">exec dbms_output.put_line(&#39;hello world1111111&#39;);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/6afc315404ed49bb9f4a3358ece7ff8a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5aSc54yr56iL5bqP54y_,size_20,color_FFFFFF,t_70,g_se,x_16"></p><h2 id="5、new-line："><a href="#5、new-line：" class="headerlink" title="5、new_line："></a>5、new_line：</h2><p>作为一行的结束，可以理解为写入buffer时的换行符</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">set serveroutput onbegin  dbms_output.put_line(&#39;hello world1111111&#39;);  dbms_output.put(&#39;Hello, Lao An&#39;);  dbms_output.new_line();  dbms_output.put_line(&#39;Hello, Lao An&#39;);end;&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/184650230b38414d9a9c55c14a29b417.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5aSc54yr56iL5bqP54y_,size_20,color_FFFFFF,t_70,g_se,x_16"></p><p><strong>这里运用了begin+&#x2F;来执行PL&#x2F;SQL过程，我解释一下oracle中斜杠(&#x2F;)<strong>的含义 斜杠就是让</strong>服务器执行前面所写的sql脚本</strong>。如果是普通的select语句，一个分号，就可以执行了。但是如果是存储过程，那么遇到分号，就不能马上执行了。这个时候，就需要通过斜杠(&#x2F;)来执行。</p><p><img src="https://img-blog.csdnimg.cn/33849042ca5845109d969979e1147cb5.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5aSc54yr56iL5bqP54y_,size_20,color_FFFFFF,t_70,g_se,x_16"></p><h2 id="6、get-line-value-index-："><a href="#6、get-line-value-index-：" class="headerlink" title="6、get_line(value, index)："></a>6、get_line(value, index)：</h2><p>获取缓冲区的单行信息。</p><p>注：使用get_line时不能用put_line输出，因为put_line之后会将buffer清空。(当然在<strong>serveroutput off的情况下put_line是不影响buffer的</strong>)。</p><h2 id="7、get-lines-array-index-："><a href="#7、get-lines-array-index-：" class="headerlink" title="7、get_lines(array, index)："></a>7、get_lines(array, index)：</h2><p>以数组形式来获取缓冲区的多行信息</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">declare   v_data dbms_output.chararr;   --先声明局部变量                          v_numlines number;                                   begin                                                  --enable the buffer first.                             dbms_output.enable(1000000);   --设置缓冲区的大小                                                                               dbms_output.put_line(&#39;line one&#39;);                       dbms_output.put_line(&#39;line two&#39;);                       dbms_output.put_line(&#39;line three&#39;);                                                                          v_numlines :&#x3D; 3;                                       dbms_output.get_lines(v_data, v_numlines);  --array, index           for v_counter in 1..v_numlines loop                        dbms_output.put_line(v_data(v_counter));               end loop;                                           end;                                                &#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 输出：</p><p><img src="https://img-blog.csdnimg.cn/91e4417305374c8199922a56fd95e2d6.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5aSc54yr56iL5bqP54y_,size_10,color_FFFFFF,t_70,g_se,x_16"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++_中数据类型大小（所占用字节数）</title>
      <link href="/2023/06/22/c-zhong-shu-ju-lei-xing-da-xiao-suo-zhan-yong-zi-jie-shu/"/>
      <url>/2023/06/22/c-zhong-shu-ju-lei-xing-da-xiao-suo-zhan-yong-zi-jie-shu/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#include&lt;iostream></span>using namespace std<span class="token punctuation">;</span><span class="token comment">#define str(type) #type</span><span class="token comment">#define sz(type) cout&lt;&lt; str(type) &lt;&lt; ":" &lt;&lt; sizeof(type) &lt;&lt; "B"&lt;&lt; endl; </span>int <span class="token function-name function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>sz<span class="token punctuation">(</span>char<span class="token punctuation">)</span><span class="token punctuation">;</span>sz<span class="token punctuation">(</span>unsigned char<span class="token punctuation">)</span><span class="token punctuation">;</span>sz<span class="token punctuation">(</span>short<span class="token punctuation">)</span><span class="token punctuation">;</span>sz<span class="token punctuation">(</span>unsigned short<span class="token punctuation">)</span><span class="token punctuation">;</span>sz<span class="token punctuation">(</span>int<span class="token punctuation">)</span><span class="token punctuation">;</span>sz<span class="token punctuation">(</span>unsigned int<span class="token punctuation">)</span><span class="token punctuation">;</span>sz<span class="token punctuation">(</span>long<span class="token punctuation">)</span><span class="token punctuation">;</span>sz<span class="token punctuation">(</span>unsigned long<span class="token punctuation">)</span><span class="token punctuation">;</span>sz<span class="token punctuation">(</span>int long<span class="token punctuation">)</span><span class="token punctuation">;</span>sz<span class="token punctuation">(</span>unsigned int long<span class="token punctuation">)</span><span class="token punctuation">;</span>sz<span class="token punctuation">(</span>long long<span class="token punctuation">)</span><span class="token punctuation">;</span>sz<span class="token punctuation">(</span>unsigned long long<span class="token punctuation">)</span><span class="token punctuation">;</span>sz<span class="token punctuation">(</span>float<span class="token punctuation">)</span><span class="token punctuation">;</span>sz<span class="token punctuation">(</span>double<span class="token punctuation">)</span><span class="token punctuation">;</span>sz<span class="token punctuation">(</span>long double<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token builtin class-name">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="define字符串化运算符"><a href="#define字符串化运算符" class="headerlink" title="define字符串化运算符"></a>define字符串化运算符</h1><p>在这里第四行，用到了define 的一元运算符 #，它常称为字符串化运算符（stringify operator 或 stringizing operator），<strong>它会把宏调用时的实参转换为字符串</strong>。# 的操作数必须是宏替换文本中的形参。当形参名称出现在替换文本中，并且具有前缀 # 字符时，预处理器会把与该形参对应的实参放到一对双引号中，形成一个字符串字面量。</p><p><strong>比如在这里，sz(char)，#会把char转化成”char”，赋值给str(type)，然后输出。</strong></p><h1 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h1><p> <br><img src="https://img-blog.csdnimg.cn/6c36ca9663924a3e9d801828e632ee64.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5aSc54yr56iL5bqP54y_,size_8,color_FFFFFF,t_70,g_se,x_16"></p>]]></content>
      
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++_中explicit的作用及用法（虽然简单，但是还是有用的）</title>
      <link href="/2023/06/22/c-zhong-explicit-de-zuo-yong-ji-yong-fa-sui-ran-jian-dan-dan-shi-huan-shi-you-yong-de/"/>
      <url>/2023/06/22/c-zhong-explicit-de-zuo-yong-ji-yong-fa-sui-ran-jian-dan-dan-shi-huan-shi-you-yong-de/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p><strong>目录</strong></p><p><a href="#%C2%A0C++explicit%EF%BC%88%E5%AE%98%E7%BD%91%E7%9A%84%E8%AF%B4%E6%B3%95%EF%BC%89"> C++explicit（官网的说法）</a></p><p><a href="#firstHeading">explicit specifier</a></p><p><a href="#C++explicit%20%E6%B8%85%E6%A5%9A%E7%9A%84%E8%AF%B4%E6%B3%95%EF%BC%88%E5%BB%BA%E8%AE%AE%E8%8B%B1%E6%96%87%E4%B8%8D%E5%A5%BD%E7%9A%84%E4%BB%8E%E8%BF%99%E9%87%8C%E5%BC%80%E5%A7%8B%E9%A3%9F%E7%94%A8%E5%93%A6%EF%BC%89">C++explicit 清楚的说法（建议英文不好的从这里开始食用哦）</a></p><p><a href="#explicit%E4%BD%9C%E7%94%A8:">explicit作用:</a></p><p><a href="#explicit%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9:">explicit使用注意事项:</a></p><p><a href="#C++explicit%E4%BD%BF%E7%94%A8%E7%9A%84%E4%BE%8B%E5%AD%90%EF%BC%88%E5%BB%BA%E8%AE%AE%E5%96%9C%E6%AC%A2%E8%87%AA%E5%B7%B1%E6%95%B2%E4%BB%A3%E7%A0%81%E5%AE%9E%E9%AA%8C%E7%9A%84%E4%BB%8E%E8%BF%99%E9%87%8C%E5%BC%80%E5%A7%8B%E9%A3%9F%E7%94%A8%E5%93%A6%EF%BC%89">C++explicit使用的例子（建议喜欢自己敲代码实验的从这里开始食用哦）</a></p><p><a href="#%E4%BE%8B%E5%AD%90">例子</a></p><p><a href="#%C2%A0%E4%B8%8A%E9%9D%A2%E4%B8%89%E8%A1%8C%E7%9A%84%E6%8A%A5%E9%94%99%E4%BF%A1%E6%81%AF%EF%BC%9A"> 上面三行的报错信息：</a></p><p><a href="#%E6%80%BB%E7%BB%93">总结</a></p><h1 id="C-explicit（官网的说法）"><a href="#C-explicit（官网的说法）" class="headerlink" title="C++explicit（官网的说法）"></a>C++explicit（官网的说法）</h1><h1 id="explicit-specifier"><a href="#explicit-specifier" class="headerlink" title="explicit specifier"></a><code>explicit</code> specifier</h1><p><code>**explicit**</code>(1)<code>**explicit (**</code> expression <code>**)**</code>(2)(since C++20)<br>expression-<a href="https://en.cppreference.com/w/cpp/language/constant_expression#Converted_constant_expression">contextually converted constant expression of type bool</a></p><p>1) Specifies that a constructor or conversion function (since C++11) or <a href="https://en.cppreference.com/w/cpp/language/ctad">deduction guide</a> (since C++17) is explicit, that is, it cannot be used for <a href="https://en.cppreference.com/w/cpp/language/implicit_cast">implicit conversions</a> and <a href="https://en.cppreference.com/w/cpp/language/copy_initialization">copy-initialization</a>.</p><p>翻译：指定构造函数或转换函数 (C++11 起) 或推导指南 (C++17 起) 是显式的，也就是说，它不能用于隐式转换和复制初始化。</p><p>2) The explicit specifier may be used with a constant expression. The function is explicit if and only if that constant expression evaluates to true. (since C++20)</p><p>翻译：显式说明符可以与常量表达式一起使用。当且仅当该常量表达式的计算结果为真时，该函数才是显式的。 </p><p>The explicit specifier may only appear within the decl-specifier-seq of the declaration of a constructor or conversion function (since C++11) within its class definition.</p><p>翻译：显式说明符只能出现在其类定义中的构造函数或转换函数（C++11 起）声明的 decl-specifier-seq 中。</p><h1 id="C-explicit-清楚的说法（建议英文不好的从这里开始食用哦）"><a href="#C-explicit-清楚的说法（建议英文不好的从这里开始食用哦）" class="headerlink" title="C++explicit 清楚的说法（建议英文不好的从这里开始食用哦）"></a>C++explicit 清楚的说法（建议英文不好的从这里开始食用哦）</h1><h2 id="explicit作用"><a href="#explicit作用" class="headerlink" title="explicit作用:"></a><strong>explicit作用:</strong></h2><p>在C++中，explicit关键字用来<strong>修饰类的构造函数</strong>，被修饰的构造函数的类，不能发生相应的隐式类型转换，只能以显式的方式进行类型转换。</p><h2 id="explicit使用注意事项"><a href="#explicit使用注意事项" class="headerlink" title="explicit使用注意事项:"></a>explicit使用注意事项:</h2><p>      （1）explicit 关键字只能用于类内部的构造函数声明上。</p><p>      （2） explicit 关键字作用于单个参数的构造函数。</p><p>    * 在C++中，explicit关键字用来修饰类的构造函数，被修饰的构造函数的类，不能发生相应的隐式类型转换</p><h1 id="C-explicit使用的例子（建议喜欢自己敲代码实验的从这里开始食用哦）"><a href="#C-explicit使用的例子（建议喜欢自己敲代码实验的从这里开始食用哦）" class="headerlink" title="C++explicit使用的例子（建议喜欢自己敲代码实验的从这里开始食用哦）"></a>C++explicit使用的例子（建议喜欢自己敲代码实验的从这里开始食用哦）</h1><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;class Circle&#123;    public:        Circle()&#123;&#125;        Circle(double _a):a(_a)&#123;&#125;        Circle(int _b, int _c):b(_b), c(_c)&#123;&#125;        Circle(const Circle&amp; A)        &#123;            a&#x3D;A.a; b&#x3D;A.b; c&#x3D;A.c;        &#125;        void Print()        &#123;            cout&lt;&lt;a&lt;&lt;&quot; &quot;&lt;&lt;b&lt;&lt;&quot; &quot;&lt;&lt;c&lt;&lt;endl;        &#125;    private:        double a;        int b;        int c;&#125;;class Circle1&#123;    public:        Circle1()&#123;&#125;        explicit Circle1(double _a):a(_a)&#123;&#125;        explicit Circle1(int _b, int _c):b(_b), c(_c)&#123;&#125;        explicit Circle1(const Circle1&amp; A)        &#123;            a&#x3D;A.a; b&#x3D;A.b; c&#x3D;A.c;        &#125;        void Print()        &#123;            cout&lt;&lt;a&lt;&lt;&quot; &quot;&lt;&lt;b&lt;&lt;&quot; &quot;&lt;&lt;c&lt;&lt;endl;        &#125;    private:        double a;        int b;        int c;&#125;;int main()&#123;    Circle q1(1);    Circle w1(2, 3);    q1.Print();    w1.Print();    &#x2F;&#x2F;隐式调用, 不会报错    Circle q2 &#x3D; 1;&#x2F;&#x2F; just like Circle q(1); 调用的是Circle(double _a)    Circle w2 &#x3D; 1.0;&#x2F;&#x2F; just like Circle q(1.0); 调用的是Circle(double _a)    Circle e &#x3D; q2;&#x2F;&#x2F; 调用的是Circle(const Circle&amp; A)            &#x2F;&#x2F;隐式调用，会报错，注意Circle1()的构造函数，都有explicit    &#x2F;&#x2F; Circle1 q3 &#x3D; 1;    &#x2F;&#x2F; Circle1 w3 &#x3D; 1.0;    &#x2F;&#x2F; Circle1 e1 &#x3D; q3;    &#x2F;&#x2F; 以上三行都会报错。    &#x2F;&#x2F;显式调用，都不会有问题    Circle1 q3(1);    Circle1 w3(1.0);    Circle1 e1(q3);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="上面三行的报错信息："><a href="#上面三行的报错信息：" class="headerlink" title="上面三行的报错信息："></a>上面三行的报错信息：</h2><p><img src="https://img-blog.csdnimg.cn/597541d462a9453d918bbb4657e54c68.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5aSc54yr56iL5bqP54y_,size_16,color_FFFFFF,t_70,g_se,x_16"></p><p><img src="https://img-blog.csdnimg.cn/ea541e17239346b9abf52c487615d072.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5aSc54yr56iL5bqP54y_,size_17,color_FFFFFF,t_70,g_se,x_16"></p><p><img src="https://img-blog.csdnimg.cn/583c79b46bd24c49953bb1a84ba525b1.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5aSc54yr56iL5bqP54y_,size_14,color_FFFFFF,t_70,g_se,x_16"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>explicit可以<strong>抑制</strong>内置类型隐式转换，所以在类的构造函数中，<strong>最好尽可能多用explicit关键字，</strong>防止不必要的隐式转换。</p>]]></content>
      
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++_std::array用法</title>
      <link href="/2023/06/22/c-stdarray-yong-fa/"/>
      <url>/2023/06/22/c-stdarray-yong-fa/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="Array简介"><a href="#Array简介" class="headerlink" title="Array简介"></a>Array简介</h1><p><code>std::array</code> is a container that encapsulates fixed size arrays.</p><p>Defined in header <code>[&lt;array&gt;](https://en.cppreference.com/w/cpp/header/array)</code> template&lt;<br>    class T,     <a href="http://en.cppreference.com/w/cpp/types/size_t">std::size_t</a> N &gt; struct array;(since C++11)</p><p>它是c++里面的一个容器，在使用上与普通数组相似，但是它的大小是固定的，无法像vector一样动态扩展，安全性上面也比普通数组更加安全 。</p><h1 id="初始化方式"><a href="#初始化方式" class="headerlink" title="初始化方式"></a>初始化方式</h1><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">array&lt;int, 10&gt; arr&#x3D;&#123;1, 2, 3, 4, 5&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在这里，只初始化了数组的前五个值，后面的五个值都是0。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;array&gt;using namespace std;int main() &#123;    array&lt;int, 10&gt; a &#x3D; &#123; 1, 2 ,3, 4, 5 &#125;;    for (int i &#x3D; 0; i &lt; 10; i++)    &#123;        cout &lt;&lt; a.at(i) &lt;&lt; &quot; &quot;;    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出： </p><p><img src="https://img-blog.csdnimg.cn/b69f3e004722493e84bcb6d0812ce8bf.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5aSc54yr56iL5bqP54y_,size_13,color_FFFFFF,t_70,g_se,x_16"></p><h1 id="array容器成员函数汇总"><a href="#array容器成员函数汇总" class="headerlink" title="array容器成员函数汇总"></a>array容器成员函数汇总</h1><p><strong>成员函数功能</strong></p><ol><li>begin()返回指向容器中第一个元素的随机访问迭代器。</li><li>end()返回指向容器最后一个元素之后一个位置的随机访问迭代器，通常和 begin() 结合使用。</li><li>rbegin()返回指向最后一个元素的随机访问迭代器。</li><li>rend()返回指向第一个元素之前一个位置的随机访问迭代器。</li><li>cbegin()和 begin() 功能相同，只不过在其基础上增加了 const 属性，不能用于修改元素。</li><li>cend()和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。crbegin()和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</li><li>crend()和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</li><li>size()返回容器中当前元素的数量，其值始终等于初始化 array 类的第二个模板参数 N。</li><li>max_size()返回容器可容纳元素的最大数量，其值始终等于初始化 array 类的第二个模板参数 N。</li><li>empty()判断容器是否为空，和通过 size()&#x3D;&#x3D;0 的判断条件功能相同，但其效率可能更快。</li><li>at(n)返回容器中 n 位置处元素的引用，该函数自动检查 n 是否在有效的范围内，如果不是则抛出 out_of_range 异常。</li><li>front()返回容器中第一个元素的直接引用，该函数不适用于空的 array 容器。</li><li>back()返回容器中最后一个元素的直接应用，该函数同样不适用于空的 array 容器。</li><li>data()返回一个指向容器首个元素的指针。利用该指针，可实现复制容器中所有元素等类似功能。</li><li>fill(val)将 val 这个值赋值给容器中的每个元素。</li><li>array1.swap(array2)交换 array1 和 array2 容器中的所有元素，但前提是它们具有相同的长度和类型。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++_allocator类</title>
      <link href="/2023/06/22/c-callocator-lei/"/>
      <url>/2023/06/22/c-callocator-lei/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p><strong>目录</strong></p><p><a href="#firstHeading">std::allocator::allocate</a></p><p><a href="#c++%E4%B8%AD%E7%9A%84allocator%E7%B1%BB">c++中的allocator类</a></p><p><a href="#%E6%A6%82%E8%BF%B0">概述</a></p><p><a href="#allocator%E7%94%A8%E6%B3%95">allocator用法</a></p><p><a href="#%E8%AF%A6%E8%A7%A3">详解</a></p><p><a href="#allocate%E7%94%A8%E4%BA%8E%E5%88%86%E9%85%8D%E5%8E%9F%E5%A7%8B%E5%86%85%E5%AD%98">allocate用于分配原始内存</a></p><p><a href="#Return%20value">Return value</a></p><p><a href="#%E5%9C%A8STL%E4%B8%AD%E4%B9%9F%E4%BC%9A%E7%94%A8allocate%E7%B1%BB">在STL中也会用allocate类</a></p><h1 id="std-allocator-allocate"><a href="#std-allocator-allocate" class="headerlink" title="std::allocator::allocate"></a>std::allocator<T>::allocate</h1><p>(1)<br>pointer allocate( size_type n, const void * hint &#x3D; 0 ); (until C++17)<br>T* allocate( <a href="http://en.cppreference.com/w/cpp/types/size_t">std::size_t</a> n, const void * hint); (since C++17) (deprecated) (removed in C++20)(2)<br>T* allocate( <a href="http://en.cppreference.com/w/cpp/types/size_t">std::size_t</a> n ); (since C++17) (until C++20)<br>[[nodiscard]] constexpr T* allocate( <a href="http://en.cppreference.com/w/cpp/types/size_t">std::size_t</a> n ); (since C++20)</p><h1 id="c-中的allocator类"><a href="#c-中的allocator类" class="headerlink" title="c++中的allocator类"></a>c++中的allocator类</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li>它用于将内存的分配和对象的构造分离开来. 它分配的<strong>内存是原始的、未构造的.</strong>+ Throws <a href="https://en.cppreference.com/w/cpp/memory/new/bad_alloc">std::bad_alloc</a> if allocation fails.+ 标准库中allocator类定义在头文件memory中</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">allocator&lt;string&gt; alloc;  &#x2F;&#x2F; 定义了一个可以分配string的allocator对象auto const p &#x3D; alloc.allocate(n);  &#x2F;&#x2F; 分配n个未初始化的string内存，即为n个空string分配了内存，分配的内存是原始的、未构造的<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h1 id="allocator用法"><a href="#allocator用法" class="headerlink" title="allocator用法"></a>allocator用法</h1><ul><li>allocator a &#x2F;&#x2F; 定义了一个名为a的allocator对象，它可以为类型T的对象分配内存+ a.allocate(n) &#x2F;&#x2F; 分配能保存<strong>n个类型为T的对象的内存</strong>+ a.deallocate(p, n) &#x2F;&#x2F; <strong>释放T*指针p地址开始的内存</strong>，这块内存保存了n个类型为T的对象，p必须是一个先前由allocate返回的指针，且n必须是p创建时所要求的大小，且<strong>在调用该函数之前必须销毁在这片内存上创建的对象</strong>，这是因为在创建的过程中我们分配的是最原始的内存，所以在释放内存的时候也只能严格释放<strong>这片最原始的内存</strong>+ a.construct(p, args) &#x2F;&#x2F; p必须是一个类型为T<em>的指针，指向一片原始内存，arg将被传递给类型为T的构造函数，用来在p指向的原始内存上构建对象+ a.destory(p) &#x2F;&#x2F; p为T</em>类型的指针，用于对p指向的对象执行析构函数</li></ul><h1 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h1><ul><li><h2 id="allocate用于分配原始内存"><a href="#allocate用于分配原始内存" class="headerlink" title="allocate用于分配原始内存"></a>allocate用于<strong>分配原始内存</strong></h2></li><li><p>正如前面说到，allocate出来的内存是最原始的，未构造的内存. 它的construct成员函数接受一个指针和零个或多个额外的参数，在<strong>给定位置构造对象</strong>， 额外的参数是用于初始化构造对象的</p></li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">auto q &#x3D; p;  &#x2F;&#x2F; q指向最后构造的元素之后的位置alloc.construct(q++);  &#x2F;&#x2F; *q为空字符串alloc.construct(q++, 10, &#39;c&#39;);  &#x2F;&#x2F; *q为ccccccccccalloc.construct(q++, &quot;hi&quot;);  &#x2F;&#x2F; *q为hi<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>用完对象后，<strong>必须对这种构造的对象调用destory销毁</strong>，它接受一个指针，对指向的对象执行析构函数</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">while(q !&#x3D; p)alloc.destory(--q);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p> 循环开始处，q是指向最后构造的元素之后的一个位置，调用destory之前我们先对q进行递减操作，所以第一次调用destory销毁的是最后一个元素，依次执行销毁操作直到q和p相等. 我们只能对真正构造了的元素进行destory操作，一旦元素被销毁，就可以重新使用这部分内存来保存其他string或归还给系统，释放内存通过调用deallocate完成 </p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">alloc.deallocate(p, n)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p> 其中p不能为空，必须指向allocate分配的内存，而且大小参数n也必须与调用allocate分配内存时提供的大小参数相等。 +  ### Return value<br> Pointer to the first element of an array of <code>n</code> objects of type <code>T</code> whose elements have not been constructed yet.  就是返回未构造的第一个元素 </p><h1 id="在STL中也会用allocate类"><a href="#在STL中也会用allocate类" class="headerlink" title="在STL中也会用allocate类"></a>在STL中也会用allocate类</h1><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;memory></span></span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span> <span class="token keyword">class</span> <span class="token class-name">Vector</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Vector</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">elements</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">first_free</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    <span class="token keyword">void</span> <span class="token function">push_back</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">static</span> std<span class="token double-colon punctuation">::</span>allocator<span class="token operator">&lt;</span>T<span class="token operator">></span> alloc<span class="token punctuation">;</span> <span class="token comment">// object to get raw memory</span>    <span class="token keyword">void</span> <span class="token function">reallocate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// get more space and copy existing elements</span>    T<span class="token operator">*</span> elements<span class="token punctuation">;</span>        <span class="token comment">// pointer to first elment in the array</span>    T<span class="token operator">*</span> first_free<span class="token punctuation">;</span>      <span class="token comment">// pointer to first free element in the array</span>    T<span class="token operator">*</span> end<span class="token punctuation">;</span>             <span class="token comment">// pointer to one past the end of the array</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span> std<span class="token double-colon punctuation">::</span>allocator<span class="token operator">&lt;</span>T<span class="token operator">></span> Vector<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token double-colon punctuation">::</span>alloc<span class="token punctuation">;</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">void</span> <span class="token class-name">Vector</span><span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token double-colon punctuation">::</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> t<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>first_free <span class="token operator">==</span> end<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">reallocate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    alloc<span class="token punctuation">.</span><span class="token function">construct</span><span class="token punctuation">(</span>first_free<span class="token punctuation">,</span> t<span class="token punctuation">)</span><span class="token punctuation">;</span>    first_free<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">void</span> <span class="token class-name">Vector</span><span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token double-colon punctuation">::</span><span class="token function">reallocate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// compute size of current array and allocate space for twice as many elements</span>    std<span class="token double-colon punctuation">::</span>ptrdiff_t size <span class="token operator">=</span> first_free <span class="token operator">-</span> elements<span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>ptrdiff_t newcapacity <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> <span class="token punctuation">(</span>size <span class="token operator">></span> <span class="token number">1</span> <span class="token operator">?</span> size <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//容量翻倍</span>    T<span class="token operator">*</span> newelements <span class="token operator">=</span> alloc<span class="token punctuation">.</span><span class="token function">allocate</span><span class="token punctuation">(</span>newcapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span><span class="token function">uninitialized_copy</span><span class="token punctuation">(</span>elements<span class="token punctuation">,</span> first_free<span class="token punctuation">,</span> newelements<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//元素拷贝</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>T<span class="token operator">*</span> p <span class="token operator">=</span> first_free<span class="token punctuation">;</span> p <span class="token operator">!=</span> elements<span class="token punctuation">;</span> alloc<span class="token punctuation">.</span><span class="token function">destroy</span><span class="token punctuation">(</span><span class="token operator">--</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//原来的空间的释放</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>elements<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        alloc<span class="token punctuation">.</span><span class="token function">deallocate</span><span class="token punctuation">(</span>elements<span class="token punctuation">,</span> end <span class="token operator">-</span> elements<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    elements <span class="token operator">=</span> newelements<span class="token punctuation">;</span>    first_free <span class="token operator">=</span> elements <span class="token operator">+</span> size<span class="token punctuation">;</span>    end <span class="token operator">=</span> elements <span class="token operator">+</span> newcapacity<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络</title>
      <link href="/2023/06/20/ji-suan-ji-wang-luo/"/>
      <url>/2023/06/20/ji-suan-ji-wang-luo/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p><strong>目录</strong></p><p><a href="#%E5%B8%B8%E7%94%A8%E7%9A%84%E5%8D%8F%E8%AE%AE%EF%BC%9A">常用的协议：</a></p><p><a href="#%E6%A6%82%E5%BF%B5%C2%A0">概念 </a></p><p><a href="#OSI%207%E5%B1%82%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B%C2%A0">OSI 7层参考模型 </a></p><p><a href="#TCP/IP%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B%EF%BC%9A%E7%BD%91%E7%BD%91%E4%BC%A0%E5%BA%94">TCP&#x2F;IP参考模型：网网传应</a></p><p><a href="#%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%201%EF%BC%9A%C2%A0TCP%20%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E8%80%8C%E4%B8%8D%E6%98%AF%E4%B8%A4%E6%AC%A1%EF%BC%9F">常见面试题 1： TCP 建立连接为什么要三次握手而不是两次？</a></p><p><a href="#%E5%A5%88%E6%B0%8F%E5%87%86%E5%88%99%E4%B8%8E%E9%A6%99%E5%A5%88%E5%AE%9A%E7%90%86">奈氏准则与香奈定理</a></p><p><a href="#%E7%BC%96%E7%A0%81%E4%B8%8E%E8%B0%83%E5%88%B6">编码与调制</a></p><p><a href="#%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82">数据链路层</a></p><p><a href="#%E5%B8%A7%E5%AE%9A%E7%95%8C%EF%BC%9A">帧定界：</a></p><p><a href="#%E5%B7%AE%E9%94%99%E6%A3%80%E6%B5%8B%EF%BC%9A%E5%A5%87%E5%81%B6%E6%A0%A1%E9%AA%8C%EF%BC%88%E8%AE%A1%E7%BB%84%EF%BC%89%E3%80%82">差错检测：奇偶校验（计组）。</a></p><p><a href="#%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">可靠传输的基本概念</a></p><p><a href="#SW%E5%8D%8F%E8%AE%AE%EF%BC%9AStop%20and%20Wait%EF%BC%88%E5%81%9C%E6%AD%A2%E7%AD%89%E5%BE%85%E5%8D%8F%E8%AE%AE%EF%BC%89">SW协议：Stop and Wait（停止等待协议）</a></p><p><a href="#%E5%9B%9E%E9%80%80N%E5%B8%A7%E5%8D%8F%E8%AE%AE%EF%BC%9AGBN%E5%8D%8F%E8%AE%AE">回退N帧协议：GBN协议</a></p><p><a href="#%E9%80%89%E6%8B%A9%E9%87%8D%E4%BC%A0%E5%8D%8F%E8%AE%AE%EF%BC%9ASR%E5%8D%8F%E8%AE%AE">选择重传协议：SR协议</a></p><p><a href="#%E7%82%B9%E5%AF%B9%E7%82%B9%E5%8D%8F%E8%AE%AE%EF%BC%88Point-to-Point%20Protocol%EF%BC%89">点对点协议（Point-to-Point Protocol）</a></p><p><a href="#%E4%BB%8B%E8%B4%A8%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6">介质访问控制</a></p><p><a href="#CSMA/CD%C2%A0%E5%8D%8F%E8%AE%AE">CSMA&#x2F;CD 协议</a></p><p><a href="#CSMA/CA%E5%8D%8F%E8%AE%AE">CSMA&#x2F;CA协议</a></p><p><a href="#Mac%E5%9C%B0%E5%9D%80%20IP%E5%9C%B0%E5%9D%80%20Arp%E5%8D%8F%E8%AE%AE">Mac地址 IP地址 Arp协议</a></p><p><a href="#%E9%9B%86%E7%BA%BF%E5%99%A8%E3%80%81%E4%BA%A4%E6%8D%A2%E6%9C%BA%E3%80%81%E8%B7%AF%E7%94%B1%E5%99%A8">集线器、交换机、路由器</a></p><p><a href="#%E4%BB%A5%E5%A4%AA%E7%BD%91%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%9A%84%E8%87%AA%E5%AD%A6%E4%B9%A0%E5%92%8C%E8%BD%AC%E5%8F%91%E5%B8%A7%E7%9A%84%E6%B5%81%E7%A8%8B%C2%A0">以太网交换机的自学习和转发帧的流程 </a></p><p><a href="#%E4%BB%A5%E5%A4%AA%E7%BD%91%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%9A%84%E7%94%9F%E6%88%90%E6%A0%91%E5%8D%8F%E8%AE%AE">以太网交换机的生成树协议</a></p><p><a href="#%E8%99%9A%E6%8B%9F%E5%B1%80%E5%9F%9F%E7%BD%91VLAN%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6">虚拟局域网VLAN的实现机制</a></p><p><a href="#IPv4%E5%9C%B0%E5%9D%80%E7%9A%84%E6%A0%BC%E5%BC%8F">IPv4地址的格式</a></p><p><a href="#%E5%88%86%E7%B1%BB%E7%BC%96%E5%88%B6%E7%9A%84IPv4%E5%9C%B0%E5%9D%80">分类编制的IPv4地址</a></p><p><a href="#%E5%88%92%E5%88%86%E5%AD%90%E7%BD%91%E7%9A%84IPv4%E5%9C%B0%E5%9D%80">划分子网的IPv4地址</a></p><p><a href="#%E6%97%A0%E5%88%86%E7%B1%BB%E7%BC%96%E5%9D%80%E7%9A%84%E5%88%92%E5%88%86%E5%AD%90%E7%BD%91CIDR">无分类编址的划分子网CIDR</a></p><p><a href="#IP%E6%95%B0%E6%8D%AE%E6%8A%A5%E7%9A%84%E5%8F%91%E9%80%81%E4%B8%8E%E8%BD%AC%E5%8F%91%E8%BF%87%E7%A8%8B">IP数据报的发送与转发过程</a></p><p><a href="#%E9%9D%99%E6%80%81%E8%B7%AF%E7%94%B1%E9%85%8D%E7%BD%AE%E4%BB%A5%E5%8F%8A%E5%8F%AF%E8%83%BD%E4%BA%A7%E7%94%9F%E7%9A%84%E8%B7%AF%E7%94%B1%E7%8E%AF%E8%B7%AF%E9%97%AE%E9%A2%98">静态路由配置以及可能产生的路由环路问题</a></p><p><a href="#%E5%A4%96%E9%83%A8%20BGP%20%E4%B8%8E%E5%86%85%E9%83%A8%20BGP%20%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F">外部 BGP 与内部 BGP 有什么区别？</a></p><p><a href="#%E5%86%85%E9%83%A8%E7%BD%91%E5%85%B3%E5%8D%8F%E8%AE%AE%EF%BC%9A%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E5%8D%8F%E8%AE%AERIP%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86">内部网关协议：路由选择协议RIP的基本工作原理</a></p><p><a href="#%E5%B9%BF%E6%92%AD%E5%9F%9F%E4%B8%8E%E5%86%B2%E7%AA%81%E5%9F%9F">广播域与冲突域</a></p><p><a href="#%E5%BC%80%E6%94%BE%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84OSPF%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86">开放最短路径OSPF的基本工作原理</a></p><p><a href="#%E8%BE%B9%E7%95%8C%E7%BD%91%E5%85%B3%E5%8D%8F%E8%AE%AEBGP">边界网关协议BGP</a></p><p><a href="#IPVv4%E6%95%B0%E6%8D%AE%E6%8A%A5%E7%9A%84%E6%A0%BC%E5%BC%8F">IPVv4数据报的格式</a></p><p><a href="#%E7%BD%91%E9%99%85%E6%8E%A7%E5%88%B6%E6%8A%A5%E6%96%87%E5%8D%8F%E8%AE%AEICMP">网际控制报文协议ICMP</a></p><p><a href="#%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2NAT%E5%92%8C%E8%99%9A%E6%8B%9F%E4%B8%93%E7%94%A8%E7%BD%91VPN">网络地址转换NAT和虚拟专用网VPN</a></p><p><a href="#%E8%BF%90%E8%BE%93%E5%B1%82%E7%AE%80%E4%BB%8B">运输层简介</a></p><p><a href="#%E8%BF%90%E8%BE%93%E5%B1%82%E7%AB%AF%E5%8F%A3%E5%8F%B7%E3%80%81%E5%88%86%E7%94%A8%E3%80%81%E5%A4%8D%E7%94%A8%E7%9A%84%E6%A6%82%E5%BF%B5%C2%A0">运输层端口号、分用、复用的概念 </a></p><p><a href="#UDP%E5%92%8CTCP%E7%9A%84%E5%AF%B9%E6%AF%94">UDP和TCP的对比</a></p><p><a href="#TCP%E7%9A%84%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6">TCP的流量控制</a></p><p><a href="#TCP%E7%9A%84%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6">TCP的拥塞控制</a></p><p><a href="#TCP%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E7%9A%84%E5%AE%9E%E7%8E%B0">TCP可靠传输的实现</a></p><p><a href="#TCP%E7%9A%84%E8%BF%9E%E6%8E%A5%E5%BB%BA%E7%AB%8B%EF%BC%9A%E4%B8%89%E6%8F%A1%E6%89%8B">TCP的连接建立：三握手</a></p><p><a href="#TCP%E8%BF%9E%E6%8E%A5%E7%9A%84%E9%87%8A%E6%94%BE%EF%BC%9A%E5%9B%9B%E6%8C%A5%E6%89%8B">TCP连接的释放：四挥手</a></p><p><a href="#TCP%E6%8A%A5%E6%96%87%E6%AE%B5%E7%9A%84%E9%A6%96%E9%83%A8%E6%A0%BC%E5%BC%8F">TCP报文段的首部格式</a></p><p><a href="#B/S%E5%92%8CPtoP%E6%96%B9%E5%BC%8F">B&#x2F;S和PtoP方式</a></p><p><a href="#%E5%8A%A8%E6%80%81%E4%B8%BB%E6%9C%BA%E9%85%8D%E7%BD%AE%E5%8D%8F%E8%AE%AEDHCP">动态主机配置协议DHCP</a></p><p><a href="#%E5%9F%9F%E5%90%8D%E7%B3%BB%E7%BB%9FDNS">域名系统DNS</a></p><p><a href="#%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AEFTP">文件传输协议FTP</a></p><p><a href="#%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6">电子邮件</a></p><p><a href="#%E4%B8%87%E7%BB%B4%E7%BD%91WWW">万维网WWW</a></p><p><a href="#%E5%8F%82%E8%80%83%E8%A7%86%E9%A2%91%E9%93%BE%E6%8E%A5">参考视频链接</a></p><h1 id="第一章：计算机网络体系结构"><a href="#第一章：计算机网络体系结构" class="headerlink" title="第一章：计算机网络体系结构"></a>第一章：计算机网络体系结构</h1><h2 id="常用的协议："><a href="#常用的协议：" class="headerlink" title="常用的协议："></a>常用的协议：</h2><p><img src="https://img-blog.csdnimg.cn/fb9c783cc0c442e2a3d497680c8f4795.png"></p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><img src="https://img-blog.csdnimg.cn/253fedbd8c504b41933283d8ff6e3119.png"></p><p>计算机网络是一个互联、自治的计算机集合</p><p>计算机网络的功能：数据共享</p><p><img src="https://img-blog.csdnimg.cn/e5be72d0e6a44376ab3ec718f5b1b478.png"></p><p><img src="https://img-blog.csdnimg.cn/ce799324e4064e62a435468654ec0d7e.png"></p><p><img src="https://img-blog.csdnimg.cn/0517ad2799a94e42b39006294adc9f82.png"></p><p>kb KB</p><p><img src="https://img-blog.csdnimg.cn/c57ccbd895fe4072b13f17b2ae7241be.png"></p><p>最高频率与最低频率之差</p><p>吞吐量：单位时间内通过某个网络（通道或接口）的数据量</p><p><img src="https://img-blog.csdnimg.cn/e443f06f7f0c4875aba56b6c59df1c46.png"></p><p>发送时延是：发生在主机上，发送到信道上所需要的时间。</p><p>传播时延：从一个主机传播到另外一个主机的时间，单位m&#x2F;s</p><p>排队时延和处理时延：可以想象成机场安检的过程，发生在路由器上。</p><p><img src="https://img-blog.csdnimg.cn/4af9b8c56c3e4fb787fdbee25d11be34.png"></p><p><img src="https://img-blog.csdnimg.cn/90b7e18f73ac4d759c47e70bc682e1b1.png"></p><p>协议：对等实体之间数据交换的规则</p><p>接口：上层使用下层服务的入口（把酒装箱的服务）</p><p><img src="https://img-blog.csdnimg.cn/2a36454f6b6644ebbd6a6fce5061c316.png"></p><p>OSI 7层参考模型 </p><p><img src="https://img-blog.csdnimg.cn/f8415f92949c449d92ed1a9bb49c4a5c.png"></p><p><strong>物数网传会表应</strong></p><p><img src="https://img-blog.csdnimg.cn/78a0a734d960457abedfcd34697979e9.png"></p><p>TCP&#x2F;IP参考模型：网网传应</p><p><img src="https://img-blog.csdnimg.cn/8c2b7f35e9474184b7cf08c6b42ac46b.png"></p><h2 id="常见面试题-1：-TCP-建立连接为什么要三次握手而不是两次？"><a href="#常见面试题-1：-TCP-建立连接为什么要三次握手而不是两次？" class="headerlink" title="常见面试题 1： TCP 建立连接为什么要三次握手而不是两次？"></a>常见面试题 1： TCP 建立连接为什么要三次握手而不是两次？</h2><p>答：网上大多数资料对这个问题的回答只有简单的一句：防止已过期的连接请求报文突然又传送到服务器，因而产生错误，这既不够全面也不够具体。下面给出比较详细而全面的回答：</p><ul><li>防止已过期的连接请求报文突然又传送到服务器，因而产生错误</li></ul><p>在双方两次握手即可建立连接的情况下，假设客户端发送 A 报文段请求建立连接，由于网络原因造成 A 暂时无法到达服务器，服务器接收不到请求报文段就不会返回确认报文段，客户端在长时间得不到应答的情况下重新发送请求报文段 B，这次 B 顺利到达服务器，服务器随即返回确认报文并进入 ESTABLISHED 状态，客户端在收到 确认报文后也进入 ESTABLISHED 状态，双方建立连接并传输数据，之后正常断开连接。此时姗姗来迟的 A 报文段才到达服务器，服务器随即返回确认报文并进入 ESTABLISHED 状态，但是已经进入 CLOSED 状态的客户端无法再接受确认报文段，更无法进入 ESTABLISHED 状态，这将导致服务器长时间单方面等待，造成资源浪费。</p><ul><li>三次握手才能让双方均确认自己和对方的发送和接收能力都正常</li></ul><p>第一次握手：客户端只是发送处请求报文段，什么都无法确认，而服务器可以确认自己的接收能力和对方的发送能力正常；</p><p>第二次握手：客户端可以确认自己发送能力和接收能力正常，对方发送能力和接收能力正常；</p><p>第三次握手：服务器可以确认自己发送能力和接收能力正常，对方发送能力和接收能力正常；</p><p>可见三次握手才能让双方都确认自己和对方的发送和接收能力全部正常，这样就可以愉快地进行通信了。</p><p><img src="https://img-blog.csdnimg.cn/9629dc61c1604c4093b56a9a17d982c1.png"></p><h2 id="五层参考模型"><a href="#五层参考模型" class="headerlink" title="五层参考模型"></a>五层参考模型</h2><p><img src="https://img-blog.csdnimg.cn/10a15ff26ebc4156a8de2c884ea9e85f.png"></p><h2 id="典型的数据通信模型"><a href="#典型的数据通信模型" class="headerlink" title="典型的数据通信模型"></a>典型的数据通信模型</h2><p>数据通信：从信源输入信息，转为数字信号，通过调制调解器将数字信号转为模拟信号，广域网，左右对称。</p><p><img src="https://img-blog.csdnimg.cn/94b8f8920b5b448ab9761eddf6de6811.png"></p><h2 id="数据通信相关术语"><a href="#数据通信相关术语" class="headerlink" title="数据通信相关术语"></a>数据通信相关术语</h2><p><img src="https://img-blog.csdnimg.cn/1085a3911e344b69bfba8ded8de4c670.png"></p><h2 id="三种通信方式"><a href="#三种通信方式" class="headerlink" title="三种通信方式"></a>三种通信方式</h2><p><img src="https://img-blog.csdnimg.cn/5ef2c94d86a1485991f9f5d3df1df365.png"></p><h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><p><strong>多个分组转发的时延的计算：</strong></p><p><img src="https://s2.loli.net/2023/07/20/oeRh5ZOwYqJLIUf.png"></p><h1 id="第二章：物理层"><a href="#第二章：物理层" class="headerlink" title="第二章：物理层"></a>第二章：物理层</h1><h2 id="奈氏准则与香奈定理"><a href="#奈氏准则与香奈定理" class="headerlink" title="奈氏准则与香奈定理"></a>奈氏准则与香奈定理</h2><p>码间串扰：信号频率过快，导致码元间界限不明显，无法区分信号，奈氏准则可以解决。</p><p><img src="https://img-blog.csdnimg.cn/3d38ada810694509851b026148777b76.png"></p><p><img src="https://img-blog.csdnimg.cn/2c657f88b5074394b682101c9828493e.png"></p><p><img src="https://img-blog.csdnimg.cn/2c2ff203e655476187b80311b39fdddd.png"></p><p>例题：</p><p><img src="https://img-blog.csdnimg.cn/dc0dba84ce1e41ec919db0a615fb276a.png"></p><p>如何选择“Nice”和“香浓”</p><p><img src="https://img-blog.csdnimg.cn/486e1151b2b8404e8d212220144f15dc.png"></p><h2 id="基带信号和宽带信号"><a href="#基带信号和宽带信号" class="headerlink" title="基带信号和宽带信号"></a>基带信号和宽带信号</h2><p><img src="https://img-blog.csdnimg.cn/88cdda2b18ae43d09e0e8465c34f0c38.png"></p><p>距离近使用基带信号（发出去了就直接表达出来，比如声波），距离远使用宽带信号（衰减到了很低的频率，通过调制到高的信号）</p><h2 id="编码与调制"><a href="#编码与调制" class="headerlink" title="编码与调制"></a>编码与调制</h2><p><img src="https://img-blog.csdnimg.cn/73360047c8ed4e7e8b99cd388e581edd.png"></p><h3 id="一-数字数据编码为数字信号"><a href="#一-数字数据编码为数字信号" class="headerlink" title="一.数字数据编码为数字信号"></a>一.数字数据编码为数字信号</h3><p>1.非归零编码【NRZ】</p><p>高1低0，最普通的编码方式</p><p>编码容易实现，但没有检错功能，且无法判断一个码元的开始和结束，以至于双方难以保持同步</p><p>2.曼彻斯特编码：</p><p>将一个码元分成两个相等的间隔，前一个间隔为低电平后一个间隔为高电平表示码元1；码元0则正好相反。也可以采用相反的规定。该编码的特点是在每一个码元的中间出现电平跳动，位中间的跳变即作时钟信号（可用于同步），又坐数据信号，但它所占的频带宽度是原始数据的基带宽度的两倍。</p><p>每一个码元都被调成两个电平，所以数据传输速率只有调制速率的1&#x2F;2。</p><p>3.差分曼彻斯特编码</p><p>同1异0</p><p>常用于局域网传输，其规则是：若码元为1，则前半个码元的电平与上一个码元的后半个码元的电平相同，若为0，则相反。该编码的特点是，在每个码元的中间，都有一次电平的跳转，可以实现自同步，且抗干扰性强于曼彻斯特编码。</p><p>4.归零编码【RZ】</p><p>信号电平在一个码元之内都要恢复到零的这种编码成编码方式。</p><p>（不推荐使用）因为处于低电频比较多比较久。</p><p>5.反向不归零编码【NRZI】</p><p>信号电平翻转表示0，信号电平不变表示1. 与归零编码主要区别：一个码元内不会跳变。</p><p>综合以上的编码方式产生：</p><p>（6）4B&#x2F;5B 编码</p><p>比特流中插入额外的比特以打破一连串的0或1，就是用5个比特来编码4个比特的数据，之后再传送给接收方，因此称为4B&#x2F;5B。编码效率为80%。</p><p>只采用16种对应的64种不同的4为码，其他的16种作为控制码（帧的开始和结束，线路的状态信息等）或保留。</p><h3 id="二-数字数据调制为模拟信号"><a href="#二-数字数据调制为模拟信号" class="headerlink" title="二.数字数据调制为模拟信号"></a>二.数字数据调制为模拟信号</h3><p><img src="https://img-blog.csdnimg.cn/f38a4b777fc247939a1596288bd1736a.png"></p><p>数字数据调制技术在发送端将数字信号转换为模拟信号，而在接收端将模拟信号还原为数字信号，分别对应于调制解调器的调制和解调过程。</p><p>正交振幅调制QAM</p><p><img src="https://s2.loli.net/2023/07/21/8Bu6zCmfFexcts1.png"></p><h3 id="三-模拟数据编码为数字信号"><a href="#三-模拟数据编码为数字信号" class="headerlink" title="三.模拟数据编码为数字信号"></a>三.模拟数据编码为数字信号</h3><p><img src="https://img-blog.csdnimg.cn/a8461752f95549a58d9b9c0f53911614.png"></p><h3 id="四、编码与调制的综述："><a href="#四、编码与调制的综述：" class="headerlink" title="四、编码与调制的综述："></a>四、编码与调制的综述：</h3><p><img src="https://img-blog.csdnimg.cn/91020adbec94455197627c412481dda1.png"></p><h1 id="第三章：数据链路层"><a href="#第三章：数据链路层" class="headerlink" title="第三章：数据链路层"></a>第三章：数据链路层</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><img src="https://img-blog.csdnimg.cn/cd4e2f3397c448c0a7d85198b9e6a486.png"></p><p><img src="https://img-blog.csdnimg.cn/cc7b9077368f41978b60e0b14a7702a3.png"></p><p>数据链路层在传输数据的时候，添加首和尾，</p><p><img src="https://img-blog.csdnimg.cn/bd707318c33243c5a6db23483db7fe34.png"></p><p>称为数据链路层协议首部和尾部，简称帧头和帧尾。这个动作叫做封装成帧。</p><p><img src="https://img-blog.csdnimg.cn/ff2f7925bb6d442997320ef7ade2ec7e.png"></p><h2 id="帧定界："><a href="#帧定界：" class="headerlink" title="帧定界："></a>帧定界：</h2><p><img src="https://img-blog.csdnimg.cn/8f8d009b0ca444ac8fa20a94122a99c6.png"></p><p><img src="https://img-blog.csdnimg.cn/d5abeaea1d9d43888f1c5f0e61f17e7b.png"></p><p>如果传输数据里面正好包含了帧定界符，数据链路层会在不是帧定界符加上转义字符，防止出现误判，认为数据传输结束了。</p><h2 id="差错检测：奇偶校验（计组）"><a href="#差错检测：奇偶校验（计组）" class="headerlink" title="差错检测：奇偶校验（计组）"></a>差错检测：奇偶校验（计组）</h2><h3 id="奇偶校验"><a href="#奇偶校验" class="headerlink" title="奇偶校验"></a>奇偶校验</h3><p><img src="https://img-blog.csdnimg.cn/6ea616730ac444fb82dde9478fed1ee7.png"></p><h3 id="循环冗余校验CRC"><a href="#循环冗余校验CRC" class="headerlink" title="循环冗余校验CRC"></a>循环冗余校验CRC</h3><p><img src="https://img-blog.csdnimg.cn/35f5a4bd4a494d55ad4d251a102ce47b.png"></p><h2 id="可靠传输的基本概念"><a href="#可靠传输的基本概念" class="headerlink" title="可靠传输的基本概念"></a>可靠传输的基本概念</h2><p>首先直到有两种服务：不可靠服务（丢弃误码的帧）和可靠服务（不会丢弃）。</p><p><img src="https://img-blog.csdnimg.cn/38b202e85d6c497a91ded7ddeb8e83b1.png"></p><p>可靠传输的开销比较大，要根据需求选择。</p><h2 id="SW协议：Stop-and-Wait（停止等待协议）"><a href="#SW协议：Stop-and-Wait（停止等待协议）" class="headerlink" title="SW协议：Stop and Wait（停止等待协议）"></a>SW协议：Stop and Wait（停止等待协议）</h2><p>ACK是正确无误的收到发送方的全部数据之后接收方的回应，则NAK是出现误码的回应，丢弃该数据。</p><p>特殊情况：每次的数据传输，发送方都会启动一个超时计数器，如果DATA在传输过程中出现丢失，等待时间操过了重传时间，发送方就会重新发送，这就叫做超时重传。解决接收方收不到分组的情况：设置一个超时计数器，如果超过了最大的重传时间，发送方重传（超时重传），如下图所示：</p><p><img src="https://img-blog.csdnimg.cn/5ce2c9974adb400ab437215aa0c88dd8.png"></p><p>为了克服停止等待协议的信道利用率低的缺点，就产生了另外两种协议：后退N帧协议、选择重传协议</p><p><img src="https://img-blog.csdnimg.cn/7af198b8d611413fa2a3b20225bd03aa.png"></p><p>总结：各种可能出现的问题的描述与解决。</p><p><img src="https://img-blog.csdnimg.cn/9783f5fa0eb04a92ba3613b9acf195e0.png"></p><h2 id="回退N帧协议：GBN协议"><a href="#回退N帧协议：GBN协议" class="headerlink" title="回退N帧协议：GBN协议"></a>回退N帧协议：<a href="https://zhuanlan.zhihu.com/p/405573476">GBN协议</a></h2><p>如果发送方在收到ACK之前，可以连续发送多个DATA，则可以大大提高信道利用率，这是一种流水线式的传输。这个协议利用传输窗口，来限制发送方和连续发送分组个数。</p><p>采用的是累计确认的方式:接收方不一定要对收到的数据分组逐个发送确认，而是可以在收到几个数据分组后，对按序到达的最后一个数据分组发送确认，ACKn表示序号为n及以前的所有数据分组都已经正确接收。</p><p>在有差错的情况下：接收方利用检错码发现这个数据分组中有数据出错了，就丢弃这个数据，这样就会让接下来接受的数据序号与接受窗口的序号不匹配，这样就要把这一组的其他数据也丢弃（回退N帧的由来），全部重新发送。重新发送可以等超时计数器超时也可以根据回传的重复信号ACKn。</p><p><img src="https://img-blog.csdnimg.cn/b7ecdea1a6fb4756b412ad01e3973641.png"></p><p>总结：累计确认。接收方发送ACKN代表前面N（包括N）个帧都收到了，但是如果中间出现了丢失，重传了，就会把发送窗口内的都丢弃重传。</p><p><img src="https://img-blog.csdnimg.cn/065ca957ad294aeda36d771eafaa0c27.png"></p><h2 id="选择重传协议：SR协议"><a href="#选择重传协议：SR协议" class="headerlink" title="选择重传协议：SR协议"></a>选择重传协议：<a href="https://zhuanlan.zhihu.com/p/405575394">SR协议</a></h2><p>回退N帧协议的接受窗口尺寸只能等于1，因此接收方只能按序接受正确到达的DATA。</p><p>为了进一步提升性能，可设法只重传出现误码的数据分组，因此，接收窗口的尺寸不应该再等于1，而应该大于1，以便接收方收下失序到达但无误码并且序号落在接收窗口内的DATA，等到所缺分组收齐后再一起送交上层，这就是选择重传协议（Selective Request）。</p><p>注意：由于只重传出现误码的数据分组，接收方不能采用累计确认，要采用逐一确认。</p><p>发送窗口尺寸必须满足： <img src="https://img-blog.csdnimg.cn/02e7bc17425844518916d7a2d863bb00.png"></p><p>其中n是构成分组序号的比特数量<img src="https://img-blog.csdnimg.cn/b46103aef36648c7ba2fdc7a7f592ae8.png"></p><ul><li>如果  ：就是停止-等待协议</li><li>如果  ：造成接收方无法分辨新旧DATA的问题</li></ul><p>接收窗口的尺寸必须满足： <img src="https://img-blog.csdnimg.cn/244acbd55cee453e9e7b9c2f33be9843.png"></p><ul><li><p>如果<img src="https://img-blog.csdnimg.cn/76892842442a4a9eb4aa4100205b9611.png">：与回退N帧协议相同</p></li><li><p>如果<img src="https://img-blog.csdnimg.cn/c292ece4bb8a4ddd9c3201bab2252eab.png"> ：无意义</p></li></ul><h2 id="点对点协议（Point-to-Point-Protocol）"><a href="#点对点协议（Point-to-Point-Protocol）" class="headerlink" title="点对点协议（Point-to-Point Protocol）"></a><a href="https://www.cnblogs.com/fudashi/p/6814652.html">点对点协议（Point-to-Point Protocol）</a></h2><p>工作在数据链路层，</p><p>PPP协议的组成</p><p><img src="https://img-blog.csdnimg.cn/2046a88462854af69800f667788bc4d5.png"></p><ul><li>建立、配置数据链路连接的LCP（Link Control Protocol）+ 网络控制协议NCP（Network Control Protocol）+ 将IP数据报封装到串行链路的方法</li></ul><p>跟其他协议一样，也要解决数据链路层的三个基本问题：封装成帧，透明传输，差错检测。</p><h2 id="媒体接入控制"><a href="#媒体接入控制" class="headerlink" title="媒体接入控制"></a>媒体接入控制</h2><p><img src="https://img-blog.csdnimg.cn/d32143d24fb34a1f985be0df6410a948.png"></p><h2 id="介质访问控制"><a href="#介质访问控制" class="headerlink" title="介质访问控制"></a>介质访问控制</h2><p>　　介质访问控制就是采取一定的措施，使得两对节点之间的通信不会发生互相干扰的情况。</p><p>　　介质访问控制（就是媒体接入控制）可以分为静态划分信道和动态分配信道。</p><p>　　（1）静态划分信道：也叫信道划分介质访问控制，有四种控制的方法，1、频分多路复用FDM；2、时分多路复用TDM；3、波分多路复用WDM；4、码分多路复用CDM。</p><p>　　（2）动态分配信道，可以分为轮询访问控制  令牌传递协议；随机访问介质访问控制 ALOHA协议、CSMA协议、CSMA&#x2F;CD协议、CSMA&#x2F;CA协议。</p><h3 id="1、频分多路复用FDM"><a href="#1、频分多路复用FDM" class="headerlink" title="1、频分多路复用FDM"></a>1、频分多路复用FDM</h3><p>多路复用器接受来自多个源的模拟信号，每个信号有自己独立的带宽，信号在通信的过程中自始自终都占用这个频带，在同样的时间占用不同的带宽频率，信号被组合成一个具有更大带宽的信号</p><p><img src="https://img-blog.csdnimg.cn/0f6e460c8dae4d1196e922cb0c99d28f.png"></p><h3 id="2、时分多路复用TDM"><a href="#2、时分多路复用TDM" class="headerlink" title="2、时分多路复用TDM"></a>2、时分多路复用TDM</h3><p>时分多路复用TDM，信道分割的方法是信号占用的时间，将使用复用的各路信号在时间上互不重叠，在传输时把时间分成小的时隙，每一时隙由复用的一个信号占用。</p><p><img src="https://img-blog.csdnimg.cn/f1c59e5bb03f49a69733cc1cbc4cc807.png"></p><h3 id="3、波分多路复用WDM"><a href="#3、波分多路复用WDM" class="headerlink" title="3、波分多路复用WDM"></a>3、波分多路复用WDM</h3><p><img src="https://img-blog.csdnimg.cn/151a54463c37462caadb8472f9628a66.png"></p><h3 id="4、码分多路复用CDM"><a href="#4、码分多路复用CDM" class="headerlink" title="4、码分多路复用CDM"></a>4、码分多路复用CDM</h3><p>它既共享信道的频率，也共享时间，是一种真正的动态复用技术</p><h2 id="CSMA-x2F-CD-协议"><a href="#CSMA-x2F-CD-协议" class="headerlink" title="CSMA&#x2F;CD 协议"></a>CSMA&#x2F;CD 协议</h2><p>总线局域网使用的协议：CSMA&#x2F;CD协议为带有冲突检测的载波监听多路访问技术，数据链路层，协议的实质是“载波监听”和“碰撞检测”。</p><p>载波监听就是利用电子技术检测总线上有没有其他计算机也在发送。载波监听实际上就是检测信道。在发送前，每个站不停地检测信道，是为了获得发送权；在发送中检测信道，是为了及时发现有没有其他站的发送和本站发送的碰撞，这就是碰撞检测。总之，载波监听是全程都在进行的。</p><p>碰撞检测就是边发送边监听。就是网卡边发送数据边检测新岛上的信号电压的变化情况，以便判断自己在发送数据的时候其他站是否也在发送数据。当几个站同时在总线上发送数据时，总线上的信号电压变化幅度将会增大（互相叠加），当网卡检测到的信号电压超过一定的门限值时，说明总线上至少有两个站同时在发送数据，表明产生了碰撞（冲突），所以也称为冲突检测。这时，由于接收的信号已经识别不出来，所以任何一个正在发送的站就会立即停止发送数据，然后等待一段随机事件以后再次发送。</p><p>CSMA&#x2F;CD 算法如下</p><ul><li>当帧准备好时，发送站检查信道是空闲还是忙碌。+ 如果信道拥塞，该站将等待直到它变得可用。+ 如果信道是空的，则站开始传输并观察信道是否发生冲突+ 如果检测到冲突，该站启动冲突解决程序。</li></ul><p>站点重置重传计数器并完成帧传输。</p><p>尽管 CSMA&#x2F;CS 检测到冲突，但它没有减少冲突数量的机制。因此，它不适用于大型网络，因为当添加更多站点时性能会呈指数级下降。</p><h2 id="CSMA-x2F-CA协议"><a href="#CSMA-x2F-CA协议" class="headerlink" title="CSMA&#x2F;CA协议"></a>CSMA&#x2F;CA协议</h2><p>载波监听多点接入 &#x2F; 碰撞避免协议（Carrier Sense Multiple Access With Collision Avoidance）</p><p>CSMA&#x2F;CA 的算法如下：</p><ul><li>当帧准备好时，发送站检查信道是空闲还是忙碌。+ 如果通道不畅通，则节点开始等待随机时间量，然后再检查是否畅通。</li></ul><p>这个等待时间被称为“退避因子”，它由退避计数器倒计时。</p><ul><li>如果信道空闲，则站等待帧间间隙 (IFG) 时间，然后发送帧。+ 它在发送帧后设置一个计时器。+ 然后该站等待接收器的确认。</li></ul><p>如果在定时器超时前收到确认，则表示发送成功。</p><ul><li>否则，它会等待一个回退时间段并重新启动算法。</li></ul><p>CMSA&#x2F;CA 防止冲突。当它等待确认时，数据不会不必要地丢失，并且避免了浪费的传输。CSMA&#x2F;CA 非常适合无线传输。</p><h2 id="Mac地址-IP地址-Arp协议"><a href="#Mac地址-IP地址-Arp协议" class="headerlink" title="Mac地址 IP地址 Arp协议"></a>Mac地址 IP地址 Arp协议</h2><p><img src="https://img-blog.csdnimg.cn/985b1e00a3c4487ca861693bc211682e.png"></p><p>Mac地址又称为物理地址，MAC 地址由六组两位字符组成，由冒号分隔。比如00:1B:44:11:3A:B7，就是一个 MAC 地址。固化在网卡的EEPROM中，所以叫做硬件地址。</p><p>IP地址：完整的 IP 寻址范围从 0.0.0.0 到 255.255.255.255。</p><p>数据包的转发：数据包在转发过程中，源IP地址和目的IP地址始终保持不变，而数据在数据链路层通过ARP协议找到一条去往目的地的路，即路上要经过的路由器的MAC地址，经过一个或多个路由器（一次只能够找到下一步的MAC地址，不能一次性的把路上所有的MAC都找到），最终交付给目的地。</p><p><img src="https://img-blog.csdnimg.cn/12af1a7f22e841989ec813e76d65d02f.png"></p><p><img src="https://img-blog.csdnimg.cn/7360393ad10f481c9b0cc9eec76394c6.png"></p><p><a href="https://cloud.tencent.com/developer/news/637065">一文读懂ARP协议，从IP获取对方MAC实操</a> </p><h2 id="集线器、交换机、路由器"><a href="#集线器、交换机、路由器" class="headerlink" title="集线器、交换机、路由器"></a>集线器、交换机、路由器</h2><p>集线器以广播方式发送，交换机单独发送</p><p><img src="https://img-blog.csdnimg.cn/0010f4b68f3b4557a48c692e73a1c254.png"></p><p>集线器对接收到的信号放大、转发，交换机根据MAC地址对帧进行转发。</p><p><img src="https://img-blog.csdnimg.cn/888ac41ce78d4aad86f0a111553c8722.png"></p><p><a href="https://www.eet-china.com/mp/a73949.html">一文让你搞懂：路由器，集线器，交换机，网桥，光猫有啥区别？</a></p><h2 id="以太网交换机的自学习和转发帧的流程"><a href="#以太网交换机的自学习和转发帧的流程" class="headerlink" title="以太网交换机的自学习和转发帧的流程"></a>以太网交换机的自学习和转发帧的流程</h2><p><img src="https://img-blog.csdnimg.cn/670ac883aca7420586fb8e53a850d854.png"></p><p><img src="https://img-blog.csdnimg.cn/56dccf0ac6cd4672aba092571f69f144.png"></p><h2 id="以太网交换机的生成树协议"><a href="#以太网交换机的生成树协议" class="headerlink" title="以太网交换机的生成树协议"></a>以太网交换机的生成树协议</h2><p><img src="https://img-blog.csdnimg.cn/04c2ca11663e4980982423008433654e.png"></p><h2 id="虚拟局域网VLAN的实现机制"><a href="#虚拟局域网VLAN的实现机制" class="headerlink" title="虚拟局域网VLAN的实现机制"></a>虚拟局域网VLAN的实现机制</h2><p>对以太网的MAC帧进行了扩展，插入了四个字节的VLAN标记。当交换机收到普通的以太网帧时，插入四字节的VLAN标记，转变为802.1Q帧，“打标签”。当交换机转发802.1Q帧时，会删除标签，“去标签”。</p><p><img src="https://img-blog.csdnimg.cn/b6e72333ee944c81a7d86634295ad3fd.png"></p><p>交换机的Access端口：PVID与VID相等时才会转发，用于连接用户计算机。</p><p><img src="https://img-blog.csdnimg.cn/066c241eaf2440d19b02c4536d5a2fc7.png"></p><p>Trunk端口：用于连接交换机之间或者交换机与路由器之间。</p><p><img src="https://img-blog.csdnimg.cn/2deb1f838eac45ddaf908bcbaae0155e.png"></p><p>Hybird端口：发送时查看该帧是否在端口的去标签列表中，存在则去标签转发，否则直接转发；接受时</p><p><img src="https://img-blog.csdnimg.cn/546a6319646a4c21a34a89b7a3e0a0d4.png"></p><p>虚拟局域网VLAN的实现机制</p><p>对以太网的MAC帧进行了扩展，插入了四个字节的VLAN标记。当交换机收到普通的以太网帧时，插入四字节的VLAN标记，转变为802.1Q帧，“打标签”。当交换机转发802.1Q帧时，会删除标签，“去标签”。</p><p><img src="https://img-blog.csdnimg.cn/f5fe83defdd34e9a82d510866262c1e4.png"></p><p>交换机的Access端口：PVID与VID相等时才会转发，用于连接用户计算机。</p><p><img src="https://img-blog.csdnimg.cn/a1508fea46c24a8b939d5851412a688a.png"></p><p>Trunk端口：用于连接交换机之间或者交换机与路由器之间。</p><p><img src="https://img-blog.csdnimg.cn/691a870ef6ca4d86ba6ea69e77211c55.png"></p><p>Hybird端口：发送时查看该帧是否在端口的去标签列表中，存在则去标签转发，否则直接转发；接受时</p><p><img src="https://img-blog.csdnimg.cn/38dd150fd262475fad714c65b9257f80.png"></p><h1 id="第四章：网络层"><a href="#第四章：网络层" class="headerlink" title="第四章：网络层"></a>第四章：网络层</h1><h2 id="IPv4地址的格式"><a href="#IPv4地址的格式" class="headerlink" title="IPv4地址的格式"></a>IPv4地址的格式</h2><p>点分十进制表示方法：</p><p><img src="https://img-blog.csdnimg.cn/4f5c8548fc3743da887a612825744600.png"></p><p>辨别ABC类地址</p><p><img src="https://img-blog.csdnimg.cn/f555fa48ed484a0a96e71dc7a1a9d533.png"></p><h2 id="分类编制的IPv4地址"><a href="#分类编制的IPv4地址" class="headerlink" title="分类编制的IPv4地址"></a>分类编制的IPv4地址</h2><p>小结：主机号全零是网络地址，全一是广播地址，注意ABC类地址的范围</p><p><img src="https://img-blog.csdnimg.cn/a9a8afe218404f1ea23b42cb4d95f850.png"></p><h2 id="划分子网的IPv4地址"><a href="#划分子网的IPv4地址" class="headerlink" title="划分子网的IPv4地址"></a>划分子网的IPv4地址</h2><p>子网掩码：使用连续的1来代表网络号和子网号，0对应主机号，与原来的网络地址相与就可以得到网络地址。</p><p><img src="https://img-blog.csdnimg.cn/2511e43a339d4f819a2ea037f1c32875.png"></p><p>划分细节：全零的和全一的要忽略掉</p><p><img src="https://img-blog.csdnimg.cn/28f70672318a497db8a46837a3962ec1.png"></p><p>小结：</p><p><img src="https://img-blog.csdnimg.cn/673e396d7304422ea0b042885d425ede.png"></p><h2 id="无分类编址的划分子网CIDR"><a href="#无分类编址的划分子网CIDR" class="headerlink" title="无分类编址的划分子网CIDR"></a>无分类编址的划分子网CIDR</h2><p>在IPv4地址后面加上斜线，表示网络前缀所占的比特数量。</p><p><img src="https://img-blog.csdnimg.cn/882a3453ea464552a79e8dce6df9785f.png"></p><p>最长前缀匹配：</p><p><img src="https://img-blog.csdnimg.cn/a9393a3c29fb4a2683702f55fa792aa8.png"></p><p>举例说明：</p><p><img src="https://img-blog.csdnimg.cn/894242eb41264e69aa18392d8d32e96a.png"></p><p>例题2：</p><p><img src="https://img-blog.csdnimg.cn/d390e4fe857d4c9fb70153f47d520bc7.png"></p><p>小结：</p><p><img src="https://img-blog.csdnimg.cn/bdc1a6541ed943c9854fa7fa1e5ae5ac.png"></p><h2 id="IP数据报的发送与转发过程"><a href="#IP数据报的发送与转发过程" class="headerlink" title="IP数据报的发送与转发过程"></a>IP数据报的发送与转发过程</h2><p>如果在同一个网络中，直接交付；不在，间接交付。</p><p><strong>如何判断目的主机与自己是否在同一个网络中？</strong></p><p>将本机IP地址与本机子网掩码相与得到网络地址，将目的主机IP地址与本机子网掩码相与得到另外一个网络地址，看看两个网络地址是否相同。同，在一个网络；不同在不同的网络。</p><p><img src="https://img-blog.csdnimg.cn/1b1eccc36c9543688b2bf826d946450f.png"></p><h2 id="静态路由配置以及可能产生的路由环路问题"><a href="#静态路由配置以及可能产生的路由环路问题" class="headerlink" title="静态路由配置以及可能产生的路由环路问题"></a>静态路由配置以及可能产生的路由环路问题</h2><p>网络管理员自己手动配置路由表。</p><p><img src="https://img-blog.csdnimg.cn/87cc07ac8af4429b9dc01f721c7e5d26.png"></p><h2 id="外部-BGP-与内部-BGP-有什么区别？"><a href="#外部-BGP-与内部-BGP-有什么区别？" class="headerlink" title="外部 BGP 与内部 BGP 有什么区别？"></a>外部 BGP 与内部 BGP 有什么区别？</h2><p>在互联网上，路由交换和流量传输是通过外部 BGP（eBGP）进行的。自治系统也可使用 BGP 的内部版本来路由内部网络上的数据，也就是 iBGP（internal）。应该指出的是，使用内部 BGP 并非使用外部 BGP 的前提条件。自治系统可从多种内部协议中选择，来连接内部网络上的路由器。</p><p>外部 BGP 就像国际运输。在国际上运送邮件时，需要遵循特定的标准和规则。邮件到达目的地国家后，必须通过目的地国家的本地邮政服务才能达到其最终目的地。每个国家都有自己的内部邮政服务，不必遵循其他国家的相同规则。同样，每个自治系统都可以有自己的内部路由协议，用于路由自身网络内部的数据。</p><h2 id="内部网关协议：路由信息协议RIP的基本工作原理"><a href="#内部网关协议：路由信息协议RIP的基本工作原理" class="headerlink" title="内部网关协议：路由信息协议RIP的基本工作原理"></a>内部网关协议：路由信息协议RIP的基本工作原理</h2><p>RIP的路由条目的更新规则，先加1，然后逐渐更新</p><p><img src="https://img-blog.csdnimg.cn/c124805b378f4c61a971f52a755a66ba.png"></p><p>使用跳数来衡量到达目的网络的距离，next hop，下一跳</p><p><img src="https://img-blog.csdnimg.cn/9961223a7ffd40939ab535a9495b31bd.png"></p><h2 id="广播域与冲突域"><a href="#广播域与冲突域" class="headerlink" title="广播域与冲突域"></a>广播域与冲突域</h2><p>一个集线器（中继器）连接的网络成为冲突域，因为每台主机都连接在了同一条线路上，所以传送信息时会冲突。<strong>冲突域是基于第一层(物理层)</strong></p><p>而交换机的本质是一个多借口网桥，就是说由交换机组成的网络中，任意两台主机通信都是通过一条专有线路，故不会冲突。所以交换机出来的每个接口都是一个冲突域。<strong>广播域是基于第二层(链路层)</strong></p><p>通常一个局域网VLAN算一个广播域，故路由器的每个端口产生一个广播域。</p><h2 id="开放最短路径OSPF的基本工作原理"><a href="#开放最短路径OSPF的基本工作原理" class="headerlink" title="开放最短路径OSPF的基本工作原理"></a>开放最短路径OSPF的基本工作原理</h2><p>在自治系统AS中可以通过OSPF将其划分成更小的区域。</p><p><img src="https://img-blog.csdnimg.cn/ce148a6ff01b4569b374611147313b1d.png"></p><h3 id="OSPF在多点接入网络中路由邻居关系的建立"><a href="#OSPF在多点接入网络中路由邻居关系的建立" class="headerlink" title="OSPF在多点接入网络中路由邻居关系的建立"></a>OSPF在多点接入网络中路由邻居关系的建立</h3><p>选举指定路由器DR和备用的指定路由器BDR，减少网络中邻居关系之间的问候分组（Hello分组）</p><p><img src="https://s2.loli.net/2023/07/24/KhRbkJlWF6VernL.png" alt="image-20230724165601768"></p><h3 id="OSPF小结"><a href="#OSPF小结" class="headerlink" title="OSPF小结"></a>OSPF小结</h3><p><img src="https://img-blog.csdnimg.cn/e772b21b41f04d1f9b6765cf985cfb36.png"></p><h2 id="边界网关协议BGP"><a href="#边界网关协议BGP" class="headerlink" title="边界网关协议BGP"></a>边界网关协议BGP</h2><p>BGP是找到有路径就可以，不用去找最佳的路由。</p><p><img src="https://img-blog.csdnimg.cn/852d8062d30a45969c981b765eaa9d47.png"></p><p>例题：</p><p><img src="https://img-blog.csdnimg.cn/029ca4afc3144ab9ba44a69539f70932.png"></p><p>小结：</p><p><img src="https://img-blog.csdnimg.cn/bd44fdb4680141fb8f2ed835a5713968.png"></p><h2 id="IPVv4数据报的格式"><a href="#IPVv4数据报的格式" class="headerlink" title="IPVv4数据报的格式"></a>IPVv4数据报的格式</h2><p>TTL字段的作用：防止IP数据报在网络中永久兜圈。</p><p>如下图将R2的静态路由表配置错了，导致要转发给R3的转发给了R1，造成路由环路。</p><p><img src="https://img-blog.csdnimg.cn/bc99ba4e538a411085020b799467e526.png"></p><p>当IP数据报经过一个路由器的时候：TTL字段减一，首部检验和需要更改，如果IP数据报过大，大于MTU（最大数据报单元），则要重新分片，标志字段、总长度字段、片位移字段都要修改。</p><p><img src="https://img-blog.csdnimg.cn/5c0ea351cc244fa895481c3c59f08e90.png"></p><h2 id="网际控制报文协议ICMP"><a href="#网际控制报文协议ICMP" class="headerlink" title="网际控制报文协议ICMP"></a>网际控制报文协议ICMP</h2><p>通过ICMP来发送差错报告报文和询问报文，ICMP报文被封装在IP数据报中发送出去，有五种差错报文。</p><p>ICMP的应用：PING、traceroute（TTL从1开始，到了一个中间的站点，发送一个时间超过报文）</p><p><img src="https://img-blog.csdnimg.cn/e686be839f394ae7bccfbc3c3e2404a7.png"></p><h2 id="网络地址转换NAT和虚拟专用网VPN"><a href="#网络地址转换NAT和虚拟专用网VPN" class="headerlink" title="网络地址转换NAT和虚拟专用网VPN"></a>网络地址转换NAT和虚拟专用网VPN</h2><p>利用端口号和IP地址一起放入转换表中，这样可以极大程度的利用一个分配IP地址路由器与多个主机的多个服务之间通信、转发，减缓IP地址的使用。</p><p><img src="https://img-blog.csdnimg.cn/7603516f32f641f28dd366cc80dcfbc0.png"></p><p>两个私有的网通过公有的因特网进行通信，这个时候会将原始的数据进行加密处理，然后将其封装，保证数据安全。</p><p>外地员工连内网，利用专有的软件，远程接入VPN</p><p><img src="https://img-blog.csdnimg.cn/5b0d54007dd2445797b0a044e4fb3548.png"></p><h2 id="移动IP技术"><a href="#移动IP技术" class="headerlink" title="移动IP技术"></a>移动IP技术</h2><p>通俗的解释：归属代理就相当于你老家的邮局，外地代理就相当于你公司的邮局，你可能换不同公司，但你的老同学给你寄东西可以先寄给你老家，然后转交给你的公司</p><p>应用场景：在移动的汽车内下载文件</p><p><img src="https://s2.loli.net/2023/07/24/eyLmW7UwtFj6Tvp.png" alt="image-20230724173809610"></p><h1 id="第五章：运输层"><a href="#第五章：运输层" class="headerlink" title="第五章：运输层"></a>第五章：运输层</h1><h2 id="运输层简介"><a href="#运输层简介" class="headerlink" title="运输层简介"></a>运输层简介</h2><p>通过这一层的封装，两个计算机之间的通信好像变成了它们之间两个进程之间的直接通信，端口号代表了进程的标识符（0-65535，0-2^16-1）。</p><p><img src="https://img-blog.csdnimg.cn/d23f41ef64c040ea994c53cca10cb04d.png"></p><h2 id="运输层端口号、分用、复用的概念"><a href="#运输层端口号、分用、复用的概念" class="headerlink" title="运输层端口号、分用、复用的概念"></a>运输层端口号、分用、复用的概念</h2><p>应用层协议的常用熟知端口号。</p><p><img src="https://img-blog.csdnimg.cn/43addfd97cee4ff3981f67aa4bb4bee5.png"></p><p>端口号只具有本地意义，不同计算机之间的相同端口号是没有联系的。</p><p><img src="https://img-blog.csdnimg.cn/61d88ad2e5324e12942048bdd045f7c9.png"></p><h2 id="UDP和TCP的对比"><a href="#UDP和TCP的对比" class="headerlink" title="UDP和TCP的对比"></a>UDP和TCP的对比</h2><p>UDP支持单播、多播以及广播，TCP仅支持1对1的服务。</p><p>UDP适用于视频通话</p><p><img src="https://img-blog.csdnimg.cn/fbaf0c5aa964406ca1f04340c2a40573.png"></p><p>UDP面向报文，TCP面向字节流。</p><p><img src="https://img-blog.csdnimg.cn/0ead83be92d94f65aa5131475282148f.png"></p><p>UDP首部只有8个字节，TCP首部最少20字节，最多60字节。</p><p><img src="https://img-blog.csdnimg.cn/b2c80ecffebe4abdb7e1708aeed0b729.png"></p><p>小结：</p><p><img src="https://img-blog.csdnimg.cn/f9c6c942c08744dea8b0366e1593741e.png"></p><h2 id="TCP的流量控制"><a href="#TCP的流量控制" class="headerlink" title="TCP的流量控制"></a>TCP的流量控制</h2><p>解决死锁情况的计时器：在接收方将窗口修改为0时启动，</p><p>零窗口探测报文在rwnd&#x3D;0时也可以接收。</p><p>大写的ACK是确认信号，返回给client，小写的ack是累计确认，表示ack号字节以前的数据都收到了。</p><p><img src="https://img-blog.csdnimg.cn/c7f2754415d6437d9ca11ac1fdabaf3a.png"></p><p>例题：注意通高的接受窗口的大小是2000字节</p><p><img src="https://img-blog.csdnimg.cn/e51e63d89af14aa48df52851a904e2c8.png"></p><p>小结：流量控制是为了让发送方的发送速度不要过快，利用的是滑动窗口的机制。接收方发送零窗口通知后，发送方收到后会启动持续计时器。接收方是通过rwnd的值来设置窗口大小，从而实现流量控制。</p><p><img src="https://img-blog.csdnimg.cn/82dbdd4e7c8f455aa78026c42f5059d8.png"></p><h2 id="TCP的拥塞控制"><a href="#TCP的拥塞控制" class="headerlink" title="TCP的拥塞控制"></a>TCP的拥塞控制</h2><p>慢开始，拥塞避免：</p><p>维护三个变量：拥塞窗口cwnd、发送窗口swnd，慢开始门限ssthresh。</p><p><img src="https://img-blog.csdnimg.cn/4646d065760f4e4284b09047d7913e0c.png"></p><p>快重传算法：不等待超时重传计时器的超时，而是收到了三个连续的重复确认就将报文段立即重传。</p><p><img src="https://img-blog.csdnimg.cn/c688bcccb4b34422a94ddd5bcf0fe114.png"></p><p>快恢复算法：收到三个重复确认就知道了只是丢失了个别的报文段，这个时候不启动慢开始算法，而是执行快恢复算法。</p><p><img src="https://img-blog.csdnimg.cn/774dd5e4144e4c518f228718ace023d3.png"></p><p>慢开始，拥塞控制，快重传，快恢复</p><p><img src="https://img-blog.csdnimg.cn/39fcf6826f94478faf3cb0cd1f34547b.png"></p><p>TCP超时重传时间的计算</p><p>RTO&#x3D;RTTs+4*RTT D；</p><p>出现超时重传，新RTO&#x3D;2*旧的RTO。</p><p><img src="https://img-blog.csdnimg.cn/f80d68c1c0e44794b629796fd445b1b7.png"></p><h2 id="TCP可靠传输的实现"><a href="#TCP可靠传输的实现" class="headerlink" title="TCP可靠传输的实现"></a>TCP可靠传输的实现</h2><p>返送窗口的前沿和后沿的移动情况，</p><p><img src="https://img-blog.csdnimg.cn/52e84af5653c470fbda5718335c16500.png"></p><p>小结：以字节为单位的滑动窗口来实现可靠传输。而对于没有按序到达的数据的处理，没有明确规定，通常是将这些数据临时保存在接收窗口中。</p><p><img src="https://img-blog.csdnimg.cn/dcebef6fe5124728bd3f5b81314a1220.png"></p><h2 id="TCP的连接建立：三握手"><a href="#TCP的连接建立：三握手" class="headerlink" title="TCP的连接建立：三握手"></a>TCP的连接建立：三握手</h2><p>三报文握手来建立连接。</p><p><img src="https://img-blog.csdnimg.cn/a5423c39832b4c94b230e67a968cbff2.png"></p><p>两次握手不可行的示意图：失效的TCP连接请求在一段时间后到达服务端，服务端也会认为是一个请求，错误的进入ESTABLISHED状态，会浪费资源。</p><p><img src="https://img-blog.csdnimg.cn/e9af9490c0164a75a51f0517b827d6da.png"></p><p>所以第三次握手不是多余的；</p><p><img src="https://img-blog.csdnimg.cn/4e80798d88e84c9a89df449f55496209.png"></p><p>例题：SYN&#x3D;1 ACK&#x3D;1 seq&#x3D;11221 ack&#x3D;11221</p><p><img src="https://img-blog.csdnimg.cn/eeffe6784ef649fa97fb915ebac7f631.png"></p><p>小结：SYN&#x3D;1的报文段不能携带数据。</p><p><img src="https://img-blog.csdnimg.cn/d0a78f9448c34e7bb6dba8da42a83ea2.png"></p><h2 id="TCP连接的释放：四挥手"><a href="#TCP连接的释放：四挥手" class="headerlink" title="TCP连接的释放：四挥手"></a>TCP连接的释放：四挥手</h2><p>4报文挥手，客户端最后还要经过2MSL的时间才会进入关闭状态，确保返回给服务器的ACK到达服务端，以及清理掉此次连接中的所有报文段。</p><p><img src="https://img-blog.csdnimg.cn/b7a540c088e744e2b5f5c00737fce93f.png"></p><p>使用2*MSL时间的原因：当出现最后的确认报文段丢失的情况时，还可以收到服务端的FIN信号，否则服务器就会一直重传FIN报文段，而此时客户端已经进入了CLOSED状态，不会发送ACK，服务端这时会一直收不到确认信号。</p><p><img src="https://img-blog.csdnimg.cn/f2fdfceb80e44182b7f9d8ab1ff3aeb6.png"></p><p>保活计时器</p><p><img src="https://img-blog.csdnimg.cn/b051b9fec6914671a305be27606b66a6.png"></p><h2 id="TCP报文段的首部格式"><a href="#TCP报文段的首部格式" class="headerlink" title="TCP报文段的首部格式"></a>TCP报文段的首部格式</h2><p>都有20字节的固定首部</p><p><img src="https://img-blog.csdnimg.cn/0eed4e40c69b40f3bb4d6c84cc5dec1c.png"></p><h1 id="第六章：应用层"><a href="#第六章：应用层" class="headerlink" title="第六章：应用层"></a>第六章：应用层</h1><h2 id="B-x2F-S和P2P方式"><a href="#B-x2F-S和P2P方式" class="headerlink" title="B&#x2F;S和P2P方式"></a>B&#x2F;S和P2P方式</h2><p>P2P方式是两边对等的，没有固定的服务端和客户端，</p><p><img src="https://img-blog.csdnimg.cn/7791c8324f8f4e6aa6cd1d07ac087dfe.png"></p><h2 id="动态主机配置协议DHCP"><a href="#动态主机配置协议DHCP" class="headerlink" title="动态主机配置协议DHCP"></a>动态主机配置协议DHCP</h2><p>DHCP的工作过程：主要有四步，DHCP DISCOVER、DHCP OFFER、DHCP REQUEST、DHCP ACK。</p><p><img src="https://img-blog.csdnimg.cn/d7332fef336047de984f5e003408675c.png"></p><p>DHCP中继代理：在主机发送广播的DHCP DISCOVER时，将路由器当成中继代理，让它给服务器发送单播DHCP DISCOVER，这样主机就可以获取到IP地址分配。如果不这样配置，路由器会直接丢弃广播的DHCP DISCOVER。</p><p><img src="https://img-blog.csdnimg.cn/d2c09e54836942e4a7aa6f732c4bd777.png"></p><p>小结：</p><p><img src="https://img-blog.csdnimg.cn/9ef3bdde05704fa482ae618afb99d432.png"></p><h2 id="域名系统DNS"><a href="#域名系统DNS" class="headerlink" title="域名系统DNS"></a>域名系统DNS</h2><p>域名的层次结构：树根没有域名，顶级、二级、三级、四级域名。</p><p><img src="https://img-blog.csdnimg.cn/ba5b4ee5d5aa4bb086a890e1c9edda80.png"></p><p>域名的解析有两种：递归查询和迭代查询。</p><p><img src="https://img-blog.csdnimg.cn/e48b660d791147b49924ba1b6f107ee0.png"></p><h2 id="文件传输协议FTP"><a href="#文件传输协议FTP" class="headerlink" title="文件传输协议FTP"></a>文件传输协议FTP</h2><p>三条命令，可以传输文件</p><p>fpt ip; &#x2F;&#x2F;连接FTP服务器</p><p>get [name]&#x2F;&#x2F;下载文件</p><p>put [name]&#x2F;&#x2F;上传文件</p><p><img src="https://img-blog.csdnimg.cn/582ded89c75f4f049cb95e424c0c6c9d.png"></p><p><img src="https://img-blog.csdnimg.cn/73a0f218414247129ba2e59b99afa3bc.png"></p><p>小结</p><p><img src="https://s2.loli.net/2023/07/25/ksQzKMjp46nIyLJ.png"></p><h2 id="电子邮件"><a href="#电子邮件" class="headerlink" title="电子邮件"></a>电子邮件</h2><p>简单邮件传送协议SMTP：simple mail transfer protocol，基于TCP连接，使用熟知端口号25，只能发送ASCII文本。</p><p><img src="https://img-blog.csdnimg.cn/1ea41adb8ef0430086ed44888eaf7f66.png"></p><p>电子邮件的格式：信封和内容</p><p><img src="https://img-blog.csdnimg.cn/f7bd5712d610441ba05057b7824d35fd.png"></p><p>小结：常见的邮件读取协议有POP3、IMAP。邮件读取协议是指邮件服务器读取邮件内容的时候要遵循的协议。</p><p><img src="https://img-blog.csdnimg.cn/df53058638094f77b5cbbee24dabd68f.png"></p><h2 id="万维网WWW"><a href="#万维网WWW" class="headerlink" title="万维网WWW"></a>万维网WWW</h2><p>HTTP的报文格式：包含请求报文和响应报文</p><p><img src="https://img-blog.csdnimg.cn/8e9f7489cf1f4059a447c0a5da0b232e.png"></p><p>万维网缓存与代理服务器：提高万维网的效率，减轻原始服务器的压力。</p><p><img src="https://img-blog.csdnimg.cn/531aaa4985c5495abe4b5d2e7c7222c2.png"></p><p>小结：</p><p>万维网使用统一资源定位符URL来指定英特网上的资源的位置：</p><p>&lt;协议&gt;:&#x2F;&#x2F;&lt;主机&gt;:&lt;端口&gt;&#x2F;&lt;路径&gt;，如：<a href="https://www.baidu.com/">https://www.baidu.com/</a></p><p>HTTP是超文本传输协议，1.0采用无连接的方式，1.1采用持续连接的方式</p><p>（keep-alive），</p><p><img src="https://img-blog.csdnimg.cn/5f8dfed559db45589de599feb0caa3b0.png"></p><h1 id="参考视频链接"><a href="#参考视频链接" class="headerlink" title="参考视频链接"></a>参考视频链接</h1><p><a href="https://www.bilibili.com/video/BV1c4411d7jb?p=1&vd_source=b99c7e40ffa0f64b68b706f2af755c8e">计算机网络微课堂（有字幕无背景音乐版）</a> </p><p><a href="https://www.bilibili.com/video/BV1NT411g7n6">深入浅出计算机网络 微课视频</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>广播域与冲突域</title>
      <link href="/2023/06/20/guang-bo-yu-yu-chong-tu-yu/"/>
      <url>/2023/06/20/guang-bo-yu-yu-chong-tu-yu/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="广播域与冲突域"><a href="#广播域与冲突域" class="headerlink" title="广播域与冲突域"></a>广播域与冲突域</h1><p> 一个集线器（中继器）连接的网络成为冲突域，因为每台主机都连接在了同一条线路上，所以传送信息时会冲突。 冲突域是基于第一层(物理层)</p><p>而交换机的本质是一个多借口网桥，就是说由交换机组成的网络中，任意两台主机通信都是通过一条专有线路，故不会冲突。所以交换机出来的每个接口都是一个冲突域。 广播域是基于第二层(链路层)</p><p>通常一个局域网VLAN算一个广播域，故路由器的每个端口产生一个广播域。</p><p>例题：</p><p>在下图的网络配置中，总共有（）个广播域，（）个冲突域。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/58c839a3804405ab3622e4e9ded13dc3.png"></p><p>答案是：2个广播域，7个冲突域。</p><p>解析：每个路由器的一个端口就是一个广播域和冲突域；集线器不隔离冲突域 ，也不隔离广播域；交换机隔离冲突域，不隔离广播域。所以路由器有两个端口，就有两个广播域；左边有一个冲突域，右边有6个冲突域，总共7个。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>跟腾讯架构大师学网络框架与后台架构</title>
      <link href="/2023/06/20/gen-teng-xun-jia-gou-da-shi-xue-wang-luo-kuang-jia-yu-hou-tai-jia-gou/"/>
      <url>/2023/06/20/gen-teng-xun-jia-gou-da-shi-xue-wang-luo-kuang-jia-yu-hou-tai-jia-gou/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p><strong>目录</strong></p><p><a href="#%E8%B7%9F%E8%85%BE%E8%AE%AF%E6%9E%B6%E6%9E%84%E5%A4%A7%E5%B8%88%E5%AD%A6%E7%BD%91%E7%BB%9C%E6%A1%86%E6%9E%B6%E4%B8%8E%E5%90%8E%E5%8F%B0%E6%9E%B6%E6%9E%84">跟腾讯架构大师学网络框架与后台架构</a></p><p><a href="#%E5%8D%95%E6%9C%BA%E6%9C%8D%E5%8A%A1">单机服务</a></p><p><a href="#1%E3%80%81%E5%8D%95%E6%9C%BA%E6%9C%8D%E5%8A%A1%EF%BC%9A%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">1、单机服务：基本概念</a></p><p><a href="#2%E3%80%81%E5%8D%95%E6%9C%BA%E6%9C%8D%E5%8A%A1%EF%BC%9A%E5%90%8C%E6%AD%A5%E9%98%BB%E5%A1%9E%E2%80%8B%E7%BC%96%E8%BE%91">2、单机服务：同步阻塞​编辑</a></p><p><a href="#3%E3%80%81%E5%8D%95%E6%9C%BA%E6%9C%8D%E5%8A%A1%EF%BC%9A%E5%BC%82%E6%AD%A5%E9%9D%9E%E9%98%BB%E5%A1%9E%E6%A1%86%E6%9E%B6">3、单机服务：异步非阻塞框架</a></p><p><a href="#4%E3%80%81%E5%8D%95%E6%9C%BA%E6%9C%8D%E5%8A%A1%EF%BC%9A%E5%85%B8%E5%9E%8B%E6%A1%86%E6%9E%B6%EF%BC%9A">4、单机服务：典型框架：</a></p><p><a href="#5%E3%80%81%E5%8D%95%E6%9C%BA%E6%9C%8D%E5%8A%A1%EF%BC%9A%E5%8D%8F%E7%A8%8B%E6%A1%86%E6%9E%B6">5、单机服务：协程框架</a></p><p><a href="#6%E3%80%81%E5%8D%95%E6%9C%BA%E6%9C%8D%E5%8A%A1%EF%BC%9A%E6%96%B0%E7%8E%A9%E6%B3%95%EF%BC%8CNODEJS%E7%9A%84%E9%97%AD%E5%8C%85">6、单机服务：新玩法，NODEJS的闭包</a></p><p><a href="#7%E3%80%81%E5%8D%95%E6%9C%BA%E6%9C%8D%E5%8A%A1%EF%BC%9A%E5%87%A0%E7%A7%8D%E5%85%B8%E5%9E%8B%E6%A1%86%E6%9E%B6%E5%AF%B9%E6%AF%94">7、单机服务：几种典型框架对比</a></p><p><a href="#8%E3%80%81%E5%8D%95%E6%9C%BA%E6%9C%8D%E5%8A%A1%EF%BC%9A%E7%BD%91%E7%BB%9C%E6%A1%86%E6%9E%B6%E7%9A%84%E7%9B%91%E6%8E%A7">8、单机服务：网络框架的监控</a></p><p><a href="#9%E3%80%81%E5%8D%95%E6%9C%BA%E6%9C%8D%E5%8A%A1%EF%BC%9A%E4%BB%8EC10K%E9%97%AE%E9%A2%98%E5%88%B0C10M%E9%97%AE%E9%A2%98">9、单机服务：从C10K问题到C10M问题</a></p><p><a href="#10%E3%80%81%E5%8D%95%E6%9C%BA%E6%9C%8D%E5%8A%A1%EF%BC%9A%E7%A5%9E%E5%99%A8">10、单机服务：神器</a></p><p><a href="#Cache%20%E7%B1%BB%E6%9C%8D%E5%8A%A1">Cache 类服务</a></p><p><a href="#1%E3%80%81Cache%E7%B1%BB%E6%9C%8D%E5%8A%A1%EF%BC%9A%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">1、Cache类服务：基本概念</a></p><p><a href="#2%E3%80%81Cache%E7%B1%BB%EF%BC%9ALocal%20Cache">2、Cache类：Local Cache</a></p><p><a href="#3%E3%80%81Cache%E7%B1%BB%EF%BC%9A%E5%88%86%E5%B8%83%E5%BC%8FCache">3、Cache类：分布式Cache</a></p><p><a href="#%E5%AD%98%E5%82%A8%E7%B1%BB">存储类</a></p><p><a href="#1%E3%80%81%E5%AD%98%E5%82%A8%E7%B1%BB%EF%BC%9A%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E2%80%8B%E7%BC%96%E8%BE%91">1、存储类：基本概念​编辑</a></p><p><a href="#2%E3%80%81%E5%AD%98%E5%82%A8%E7%B1%BB%EF%BC%9ASQL">2、存储类：SQL</a></p><p><a href="#3%E3%80%81%E5%AD%98%E5%82%A8%E7%B1%BB%EF%BC%9ANOSQL">3、存储类：NOSQL</a></p><p><a href="#4%E3%80%81%E5%AD%98%E5%82%A8%E7%B1%BB%EF%BC%9A%E5%A6%82%E4%BD%95%E4%B8%8D%E4%B8%A2%E6%95%B0%E6%8D%AE">4、存储类：如何不丢数据</a></p><p><a href="#5%E3%80%81%E5%AD%98%E5%82%A8%E7%B1%BB%EF%BC%9A%E5%85%B6%E4%BB%96%E5%AD%98%E5%82%A8">5、存储类：其他存储</a></p><p><a href="#%E9%80%9A%E8%AE%AF%E7%B1%BB%E6%9C%8D%E5%8A%A1%E2%80%8B%E7%BC%96%E8%BE%91">通讯类服务​编辑</a></p><p><a href="#%E8%AE%A1%E7%AE%97%E7%B1%BB%E6%9C%8D%E5%8A%A1">计算类服务</a></p><p><a href="#%E2%80%8B%E7%BC%96%E8%BE%91">​编辑</a></p><p><a href="#%E5%AF%BB%E5%9D%80%E7%B1%BB%E6%9C%8D%E5%8A%A1">寻址类服务</a></p><p><a href="#%E4%BA%8B%E5%8A%A1%E7%B1%BB%E6%9C%8D%E5%8A%A1">事务类服务</a></p><p><a href="#%E5%B1%95%E6%9C%9B">展望</a></p><p><a href="#%E8%A7%86%E9%A2%91%E9%93%BE%E6%8E%A5">视频链接</a></p><h1 id="跟腾讯架构大师学网络框架与后台架构"><a href="#跟腾讯架构大师学网络框架与后台架构" class="headerlink" title="跟腾讯架构大师学网络框架与后台架构"></a>跟腾讯架构大师学网络框架与后台架构</h1><h2 id="单机服务"><a href="#单机服务" class="headerlink" title="单机服务"></a>单机服务</h2><h2 id="1、单机服务：基本概念"><a href="#1、单机服务：基本概念" class="headerlink" title="1、单机服务：基本概念"></a>1、单机服务：基本概念</h2><p><img src="https://img-blog.csdnimg.cn/55d5b77b35c94c63a074bf1fe72bc547.png"></p><h2 id="2、单机服务：同步阻塞"><a href="#2、单机服务：同步阻塞" class="headerlink" title="2、单机服务：同步阻塞"></a>2、单机服务：同步阻塞</h2><p><img src="https://img-blog.csdnimg.cn/c06c9be4fdb84121a914af18173b0411.png"></p><p> </p><h2 id="3、单机服务：异步非阻塞框架"><a href="#3、单机服务：异步非阻塞框架" class="headerlink" title="3、单机服务：异步非阻塞框架"></a>3、单机服务：异步非阻塞框架</h2><p>使用非阻塞IO，检测到有事件</p><p>性能最高：不会阻塞IO，数据拷贝最少</p><p><img src="https://img-blog.csdnimg.cn/483f1de6bcde4b9281ff41ab37eaf348.png"></p><p> </p><h2 id="4、单机服务：典型框架："><a href="#4、单机服务：典型框架：" class="headerlink" title="4、单机服务：典型框架："></a>4、单机服务：典型框架：</h2><p><img src="https://img-blog.csdnimg.cn/b1c58c550e9340d0bfbebb1f7b7d0c5a.png"></p><p> </p><h2 id="5、单机服务：协程框架"><a href="#5、单机服务：协程框架" class="headerlink" title="5、单机服务：协程框架"></a>5、单机服务：协程框架</h2><p><img src="https://img-blog.csdnimg.cn/31fe20c831fe4b33b0b134a5128ff38d.png"></p><h2 id="6、单机服务：新玩法，NODEJS的闭包"><a href="#6、单机服务：新玩法，NODEJS的闭包" class="headerlink" title="6、单机服务：新玩法，NODEJS的闭包"></a>6、单机服务：新玩法，NODEJS的闭包</h2><p>利用上层来保存，可以直接使用上层的局部变量，回调的地狱。<br><img src="https://img-blog.csdnimg.cn/11117a7ab6fd407ba560e135ae68596f.png"></p><p> </p><h2 id="7、单机服务：几种典型框架对比"><a href="#7、单机服务：几种典型框架对比" class="headerlink" title="7、单机服务：几种典型框架对比"></a>7、单机服务：几种典型框架对比</h2><p><code>nodejs</code>可能比多线程同步高<br><img src="https://img-blog.csdnimg.cn/ca91f235d577474f836476480ce1e930.png"></p><p> </p><h2 id="8、单机服务：网络框架的监控"><a href="#8、单机服务：网络框架的监控" class="headerlink" title="8、单机服务：网络框架的监控"></a>8、单机服务：网络框架的监控</h2><p>监控点多一点，出现问题的时候就比较快的找到问题所在。<br><img src="https://img-blog.csdnimg.cn/139325a2cf4946a0b38c94151d912130.png"></p><p> </p><h2 id="9、单机服务：从C10K问题到C10M问题"><a href="#9、单机服务：从C10K问题到C10M问题" class="headerlink" title="9、单机服务：从C10K问题到C10M问题"></a>9、单机服务：从C10K问题到C10M问题</h2><p><img src="https://img-blog.csdnimg.cn/b2a3871eb49b4fc1ade8c358631c58c7.png"></p><p> </p><h2 id="10、单机服务：神器"><a href="#10、单机服务：神器" class="headerlink" title="10、单机服务：神器"></a>10、单机服务：神器</h2><p><img src="https://img-blog.csdnimg.cn/072d7bf470a24c48aa11b026356333d0.png"></p><p> </p><h2 id="Cache-类服务"><a href="#Cache-类服务" class="headerlink" title="Cache 类服务"></a>Cache 类服务</h2><h2 id="1、Cache类服务：基本概念"><a href="#1、Cache类服务：基本概念" class="headerlink" title="1、Cache类服务：基本概念"></a>1、Cache类服务：基本概念</h2><p><img src="https://img-blog.csdnimg.cn/109c7607980b4f0b9cc76c3e342419ea.png"></p><p> </p><h2 id="2、Cache类：Local-Cache"><a href="#2、Cache类：Local-Cache" class="headerlink" title="2、Cache类：Local Cache"></a>2、Cache类：Local Cache</h2><p><img src="https://img-blog.csdnimg.cn/700ccc63c546415cb75bdb8357c0edba.png"></p><p> </p><h2 id="3、Cache类：分布式Cache"><a href="#3、Cache类：分布式Cache" class="headerlink" title="3、Cache类：分布式Cache"></a>3、Cache类：分布式Cache</h2><p><img src="https://img-blog.csdnimg.cn/2cc03bdf362d4b5498f36feba06a82c6.png"></p><p> </p><h2 id="存储类"><a href="#存储类" class="headerlink" title="存储类"></a>存储类</h2><h2 id="1、存储类：基本概念"><a href="#1、存储类：基本概念" class="headerlink" title="1、存储类：基本概念"></a>1、存储类：基本概念</h2><p><img src="https://img-blog.csdnimg.cn/bb3e5b4c1cfd42da99ad8660782f4711.png"></p><p> </p><h2 id="2、存储类：SQL"><a href="#2、存储类：SQL" class="headerlink" title="2、存储类：SQL"></a>2、存储类：SQL</h2><p><img src="https://img-blog.csdnimg.cn/e6bd6d57996b46edab4bac05c96059b7.png"></p><p> </p><h2 id="3、存储类：NOSQL"><a href="#3、存储类：NOSQL" class="headerlink" title="3、存储类：NOSQL"></a>3、存储类：NOSQL</h2><p>有持久化与非持久化的选择，可能是一个状态，不需要落地</p><p>很容易扩展，平行扩展。</p><p>弱一致性</p><p>远程数据库redis，文档数据库mongoDB。<br><img src="https://img-blog.csdnimg.cn/c25102f873a24480a778b3a58da602f9.png"></p><p>while key-value ?<br><img src="https://img-blog.csdnimg.cn/fec8269f285e4e6da4a8a49bb15fc303.png"></p><p>CAP理论</p><p><img src="https://img-blog.csdnimg.cn/64cedc466e6b4d6882d99ec59c83add4.png"></p><h2 id="4、存储类：如何不丢数据"><a href="#4、存储类：如何不丢数据" class="headerlink" title="4、存储类：如何不丢数据"></a>4、存储类：如何不丢数据</h2><p>master-slave：master宕机之后，将slave转为master。</p><p>流水+快照：<br><img src="https://img-blog.csdnimg.cn/8ff2e265f1db4cb0a8c76eca039d4280.png"></p><h2 id="5、存储类：其他存储"><a href="#5、存储类：其他存储" class="headerlink" title="5、存储类：其他存储"></a>5、存储类：其他存储</h2><p><img src="https://img-blog.csdnimg.cn/528f7b7b26294fba8d2d7f141e4d5104.png"></p><p> </p><h2 id="通讯类服务"><a href="#通讯类服务" class="headerlink" title="通讯类服务"></a>通讯类服务</h2><p><img src="https://img-blog.csdnimg.cn/93692cb56a4243d28efa848aa37650c6.png"></p><h2 id="计算类服务"><a href="#计算类服务" class="headerlink" title="计算类服务"></a>计算类服务</h2><h2 id=""><a href="#" class="headerlink" title=""></a></h2><p><img src="https://img-blog.csdnimg.cn/70fe9f09378f46b8b1a4ffa8f09afffa.png"></p><h2 id="寻址类服务"><a href="#寻址类服务" class="headerlink" title="寻址类服务"></a>寻址类服务</h2><p><img src="https://img-blog.csdnimg.cn/03e85d73e2fd4f56b4e722c772c1afc2.png"> </p><h2 id="事务类服务"><a href="#事务类服务" class="headerlink" title="事务类服务"></a>事务类服务</h2><p><img src="https://img-blog.csdnimg.cn/08d39e57acf44e27bf6d3882f0d297b4.png"></p><h2 id="展望"><a href="#展望" class="headerlink" title="展望"></a>展望</h2><p><img src="https://img-blog.csdnimg.cn/ab4c9fbdbfb343d2bf966f36f3016d72.png"></p><h2 id="视频链接"><a href="#视频链接" class="headerlink" title="视频链接"></a>视频链接</h2><p><a href="https://www.bilibili.com/video/BV1Jv41117Zu/?spm_id_from=333.1007.top_right_bar_window_custom_collection.content.click&vd_source=b99c7e40ffa0f64b68b706f2af755c8e">跟腾讯架构大师学网络框架与后台架构_哔哩哔哩_bilibili</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统基础教程</title>
      <link href="/2023/06/20/cao-zuo-xi-tong-ji-chu-jiao-cheng/"/>
      <url>/2023/06/20/cao-zuo-xi-tong-ji-chu-jiao-cheng/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p><strong>目录</strong></p><p><a href="#dyPbB">第二章：处理器管理</a></p><p><a href="#j24Yd">概览</a></p><p><a href="#WTiLL">进程调度的层次</a></p><p><a href="#pYCho">进程的调度方式：</a></p><p><a href="#BBnyp">调度的评价标准：</a></p><p><a href="#Er6TJ">典型的调度算法：</a></p><p><a href="#pg1lZ">第三章：同步、通信和死锁</a></p><p><a href="#w5FKk">什么是进程同步？</a></p><p><a href="#rcJFr">什么是进程互斥？</a></p><p><a href="#ftNhX">进程同步的实现方式</a></p><p><a href="#Drhyo">进程互斥的实现方式</a></p><p><a href="#mbDeV">信号量和PV操作</a></p><p><a href="#qAUAW">管程</a></p><h1 id="第二章：处理器管理"><a href="#第二章：处理器管理" class="headerlink" title="第二章：处理器管理"></a><strong>第二章：处理器管理</strong></h1><p><a href="https://houbb.github.io/2020/10/04/os-03-schedule">操作系统学习(3)处理机调度：调度的概念、时机、切换、过程以及调度方式和基本准则 | Echo Blog</a></p><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>1、指令系统和寄存器。</p><p>2、特权指令和非特权指令：特权指令只能在内核态使用，非特权指令在内核态和用户态（管态和目态）都可以使用。</p><p>3、内核态、用户态</p><p>4、处理器状态及其转换：有几种情况可以让处理器从用户态转为内核态，一、执行系统调用，程序请求操作系统服务；二、中断事件；三、产生异常。</p><p><strong>中断技术：</strong>分为内中断（出现就立即执行），外中断。</p><h2 id="进程调度的层次"><a href="#进程调度的层次" class="headerlink" title="进程调度的层次"></a>进程调度的层次</h2><p><strong>有三种层次：</strong></p><p>1、高级调度：作业调度，内存与辅存之间的调度</p><p>2、中级调度：一种缓冲机制，作用是将暂时挂起的进程重新调入内存运行。进程挂起当内存不足的时候该进程不进入内存，而是在外存等待，即挂起状态。</p><p>3、低级调度：进程&#x2F;线程调度，是操作系统中最基本的一种调度。</p><h2 id="进程的调度方式："><a href="#进程的调度方式：" class="headerlink" title="进程的调度方式："></a>进程的调度方式：</h2><p>1、非剥夺式调度，一旦开始就必须等他运行结束，实现简单，系统开销小。</p><p>2、剥夺式调度：在有优先级的进程时，处理一个优先级更高的进程，这个进程就要是剥夺式进程，就是要处理更加紧急的进程任务。<strong>釆用剥夺式的调度，对提高系统吞吐率和响应效率都有明显的好处。</strong></p><h2 id="调度的评价标准："><a href="#调度的评价标准：" class="headerlink" title="调度的评价标准："></a>调度的评价标准：</h2><p>1、CPU 利用率</p><p>2、系统吞吐率</p><p>3、周转时间：作业完成时间-作业到来时间</p><p>平均作业周转时间（相加之和&#x2F;数量）、平均带权作业周转时间&#x3D;（完成时间&#x2F;所需CPU时间+…）&#x2F;size</p><p>4、等待时间</p><p>5、响应时间</p><h2 id="典型的调度算法："><a href="#典型的调度算法：" class="headerlink" title="典型的调度算法："></a>典型的调度算法：</h2><p><strong>1、先来先服务算法（First Come First Served，FCFS）：</strong>每次从就绪队列中选择最先进入该队列的进程，直到完成。</p><p><strong>2、短作业优先算法（Shortest Job First，SJF）：</strong>从后备队列中选择一个或若干个估计运行时间最短的作业，将它们调入内存运行。由于一直选则最短的作业运行，最早进入但是运行时间长的作业等待时间会很长，<strong>出现饥饿现象。</strong></p><p><strong>3、最短剩余时间优先算法（Shortest Remaining Time First，SRTF）：</strong>将SJF改为剥夺式算法就成为了该算法。</p><p><strong>3、优先级调度算法：</strong>优先级调度算法每次从后备作业队列中选择优先级最髙的一个或几个作业，将它们调入内存，分配必要的资源，创建进程并放入就绪队列。也分为静态优先级和动态优先级，静态优先级可能会造成饥饿现象，即低优先级的进程一直推迟运行。</p><p><strong>4、高响应比优先算法（Highest Response Radio First，HRRF）：</strong>该算法是对FCFS调度算法和SJF调度算法的一种综合平衡，同时考虑每个作业的等待时间和估计的运行时间。在每次进行作业调度时，先计算后备作业队列中每个作业的响应比，从中<strong>选出响应比最高</strong>的作业投入运行。其中响应比&#x3D;(等待时间 + 作业处理时间) &#x2F; 作业处理时间。</p><p><strong>5、时间片轮转调度算法（Round-Robin，RR）：</strong>在这种算法中，系统将所有就绪进程按到达时间的先后次序排成一个队列，进程调度程序总是选择就绪队列中第一个进程执行，即先来先服务的原则，但仅能运行一个时间片，如100ms，形成一个时间环。</p><p><strong>6、多级反馈队列调度算法：</strong>它是时间片轮转调度算法和优先级调度算法的综合和发展，多个就绪队列，每个队列赋予不同的优先级，而且赋予每个队列的时间片也不相同，如第一个队列的优先级最高，时间片最短。如果是一个短作业，它在级别较高的队列就可以处理完；如果是一个长作业，第一级队列没有完成，可以转到下一个时间片更长的队列<strong>末尾</strong>，以此类推。</p><h1 id="第三章：同步、通信和死锁"><a href="#第三章：同步、通信和死锁" class="headerlink" title="第三章：同步、通信和死锁"></a>第三章：同步、通信和死锁</h1><p><a href="https://blog.csdn.net/Shangxingya/article/details/113799732">操作系统~进程同步与进程互斥的概念和实现方式_Listen-Y的博客-CSDN博客</a></p><h2 id="什么是进程同步？"><a href="#什么是进程同步？" class="headerlink" title="什么是进程同步？"></a>什么是进程同步？</h2><p><img src="https://img-blog.csdnimg.cn/img_convert/6bf12302e0c526b5e63e31f3d67167c8.png"></p><p>请看这个管道通信的例子，显然必须先往里面写了数据之后，才可以读数据，但是读数据和写数据是异步发生的，我们不知道实际的读写数据操作谁先谁后，所以需要用进程同步来解决这种问题。</p><p>同步亦称<strong>直接制约关系</strong>，它是指为完成某种任务而建立的两个或多个进程，这些进程因为需要在某些位置上协调它们的工作次序而产生的制约关系。进程间的直接制约关系就是<strong>源于它们之间的相互合作</strong>。</p><h2 id="什么是进程互斥？"><a href="#什么是进程互斥？" class="headerlink" title="什么是进程互斥？"></a>什么是进程互斥？</h2><p>一句话来解释就是对共享资源（也叫临界资源）的互斥访问的控制。共享资源就是多个进程之间的需要共享的资源，在一个进程使用的时候，另外一个进程必须等待（C++中可以使用std::unique_lock<a href="std::mutex">std::mutex</a> std::lock_guard<a href="std::mutex">std::mutex</a>来实现资源的互斥锁）。</p><p>实现资源互斥，需要遵循以下原则:1.空闲让进。2.忙则等待。3.有限等待。4. 让权等待。</p><h2 id="进程同步的实现方式"><a href="#进程同步的实现方式" class="headerlink" title="进程同步的实现方式"></a>进程同步的实现方式</h2><p>1、临界区：Critical Section 通过对多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问。</p><p>2、互斥量（Mutex）：为协调共同对一个共享资源的单独访问而设计的。</p><p>3、信号量（Semaphore）</p><p>4、事件：用来通知线程有一些事件已发生，从而启动后继任务的开始。</p><h2 id="进程互斥的实现方式"><a href="#进程互斥的实现方式" class="headerlink" title="进程互斥的实现方式"></a>进程互斥的实现方式</h2><p>软件算法：Peterson算法，给每个进程设置标志，为true代表此进程要求进入临界区。</p><p>硬件算法：</p><p>1、中断屏蔽方法：利用“开&#x2F;关中断指令”实现（与原语的实现思想相同，即在某进程开始访问临界区到结束访问为止都不允许被中断，也就不能发生进程切换，因此也不可能发生两个线程同时访问临界区的情况)</p><p>2、测试并设置指令：系统利用TS指令来实现临界区的上锁和开锁原语操作（不可以中断的操作）。</p><p>3、对换指令：void SWAP(bool key, bool lock){ bool temp&#x3D;b; b&#x3D;a; a&#x3D;tmep;}</p><h2 id="信号量和PV操作"><a href="#信号量和PV操作" class="headerlink" title="信号量和PV操作"></a>信号量和PV操作</h2><p><strong>1、一般信号量</strong></p><p><code>**typedef struct&#123; int value; struct pcb* list;&#125;**</code><strong>，</strong><code>**void P(semaphore s)&#123; s.value--; if(s.value&lt;0) sleep(s.list);&#125;**</code><strong>，</strong></p><p><code>**void V(semaphore s)&#123; s.value++; if(s.value&lt;=0) wakeup(s.list);&#125;**</code></p><p>上面就是PV操作的相关结构和函数，注意PV操作都是原语（Atomic Language）。</p><p>推论：</p><p>1）若<code>s.value&gt;0</code>，s.value代表可以使用的资源数量。</p><p>2）若<code>s.value&lt;0</code>，s.value代表等待队列中的进程数量。</p><p>3）通常P操作代表申请一个资源，v操作代表归还一个资源</p><p><strong>信号量解决的问题：</strong></p><ul><li>信号量实现互斥+ 信号量解决五位哲学家进餐问题+ 信号量解决生产者-消费者问题+ 信号量解决读者-写者问题+ 信号量解决睡眠理发师问题。</li></ul><h2 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h2><p>在管程中有一个很重要的东西，叫做条件变量。</p><p><a href="https://www.zhihu.com/question/68017337">怎样理解C++11中的条件变量？ - 知乎</a></p><p><a href="https://en.cppreference.com/w/cpp/thread/condition_variable">std::condition_variable - cppreference.com</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>八大排序算法</title>
      <link href="/2023/06/20/ba-da-pai-xu-suan-fa/"/>
      <url>/2023/06/20/ba-da-pai-xu-suan-fa/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><h2 id="1、冒泡排序"><a href="#1、冒泡排序" class="headerlink" title="1、冒泡排序"></a>1、冒泡排序</h2><pre class="line-numbers language-none"><code class="language-none">template&lt;typename T&gt;void BubbleSort(T a[], int len)&#123;    for(int i&#x3D;0; i&lt;len; i++)&#123;        for(int j&#x3D;0; j&lt;len-i-1; j++)&#123;            if(a[j]&gt;a[j+1])            &#123;                swap(a[j], a[j+1]);            &#125;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2、选择排序"><a href="#2、选择排序" class="headerlink" title="2、选择排序"></a>2、选择排序</h2><pre class="line-numbers language-none"><code class="language-none">template&lt;typename T&gt;void SelectSort(T arr[], int len)&#123;    for(int i&#x3D;0; i&lt;len; i++)&#123;        int min&#x3D;i;        for(int j&#x3D;i+1; j&lt;len; j++)&#123;            if(arr[j]&lt;arr[min])&#123;                min&#x3D;j;            &#125;        &#125;        swap(arr[i], arr[min]);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3、插入排序"><a href="#3、插入排序" class="headerlink" title="3、插入排序"></a>3、插入排序</h2><pre class="line-numbers language-none"><code class="language-none">template&lt;typename T&gt;void InsertSort(T arr[], int len)&#123;    for(int i&#x3D;1; i&lt;len; i++)&#123;        int key&#x3D;arr[i];        int j&#x3D;i-1;        while(j&gt;&#x3D;0 &amp;&amp; key&lt;arr[j])&#123;            arr[j+1]&#x3D;arr[j];            j--;        &#125;        arr[j+1]&#x3D;key;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4、希尔排序"><a href="#4、希尔排序" class="headerlink" title="4、希尔排序"></a>4、希尔排序</h2><pre class="line-numbers language-none"><code class="language-none">template&lt;typename T&gt;void ShellSort(T arr[], int len)&#123;    int gap&#x3D;1;    while(gap&lt;len&#x2F;3)&#123;        gap&#x3D;gap*3+1;    &#125;    while(gap&gt;&#x3D;1)&#123;        for(int i&#x3D;gap; i&lt;len; i++)&#123;            for(int j&#x3D;i; j&gt;gap &amp;&amp; arr[j]&lt;arr[j-gap]; j-&#x3D;gap)&#123;                swap(arr[j], arr[j-gap]);            &#125;        &#125;        gap&#x2F;&#x3D;3;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5、快速排序"><a href="#5、快速排序" class="headerlink" title="5、快速排序"></a>5、快速排序</h2><pre class="line-numbers language-none"><code class="language-none">void quickSort(int a[], int l, int r)&#123;    if (l &lt; r) &#123;        int i,j,x;        i &#x3D; l;        j &#x3D; r;        x &#x3D; a[i];        while (i &lt; j) &#123;            while(i &lt; j &amp;&amp; a[j] &gt; x)                j--; &#x2F;&#x2F; 从右向左找第一个小于x的数            if(i &lt; j)                a[i++] &#x3D; a[j];            while(i &lt; j &amp;&amp; a[i] &lt; x)                i++; &#x2F;&#x2F; 从左向右找第一个大于x的数            if(i &lt; j)                a[j--] &#x3D; a[i];        &#125;        a[i] &#x3D; x;&#x2F;&#x2F;没有理解这一行        quickSort(a, l, i-1); &#x2F;* 递归调用 *&#x2F;        quickSort(a, i+1, r); &#x2F;* 递归调用 *&#x2F;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="6、堆排序"><a href="#6、堆排序" class="headerlink" title="6、堆排序"></a>6、堆排序</h2><pre class="line-numbers language-none"><code class="language-none">void sift_down(int arr[], int start, int end)&#123;    int parent &#x3D; start;    int child &#x3D; 2*start+1;    while(child&lt;&#x3D;end)&#123;        if(child+1&lt;&#x3D;end &amp;&amp; arr[child]&lt;arr[child+1])            child++;        if(arr[parent]&gt;arr[child])            return ;        else&#123;            swap(arr[parent], arr[child]);            &#x2F;&#x2F;往下调整            parent&#x3D;child;            child&#x3D;2*parent+1;        &#125;    &#125;&#125;void heap_sort(int arr[], int len)&#123;    &#x2F;&#x2F;调整为大根堆，从最后一个父元素开始(len-1-1)&#x2F;2    for(int i&#x3D;(len-1-1)&#x2F;2; i&gt;&#x3D;0; i--) sift_down(arr, i, len-1);    &#x2F;&#x2F;将堆的根（最大值）掉换到最后一个元素（从小到大排序），在重新调整为大根堆    for(int i&#x3D;len-1; i&gt;&#x3D;0; i--)&#123;        swap(arr[0], arr[i]);        sift_down(arr, 0, i-1);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="7、归并排序"><a href="#7、归并排序" class="headerlink" title="7、归并排序"></a>7、归并排序</h2><p>一半一半砍开来，砍成只有两个元素之后，归并。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">void</span> <span class="token function">merge_sort1</span><span class="token punctuation">(</span>T arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> len<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    T<span class="token operator">*</span> a <span class="token operator">=</span> arr<span class="token punctuation">;</span>    T<span class="token operator">*</span> b <span class="token operator">=</span> <span class="token keyword">new</span> T<span class="token punctuation">[</span>len<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> seg <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> seg <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> seg <span class="token operator">+=</span> seg<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">//区间长度</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> start <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> start <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> start <span class="token operator">+=</span> seg <span class="token operator">+</span> seg<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> low <span class="token operator">=</span> start<span class="token punctuation">,</span> mid <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>start <span class="token operator">+</span> seg<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">,</span> high <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>start <span class="token operator">+</span> seg <span class="token operator">+</span> seg<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> k <span class="token operator">=</span> low<span class="token punctuation">;</span>            <span class="token keyword">int</span> start1 <span class="token operator">=</span> low<span class="token punctuation">,</span> end1 <span class="token operator">=</span> mid<span class="token punctuation">;</span>            <span class="token keyword">int</span> start2 <span class="token operator">=</span> mid<span class="token punctuation">,</span> end2 <span class="token operator">=</span> high<span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>start1 <span class="token operator">&lt;</span> end1 <span class="token operator">&amp;&amp;</span> start2 <span class="token operator">&lt;</span> end2<span class="token punctuation">)</span>                b<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>start1<span class="token punctuation">]</span> <span class="token operator">&lt;</span> a<span class="token punctuation">[</span>start2<span class="token punctuation">]</span> <span class="token operator">?</span> a<span class="token punctuation">[</span>start1<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">:</span> a<span class="token punctuation">[</span>start2<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>start1 <span class="token operator">&lt;</span> end1<span class="token punctuation">)</span>                b<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>start1<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>start2 <span class="token operator">&lt;</span> end2<span class="token punctuation">)</span>                b<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>start2<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        T<span class="token operator">*</span> temp <span class="token operator">=</span> a<span class="token punctuation">;</span>        a <span class="token operator">=</span> b<span class="token punctuation">;</span>        b <span class="token operator">=</span> temp<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">!=</span> arr<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">//这里没有看懂</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>            b<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        b <span class="token operator">=</span> a<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span> b<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="8、桶排序"><a href="#8、桶排序" class="headerlink" title="8、桶排序"></a>8、桶排序</h2><p>将数据放到到各个桶中，在插入数据的时候每个桶的数据保持有序，所以每个桶相当于是一个有序链表。最后将各个桶合并起来，即将各个链表Merge，形成一个有序的整体。</p><pre class="line-numbers language-none"><code class="language-none">#include&lt;iterator&gt;#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;const int BUCKET_NUM &#x3D; 10;&#x2F;&#x2F; 桶的个数&#x2F;** *链表结构体 *&#x2F;struct ListNode&#123;explicit ListNode(int i&#x3D;0):mData(i),mNext(NULL)&#123;&#125;ListNode* mNext;int mData;&#125;;&#x2F;** * 插入的时候是有序的，返回值是头节点 *&#x2F;ListNode* insert(ListNode* head,int val)&#123;ListNode dummyNode;ListNode *newNode &#x3D; new ListNode(val);ListNode *pre,*curr;dummyNode.mNext &#x3D; head;pre &#x3D; &amp;dummyNode;curr &#x3D; head;while(NULL!&#x3D;curr &amp;&amp; curr-&gt;mData&lt;&#x3D;val)&#123;pre &#x3D; curr;curr &#x3D; curr-&gt;mNext;&#125;newNode-&gt;mNext &#x3D; curr;pre-&gt;mNext &#x3D; newNode;return dummyNode.mNext;&#125;&#x2F;** * 将两个链表合并，合并后仍然保持有序  *&#x2F;ListNode* Merge(ListNode *head1,ListNode *head2)&#123;ListNode dummyNode;ListNode *dummy &#x3D; &amp;dummyNode;while(NULL!&#x3D;head1 &amp;&amp; NULL!&#x3D;head2)&#123;if(head1-&gt;mData &lt;&#x3D; head2-&gt;mData)&#123;dummy-&gt;mNext &#x3D; head1;head1 &#x3D; head1-&gt;mNext;&#125;else&#123;dummy-&gt;mNext &#x3D; head2;head2 &#x3D; head2-&gt;mNext;&#125;dummy &#x3D; dummy-&gt;mNext;&#125;if(NULL!&#x3D;head1) dummy-&gt;mNext &#x3D; head1;if(NULL!&#x3D;head2) dummy-&gt;mNext &#x3D; head2;return dummyNode.mNext;&#125;&#x2F;** * 桶排序主体部分 *&#x2F;void BucketSort(int n,int arr[])&#123;vector&lt;ListNode*&gt; buckets(BUCKET_NUM,(ListNode*)(0));&#x2F;&#x2F; 存的是每个桶的头节点，一个桶相当于是一个有序链表for(int i&#x3D;0;i&lt;n;++i)&#123;int index &#x3D; arr[i]&#x2F;BUCKET_NUM; &#x2F;&#x2F; 看要将数据放在哪个桶里面ListNode *head &#x3D; buckets.at(index);&#x2F;&#x2F; 局部变量buckets.at(index) &#x3D; insert(head,arr[i]);&#x2F;&#x2F; 插入桶中&#125;ListNode *head &#x3D; buckets.at(0); &#x2F;&#x2F; 初始值是第0个桶for(int i&#x3D;1;i&lt;BUCKET_NUM;++i)&#123;head &#x3D; Merge(head,buckets.at(i)); &#x2F;&#x2F; 将两个桶合并&#125;for(int i&#x3D;0;i&lt;n;++i)&#123;arr[i] &#x3D; head-&gt;mData;head &#x3D; head-&gt;mNext;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>string底层实现之SSO</title>
      <link href="/2023/06/20/string-di-ceng-shi-xian-zhi-sso/"/>
      <url>/2023/06/20/string-di-ceng-shi-xian-zhi-sso/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="string底层实现之SSO"><a href="#string底层实现之SSO" class="headerlink" title="string底层实现之SSO"></a>string底层实现之SSO</h1><p><a href="https://cplusplus.com/reference/string/string/string/">string的构造函数</a></p><p><a href="https://www.ccppcoding.com/archives/1199">参考资料</a></p><p>Simple String Optimization，最小字符串优化，基本原理是：<strong>当分配的字节数小于16字节的时候，直接从栈上进行进行内存分配，如果大于16字节，则在堆上进行内存分配。</strong></p><p>验证一下：</p><pre class="line-numbers language-none"><code class="language-none">#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;stdlib.h&gt;using namespace std;void *operator new(size_t n)&#123;    cout&lt;&lt;&quot;new size&#x3D;&quot;&lt;&lt;n;    return malloc(n);&#125;void operator delete(void* p)&#123;    free(p);&#125;int main()&#123;    for(int i&#x3D;0; i&lt;30; i++)&#123;        cout&lt;&lt;&quot;i&#x3D;&quot;&lt;&lt;i&lt;&lt;&quot;: &quot;&lt;&lt;string(i, &#39;&#x3D;&#39;)&lt;&lt;endl;    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里对new进行了重载，以便我们观察是否调用的new。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@***********************:~<span class="token comment"># g++ -o test test.cpp </span>root@***********************:~<span class="token comment"># ./test</span><span class="token assign-left variable">i</span><span class="token operator">=</span><span class="token number">0</span>: <span class="token assign-left variable">i</span><span class="token operator">=</span><span class="token number">1</span>: <span class="token operator">=</span><span class="token assign-left variable">i</span><span class="token operator">=</span><span class="token number">2</span>: <span class="token operator">==</span><span class="token assign-left variable">i</span><span class="token operator">=</span><span class="token number">3</span>: <span class="token operator">==</span><span class="token operator">=</span><span class="token assign-left variable">i</span><span class="token operator">=</span><span class="token number">4</span>: <span class="token operator">==</span><span class="token operator">==</span><span class="token assign-left variable">i</span><span class="token operator">=</span><span class="token number">5</span>: <span class="token operator">==</span><span class="token operator">==</span><span class="token operator">=</span><span class="token assign-left variable">i</span><span class="token operator">=</span><span class="token number">6</span>: <span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token assign-left variable">i</span><span class="token operator">=</span><span class="token number">7</span>: <span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">=</span><span class="token assign-left variable">i</span><span class="token operator">=</span><span class="token number">8</span>: <span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token assign-left variable">i</span><span class="token operator">=</span><span class="token number">9</span>: <span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">=</span><span class="token assign-left variable">i</span><span class="token operator">=</span><span class="token number">10</span>: <span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token assign-left variable">i</span><span class="token operator">=</span><span class="token number">11</span>: <span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">=</span><span class="token assign-left variable">i</span><span class="token operator">=</span><span class="token number">12</span>: <span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token assign-left variable">i</span><span class="token operator">=</span><span class="token number">13</span>: <span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">=</span><span class="token assign-left variable">i</span><span class="token operator">=</span><span class="token number">14</span>: <span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token assign-left variable">i</span><span class="token operator">=</span><span class="token number">15</span>: <span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">=</span><span class="token assign-left variable">i</span><span class="token operator">=</span><span class="token number">16</span>: new <span class="token assign-left variable">size</span><span class="token operator">=</span><span class="token number">17</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token assign-left variable">i</span><span class="token operator">=</span><span class="token number">17</span>: new <span class="token assign-left variable">size</span><span class="token operator">=</span><span class="token number">18</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">=</span><span class="token assign-left variable">i</span><span class="token operator">=</span><span class="token number">18</span>: new <span class="token assign-left variable">size</span><span class="token operator">=</span><span class="token number">19</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token assign-left variable">i</span><span class="token operator">=</span><span class="token number">19</span>: new <span class="token assign-left variable">size</span><span class="token operator">=</span><span class="token number">20</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">=</span><span class="token assign-left variable">i</span><span class="token operator">=</span><span class="token number">20</span>: new <span class="token assign-left variable">size</span><span class="token operator">=</span><span class="token number">21</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token assign-left variable">i</span><span class="token operator">=</span><span class="token number">21</span>: new <span class="token assign-left variable">size</span><span class="token operator">=</span><span class="token number">22</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">=</span><span class="token assign-left variable">i</span><span class="token operator">=</span><span class="token number">22</span>: new <span class="token assign-left variable">size</span><span class="token operator">=</span><span class="token number">23</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token assign-left variable">i</span><span class="token operator">=</span><span class="token number">23</span>: new <span class="token assign-left variable">size</span><span class="token operator">=</span><span class="token number">24</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">=</span><span class="token assign-left variable">i</span><span class="token operator">=</span><span class="token number">24</span>: new <span class="token assign-left variable">size</span><span class="token operator">=</span><span class="token number">25</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token assign-left variable">i</span><span class="token operator">=</span><span class="token number">25</span>: new <span class="token assign-left variable">size</span><span class="token operator">=</span><span class="token number">26</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">=</span><span class="token assign-left variable">i</span><span class="token operator">=</span><span class="token number">26</span>: new <span class="token assign-left variable">size</span><span class="token operator">=</span><span class="token number">27</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token assign-left variable">i</span><span class="token operator">=</span><span class="token number">27</span>: new <span class="token assign-left variable">size</span><span class="token operator">=</span><span class="token number">28</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">=</span><span class="token assign-left variable">i</span><span class="token operator">=</span><span class="token number">28</span>: new <span class="token assign-left variable">size</span><span class="token operator">=</span><span class="token number">29</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token assign-left variable">i</span><span class="token operator">=</span><span class="token number">29</span>: new <span class="token assign-left variable">size</span><span class="token operator">=</span><span class="token number">30</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">=</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这就说明当字符串长度小于16时，是在栈上面分配内存，大于16的时候，在堆上分配内存，也就是调用了new方法。</p>]]></content>
      
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Static、#define、const、mutable、typedef</title>
      <link href="/2023/06/20/staticdefineconstmutabletypedef/"/>
      <url>/2023/06/20/staticdefineconstmutabletypedef/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="Static、-define、const、mutable、typedef"><a href="#Static、-define、const、mutable、typedef" class="headerlink" title="Static、#define、const、mutable、typedef"></a>Static、#define、const、mutable、typedef</h1><p>代码存储区域：常量区、代码区、静态区（全局区）、堆区、栈区</p><p>栈区向下增长，堆区向上增长。<strong>栈由系统管理，没有内存碎片，每个元素之间都是连续的，大小比较小，8k，可以修改系统参数</strong>，堆区存储动态开辟的变量。</p><p>还有一个内核空间，但是它不与用户直接交互（内核区）。</p><p><img src="https://img-blog.csdnimg.cn/03ce5015530048e18593741047e6988d.png#pic_center"></p><h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><p>修饰局部变量：局部变量的存储区域改变、变为静态区，生命周期改为程序结束才销毁。</p><p>修饰全局变量：全局变量只能在本文件中访问，不能在其它文件中访问， <strong>extern 外部声明</strong>也不可以。</p><p>修饰成员变量：静态成员变量不属于实体的类对象，要在类外初始化</p><p>修饰成员函数：静态函数<strong>属于类不属于类对象</strong> 需要通过类作用域调用 <strong>函数无this指针</strong>(静态成员函数仅能访问静态的数据成员，不能访问非静态的数据成员，也不能访问非静态的成员函数)</p><h2 id="define"><a href="#define" class="headerlink" title="#define"></a>#define</h2><p>带参数的宏定义可以减少函数调用的开销，在运行时只是简单的展开。</p><h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><p>申明一个常量，在运行期间可以进行类型检查。</p><h2 id="mutable"><a href="#mutable" class="headerlink" title="mutable"></a>mutable</h2><p>mutable为可变的，易变的跟C++中的const是反义词。被mutable修饰的变量(mutable智能用于修饰类的非静态数据成员)<strong>,将永远处于可变的状态</strong>, 即使在一个const函数中</p><h2 id="typedef"><a href="#typedef" class="headerlink" title="typedef"></a>typedef</h2><p>用途： 1、为名称复杂的变量创建别名； 2、创建与平台无关的变量，当跨平台时，只要改下 typedef 本身就行，不用对其他源码做任何修改。 另外，因为typedef是定义了一种类型的新别名，不是简单的字符串替换，所以它比宏来得稳健（虽然用宏有时也可以完成以上的用途）。 比如：<a href="https://en.cppreference.com/w/cpp/types/size_t">size_t的介绍</a></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 在vs中，short 2个字节，int 4个，long也是4个，long long 8个</span><span class="token keyword">typedef</span> <span class="token keyword">short</span> <span class="token keyword">int16_t</span><span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">int</span> <span class="token keyword">int32_t</span><span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">long</span> <span class="token keyword">long</span> <span class="token keyword">int64_t</span><span class="token punctuation">;</span><span class="token comment">// 在Linux下，short 2个，int 4 个，long 8个，long long 也是8个</span><span class="token keyword">typedef</span> <span class="token keyword">short</span> <span class="token keyword">int16_t</span><span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">int</span> <span class="token keyword">int32_t</span><span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">long</span> <span class="token keyword">int64_t</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>所以在程序源码中，只使用这些在头文件中声明的别名。 参考：<a href="https://www.cnblogs.com/Solomon-xm/articles/9140576.html">typedef用法详解</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Reactor模式理论支持</title>
      <link href="/2023/06/20/reactor-mo-shi-li-lun-zhi-chi/"/>
      <url>/2023/06/20/reactor-mo-shi-li-lun-zhi-chi/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p><strong>目录</strong></p><p><a href="#1.%20%E5%89%8D%E8%A8%80">1. 前言</a></p><p><a href="#2%E3%80%81%E4%B8%BB%E8%A6%81%E6%80%9D%E6%83%B3">2、主要思想</a></p><p><a href="#3%E3%80%81%E4%B8%89%E7%A7%8D%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AE%9E%E7%8E%B0">3、三种不同的实现</a></p><p><a href="#%E5%8D%95%20Reactor%20%E5%8D%95%E7%BA%BF%E7%A8%8B">单 Reactor 单线程</a></p><p><a href="#%E5%8D%95%20Reactor%20%E5%A4%9A%E7%BA%BF%E7%A8%8B">单 Reactor 多线程</a></p><p><a href="#%E4%B8%BB%E4%BB%8E%20Reactor%20%E5%A4%9A%E7%BA%BF%E7%A8%8B">主从 Reactor 多线程</a></p><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>开始的服务端的设计是每一个连接都创建一个thread去处理，但是当请求开始变多了之后，比如有1w的request到达服务端，就会 **pthread_create() **创建1w个thread，结束之后销毁线程。这样的创建，处理完然后销毁无疑是非常消耗资源的。</p><p>之后就升级，采用线程池处理请求，提前在一个队列中创建多个线程，从线程池取出线程处理。还有要注意，这个线程队列是全局共享的，为了避免多个线程竞争，要提前给这个线程加锁。</p><p>采用线程池处理主要有两个原因：1、不用频繁的创建和销毁线程。2、线程池能处理的线程有上限，可以防止无限开辟线程而将服务器资源消耗殆尽，挂掉。</p><p>线程池：<a href="https://en.wikipedia.org/wiki/Thread_pool">https://en.wikipedia.org/wiki/Thread_pool</a></p><p>实现：<a href="https://github.com/progschj/ThreadPool/blob/master/ThreadPool.h">ThreadPool&#x2F;ThreadPool.h at master · progschj&#x2F;ThreadPool · GitHub</a></p><p>其实在上面的模型是个【<strong>多线程模型</strong>】，其实还有一种【<strong>多进程模型</strong>】。主要思想是利用** fork()** 函数，创建子进程。父进程要处理好自己的孩子，就是在进程退出的时候要回收好资源，否则可能变成【僵尸进程】（进程只保留了相关的信息，但是占用了进程号）。怎么回收资源呢？答案是调用【**wait()<strong>】和【</strong>waitpid()**】。在这个过程中，对父进程和子进程的处理是不相同的：</p><ul><li>父进程：只需要管理监听的 【Socket】描述符，而不关心已经连接的【Socket】+ 子进程：只关心已经连接的【Socket】，不用管监听的【Socket】</li></ul><p>上面两个模型，【<strong>多线程模型</strong>】缺点主要是服务端如果同时维护多个线程是不现实的，操作系统会扛不住；【<strong>多进程模型</strong>】缺点则是在多个连接同时存在的情况下进程的上下文切换所耗费的系统资源过大。这个时候更为设计一种高效的模式是当务之急，【<strong>Reactor模式</strong>】应运而生</p><h2 id="2、主要思想"><a href="#2、主要思想" class="headerlink" title="2、主要思想"></a>2、主要思想</h2><p>【<strong>Reactor模式</strong>】基于【<strong>select&#x2F;poll&#x2F;epoll</strong>】的【<strong>IO多路复用</strong>】进行了一层封装，使得我们在编写网络程序的时候，不需要考虑底层API的细节，符合当下面向对象的思想。</p><p> IO复用：<a href="https://mp.weixin.qq.com/s/Qpa0qXxuIM8jrBqDaXmVNA">这次答应我，一举拿下 I&#x2F;O 多路复用！</a></p><p>【<strong>Reactor模式</strong>】的 Reactor 的翻译是反应堆，意思是只要来了一个事件，Reactor 就有反应。</p><p>Reactor主要包括两个部分：Reactor 和处理资源池。</p><ul><li>Reactor 负责监听事件和分发事件，事件可能是读写事件或连接事件。+ 处理资源池将Reactor 分发给他的事件，主要的流程：Read-&gt;处理业务-&gt;Send</li></ul><p>因此 【<strong>Reactor模式</strong>】也叫【<strong>Dispatcher 模式】</strong>，一个主线程负责监听和分发事件，其他的线程处理业务，所以这个名字应该更加的贴切。</p><p>目的是减少等待，当遇到需要等待的IO的时候，先释放资源，在IO完成之后，通过事件驱动的方式没继续接下来的处理。</p><p>根据 Reactor 的数量和处理资源池线程的数量不同，有 3 种典型的实现：</p><ul><li>单 Reactor 单线程 +  单 Reactor 多线程 +  主从 Reactor 多线程</li></ul><h2 id="3、三种不同的实现"><a href="#3、三种不同的实现" class="headerlink" title="3、三种不同的实现"></a>3、三种不同的实现</h2><h3 id="单-Reactor-单线程"><a href="#单-Reactor-单线程" class="headerlink" title="单 Reactor 单线程"></a>单 Reactor 单线程</h3><p>话不多说，先看一个图片。</p><p><img src="https://img-blog.csdnimg.cn/8a592a409ca64f1eba4ef26fc02d9917.png"></p><p> 首先从图中可以看到：</p><ul><li>Reactor 处理监听以及事件的分发+ Accept 处理连接+ Handler 处理IO事件以及业务</li></ul><p>下面详细介绍下流程：</p><ul><li>【<strong>Reactor</strong>】通过 select（IO多路复用接口）监听多个 Socket ，如果 Socket 有事件发生，判断事件类别后看看分配给【<strong>Acceptor</strong>】，还是【<strong>Handler</strong>】。+ 如果是建立连接事件，交付给【<strong>Acceptor</strong>】处理，【<strong>Acceptor</strong>】会创建一个【<strong>Handler</strong>】来处理这个刚连接的 Socket 的后续事件。+ 如果是处理非连接事件，交付给【<strong>Handler</strong>】处理，一般处理过程：read-&gt;业务处理-&gt;send。</li></ul><p>缺点是无法利用CPU多核的能力</p><p>应用场景：Redis使用的就是这种模式，但是它是在内存中处理业务的，所以处理起来很快。</p><h3 id="单-Reactor-多线程"><a href="#单-Reactor-多线程" class="headerlink" title="单 Reactor 多线程"></a>单 Reactor 多线程</h3><p>看一下流程图</p><p><img src="https://img-blog.csdnimg.cn/93aaef58ff03418da459b6110980b9e4.png"></p><p>流程：</p><ul><li>【<strong>Reactor</strong>】通过 select（IO多路复用接口）监听多个 Socket ，如果 Socket 有事件发生，判断事件类别后看看分配给【<strong>Acceptor</strong>】，还是【<strong>Handler</strong>】。+ 如果是建立连接事件，交付给【<strong>Acceptor</strong>】处理，【<strong>Acceptor</strong>】会创建一个【<strong>Handler</strong>】来处理这个刚连接的 Socket 的后续事件。+ 如果是处理非连接事件，交付给【<strong>Handler</strong>】处理。</li></ul><p>上面的三个步骤和单 Reactor 单线程方案是一样的，接下来的步骤就开始不一样了：</p><ul><li>【<strong>Handler</strong>】 对象不再负责业务处理，只负责数据的接收和发送，【<strong>Handler</strong>】 对象通过 read 读取到数据后，会将数据发给子线程里的 【<strong>Processor</strong>】 对象进行业务处理；+ 子线程里的 【<strong>Processor</strong>】 对象就进行业务处理，处理完后，将结果发给主线程中的 【<strong>Handler</strong>】对象，接着由 【<strong>Handler</strong>】通过 send 方法将响应结果发送给 client；</li></ul><h3 id="主从-Reactor-多线程"><a href="#主从-Reactor-多线程" class="headerlink" title="主从 Reactor 多线程"></a>主从 Reactor 多线程</h3><p>流程：</p><ul><li>主线程中的 MainReactor 对象通过 select 监控连接建立事件，收到事件后通过 Acceptor 对象中的 accept 获取连接，将新的连接分配给某个子线程；+ 子线程中的 SubReactor 对象将 MainReactor 对象分配的连接加入 select 继续进行监听，并创建一个 Handler 用于处理连接的响应事件。+ 如果有新的事件发生时，SubReactor 对象会调用当前连接对应的 Handler 对象来进行响应。+ Handler 对象通过 read -&gt; 业务处理 -&gt; send 的流程来完成完整的业务流程。</li></ul><p><a href="https://www.zhihu.com/question/26943938/answer/1856426252">如何深刻理解Reactor和Proactor？ - 知乎</a></p><p><a href="https://www.modb.pro/db/189720">从Reactor模式俯瞰Nginx，你会发现你与高手的差距就在设计模式上，不在内卷上 - 墨天轮</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>QT中国象棋初版</title>
      <link href="/2023/06/20/qt-zhong-guo-xiang-qi-chu-ban/"/>
      <url>/2023/06/20/qt-zhong-guo-xiang-qi-chu-ban/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="Chinese-Chess"><a href="#Chinese-Chess" class="headerlink" title="Chinese-Chess"></a>Chinese-Chess</h1><p>中国象棋初版</p><p>实现了单人双方对战、人对战电脑、开两个客户端联机对战</p><pre class="line-numbers language-none"><code class="language-none">佛曰: *          写字楼里写字间，写字间里程序员； *          程序人员写程序，又拿程序换酒钱。 *          酒醒只在网上坐，酒醉还来网下眠； *          酒醉酒醒日复日，网上网下年复年。 *          但愿老死电脑间，不愿鞠躬老板前； *          奔驰宝马贵者趣，公交自行程序员。 *          别人笑我忒疯癫，我笑自己命太贱； *          不见满街漂亮妹，哪个归得程序员？<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="界面展示"><a href="#界面展示" class="headerlink" title="界面展示"></a>界面展示</h2><h3 id="主菜单界面："><a href="#主菜单界面：" class="headerlink" title="主菜单界面："></a>主菜单界面：</h3><p><img src="https://img-blog.csdnimg.cn/0460f32b642f4d29862cfe1d8effac0e.png#pic_center"></p><p>主界面部分代码：</p><pre class="line-numbers language-none"><code class="language-none">#include &quot;choosemainwindow.h&quot;ChooseMainWindow::ChooseMainWindow(QWidget *parent) : QDialog(parent)&#123;    this-&gt;setWindowTitle(&quot;选择游戏方式&quot;);    this-&gt;setFixedSize(250,120);    this-&gt;setWindowIcon(QIcon(&quot;:&#x2F;images&#x2F;chess.svg&quot;));    QVBoxLayout* lay &#x3D; new QVBoxLayout(this);    lay-&gt;addWidget(m_buttons[0] &#x3D; new QPushButton(&quot;玩家自己对战&quot;));    lay-&gt;addWidget(m_buttons[1] &#x3D; new QPushButton(&quot;玩家和AI对战&quot;));    lay-&gt;addWidget(m_buttons[2] &#x3D; new QPushButton(&quot;双人网络对战&quot;));    &#x2F;*游戏方式一: 自己和自己下棋【同一台PC机器】*&#x2F;    connect(m_buttons[0], &amp;QPushButton::clicked,[&#x3D;]()&#123;        this-&gt;hide();        m_pAgainstYourself &#x3D; new ChessBoard();        m_pAgainstYourself-&gt;setWindowTitle(&quot;玩家自己对战&quot;);        m_pAgainstYourself-&gt;show();        &#x2F;&#x2F;返回主窗口        connect(m_pAgainstYourself,&amp;ChessBoard::toMenu,[&#x3D;]()&#123;            m_pAgainstYourself-&gt;close();            this-&gt;show();        &#125;);    &#125;);    &#x2F;*游戏方式二: 自己和电脑下棋【同一台PC机器】*&#x2F;    connect(m_buttons[1], &amp;QPushButton::clicked,[&#x3D;]()&#123;        this-&gt;hide();        m_pRobotGame &#x3D; new RobotGame();        m_pRobotGame-&gt;setWindowTitle(&quot;玩家和AI对战&quot;);        m_pRobotGame-&gt;show();        &#x2F;&#x2F;返回主窗口        connect(m_pRobotGame,&amp;ChessBoard::toMenu,[&#x3D;]()&#123;            m_pRobotGame-&gt;close();            this-&gt;show();        &#125;);    &#125;);    &#x2F;*游戏方式三: 双人局域网下棋【可在局域网下不同台PC机器】*&#x2F;    connect(m_buttons[2], &amp;QPushButton::clicked,[&#x3D;]()&#123;        this-&gt;hide();        QMessageBox::StandardButtons ret &#x3D; QMessageBox::question(NULL, &quot;提示&quot;, &quot;是否作为服务器启动[选择红方]?&quot;);        bool bServer &#x3D; false;        if(ret &#x3D;&#x3D; QMessageBox::Yes)            bServer &#x3D; true;        m_pNetworkGame &#x3D; new NetworkGame(bServer);        m_pNetworkGame-&gt;setWindowTitle(&quot;双人网络对战&quot;);        m_pNetworkGame-&gt;show();        &#x2F;&#x2F;返回主窗口        connect(m_pNetworkGame,&amp;ChessBoard::toMenu,[&#x3D;]()&#123;            m_pNetworkGame-&gt;close();            this-&gt;show();        &#125;);    &#125;);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="玩家和自己对战界面："><a href="#玩家和自己对战界面：" class="headerlink" title="玩家和自己对战界面："></a>玩家和自己对战界面：</h3><p><img src="https://img-blog.csdnimg.cn/ddce9e5977c9405488ea8601f44ce0d2.png#pic_center"></p><p>棋盘绘制部分代码：</p><pre class="line-numbers language-none"><code class="language-none">void ChessBoard::paintEvent(QPaintEvent *)&#123;    QPainter painter(this);    painter.setRenderHint(QPainter::Antialiasing, true);&#x2F;&#x2F;渲染提示    int side &#x3D; qMin(int(ui-&gt;centralwidget-&gt;width() - ui-&gt;rightWidget-&gt;width()), ui-&gt;label-&gt;height());    painter.scale(side &#x2F; 960.0, side &#x2F; 960.0);    m_offset &#x3D; 60;              &#x2F;&#x2F;距离界面的边距    m_distance &#x3D; 90;            &#x2F;&#x2F;间距为90px    m_radius &#x3D; m_distance&#x2F;2;    &#x2F;&#x2F;棋子半径为d&#x2F;2    for(int i &#x3D; 0; i &lt;10; i++)&#123;        painter.drawLine(QPoint(m_offset, m_offset+i*m_distance), QPoint(m_offset+8*m_distance, m_offset+i*m_distance));    &#125;    for(int i&#x3D;0; i&lt;9; i++)&#123;        if(i&#x3D;&#x3D;0 || i&#x3D;&#x3D;8)&#123;            painter.drawLine(QPoint(m_offset+i*m_distance, m_offset), QPoint(m_offset+i*m_distance, m_offset+9*m_distance));        &#125;else&#123;            painter.drawLine(QPoint(m_offset+i*m_distance, m_offset), QPoint(m_offset+i*m_distance, m_offset+4*m_distance));            painter.drawLine(QPoint(m_offset+i*m_distance, m_offset+5*m_distance), QPoint(m_offset+i*m_distance, m_offset+9*m_distance));        &#125;    &#125;    painter.drawLine(QPoint(m_offset+3*m_distance, m_offset), QPoint(m_offset+5*m_distance, m_offset+2*m_distance));    painter.drawLine(QPoint(m_offset+3*m_distance, m_offset+2*m_distance), QPoint(m_offset+5*m_distance, m_offset));    painter.drawLine(QPoint(m_offset+3*m_distance, m_offset+7*m_distance), QPoint(m_offset+5*m_distance, m_offset+9*m_distance));    painter.drawLine(QPoint(m_offset+3*m_distance, m_offset+9*m_distance), QPoint(m_offset+5*m_distance, m_offset+7*m_distance));    QRect rect1(m_offset+m_distance,   m_offset+4*m_distance, m_distance, m_distance);    QRect rect2(m_offset+2*m_distance, m_offset+4*m_distance, m_distance, m_distance);    QRect rect3(m_offset+5*m_distance, m_offset+4*m_distance, m_distance, m_distance);    QRect rect4(m_offset+6*m_distance, m_offset+4*m_distance, m_distance, m_distance);    painter.setFont(QFont(&quot;FangSong&quot;, m_radius * 5 &#x2F; 6, 800));    painter.drawText(rect1, &quot;楚&quot;, QTextOption(Qt::AlignCenter));    painter.drawText(rect2, &quot;河&quot;, QTextOption(Qt::AlignCenter));    painter.drawText(rect3, &quot;汉&quot;, QTextOption(Qt::AlignCenter));    painter.drawText(rect4, &quot;界&quot;, QTextOption(Qt::AlignCenter));    &#x2F;&#x2F;*******************绘画棋子*******************    &#x2F;&#x2F;绘制上次移动棋子的起止位置    if(m_isShowStep)        drawLastStep(painter,m_chessSteps);    for(int i &#x3D; 0; i &lt; 32; i++)        drawChessPieces(painter, i);    &#x2F;&#x2F;绘制文本棋谱    drawTextStep();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="玩家和AI对战界面："><a href="#玩家和AI对战界面：" class="headerlink" title="玩家和AI对战界面："></a>玩家和AI对战界面：</h3><p><img src="https://img-blog.csdnimg.cn/275f7732d6ca46488f458bb459f0dec3.png#pic_center"></p><p>其实并不算是真正的AI，算法实现的是只要有可以吃到的子，就会直接吃掉，有多个可以吃掉的子，会计算各个棋子的得分，没有就随便走一步。</p><p>部分实现代码：</p><pre class="line-numbers language-none"><code class="language-none">ChessStep *RobotGame::getBestMove()&#123;    int maxScore &#x3D; -10000;    ChessStep* retStep &#x3D; NULL;    &#x2F;&#x2F;有可击杀的红棋子就走击杀红棋子最优的一步    &#x2F;&#x2F; 1.看看有那些步骤可以走    QVector&lt;ChessStep*&gt; steps;    getAllPossibleMoveStep(steps);    &#x2F;&#x2F;没有可击杀的红棋子就走最后的一步    QVector&lt;ChessStep*&gt; stepsAndNoKill;    getAllPossibleMoveStepAndNoKill(stepsAndNoKill);    &#x2F;&#x2F;2.试着走一下    for(QVector&lt;ChessStep*&gt;::iterator it &#x3D; steps.begin(); it!&#x3D;steps.end(); it++)    &#123;        ChessStep* step &#x3D; *it;        fakeMove(step);        int score &#x3D; calcScore();   &#x2F;&#x2F;3.计算最好的局面分        unFakeMove(step);        if(score &gt; maxScore)        &#123;            maxScore &#x3D; score;            retStep &#x3D; step;        &#125;    &#125;    if(retStep !&#x3D; NULL)        return retStep;    &#x2F;&#x2F;2.试着走一下    &#x2F;&#x2F;从这种不击杀红棋子，只是单纯移动黑棋steps里面，随机抽选一种进行下棋    int nStepsCount &#x3D; stepsAndNoKill.count();    qsrand(QTime(0,0,0).secsTo(QTime::currentTime()));    int temp &#x3D;qrand()% nStepsCount;    QVector&lt;ChessStep*&gt;::iterator it &#x3D; stepsAndNoKill.begin();    retStep &#x3D; it[temp];    if(retStep &#x3D;&#x3D; NULL)        whoWin();    return retStep;&#125;int RobotGame::calcScore()&#123;    &#x2F;&#x2F;enum m_emTYPE&#123;JIANG, SHI, XIANG, MA, CHE, PAO, BING&#125;;    &#x2F;&#x2F;黑棋分数 - 红棋分数    int redGrossScore &#x3D; 0;    int blackGrossScore &#x3D; 0;    static int chessScore[]&#x3D;&#123;200, 20, 40, 60, 100, 80, 10&#125;;    for(int i&#x3D;0; i&lt;16; i++)    &#123;        if(m_chessPieces[i].m_isDead)            continue;        blackGrossScore +&#x3D; chessScore[m_chessPieces[i].m_emType];    &#125;    for(int i&#x3D;16; i&lt;32; i++)    &#123;        if(m_chessPieces[i].m_isDead)            continue;        redGrossScore +&#x3D; chessScore[m_chessPieces[i].m_emType];    &#125;    return (blackGrossScore - redGrossScore);&#125;void RobotGame::getAllPossibleMoveStep(QVector&lt;ChessStep *&gt; &amp;steps)&#123;    for(int id &#x3D; 0; id&lt;16; id++)&#123;        if(m_chessPieces[id].m_isDead)            continue;        for(int row&#x3D;0; row&lt;10; row++)&#123;            for(int col&#x3D;0; col&lt;9; col++)&#123;                int i &#x3D; 16;             &#x2F;&#x2F;机器人是黑方                for( ; i &lt;&#x3D; 31; i++)&#123;                    if(m_chessPieces[i].m_row &#x3D;&#x3D; row &amp;&amp; m_chessPieces[i].m_col &#x3D;&#x3D; col &amp;&amp; m_chessPieces[i].m_isDead &#x3D;&#x3D; false)                        break;                &#125;                if(i!&#x3D;32)&#123;                    if(canMove(id, i, row, col))                        saveStep(id, i, row, col, steps);                &#125;            &#125;        &#125;    &#125;&#125;&#x2F;&#x2F; 该函数实现了一个棋类游戏中所有未死亡的棋子在棋盘上所有能够不吃子移动的走法的获取void RobotGame::getAllPossibleMoveStepAndNoKill(QVector&lt;ChessStep *&gt; &amp;steps)&#123;    for(int id &#x3D; 0; id&lt;16; id++)&#123;        if(m_chessPieces[id].m_isDead)            continue;        for(int row&#x3D;0; row&lt;10; row++)&#123;            for(int col&#x3D;0; col&lt;9; col++)&#123;                int i &#x3D; 0;                for( ; i &lt;&#x3D; 31; i++)&#123;                    if(m_chessPieces[i].m_row &#x3D;&#x3D; row &amp;&amp; m_chessPieces[i].m_col &#x3D;&#x3D; col &amp;&amp; m_chessPieces[i].m_isDead &#x3D;&#x3D; false)                        break;                &#125;                if(id &lt; 16 &amp;&amp; i &#x3D;&#x3D;32)&#123;&#x2F;&#x2F;-1??????                    if(canMove(id, -1, row, col))                        saveStep(id, -1, row, col, steps);                &#125;            &#125;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="双人网络对战："><a href="#双人网络对战：" class="headerlink" title="双人网络对战："></a>双人网络对战：</h3><p><img src="https://img-blog.csdnimg.cn/48f372c15d034afe8999976ad3bf4b1a.png#pic_center"></p><p><img src="https://img-blog.csdnimg.cn/585ab690769343649521236e64f5f9a2.png#pic_center"></p><p>部分代码展示：</p><pre class="line-numbers language-none"><code class="language-none">#include &quot;networkgame.h&quot;NetworkGame::NetworkGame(bool isServer)&#123;    m_tcpServer &#x3D; nullptr;    m_tcpSocket &#x3D; nullptr;    if(isServer)&#123;        m_isTcpServer &#x3D; true;        m_tcpServer &#x3D; new QTcpServer(this);        m_tcpServer-&gt;listen(QHostAddress::Any, 5555);        connect(m_tcpServer, &amp;QTcpServer::newConnection, this, &amp;NetworkGame::slotNewConnection);    &#125; else &#123;        m_isTcpServer &#x3D; false;        m_tcpSocket &#x3D; new QTcpSocket(this);        m_tcpSocket-&gt;connectToHost(QHostAddress(&quot;127.0.0.1&quot;), 5555);        connect(m_tcpSocket, &amp;QTcpSocket::readyRead, this, &amp;NetworkGame::slotRecv);    &#125;&#125;NetworkGame::~NetworkGame()&#123;&#125;void NetworkGame::clickPieces(int id, int row, int col)&#123;    if(m_isTcpServer)&#123;        if(m_selectID &#x3D;&#x3D; -1 &amp;&amp; m_checkedID &#x3D;&#x3D; -1)&#123;            if(m_isTcpServer !&#x3D; m_chessPieces[id].m_isRed)                return ;        &#125;    &#125; else &#123;        if(m_selectID &#x3D;&#x3D; -1 &amp;&amp; m_checkedID &#x3D;&#x3D; -1)&#123;            if(m_isTcpServer !&#x3D; m_chessPieces[id].m_isRed)                return ;        &#125;    &#125;    whoWin();    ChessBoard::clickPieces(id, row, col);    char array[3];    array[0] &#x3D; id;    array[1] &#x3D; row;    array[2] &#x3D; col;    &#x2F;&#x2F; 如果先创建的客户端，就会报错，因为构造函数没有new QTcpSocket。    m_tcpSocket-&gt;write(array, 3);&#125;void NetworkGame::slotNewConnection()&#123;    if(m_isTcpServer)        return ;    m_tcpSocket &#x3D; m_tcpServer-&gt;nextPendingConnection();    connect(m_tcpSocket, &amp;QTcpSocket::readyRead, this, &amp;NetworkGame::slotRecv);&#125;void NetworkGame::slotRecv()&#123;    QByteArray array &#x3D; m_tcpSocket-&gt;readAll();    int checkedID &#x3D; array[0];    int row &#x3D; array[1];    int col &#x3D; array[2];    ChessBoard::clickPieces(checkedID, row, col);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Author"><a href="#Author" class="headerlink" title="Author"></a>Author</h2><p><a href="https://github.com/allenmirac/Chinese-Chess">AllenMirac-ChineseChess</a></p><h1 id="巨人的肩膀"><a href="#巨人的肩膀" class="headerlink" title="巨人的肩膀"></a>巨人的肩膀</h1><p><a href="https://blog.csdn.net/qq_33154343/article/details/80931400">项目实战：Qt5／C++：QT象棋【初版】</a></p><p><a href="https://github.com/XMuli/ChineseChess">XMuli-ChineseChess</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> QT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>QT_Review之元对象系统（Moc）</title>
      <link href="/2023/06/20/qtreview-zhi-yuan-dui-xiang-xi-tong-moc/"/>
      <url>/2023/06/20/qtreview-zhi-yuan-dui-xiang-xi-tong-moc/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p><strong>目录</strong></p><p><a href="#QT%20%E5%85%83%E5%AF%B9%E8%B1%A1%E7%B3%BB%E7%BB%9F">QT 元对象系统</a></p><p><a href="#%E5%AE%9E%E9%AA%8C%E6%A1%88%E4%BE%8B">实验案例</a></p><p><a href="#%E4%BB%8E%E5%9B%9B%E4%B8%AA%E6%96%B9%E9%9D%A2%E6%9D%A5%E4%BB%8B%E7%BB%8D%E5%85%83%E5%AF%B9%E8%B1%A1%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%A5%A5%E7%A7%98">从四个方面来介绍元对象系统的奥秘</a></p><p><a href="#%E6%98%AF%E4%BB%80%E4%B9%88">是什么</a></p><p><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88">为什么</a></p><p><a href="#%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0">怎么实现</a></p><p><a href="#%E6%80%8E%E4%B9%88%E7%94%A8">怎么用</a></p><p><a href="#moc%20%E4%BD%BF%E7%94%A8">moc 使用</a></p><p><a href="#%E5%BC%95%E7%94%A8">引用</a></p><p><a href="#%E6%AC%A2%E8%BF%8E%E5%A4%A7%E5%AE%B6star">欢迎大家star</a></p><h1 id="QT-元对象系统"><a href="#QT-元对象系统" class="headerlink" title="QT 元对象系统"></a>QT 元对象系统</h1><p>QT 的元对象系统（The Meta-Object System）由它的元对象编译器（Meta-Object Compiler，moc）帮忙实现，moc 通过读取头文件中的 Q_OBJCET 宏来判断是否需要生成元对象代码。如果需要，则生成以 moc_ 开头的源文件，在链接（Linking）时会和源文件一起生成可执行文件。</p><h2 id="实验案例"><a href="#实验案例" class="headerlink" title="实验案例"></a>实验案例</h2><p>欢迎大家star：</p><p><a href="https://github.com/allenmirac/QTStudy/tree/main/QTReviewMoc">QTStudy&#x2F;QTReviewMoc at main · allenmirac&#x2F;QTStudy · GitHub</a></p><h2 id="从四个方面来介绍元对象系统的奥秘"><a href="#从四个方面来介绍元对象系统的奥秘" class="headerlink" title="从四个方面来介绍元对象系统的奥秘"></a>从四个方面来介绍元对象系统的奥秘</h2><h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><ul><li>从 QT 新增的关键字（signals、slots、emit）可以看出 QT 并不是标准的 C++ 语言，而是对其进行了一定程度的扩展。 +  元对象系统是 QT 核心的一部分，用于支持 QT 的 C++ 扩展（QT’s C++ extensions），它提供了用于对象间通信的信号与槽、运行时类型信息以及动态属性系统。</li></ul><h2 id="为什么"><a href="#为什么" class="headerlink" title="为什么"></a>为什么</h2><p>由于 QT 是标准 C++ 的一个扩展，所以编译源代码时就需要将这些扩展的语法去掉，然后交给标准 C++ 编译器，诸如 GCC、MinGW、Clang 等。</p><h2 id="怎么实现"><a href="#怎么实现" class="headerlink" title="怎么实现"></a>怎么实现</h2><p>元对象系统基于以下 3 件事：</p><ul><li><code>QObject</code>类为使用元对象系统的 QT 对象提供了一个基类。 +  <code>Q_OBJECT</code> 宏用来在类中启用元对象特性，例如动态属性、信号、槽。 +  <code>moc</code> 为每个 QObject 子类提供实现元对象特性所需要的代码。</li></ul><p>moc 工具读取 C++ 源文件。如果发现源文件中有一个类或者多个类的声明中包含 Q_OBJECT 宏，它就生成一个包含了这些类所需要的元对象代码的源文件。这个新源文件的文件名为源文件名前加上 moc_。<strong>新生成的源文件必须被 #include 到源文件中，或者更常见的是编译和连接到类的实现中。</strong></p><h2 id="怎么用"><a href="#怎么用" class="headerlink" title="怎么用"></a>怎么用</h2><p>元对象系统有以下特性：</p><ul><li><code>signals and slots</code> 一个用于对象间通信的信号与槽机制（QT 引入元对象系统最主要的原因）。 +  <code>QObject::metaObject()</code> 用来返回类关联的元对象。 +  <code>QMetaObject::className()</code> 用来在运行时获取类名，<strong>这个方法不需要原生 C++ 编译器的运行时类型信息（Runtime type information，RTTI）支持</strong>。 +  <code>QObject::inherits()</code> 用来判别一个对象是否是 QObject 继承树中的特定类的对象。 +  <code>QObject::tr()</code> 和 <code>QObject::trUtf8()</code> 提供 QT 国际化中翻译字符串的支持。 +  <code>QObject::setProperty()</code> 和 <code>QObject::property()</code> 提供动态地设置和获取属性名。 +  <code>QMetaObject::newInstance()</code> 用于构造一个类的新实例。 +  <code>qobject_cast</code> 处理继承自 QObject 类的动态转换。它不需要 RTTI 支持，并且支持跨动态库转换。转换成功返回非零指针，失败返回 nullptr。</li></ul><p>在 QObject 的派生类中，不使用 Q_OBJECT 宏以及没有元对象代码，上述元对象系统特性也能用。需要注意的是，QMetaObject::className() 只会返回离它最近且拥有元对象代码的祖先（即最近一个声明 Q_OBJECT 的祖先）的类名。所以建议 QObject 的派生类一律添加 Q_OBJECT 宏！</p><h2 id="moc-使用"><a href="#moc-使用" class="headerlink" title="moc 使用"></a>moc 使用</h2><p>在这个案例中的使用：</p><p><a href="https://github.com/allenmirac/QTStudy/blob/main/QTReviewMoc/expersion.h">QTStudy&#x2F;expersion.h at main · allenmirac&#x2F;QTStudy · GitHub</a></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">EXPERSION_H</span></span> #define EXPERSION_H ​ #include <span class="token operator">&lt;</span>QObject<span class="token operator">></span> ​ <span class="token keyword">class</span> <span class="token class-name">ExPersion</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">QObject</span></span> <span class="token punctuation">&#123;</span>     Q_OBJECT     <span class="token comment">//Connected to the property system is an additional macro, Q_CLASSINFO(), that can be used to attach additional name--value pairs to a class's meta-object</span>     <span class="token function">Q_CLASSINFO</span><span class="token punctuation">(</span><span class="token string">"author"</span><span class="token punctuation">,</span><span class="token string">"hzy"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token function">Q_CLASSINFO</span><span class="token punctuation">(</span><span class="token string">"version"</span><span class="token punctuation">,</span> <span class="token string">"1.1.1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token function">Q_CLASSINFO</span><span class="token punctuation">(</span><span class="token string">"info"</span><span class="token punctuation">,</span> <span class="token string">"QT5 Meta Object and Property Example"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">//A property behaves like a class data member, but it has additional features accessible through the Meta-Object System.</span>     <span class="token function">Q_PROPERTY</span><span class="token punctuation">(</span><span class="token keyword">int</span> age READ getAge WRITE setAge NOTIFY ageChanged<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token function">Q_PROPERTY</span><span class="token punctuation">(</span>QString name MEMBER m_name<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token function">Q_PROPERTY</span><span class="token punctuation">(</span><span class="token keyword">int</span> score MEMBER m_score<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">public</span><span class="token operator">:</span>     <span class="token keyword">explicit</span> <span class="token function">ExPersion</span><span class="token punctuation">(</span>QString name<span class="token punctuation">,</span> QObject <span class="token operator">*</span>parent <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span> ​ <span class="token keyword">public</span><span class="token operator">:</span>     <span class="token keyword">int</span> <span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">void</span> <span class="token function">setAge</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span> ​     <span class="token keyword">void</span> <span class="token function">incAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> ​ signals<span class="token operator">:</span>     <span class="token keyword">void</span> <span class="token function">ageChanged</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span> ​ <span class="token keyword">private</span><span class="token operator">:</span>     <span class="token keyword">int</span> m_age <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>     QString m_name<span class="token punctuation">;</span>     <span class="token keyword">int</span> m_score <span class="token operator">=</span> <span class="token number">50</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span> ​ #endif <span class="token comment">// EXPERSION_H</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>官方文档的Example：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">MyClass</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">QObject</span></span> <span class="token punctuation">&#123;</span>     Q_OBJECT     <span class="token function">Q_PROPERTY</span><span class="token punctuation">(</span>Priority priority READ priority WRITE setPriority NOTIFY priorityChanged<span class="token punctuation">)</span> ​ <span class="token keyword">public</span><span class="token operator">:</span>     <span class="token function">MyClass</span><span class="token punctuation">(</span>QObject <span class="token operator">*</span>parent <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token operator">~</span><span class="token function">MyClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> ​     <span class="token keyword">enum</span> <span class="token class-name">Priority</span> <span class="token punctuation">&#123;</span> High<span class="token punctuation">,</span> Low<span class="token punctuation">,</span> VeryHigh<span class="token punctuation">,</span> VeryLow <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>     <span class="token function">Q_ENUM</span><span class="token punctuation">(</span>Priority<span class="token punctuation">)</span> ​     <span class="token keyword">void</span> <span class="token function">setPriority</span><span class="token punctuation">(</span>Priority priority<span class="token punctuation">)</span>     <span class="token punctuation">&#123;</span>         m_priority <span class="token operator">=</span> priority<span class="token punctuation">;</span>         emit <span class="token function">priorityChanged</span><span class="token punctuation">(</span>priority<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">&#125;</span>     Priority <span class="token function">priority</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>     <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> m_priority<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> ​ signals<span class="token operator">:</span>     <span class="token keyword">void</span> <span class="token function">priorityChanged</span><span class="token punctuation">(</span>Priority<span class="token punctuation">)</span><span class="token punctuation">;</span> ​ <span class="token keyword">private</span><span class="token operator">:</span>     Priority m_priority<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><a href="https://beyondyuanshu.github.io/2019/09/03/qt-core-the-meta-object-system.html">Qt 核心之元对象系统 - Shu’s Site</a></p><p><a href="https://doc.qt.io/qt-6/qobject.html#Q_PROPERTY">QObject Class | Qt Core 6.4.3</a></p><h2 id="欢迎大家star"><a href="#欢迎大家star" class="headerlink" title="欢迎大家star"></a>欢迎大家star</h2><p><a href="https://github.com/allenmirac/QTStudy">GitHub - allenmirac&#x2F;QTStudy: This is a repository to learn QT.</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> QT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>QT_Review之_QSlider（滑块）</title>
      <link href="/2023/06/20/qtreview-zhi-qslider-hua-kuai/"/>
      <url>/2023/06/20/qtreview-zhi-qslider-hua-kuai/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p><strong>目录</strong></p><p><a href="#QT%20QSlider">QT QSlider</a></p><p><a href="#%E6%98%AF%E4%BB%80%E4%B9%88">是什么</a></p><p><a href="#%E5%AE%9E%E9%AA%8C%E6%A1%88%E4%BE%8B">实验案例</a></p><p><a href="#%E6%80%8E%E4%B9%88%E7%94%A8">怎么用</a></p><p><a href="#%E6%A1%88%E4%BE%8B">案例</a></p><p><a href="#%E6%AC%A2%E8%BF%8E%E5%A4%A7%E5%AE%B6star">欢迎大家star</a></p><h1 id="QT-QSlider"><a href="#QT-QSlider" class="headerlink" title="QT QSlider"></a>QT QSlider</h1><h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><p>滑块是控制有界值的经典小部件。它允许用户沿着水平或垂直槽移动滑块手柄，并将手柄的位置转换为合法范围内的整数值。</p><p><code>QSlider</code> 自己的功能很少，大部分功能都继承于 <code>QAbstractSlider</code>。最常用的函数是 <code>setValue ()</code> ，它可以将滑块直接设置为某个值; <code>triggerAction ()</code>可以模拟单击的效果(对快捷键有用) ;<code>setSingleStep ()</code>，<code>setPageStep ()</code>可以设置步骤; <code>setMinimum()</code>和 <code>setMaximum()</code>可以定义滚动条的范围。</p><h2 id="实验案例"><a href="#实验案例" class="headerlink" title="实验案例"></a>实验案例</h2><p>欢迎大家star：</p><p><a href="https://github.com/allenmirac/QTStudy/tree/main/QTReviewQSlider">QTStudy&#x2F;QTReviewQSlider at main · allenmirac&#x2F;QTStudy · GitHub</a></p><h2 id="怎么用"><a href="#怎么用" class="headerlink" title="怎么用"></a>怎么用</h2><p><strong>继承的属性：</strong></p><ul><li><code>minimum</code>、<code>maximum</code>：设置输入范围的最小值和最大值，例如，用红、绿、蓝配色时，每 种基色的大小范围是0~255，所以设置<strong>minimum</strong>为0，<strong>maximum</strong>为255。 +  <code>singlestep</code>:单步长，拖动标尺上的滑块，或按下左&#x2F;右光标键时的最小变化数值。 +  <code>pageStep</code>:在<strong>Slider</strong>上输入焦点，按<strong>PgUp</strong>或<strong>PgDn</strong>键时变化的数值。 +  <code>value</code>：组件的当前值，拖动滑块时自动改变此值，并限定在<strong>minimum</strong>和<strong>maximum</strong>定义的 范围之内。 +  <code>sliderPosition</code>:滑块的位置，若<strong>tracking</strong>属性设置为true，<strong>sliderPosition</strong>就等于value。 +  <strong><code>tracking</code>：sliderPosition</strong>是否等同于<strong>value</strong>，如果<strong>tracking</strong>&#x3D;true，改变value时也同时改变 sliderPosition。 +  <code>orientation</code>: <strong>Slider</strong>的方向，可以设置为水平或垂直。方向参数是Qt的枚举类型enum +  <code>Qt::Orientation</code>：取值包括以下两种。<br>枚举含义Qt::Horizontal水平方向Qt::Vertical垂直方向+  <code>invertedAppearance</code>:显示方式是否反向，<strong>invertedAppearance</strong>&#x3D;false时，水平的Slider由左向右数值增大，否则反过来。 +  <code>invertedControls</code>：反向按键控制，若<strong>invertedControls</strong>&#x3D;true，则按下<strong>PgUp</strong>或<strong>PgDn</strong>按键时调整数值的反向相反。 +  <strong>属于QSlider的专有属性有两个，如下：</strong> +  <code>tickPosition</code>:标尺刻度的显示位置，使用枚举类型<strong>QSlider:TickPosition</strong>，取值包括以下6种<br>枚举含义QSlider::NoTicks不显示刻度QSlider::TicksBothSides标尺两侧都显示刻度QSlider::TicksAbove标尺上方显示刻度QSlider::TicksBelow标尺下方显示刻度QSlider::TicksLeft标尺左侧显示刻度QSlider::TicksRight标尺右侧显示刻度+  <code>ticklnterval</code>：标尺刻度的间隔值，若设置为0，会在<strong>singleStep</strong>和<strong>pageStep</strong>之间自动选择。</li></ul><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"> #include <span class="token string">"exqslider.h"</span> #include <span class="token string">"ui_exqslider.h"</span> ​ <span class="token class-name">ExQSlider</span><span class="token double-colon punctuation">::</span><span class="token function">ExQSlider</span><span class="token punctuation">(</span>QWidget <span class="token operator">*</span>parent<span class="token punctuation">)</span>     <span class="token operator">:</span> <span class="token function">QWidget</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span>     <span class="token punctuation">,</span> <span class="token function">ui</span><span class="token punctuation">(</span><span class="token keyword">new</span> Ui<span class="token double-colon punctuation">::</span>ExQSlider<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>     ui<span class="token operator">-></span><span class="token function">setupUi</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token function">setWindowTitle</span><span class="token punctuation">(</span><span class="token function">QString</span><span class="token punctuation">(</span><span class="token string">"QSlider的用法"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> ​     <span class="token comment">//QSlider控件，设置最大值为255,初始范围是0-100;</span>     ui<span class="token operator">-></span>sliderRed<span class="token operator">-></span><span class="token function">setMaximum</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     ui<span class="token operator">-></span>sliderGreen<span class="token operator">-></span><span class="token function">setMaximum</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     ui<span class="token operator">-></span>sliderBlue<span class="token operator">-></span><span class="token function">setMaximum</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     ui<span class="token operator">-></span>sliderAlpha<span class="token operator">-></span><span class="token function">setMaximum</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span><span class="token punctuation">;</span> ​     <span class="token comment">//QSlider控件，设置初值</span>     ui<span class="token operator">-></span>sliderRed<span class="token operator">-></span><span class="token function">setValue</span><span class="token punctuation">(</span><span class="token number">145</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     ui<span class="token operator">-></span>sliderGreen<span class="token operator">-></span><span class="token function">setValue</span><span class="token punctuation">(</span><span class="token number">190</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     ui<span class="token operator">-></span>sliderBlue<span class="token operator">-></span><span class="token function">setValue</span><span class="token punctuation">(</span><span class="token number">251</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     ui<span class="token operator">-></span>sliderAlpha<span class="token operator">-></span><span class="token function">setValue</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span><span class="token punctuation">;</span> ​     <span class="token comment">//QTextEdit控件，设置初试颜色</span>     QColor color<span class="token punctuation">;</span>     color<span class="token punctuation">.</span><span class="token function">setRgb</span><span class="token punctuation">(</span><span class="token number">145</span><span class="token punctuation">,</span> <span class="token number">190</span><span class="token punctuation">,</span> <span class="token number">251</span><span class="token punctuation">,</span> <span class="token number">255</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     QPalette palette <span class="token operator">=</span> ui<span class="token operator">-></span>textColor<span class="token operator">-></span><span class="token function">palette</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//拿到调色板</span>     palette<span class="token punctuation">.</span><span class="token function">setColor</span><span class="token punctuation">(</span>QPalette<span class="token double-colon punctuation">::</span>Base<span class="token punctuation">,</span> color<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//设置背景颜色</span>     ui<span class="token operator">-></span>textColor<span class="token operator">-></span><span class="token function">setPalette</span><span class="token punctuation">(</span>palette<span class="token punctuation">)</span><span class="token punctuation">;</span> ​     <span class="token function">connect</span><span class="token punctuation">(</span>ui<span class="token operator">-></span>sliderRed<span class="token punctuation">,</span> <span class="token operator">&amp;</span>QSlider<span class="token double-colon punctuation">::</span>valueChanged<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>ExQSlider<span class="token double-colon punctuation">::</span>onSetColor<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token function">connect</span><span class="token punctuation">(</span>ui<span class="token operator">-></span>sliderGreen<span class="token punctuation">,</span> <span class="token operator">&amp;</span>QSlider<span class="token double-colon punctuation">::</span>valueChanged<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>ExQSlider<span class="token double-colon punctuation">::</span>onSetColor<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token function">connect</span><span class="token punctuation">(</span>ui<span class="token operator">-></span>sliderBlue<span class="token punctuation">,</span> <span class="token operator">&amp;</span>QSlider<span class="token double-colon punctuation">::</span>valueChanged<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>ExQSlider<span class="token double-colon punctuation">::</span>onSetColor<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token function">connect</span><span class="token punctuation">(</span>ui<span class="token operator">-></span>sliderAlpha<span class="token punctuation">,</span> <span class="token operator">&amp;</span>QSlider<span class="token double-colon punctuation">::</span>valueChanged<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>ExQSlider<span class="token double-colon punctuation">::</span>onSetColor<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> ​ <span class="token class-name">ExQSlider</span><span class="token double-colon punctuation">::</span><span class="token operator">~</span><span class="token function">ExQSlider</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>     <span class="token keyword">delete</span> ui<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> ​ <span class="token keyword">void</span> <span class="token class-name">ExQSlider</span><span class="token double-colon punctuation">::</span><span class="token function">onSetColor</span><span class="token punctuation">(</span><span class="token keyword">int</span> val<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>     <span class="token function">Q_UNUSED</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span> ​     <span class="token keyword">int</span> nRed <span class="token operator">=</span> ui<span class="token operator">-></span>sliderRed<span class="token operator">-></span><span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">int</span> nGreen <span class="token operator">=</span> ui<span class="token operator">-></span>sliderGreen<span class="token operator">-></span><span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">int</span> nBlue <span class="token operator">=</span> ui<span class="token operator">-></span>sliderBlue<span class="token operator">-></span><span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">int</span> nAlpha <span class="token operator">=</span> ui<span class="token operator">-></span>sliderAlpha<span class="token operator">-></span><span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> ​     QColor color<span class="token punctuation">;</span>     color<span class="token punctuation">.</span><span class="token function">setRgb</span><span class="token punctuation">(</span>nRed<span class="token punctuation">,</span> nGreen<span class="token punctuation">,</span> nBlue<span class="token punctuation">,</span> nAlpha<span class="token punctuation">)</span><span class="token punctuation">;</span>     QPalette palette <span class="token operator">=</span> ui<span class="token operator">-></span>textColor<span class="token operator">-></span><span class="token function">palette</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     palette<span class="token punctuation">.</span><span class="token function">setColor</span><span class="token punctuation">(</span>QPalette<span class="token double-colon punctuation">::</span>Base<span class="token punctuation">,</span> color<span class="token punctuation">)</span><span class="token punctuation">;</span>     ui<span class="token operator">-></span>textColor<span class="token operator">-></span><span class="token function">setPalette</span><span class="token punctuation">(</span>palette<span class="token punctuation">)</span><span class="token punctuation">;</span> ​     ui<span class="token operator">-></span>labRGBVal<span class="token operator">-></span><span class="token function">setText</span><span class="token punctuation">(</span><span class="token function">QString</span><span class="token punctuation">(</span><span class="token string">"RGB(%1, %2, %3, %4)"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">arg</span><span class="token punctuation">(</span>nRed<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">arg</span><span class="token punctuation">(</span>nGreen<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">arg</span><span class="token punctuation">(</span>nBlue<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">arg</span><span class="token punctuation">(</span>nAlpha<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> ​ <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="欢迎大家star"><a href="#欢迎大家star" class="headerlink" title="欢迎大家star"></a>欢迎大家star</h2><p><a href="https://github.com/allenmirac/QTStudy">GitHub - allenmirac&#x2F;QTStudy: This is a repository to learn QT.</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> QT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>QComboBox_和_QPlainTextEdit</title>
      <link href="/2023/06/20/qcombobox-he-qplaintextedit/"/>
      <url>/2023/06/20/qcombobox-he-qplaintextedit/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p><strong>目录</strong></p><p><a href="#QComboBox">QComboBox</a></p><p><a href="#%E6%B7%BB%E5%8A%A0%E9%A1%B9">添加项</a></p><p><a href="#%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0">常用函数</a></p><p><a href="#QPlainTextEdit">QPlainTextEdit</a></p><p><a href="#%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95">使用方法</a></p><p><a href="#%E7%A4%BA%E4%BE%8B">示例</a></p><p><a href="#%E6%AC%A2%E8%BF%8E%E5%A4%A7%E5%AE%B6star">欢迎大家star</a></p><h1 id="QComboBox"><a href="#QComboBox" class="headerlink" title="QComboBox"></a>QComboBox</h1><p>QComboBox 主要的功能是提供一个下拉列表供选择输入，也可以直接当作一个 QLineEdit 用作输入（<code>ui-&gt;comboBox-&gt;setEditable(true);</code>）。</p><h2 id="添加项"><a href="#添加项" class="headerlink" title="添加项"></a>添加项</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token class-name">ExQComboBox</span><span class="token double-colon punctuation">::</span><span class="token function">on_btnInitNameAge_clicked</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    QIcon ico<span class="token punctuation">;</span>    ico<span class="token punctuation">.</span><span class="token function">addFile</span><span class="token punctuation">(</span><span class="token string">":/girl.ico"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>​    QMap<span class="token operator">&lt;</span>QString<span class="token punctuation">,</span> QString<span class="token operator">></span> map<span class="token punctuation">;</span>    map<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token string">"张投"</span><span class="token punctuation">,</span> <span class="token string">"16岁"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    map<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token string">"张我"</span><span class="token punctuation">,</span> <span class="token string">"17岁"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    map<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token string">"张以"</span><span class="token punctuation">,</span> <span class="token string">"18岁"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    map<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token string">"张木"</span><span class="token punctuation">,</span> <span class="token string">"19岁"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    map<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token string">"张李"</span><span class="token punctuation">,</span> <span class="token string">"20岁"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    map<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token string">"张，"</span><span class="token punctuation">,</span> <span class="token string">"21岁"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    map<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token string">"张报"</span><span class="token punctuation">,</span> <span class="token string">"22岁"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>​    ui<span class="token operator">-></span>comboBoxRight<span class="token operator">-></span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">foreach</span><span class="token punctuation">(</span><span class="token keyword">const</span> QString <span class="token operator">&amp;</span>str<span class="token punctuation">,</span> map<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        ui<span class="token operator">-></span>comboBoxRight<span class="token operator">-></span><span class="token function">addItem</span><span class="token punctuation">(</span>ico<span class="token punctuation">,</span> str<span class="token punctuation">,</span> map<span class="token punctuation">.</span><span class="token function">value</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里用了foreach遍历map。</p><p>添加具有用户数据的项 QComboBox::addltem() 函数的两种参数的原型定义如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">addItem</span> <span class="token punctuation">(</span><span class="token keyword">const</span> QString <span class="token operator">&amp;</span>text<span class="token punctuation">,</span> <span class="token keyword">const</span> QVariant <span class="token operator">&amp;</span>userData <span class="token operator">=</span> <span class="token function">QVariant</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">void</span> <span class="token function">addItem</span> <span class="token punctuation">(</span><span class="token keyword">const</span> QIcon <span class="token operator">&amp;</span>icon<span class="token punctuation">,</span> <span class="token keyword">const</span> QString <span class="token operator">&amp;</span>text<span class="token punctuation">,</span> <span class="token keyword">const</span> QVariant <span class="token operator">&amp;</span>userData <span class="token operator">=</span> <span class="token function">QVariant</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h2><p>QComboBox 存储的项是一个列表，但是 QComboBox 不提供整个列表用于访问，可以通过索引访问某个项。访问项的一些函数主要有以下几种：</p><ul><li>int currentlndex()：返回当前项的序号，第一个项的序号为0。 +  QString currentText()：返回当前项的文字。 +  QVariant currentData(int role &#x3D; Qt::UserRole)：返回当前项的关联数据，数据的缺省角色为 role &#x3D; Qt::UserRole，角色的意义在后续章节会详细介绍。 +  QString itemText(int index)：返回指定索引号的项的文字。 +  QVariant itemData(int index, int role &#x3D; Qt%:UserRole)：返回指定索引号的项的关联数据。 +  int count()：返回项的个数。</li></ul><p>在一个 QComboBox 组件上选择项发生变化时，会发射如下两个信号：<br>void currentlndexChanged(int index)<br>void currentlndexChanged(const QString &amp;text)</p><h1 id="QPlainTextEdit"><a href="#QPlainTextEdit" class="headerlink" title="QPlainTextEdit"></a>QPlainTextEdit</h1><p>QPlainTextEdit 是一个多行文本编辑器，用于显示和编辑多行简单文本。</p><p>QPlainTextEdit 提供**cut( )、copy( )、paste( )、undo( )、redo( )、clear( )、selectAll( )**等标准编辑功 能的槽函数，QPlainTextEdit还提供一个标准的右键快捷菜单。</p><p>QPlainTextEdit的文字内容以QTextDocument类型存储，函数document()返回这个文档对象的指针。</p><p>QTextDocument是内存中的文本对象，以文本块的方式存储，一个文本块就是一个段落，每个段落以回车符结束。QTextDocument提供一些函数实现对文本内容的存取。</p><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>常用函数含义()appendPlainText()向QPlain TextEdit添加一行话int blockCount()获得文本块个数QTextBlock findBlockByNumber(int blockNumber)读取某一个文本块，序号从0开始，至blockCount()-1结束。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token class-name">ExQComboBox</span><span class="token double-colon punctuation">::</span><span class="token function">onSelectDisplay</span><span class="token punctuation">(</span>QString str<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    QString strData <span class="token operator">=</span> ui<span class="token operator">-></span>comboBoxRight<span class="token operator">-></span><span class="token function">currentData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    ui<span class="token operator">-></span>plainTextEdit<span class="token operator">-></span><span class="token function">appendPlainText</span><span class="token punctuation">(</span>str <span class="token operator">+</span> <span class="token string">" "</span> <span class="token operator">+</span> strData<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h1 id="欢迎大家star"><a href="#欢迎大家star" class="headerlink" title="欢迎大家star"></a>欢迎大家star</h1><p>这里是项目的源码，是一个很好的练习的例子，可以自己敲着玩一玩，练习练习手感</p><p><a href="https://github.com/allenmirac/QTStudy/tree/main/QTReviewQCombobox">QTStudy&#x2F;QTReviewQCombobox at main · allenmirac&#x2F;QTStudy · GitHub</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> QT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python细碎知识点（getattr......）</title>
      <link href="/2023/06/20/python-xi-sui-zhi-shi-dian-getattr/"/>
      <url>/2023/06/20/python-xi-sui-zhi-shi-dian-getattr/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p><strong>目录</strong></p><p><a href="#%E7%B1%BB%E5%A4%96%E7%BB%99%E7%B1%BB%E5%A2%9E%E5%8A%A0%E5%B1%9E%E6%80%A7%E3%80%81%E8%AE%BE%E7%BD%AE%E5%B1%9E%E6%80%A7">类外给类增加属性、设置属性</a></p><p><a href="#%E7%B1%BB%E5%A4%96%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7%C2%A0">类外定义属性 </a></p><p><a href="#Python%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%EF%BC%9A%C2%A0">Python运算符重载： </a></p><p><a href="#%E7%B1%BB%E7%9A%84%E6%96%B9%E6%B3%95__doc__(%E8%BE%93%E5%87%BA%E6%B3%A8%E9%87%8A)%C2%A0">类的方法__doc__(输出注释) </a></p><p><a href="#%E7%B1%BB%E7%9A%84%E6%96%B9%E6%B3%95__name__%EF%BC%9A%C2%A0">类的方法__name__： </a></p><p><a href="#%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F%EF%BC%9A%C2%A0">变量作用域： </a></p><p><a href="#%C2%A0set%E7%9A%84%E8%AF%A6%E7%BB%86%E7%94%A8%E6%B3%95"> set的详细用法</a></p><p><a href="#Generation">Generation</a></p><p><a href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%98%AF%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%B1%BB%E5%9E%8B">字符串是不可变类型</a></p><h2 id="类外给类增加属性、设置属性"><a href="#类外给类增加属性、设置属性" class="headerlink" title="类外给类增加属性、设置属性"></a>类外给类增加属性、设置属性</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">change</span><span class="token punctuation">:</span>     <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> z<span class="token punctuation">)</span><span class="token punctuation">:</span>         self<span class="token punctuation">.</span>a <span class="token operator">=</span> x <span class="token operator">+</span> y <span class="token operator">+</span> z x <span class="token operator">=</span> change<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span> y <span class="token operator">=</span> <span class="token builtin">getattr</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> <span class="token string">'a'</span><span class="token punctuation">)</span> <span class="token keyword">print</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span>y <span class="token operator">=</span> <span class="token builtin">getattr</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> <span class="token string">"b"</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment"># 第三个参数是默认值，不存在该属性则将y设置为默认值，</span><span class="token comment"># 注意y是int型数据！！！</span><span class="token keyword">print</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token builtin">setattr</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> <span class="token string">'a'</span><span class="token punctuation">,</span> y<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>a<span class="token punctuation">)</span><span class="token comment"># 6</span><span class="token comment"># 1</span><span class="token comment"># 2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="类外定义属性"><a href="#类外定义属性" class="headerlink" title="类外定义属性"></a>类外定义属性</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">fruits</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> price<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>price <span class="token operator">=</span> priceobj<span class="token operator">=</span>fruits<span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span>obj<span class="token punctuation">.</span>quantity<span class="token operator">=</span><span class="token number">10</span>obj<span class="token punctuation">.</span>bags<span class="token operator">=</span><span class="token number">2</span><span class="token keyword">print</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span>quantity<span class="token operator">+</span><span class="token builtin">len</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span>__dict__<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment"># 13</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Python运算符重载："><a href="#Python运算符重载：" class="headerlink" title="Python运算符重载："></a>Python运算符重载：</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python">Suppose i <span class="token keyword">is</span> <span class="token number">5</span> <span class="token keyword">and</span> j <span class="token keyword">is</span> <span class="token number">4</span><span class="token punctuation">,</span> i <span class="token operator">*</span> j <span class="token keyword">is</span> same <span class="token keyword">as</span> ______<span class="token punctuation">.</span>A<span class="token punctuation">.</span> i<span class="token punctuation">.</span>__mul<span class="token punctuation">(</span>j<span class="token punctuation">)</span>B<span class="token punctuation">.</span> i<span class="token punctuation">.</span>__mul__<span class="token punctuation">(</span>j<span class="token punctuation">)</span>C<span class="token punctuation">.</span> i<span class="token punctuation">.</span>__Mul<span class="token punctuation">(</span>j<span class="token punctuation">)</span>D<span class="token punctuation">.</span> i<span class="token punctuation">.</span>__MUL<span class="token punctuation">(</span>j<span class="token punctuation">)</span>我的答案<span class="token punctuation">:</span> B<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python">If a <span class="token keyword">class</span> <span class="token class-name">defines</span> the __str__<span class="token punctuation">(</span>self<span class="token punctuation">)</span> method<span class="token punctuation">,</span> <span class="token keyword">for</span> an <span class="token builtin">object</span> obj <span class="token keyword">for</span> the <span class="token keyword">class</span><span class="token punctuation">,</span> you can use which command to invoke the __str__ method<span class="token punctuation">.</span>A<span class="token punctuation">.</span> obj<span class="token punctuation">.</span>__str__<span class="token punctuation">(</span><span class="token punctuation">)</span>B<span class="token punctuation">.</span> <span class="token builtin">str</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span>C<span class="token punctuation">.</span> <span class="token keyword">print</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span>D<span class="token punctuation">.</span> <span class="token builtin">all</span> of the mentioned我的答案<span class="token punctuation">:</span> D<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 实现自己的复数类型，运算符重载</span><span class="token keyword">class</span> <span class="token class-name">MyComplex</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>real<span class="token punctuation">,</span>image<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>real <span class="token operator">=</span> real        self<span class="token punctuation">.</span>image <span class="token operator">=</span> image    <span class="token keyword">def</span> <span class="token function">__add__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>other<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> MyComplex<span class="token punctuation">(</span>self<span class="token punctuation">.</span>real<span class="token operator">+</span>other<span class="token punctuation">.</span>real<span class="token punctuation">,</span>self<span class="token punctuation">.</span>image<span class="token operator">+</span>other<span class="token punctuation">.</span>image<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">__sub__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>other<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> MyComplex<span class="token punctuation">(</span>self<span class="token punctuation">.</span>real<span class="token operator">-</span>other<span class="token punctuation">.</span>real<span class="token punctuation">,</span>self<span class="token punctuation">.</span>image<span class="token operator">-</span>other<span class="token punctuation">.</span>image<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">__mul__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> other<span class="token punctuation">)</span><span class="token punctuation">:</span>        re <span class="token operator">=</span> self<span class="token punctuation">.</span>real<span class="token operator">*</span>other<span class="token punctuation">.</span>real<span class="token operator">-</span>self<span class="token punctuation">.</span>image<span class="token operator">*</span>other<span class="token punctuation">.</span>image        im <span class="token operator">=</span> self<span class="token punctuation">.</span>real<span class="token operator">*</span>other<span class="token punctuation">.</span>real<span class="token operator">-</span>self<span class="token punctuation">.</span>image<span class="token operator">*</span>other<span class="token punctuation">.</span>image        <span class="token keyword">return</span> MyComplex<span class="token punctuation">(</span>re<span class="token punctuation">,</span>im<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">__str__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>image<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">:</span>                       <span class="token keyword">return</span> <span class="token builtin">str</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>real<span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">'+'</span><span class="token operator">+</span><span class="token builtin">str</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>image<span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">'j'</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token builtin">str</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>real<span class="token punctuation">)</span><span class="token operator">+</span><span class="token builtin">str</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>image<span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">'j'</span><span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    c1 <span class="token operator">=</span> MyComplex<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>c1<span class="token punctuation">)</span>    c2 <span class="token operator">=</span> MyComplex<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        op <span class="token operator">=</span> <span class="token builtin">input</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> op <span class="token operator">==</span> <span class="token string">'+'</span><span class="token punctuation">:</span>            <span class="token keyword">print</span><span class="token punctuation">(</span>c1<span class="token operator">+</span>c2<span class="token punctuation">)</span>        <span class="token keyword">elif</span> op <span class="token operator">==</span> <span class="token string">'-'</span><span class="token punctuation">:</span>            <span class="token keyword">print</span><span class="token punctuation">(</span>c1<span class="token operator">-</span>c2<span class="token punctuation">)</span>        <span class="token keyword">elif</span> op <span class="token operator">==</span> <span class="token string">'*'</span><span class="token punctuation">:</span>            <span class="token keyword">print</span><span class="token punctuation">(</span>c1<span class="token operator">*</span>c2<span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token keyword">break</span><span class="token keyword">if</span> __name__<span class="token operator">==</span><span class="token string">"__main__"</span><span class="token punctuation">:</span>main<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="类的方法-doc-输出注释"><a href="#类的方法-doc-输出注释" class="headerlink" title="类的方法__doc__(输出注释)"></a>类的方法__doc__(输出注释)</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># What will be the output of the following Python code?</span><span class="token keyword">class</span> <span class="token class-name">stud</span><span class="token punctuation">:</span>    <span class="token string">'Base class for all students'</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> roll_no<span class="token punctuation">,</span> grade<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>roll_no <span class="token operator">=</span> roll_no        self<span class="token punctuation">.</span>grade <span class="token operator">=</span> grade    <span class="token keyword">def</span> <span class="token function">display</span> <span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Roll no : "</span><span class="token punctuation">,</span> self<span class="token punctuation">.</span>roll_no<span class="token punctuation">,</span> <span class="token string">", Grade: "</span><span class="token punctuation">,</span> self<span class="token punctuation">.</span>grade<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>stud<span class="token punctuation">.</span>__doc__<span class="token punctuation">)</span>A<span class="token punctuation">.</span> Exception <span class="token keyword">is</span> thrownB<span class="token punctuation">.</span> __main__C<span class="token punctuation">.</span> Nothing <span class="token keyword">is</span> displayedD<span class="token punctuation">.</span> Base <span class="token keyword">class</span> <span class="token class-name">for</span> <span class="token builtin">all</span> students我的答案<span class="token punctuation">:</span> D<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="类的方法-name-："><a href="#类的方法-name-：" class="headerlink" title="类的方法__name__："></a>类的方法__name__：</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python">What does <span class="token keyword">print</span><span class="token punctuation">(</span>Test<span class="token punctuation">.</span>__name__<span class="token punctuation">)</span> display <span class="token punctuation">(</span>assuming Test <span class="token keyword">is</span> the name of the <span class="token keyword">class</span><span class="token punctuation">)</span>?A<span class="token punctuation">.</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>B<span class="token punctuation">.</span> Exception <span class="token keyword">is</span> thrownC<span class="token punctuation">.</span> TestD<span class="token punctuation">.</span> __main__我的答案<span class="token punctuation">:</span> C<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="变量作用域："><a href="#变量作用域：" class="headerlink" title="**变量作用域： **"></a>**变量作用域： **</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">add</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span>k<span class="token punctuation">)</span><span class="token punctuation">:</span>     c<span class="token punctuation">.</span>test <span class="token operator">+=</span> <span class="token number">1</span>     k <span class="token operator">+=</span> <span class="token number">2</span> <span class="token keyword">class</span> <span class="token class-name">A</span><span class="token punctuation">:</span>     <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>         self<span class="token punctuation">.</span>test <span class="token operator">=</span> <span class="token number">0</span> a<span class="token operator">=</span>A<span class="token punctuation">(</span><span class="token punctuation">)</span> k<span class="token operator">=</span><span class="token number">0</span> add<span class="token punctuation">(</span>a<span class="token punctuation">,</span>k<span class="token punctuation">)</span> <span class="token keyword">print</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span>test<span class="token punctuation">,</span> k<span class="token punctuation">)</span> A<span class="token punctuation">.</span> <span class="token number">0</span> <span class="token number">0</span>B<span class="token punctuation">.</span> <span class="token number">1</span> <span class="token number">0</span>C<span class="token punctuation">.</span> <span class="token number">0</span> <span class="token number">2</span>D<span class="token punctuation">.</span> <span class="token number">1</span> <span class="token number">2</span>我的答案<span class="token punctuation">:</span> B<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="set的详细用法"><a href="#set的详细用法" class="headerlink" title="set的详细用法"></a>set的详细用法</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">s <span class="token operator">=</span> set<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment"># 将集合初始化为空的</span><span class="token comment"># 不能是 s=&#123;&#125;,这里s树dict类型</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><a href="https://www.cnblogs.com/whatisfantasy/p/5956775.html">​​​​​​​Python基本数据类型之set - morra - 博客园 (cnblogs.com)<br><img src="https://csdnimg.cn/release/blog_editor_html/release2.1.3/ckeditor/plugins/CsdnLink/icons/icon-default.png?t=M4AD"><br>https://www.cnblogs.com/whatisfantasy/p/5956775.html</a></p><h2 id="Generation"><a href="#Generation" class="headerlink" title="Generation"></a>Generation</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">fib</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">:</span>    n<span class="token punctuation">,</span>a<span class="token punctuation">,</span>b<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span>    <span class="token keyword">while</span> n<span class="token operator">&lt;</span>x<span class="token punctuation">:</span>        <span class="token keyword">yield</span> b        a<span class="token punctuation">,</span>b<span class="token operator">=</span>b<span class="token punctuation">,</span>a<span class="token operator">+</span>b        n<span class="token operator">+=</span><span class="token number">1</span>    <span class="token keyword">return</span> b<span class="token comment"># print()</span><span class="token keyword">for</span> i <span class="token keyword">in</span> fib<span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token comment"># 1</span><span class="token comment"># 2</span><span class="token comment"># 3</span><span class="token comment"># 5</span><span class="token comment"># 8</span><span class="token comment"># 13</span><span class="token comment"># 21</span><span class="token comment"># 34</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017318207388128">生成器 - 廖雪峰的官方网站研究互联网产品和技术，提供原创中文精品教程<br><img src="https://csdnimg.cn/release/blog_editor_html/release2.1.3/ckeditor/plugins/CsdnLink/icons/icon-default.png?t=M4AD"><br>https://www.liaoxuefeng.com/wiki/1016959663602400/1017318207388128</a><a href="https://www.geeksforgeeks.org/generators-in-python/">Generators in Python - GeeksforGeeks<br><img src="https://csdnimg.cn/release/blog_editor_html/release2.1.3/ckeditor/plugins/CsdnLink/icons/icon-default.png?t=M4AD"><br>https://www.geeksforgeeks.org/generators-in-python/</a></p><h2 id="字符串是不可变类型"><a href="#字符串是不可变类型" class="headerlink" title="字符串是不可变类型"></a>字符串是不可变类型</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token punctuation">(</span><span class="token string">'ab'</span><span class="token punctuation">,</span> <span class="token string">'cd'</span><span class="token punctuation">,</span> <span class="token string">'efcdgh'</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> x<span class="token operator">=</span><span class="token string">'abcd'</span><span class="token operator">>></span><span class="token operator">></span> a<span class="token operator">=</span>x<span class="token punctuation">.</span>upper<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> x<span class="token string">'abcd'</span><span class="token operator">>></span><span class="token operator">></span> a<span class="token string">'ABCD'</span><span class="token operator">>></span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> </p>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PAT_(Basic_Level)_Practice_（中文）1054_求平均值</title>
      <link href="/2023/06/20/patbasiclevelpractice-zhong-wen-1054-qiu-ping-jun-zhi/"/>
      <url>/2023/06/20/patbasiclevelpractice-zhong-wen-1054-qiu-ping-jun-zhi/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="PAT-Basic-Level-Practice-（中文）1054-求平均值"><a href="#PAT-Basic-Level-Practice-（中文）1054-求平均值" class="headerlink" title="PAT (Basic Level) Practice （中文）1054 求平均值"></a>PAT (Basic Level) Practice （中文）1054 求平均值</h1><p>分数 20</p><h3 id="题目简介："><a href="#题目简介：" class="headerlink" title="题目简介："></a>题目简介：</h3><p>本题的基本要求非常简单：给定 N 个实数，计算它们的平均值。但复杂的是有些输入数据可能是非法的。一个“合法”的输入是 [−1000,1000] 区间内的实数，并且最多精确到小数点后 2 位。当你计算平均值的时候，不能把那些非法的数据算在内。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入第一行给出正整数 N（≤100）。随后一行给出 N 个实数，数字间以一个空格分隔。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>对每个非法输入，在一行中输出 <code>ERROR: X is not a legal number</code>，其中 <code>X</code> 是输入。最后在一行中输出结果：<code>The average of K numbers is Y</code>，其中 <code>K</code> 是合法输入的个数，<code>Y</code> 是它们的平均值，精确到小数点后 2 位。如果平均值无法计算，则用 <code>Undefined</code> 替换 <code>Y</code>。如果 <code>K</code> 为 1，则输出 <code>The average of 1 number is Y</code>。</p><h3 id="输入样例-1："><a href="#输入样例-1：" class="headerlink" title="输入样例 1："></a>输入样例 1：</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">7</span><span class="token number">5</span> <span class="token parameter variable">-3.2</span> aaa <span class="token number">9999</span> <span class="token number">2.3</span>.4 <span class="token number">7.123</span> <span class="token number">2.35</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="输出样例-1："><a href="#输出样例-1：" class="headerlink" title="输出样例 1："></a>输出样例 1：</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ERROR: aaa is not a legal numberERROR: <span class="token number">9999</span> is not a legal numberERROR: <span class="token number">2.3</span>.4 is not a legal numberERROR: <span class="token number">7.123</span> is not a legal numberThe average of <span class="token number">3</span> numbers is <span class="token number">1.38</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="输入样例-2："><a href="#输入样例-2：" class="headerlink" title="输入样例 2："></a>输入样例 2：</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">2</span>aaa <span class="token parameter variable">-9999</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="输出样例-2："><a href="#输出样例-2：" class="headerlink" title="输出样例 2："></a>输出样例 2：</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ERROR: aaa is not a legal numberERROR: <span class="token parameter variable">-9999</span> is not a legal numberThe average of <span class="token number">0</span> numbers is Undefined<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>代码长度限制        16 KB；时间限制        400 ms；内存限制        64 MB；</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstdio></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> n<span class="token punctuation">,</span> cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> a<span class="token punctuation">[</span><span class="token number">50</span><span class="token punctuation">]</span><span class="token punctuation">,</span> b<span class="token punctuation">[</span><span class="token number">50</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">double</span> temp <span class="token operator">=</span> <span class="token number">0.0</span><span class="token punctuation">,</span> sum <span class="token operator">=</span> <span class="token number">0.0</span><span class="token punctuation">;</span>    cin <span class="token operator">>></span> n<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">sscanf</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> <span class="token string">"%lf"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>temp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//从a读出，并以%lf的格式转为int类型，a->temp。</span>        <span class="token function">sprintf</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span> <span class="token string">"%.2f"</span><span class="token punctuation">,</span>temp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//将temp保留两位小数后输出到b中，而不是控制台。</span>        <span class="token keyword">int</span> flag <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token function">strlen</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">!=</span> b<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> flag <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//看看a是不是两位小数以内</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>flag <span class="token operator">||</span> temp <span class="token operator">&lt;</span> <span class="token operator">-</span><span class="token number">1000</span> <span class="token operator">||</span> temp <span class="token operator">></span> <span class="token number">1000</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"ERROR: %s is not a legal number\n"</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">continue</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            sum <span class="token operator">+=</span> temp<span class="token punctuation">;</span>            cnt<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>cnt <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"The average of 1 number is %.2f"</span><span class="token punctuation">,</span> sum<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>cnt <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"The average of %d numbers is %.2f"</span><span class="token punctuation">,</span> cnt<span class="token punctuation">,</span> sum <span class="token operator">/</span> cnt<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"The average of 0 numbers is Undefined"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="分析：使用sprintf和sscanf函数"><a href="#分析：使用sprintf和sscanf函数" class="headerlink" title="分析：使用sprintf和sscanf函数~"></a>分析：使用sprintf和sscanf函数~</h3><p>char str[128];</p><p>int num &#x3D; -150;</p><p>int num2;</p><p>&#x2F;&#x2F;数字转字符串，和printf的区别是不输出到屏幕上，而是输出到字符串里</p><p>sprintf(str, “%d”, num);</p><p>&#x2F;&#x2F;字符串转数字，和scanf的区别是不从键盘读，而是从字符串里读</p><p>sscanf(str, “%d”, &amp;num2);</p>]]></content>
      
      
      
        <tags>
            
            <tag> 法学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PAT_(Basic_Level)_Practice_（中文）1028_人口普查</title>
      <link href="/2023/06/20/patbasiclevelpractice-zhong-wen-1028-ren-kou-pu-cha/"/>
      <url>/2023/06/20/patbasiclevelpractice-zhong-wen-1028-ren-kou-pu-cha/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="PAT-Basic-Level-Practice-（中文）1028-人口普查-分数-20"><a href="#PAT-Basic-Level-Practice-（中文）1028-人口普查-分数-20" class="headerlink" title="PAT (Basic Level) Practice （中文）1028 人口普查        分数 20"></a>PAT (Basic Level) Practice （中文）1028 人口普查        分数 20</h2><h3 id="题目简介："><a href="#题目简介：" class="headerlink" title="题目简介："></a>题目简介：</h3><p>某城镇进行人口普查，得到了全体居民的生日。现请你写个程序，找出镇上最年长和最年轻的人。这里确保每个输入的日期都是合法的，但不一定是合理的——假设已知镇上没有超过 200 岁的老人，而今天是 2014 年 9 月 6 日，所以超过 200 岁的生日和未出生的生日都是不合理的，应该被过滤掉。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在第一行给出正整数 N，取值在(0,105]；随后 N 行，每行给出 1 个人的姓名（由不超过 5 个英文字母组成的字符串）、以及按 <code>yyyy/mm/dd</code>（即年&#x2F;月&#x2F;日）格式给出的生日。题目保证最年长和最年轻的人没有并列。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>在一行中顺序输出有效生日的个数、最年长人和最年轻人的姓名，其间以空格分隔。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">5</span>John <span class="token number">2001</span>/05/12Tom <span class="token number">1814</span>/09/06Ann <span class="token number">2121</span>/01/30James <span class="token number">1814</span>/09/05Steve <span class="token number">1967</span>/11/20<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">3</span> Tom John<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>代码长度限制        16 KB；        时间限制        200 ms；内存限制        64 MB。</p><h3 id="解析："><a href="#解析：" class="headerlink" title="解析："></a>解析：</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstdlib></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;algorithm></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">peo</span><span class="token punctuation">&#123;</span>    string name<span class="token punctuation">;</span>    <span class="token keyword">int</span> year<span class="token punctuation">;</span>    <span class="token keyword">int</span> month<span class="token punctuation">;</span>    <span class="token keyword">int</span> day<span class="token punctuation">;</span>    <span class="token function">peo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span>    <span class="token function">name</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">year</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">month</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">day</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token function">peo</span><span class="token punctuation">(</span>string _name<span class="token punctuation">,</span> <span class="token keyword">int</span> _year<span class="token punctuation">,</span> <span class="token keyword">int</span> _month<span class="token punctuation">,</span> <span class="token keyword">int</span> _day<span class="token punctuation">)</span><span class="token operator">:</span>    <span class="token function">name</span><span class="token punctuation">(</span>_name<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">year</span><span class="token punctuation">(</span>_year<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">month</span><span class="token punctuation">(</span>_month<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">day</span><span class="token punctuation">(</span>_day<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">bool</span> <span class="token function">cmp</span><span class="token punctuation">(</span>peo p1<span class="token punctuation">,</span> peo p2<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>p1<span class="token punctuation">.</span>year<span class="token operator">!=</span>p2<span class="token punctuation">.</span>year<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> p1<span class="token punctuation">.</span>year<span class="token operator">&lt;</span>p2<span class="token punctuation">.</span>year<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>p1<span class="token punctuation">.</span>month<span class="token operator">!=</span>p2<span class="token punctuation">.</span>month<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> p1<span class="token punctuation">.</span>month<span class="token operator">&lt;</span>p2<span class="token punctuation">.</span>month<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>p1<span class="token punctuation">.</span>day<span class="token operator">!=</span>p2<span class="token punctuation">.</span>day<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> p1<span class="token punctuation">.</span>day<span class="token operator">&lt;</span>p2<span class="token punctuation">.</span>day<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> n<span class="token punctuation">;</span>    cin<span class="token operator">>></span>n<span class="token punctuation">;</span>    vector<span class="token operator">&lt;</span>peo<span class="token operator">></span> v<span class="token punctuation">;</span><span class="token comment">//如果想使用v(n)来初始化大小，必须自己定义默认构造函数</span>    <span class="token comment">//我不知到为什么使用vector&lt;peo> v(n)初始化之后，输出的v[0].name是几个空格，而且v.size()是3，没有变大</span>    peo <span class="token function">max</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">,</span> <span class="token number">2014</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//最大日期</span>    peo <span class="token function">min</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">,</span> <span class="token number">1814</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//最小日期</span>    string name<span class="token punctuation">,</span> bir<span class="token punctuation">;</span>    <span class="token keyword">int</span> sum<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//     peo p2("max", 2014, 9, 7);</span><span class="token comment">//     peo p3("min", 1814, 9, 5);</span><span class="token comment">//     cout&lt;&lt;cmp(p2, max)&lt;&lt;" "&lt;&lt;cmp(min, p3)&lt;&lt;endl;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        cin<span class="token operator">>></span>name<span class="token operator">>></span>bir<span class="token punctuation">;</span>        <span class="token keyword">int</span> y<span class="token operator">=</span><span class="token function">strtod</span><span class="token punctuation">(</span>bir<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> m<span class="token operator">=</span><span class="token function">strtod</span><span class="token punctuation">(</span>bir<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> d<span class="token operator">=</span><span class="token function">strtod</span><span class="token punctuation">(</span>bir<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        peo <span class="token function">p1</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> y<span class="token punctuation">,</span> m<span class="token punctuation">,</span> d<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">cmp</span><span class="token punctuation">(</span>p1<span class="token punctuation">,</span> max<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">cmp</span><span class="token punctuation">(</span>min<span class="token punctuation">,</span> p1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//处在最大，最小之间。</span>            v<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>p1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//自动扩容</span>            sum<span class="token operator">++</span><span class="token punctuation">;</span><span class="token comment">//记录总数</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">sort</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> v<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> cmp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//自定义排序</span><span class="token comment">//     for(int i=0; i&lt;v.size(); i++)&#123;</span><span class="token comment">//         cout&lt;&lt;v[i].name&lt;&lt;" ";</span><span class="token comment">//     &#125;</span><span class="token comment">//     cout&lt;&lt;endl;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>v<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">//注意v的size，否则引发段错误，意思就是非法访问了内存。</span>        cout<span class="token operator">&lt;&lt;</span>sum<span class="token operator">&lt;&lt;</span><span class="token string">" "</span><span class="token operator">&lt;&lt;</span>v<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>name<span class="token operator">&lt;&lt;</span><span class="token string">" "</span><span class="token operator">&lt;&lt;</span>v<span class="token punctuation">[</span>v<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>name<span class="token punctuation">;</span>    <span class="token keyword">else</span><span class="token punctuation">&#123;</span>        cout<span class="token operator">&lt;&lt;</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Oracle数据库的基础</title>
      <link href="/2023/06/20/oracle-shu-ju-ku-de-ji-chu/"/>
      <url>/2023/06/20/oracle-shu-ju-ku-de-ji-chu/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p><strong>目录</strong></p><p><a href="#%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9%C2%A0">小知识点 </a></p><p><a href="#1%E3%80%81dec">1、dec</a></p><p><a href="#2%E3%80%81nvl">2、nvl</a></p><p><a href="#3%E3%80%81minus">3、minus</a></p><p><a href="#4%E3%80%81%E8%BF%9E%E6%8E%A5join">4、连接join</a></p><p><a href="#5%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E8%8C%83%E5%BC%8F">5、数据库设计范式</a></p><p><a href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E7%AC%AC%E4%B8%80%E8%8C%83%E5%BC%8F%EF%BC%9A%EF%BC%88%E8%AE%BE%E8%AE%A1%E5%87%BA%E6%B2%A1%E6%9C%89%E6%95%B0%E6%8D%AE%E5%86%97%E4%BD%99%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%B4%E6%8A%A4%E5%BC%82%E5%B8%B8%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BB%93%E6%9E%84%EF%BC%89">数据库设计第一范式：（设计出没有数据冗余和数据维护异常的数据库结构）</a></p><p><a href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E7%AC%AC%E4%BA%8C%E8%8C%83%E5%BC%8F%EF%BC%9A">数据库设计第二范式：</a></p><p><a href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E7%AC%AC%E4%B8%89%E8%8C%83%E5%BC%8F%EF%BC%9A">数据库设计第三范式：</a></p><p><a href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A6%82%E5%BF%B5">数据库概念</a></p><p><a href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C%E8%AF%AD%E8%A8%80">数据库操作语言</a></p><p><a href="#%C2%A0%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"> 关系的基本概念</a></p><p><a href="#%E5%AE%9E%E4%BD%93%E5%AE%8C%E6%95%B4%E6%80%A7">实体完整性</a></p><p><a href="#%E5%8F%82%E7%85%A7%E5%AE%8C%E6%95%B4%E6%80%A7%EF%BC%9A%EF%BC%88foreign%20key%EF%BC%89%E5%8F%AF%E4%BB%A5%E6%98%AF%E7%A9%BA%E5%80%BC%EF%BC%8C">参照完整性：（foreign key）可以是空值，</a></p><p><a href="#%E4%B8%80%E4%BA%9B%E5%87%BD%E6%95%B0%E6%8E%A7%E5%88%B6%E5%AD%97%E7%AC%A6">一些函数控制字符</a></p><p><a href="#dual%C2%A0">dual </a></p><p><a href="#desc%E5%85%B3%E9%94%AE%E5%AD%97">desc关键字</a></p><p><a href="#having%E5%92%8C%20where%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9A">having和 where的区别：</a></p><p><a href="#2022%203-9">2022 3-9</a></p><p><a href="#%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%9A">小知识点：</a></p><p><a href="#2022-3-19%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%9E%E9%AA%8C%E5%BF%83%E5%BE%97">2022-3-19数据库实验心得</a></p><p><a href="#%E8%A7%86%E5%9B%BE">视图</a></p><p><a href="#%E8%81%94%E7%BB%93%E8%A1%A8">联结表</a></p><p><a href="#%E8%87%AA%E7%84%B6%E8%BF%9E%E6%8E%A5%E4%B8%8E%E7%AD%89%E5%80%BC%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9A">自然连接与等值连接的区别：</a></p><p><a href="#ANY%20ALL">ANY ALL</a></p><p><a href="#2022-%E5%AE%9E%E9%AA%8C%E4%B8%89%E6%80%BB%E7%BB%93">2022-实验三总结</a></p><p><a href="#2022-3-30">2022-3-30</a></p><p><a href="#PL/SQL:">PL&#x2F;SQL:</a></p><p><a href="#select%20%E9%80%89%E6%8B%A9%E4%BA%86%E4%B8%80%E4%BA%9B%E5%88%97%E4%B9%8B%E5%90%8E%EF%BC%8C%E5%A6%82%E6%9E%9C%E9%87%8C%E9%9D%A2%E6%9C%89%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0%EF%BC%8C%E5%90%8E%E9%9D%A2%E4%B8%80%E5%AE%9A%E8%A6%81%E6%9C%89group%E5%87%BD%E6%95%B0%E5%90%A6%E5%88%99%E4%BC%9A%E6%8A%A5%E9%94%99%EF%BC%8C%E5%8E%9F%E5%9B%A0%E5%A6%82%E4%B8%8B%EF%BC%9A">select 选择了一些列之后，如果里面有聚合函数，后面一定要有group函数否则会报错，原因如下：</a></p><p><a href="#2022-4-2%E5%AE%9E%E9%AA%8C%E5%9B%9B%E6%80%BB%E7%BB%93">2022-4-2实验四总结</a></p><p><a href="#%E7%B4%A2%E5%BC%95%EF%BC%8C%E8%8C%83%E5%BC%8F%E5%92%8C%E9%94%81">索引，范式和锁</a></p><p><a href="#%E5%88%9B%E5%BB%BA%E5%87%BD%E6%95%B0%E3%80%81%E8%BF%87%E7%A8%8B">创建函数、过程</a></p><p><a href="#dbms_output.put_line%E7%9A%84%E7%94%A8%E6%B3%95">dbms_output.put_line的用法</a></p><p><a href="#E-R%E5%9B%BE%E8%BD%AC%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%BC%8F">E-R图转关系模式</a></p><h1 id="小知识点"><a href="#小知识点" class="headerlink" title="小知识点"></a>小知识点</h1><h2 id="1、dec"><a href="#1、dec" class="headerlink" title="1、dec"></a>1、dec</h2><p>Oracle 数据类型：decimal | dec (presicion，scale) p是精度，代表有效位数，scale表示小数部分的范围，比如dec(8, 2)代表8位整数部分，2位小数部分。</p><h2 id="2、nvl"><a href="#2、nvl" class="headerlink" title="2、nvl"></a>2、nvl</h2><p>语法</p><p>NVL(eExpression1, eExpression2)</p><p>从两个表达式返回一个非 null 值。</p><p>参数</p><p>eExpression1, eExpression2</p><p>如果 eExpression1 的计算结果为 null 值，则eExpression2。如果 eExpression1 的计算结果不是 null 值，则返回 eExpression1。eExpression1 和 eExpression2 可以是任意一种数据类型。如果 eExpression1 与 eExpression2 的结果皆为 null 值，则 NVL( ) 返回 .NULL.</p><h2 id="3、minus"><a href="#3、minus" class="headerlink" title="3、minus"></a>3、minus</h2><p>“minus”直接翻译为中文是“减”的意思，在Oracle中也是用来做减法操作的，只不过它不是传统意义上对数字的减法，而是对查询结果集的减法。 A minus B就意味着将结果集A去除结果集B中所包含的所有记录后的结果，即在A中存在，而在B中不存在的记录。</p><h2 id="4、连接join"><a href="#4、连接join" class="headerlink" title="4、连接join"></a>4、连接join</h2><p><a href="https://blog.csdn.net/lightningmn/article/details/52805457">各种join的详细简单的解释</a></p><h2 id="5、数据库设计范式"><a href="#5、数据库设计范式" class="headerlink" title="5、数据库设计范式"></a>5、数据库设计范式</h2><h3 id="数据库设计第一范式：（设计出没有数据冗余和数据维护异常的数据库结构）"><a href="#数据库设计第一范式：（设计出没有数据冗余和数据维护异常的数据库结构）" class="headerlink" title="数据库设计第一范式：（设计出没有数据冗余和数据维护异常的数据库结构）"></a>数据库设计第一范式：（设计出没有数据冗余和数据维护异常的数据库结构）</h3><p>1、数据库表中的所有字段都只具有单一属性</p><p>2、单一属性的列是由基本的数据类型所构成的</p><p>3、设计出来的表都是简单的二维表</p><h3 id="数据库设计第二范式："><a href="#数据库设计第二范式：" class="headerlink" title="数据库设计第二范式："></a>数据库设计第二范式：</h3><p>要求一个表中只具有一个业务主键，也就是说符合第二范式的表中不能存在非主键列对只对部分主键的依赖关系</p><h3 id="数据库设计第三范式："><a href="#数据库设计第三范式：" class="headerlink" title="数据库设计第三范式："></a>数据库设计第三范式：</h3><p>指每一个非主属性既不部分依赖于也不传递依赖于业务主键，也就是在第二范式的基础上消除了非主键属性对主键的传递依赖</p><h1 id="数据库概念"><a href="#数据库概念" class="headerlink" title="数据库概念"></a>数据库概念</h1><p>长期储存在计算机内，有组织，可共享的大量数据的集合，就是数据库</p><p>数据库管理系统，（DBMS，databace mangement system），用于创建操作和管理数据库的应用程序</p><p>:xx,dnmcg2IR</p><p>数据库用来管理数据，QQ为什么能这么厉害，就是因为他有很多数据，这些数据是商业机密，使用数据库存储数据占用存储空间小，并且查询数据快Alter TABLE XS ADD ENG CHAR(20); –添加新的列</p><p><img src="https://img-blog.csdnimg.cn/15e4006db5584c11b08101a50cb98bfa.png"></p><h1 id="数据库操作语言"><a href="#数据库操作语言" class="headerlink" title="数据库操作语言"></a>数据库操作语言</h1><p><img src="https://img-blog.csdnimg.cn/09d8361536ab4cb38ed17e0299698244.png"></p><p><img src="https://img-blog.csdnimg.cn/33e3ef2a636d4fb58cf0b625aa5bd9c7.png"></p><h1 id="关系的基本概念"><a href="#关系的基本概念" class="headerlink" title="关系的基本概念"></a>关系的基本概念</h1><p><img src="https://img-blog.csdnimg.cn/c2df04e0503c423aa999b03861a20362.png"></p><p><img src="https://img-blog.csdnimg.cn/039fd6a233844267a107fa07024aa4f0.png"></p><p><img src="https://img-blog.csdnimg.cn/ea7ac41a57374271a169b6adfd48f5bd.png"></p><p>自己的某一个属性（或属性集合）在其他表中是主码，则在自己表中这个属性（或属性集合）是外码</p><h1 id="实体完整性"><a href="#实体完整性" class="headerlink" title="实体完整性"></a>实体完整性</h1><p>实体完整性：（primary key）不能是空值，不能重复</p><p><img src="https://img-blog.csdnimg.cn/8302813b572c481b801a2869363a4d4a.png"></p><h1 id="参照完整性：（foreign-key）可以是空值，"><a href="#参照完整性：（foreign-key）可以是空值，" class="headerlink" title="参照完整性：（foreign key）可以是空值，"></a>参照完整性：（foreign key）可以是空值，</h1><p><img src="https://img-blog.csdnimg.cn/8fdabac448584a039ed135d6eba7c81f.png"></p><p><img src="https://img-blog.csdnimg.cn/dff81e2cc37748e188ed3ebf4ffd7cf2.png"></p><p>select id)</p><p>from xs</p><p>where to_char(birthday,’yyyy-mm-dd’) &#x3D;’2002-06-28’;</p><p>将日期转化成char类型</p><h1 id="一些函数控制字符"><a href="#一些函数控制字符" class="headerlink" title="一些函数控制字符"></a>一些函数控制字符</h1><p><img src="https://img-blog.csdnimg.cn/fb0f9125543d4da5bc2b768a0e552eb9.png"></p><h1 id="dual"><a href="#dual" class="headerlink" title="dual"></a>dual</h1><p><img src="https://img-blog.csdnimg.cn/94b6e9c83d014a889e77de691d9e3670.png"></p><p>dual是一个一行一列的虚拟表，常用来计算表达式</p><p><img src="https://img-blog.csdnimg.cn/038b7d1d14df47278f4c8e2a3ca2eb5f.png"></p><h1 id="desc关键字"><a href="#desc关键字" class="headerlink" title="desc关键字"></a>desc关键字</h1><p>desc 查看表的结构，</p><p><img src="https://img-blog.csdnimg.cn/fafe7f4917d545d58157d142942bda99.png"></p><p>Alter TABLE XS ADD ENG CHAR(20); –添加新的列</p><p>UPDATE XS SET ENG&#x3D;’ENGLISH’ WHERE DEPT&#x3D;’计算机’;将dept&#x3D;计算机的ENG改为‘english’ SELECT SNAME, LOWER(ENG) AS LOW_ENG–将eng属性改为小写，重新命名成LOW_ENG,函数LOWER</p><p>FROM XS WHERE DEPT&#x3D;’计算机’;</p><p>commit; –&gt;提交数据</p><p>  rollback; –&gt;回滚数据</p><p>select * from user_tables;–查询用户下的所有表</p><h1 id="having和-where的区别："><a href="#having和-where的区别：" class="headerlink" title="having和 where的区别："></a>having和 where的区别：</h1><p>where在数据分组前进行过滤，having在数据分组过后进行过滤，</p><p>使用having时应该结合Group by语句，where 用于标准的行级过滤</p><h1 id="2022-3-9"><a href="#2022-3-9" class="headerlink" title="2022 3-9"></a>2022 3-9</h1><pre class="line-numbers language-none"><code class="language-none">--2022 3-9create table stu(SNO CHAR(6) PRIMARY KEY,SNAME VARCHAR2(10) UNIQUE,DEPT VARCHAR2(20) NOT NULL,SEX VARCHAR2(4) DEFAULT(&#39;男&#39;),TOTALCREDIT NUMBER(3, 0) CHECK(TOTALCREDIT&gt;&#x3D;0));insert into stu values (&#39;100001&#39;,&#39;hzy&#39;, &#39;jsj&#39;, &#39;女&#39;, &#39;100&#39;);insert into stu values (&#39;100001&#39;,&#39;hzz&#39;, &#39;jsj&#39;, &#39;女&#39;, &#39;100&#39;);insert into stu(sno,dept) values(&#39;111&#39;,&#39;rjgc&#39;);select * from stu;update stu set sname&#x3D;&#39;hjj&#39; where sno&#x3D;&#39;111&#39;;select * from stu;alter table stu modify sname varchar2(20);alter table stu modify sno char(10);alter table stu add nativeplace varchar2(20);alter table stu drop column nativeplace;alter table stu drop CONSTRAINT SYS_c007069;alter table stu add constraint stu_sname_unique unique(sname);create table stu1asselect * from stu;drop table stu1;insert into stu values(&#39;100002&#39;, &#39;张三&#39;,  &#39;计算机&#39;,&#39;男&#39;, &#39;10&#39;);--INSERT INTO stu(sno, )update stuset sex&#x3D;sex+10;update stuset dept&#x3D;&#39;软件工程&#39;where sname&#x3D;&#39;张三&#39;;delete from stuwhere TOTALCREDIT is null;commit;rollback;select * from xs;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/fa5a15a3bf3b4f3b81e3065b1f7c73f2.png"></p><h1 id="小知识点："><a href="#小知识点：" class="headerlink" title="小知识点："></a>小知识点：</h1><p>利用已有数据表建立一个新表，但不复制数据:</p><p>create TABLE S1</p><p>AS</p><p>SELECT * FROM STUDENT WHERE 1&#x3D;0;</p><p><img src="https://img-blog.csdnimg.cn/4f2d9b6cd537477d862f33a6a762ab1a.png"></p><p>UPDATE STU SET TOTALCREDIT&#x3D;NVL(TOTALCREDIT, 0)+2;</p><p>NVL(TOTALCREDIT, 0):如果totalcredit不是空，就用原来的值，是空，就用0来代替；</p><p>FROM ZLGC WHERE CATEGORY&#x3D;’课程思政示范课程’ AND COUNT(CATEGORY)&gt;50 GROUP BY SCHOOL,CATEGORY ORDER BY COUNT(CATEGORY) DESC</p><p>ERROR: ORA-00934: 此处不允许使用分组函数</p><p><img src="https://img-blog.csdnimg.cn/682e669c3da14131afbd5fbd801f7673.png"></p><p>要使用having 来过滤分组</p><h1 id="2022-3-19数据库实验心得"><a href="#2022-3-19数据库实验心得" class="headerlink" title="2022-3-19数据库实验心得"></a>2022-3-19数据库实验心得</h1><p>在本次实验中，我遇到的问题首先是1-1题目中extract函数的使用，通过从网上查询知道了，我学习到该函数的作用是将年份从date中分离出来单独计算从而得到年龄，第二个问题是2-4题目中过滤学生人数小于3的的语句，不能在group by 语句前面加where来过滤，如果使用了，错误信息是这样的，</p><p><img src="https://img-blog.csdnimg.cn/2bc12af0dac646d285de4421a091a22e.png"></p><p>查阅资料后学习到了，有group by 语句时where中不能使用聚合函数来过滤数据，此时只能使用having语句，并且having语句只能跟在group by 语句后面。这两个问题是我在本次实验中遇到的最大的难题，解决了之后，真的学习到了很多。</p><p>在本次实验中，我首先在创建user用户时就遇到了，用户名或角色名是不存在的问题，然后我先想着改一下用户名为users，结果成功了，后来才从老师那里得知是用户过期了的原因，要重新编辑用户信息才可以。</p><p>然后我在1-4题目中遇到了对设置组合主键，外键操作的不熟练问题，还有就是对于alter table tablename add colname VARCHAR(20)（添加列）;alter table tablename drop column colname（删除列）;alter table tablename drop constraint SYS_C007120;（去除限制）add constraint UQ_CNAME UNIQUE(CNAME)（添加限制）;这几个操作的不熟练，最后遇到的问题是赋值一表的结构到一个新表（不复制数据），从网上查阅资料后，知道了</p><p>最关键的一步是：SELECT * FROM STUDENT WHERE 1&#x3D;0;设置一个不可能的条件，选择之后，就不会剩下数据了。解决了这些问题后，有很大的收获。</p><h1 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h1><p>里面存储的是SQL语句，不是查询结果</p><p>创建视图后不显示结果，要通过select语句来查询</p><p><img src="https://img-blog.csdnimg.cn/9293cda35f98419d99478094baa9258e.png"></p><p><img src="https://img-blog.csdnimg.cn/91378483b1f242bdb11607af8c751e13.png"></p><p>视图的作用：简化查询语句</p><p><img src="https://img-blog.csdnimg.cn/144c129584974adb8aafe47ccc35adff.png"></p><p>有些视图可以更新，有些不可以</p><p>SELECT * FROM A NATURAL JOIN B WHERE B.B &#x3D; A.B;</p><p><img src="https://img-blog.csdnimg.cn/92bb37464bbb4673a0be9fbc733367b5.png"></p><h1 id="联结表"><a href="#联结表" class="headerlink" title="联结表"></a>联结表</h1><p>sql的left join 、right join 、inner join之间的区别</p><p>　　left join(左联接) 返回包括左表中的所有记录和右表中联结字段相等的记录 </p><p>　　right join(右联接) 返回包括右表中的所有记录和左表中联结字段相等的记录</p><p>　　inner join(等值连接) 只返回两个表中联结字段相等的行</p><pre class="line-numbers language-none"><code class="language-none">左连接SELECT *FROM student  # 主表（不会受到影响）LEFT JOIN score  # 辅表（只有满足条件的才会显示）ON student.ID &#x3D; score.SID右连接SELECT *FROM student  # 主表（只有满足条件的才会显示）RIGHT JOIN score  # 辅表（不会受到影响）ON student.ID &#x3D; score.SID全连接（是个笛卡尔积？）SELECT *FROM studentFULL JOIN scoreselect sname, cname, tname, grade--自连接  ：只返回两张表连接列的匹配项。--以下三种查询结果一样。select * from student s inner join class c on s.classid&#x3D;c.id; select * from student s join class c on s.classid&#x3D;c.id;select * from student s,class c where s.classid&#x3D;c.id;--笛卡儿乘积连接 ：即不加任何条件，达到 M*N 的结果集。--以下两种查询结果一样。select * from student s cross join class c;select * from student,class;--加上条件，产生跟自连接一样的结果。select * from student s cross join class c where s.classid&#x3D;c.id;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>自然连接要注意：</p><p>SELECT * FROM A NATURAL JOIN B WHERE B.B &#x3D; A.B;</p><p>SELECT * FROM A NATURAL JOIN B on B.B &#x3D; A.B;</p><p>这两种方法都会报错，不能有限制条件。因为自然连接它自动的进行了等值比较，所以不需要加上限制条件让他们的连接起来，自然连接是一种特殊的等值连接。</p><p><img src="https://img-blog.csdnimg.cn/17a828df928a41c88f0cf77da8c419ed.png"></p><h1 id="自然连接与等值连接的区别："><a href="#自然连接与等值连接的区别：" class="headerlink" title="自然连接与等值连接的区别："></a>自然连接与等值连接的区别：</h1><p><a href="https://zhidao.baidu.com/question/429546959.html">sql server 等值连接和自然连接的 用法_百度知道 (baidu.com)</a></p><p>SELECT * FROM A, B WHERE A.B&#x3D;B.B;</p><p>这是等值连接，相同的属性列会保存</p><p>自然连接是一种特殊的等值内连接，它是由系统根据两表的同名字段自动作等值比较的内连接，不需要用ON关键字指定连接条件</p><p><img src="https://img-blog.csdnimg.cn/f05ca09c4af44eac8406ba1c77d55cbf.png"></p><p>SELECT * FROM A NATURAL JOIN B ;</p><p>这是自然连接，自然连接是一种将相同属性列删除的等值连接</p><p><img src="https://img-blog.csdnimg.cn/05a3412b170c479cb9d6558842859bd2.png"></p><p>自然连接四个表 </p><pre class="line-numbers language-none"><code class="language-none">FROM STUDENT NATURAL JOIN SCORE NATURAL JOIN COURSE NATURAL JOIN TEACH WHERE COURSE.CNAME&#x3D;&#39;数学分析&#39; and TEACH.TNAME&#x3D;&#39;严敏&#39;;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="ANY-ALL"><a href="#ANY-ALL" class="headerlink" title="ANY ALL"></a>ANY ALL</h1><p><img src="https://img-blog.csdnimg.cn/4f1fe1ece8444b5caf81e7aca6e9244e.png"></p><p><a href="https://blog.csdn.net/zl111_1/article/details/54980639">ANY ALL的区别</a></p><p>总结成一句话就是：all 是满足所有的， and and and；any 是满足其中一个就可以，or or or</p><h1 id="2022-实验三总结"><a href="#2022-实验三总结" class="headerlink" title="2022-实验三总结"></a>2022-实验三总结</h1><p>在这次实验过程中遇到的问题就很多了，首先第一题就来了一个下马威，分不清三种连接的区别，搞得无从下手，最后自己弄了两个表才弄懂了前两个的区别，如下图：等值连接相同的属性会保留，而自然连接就会将它们合并，自然连接是一种特殊的等值连接，终于理解了，自己找了几个小时。还有一个就是join后面总是忘掉加上on条件，报了三四次缺少关键字错误才发现，我学会了，做这种题目时要首先弄清楚概念就很好下手了。然后就是left join 、right join、full join ，区分这几个，首先区分：主表（不会受到影响）， 辅表（只有满足条件的才会显示），left join 左为主表，右辅表；right join 则相反，最后的not exists的双重否定，更是搞得稀里糊涂，现在还是有点不明白。每一次实验都是一次不错的成长。</p><p>数据放到表中，表再放到库中</p><p>表中的列相当于类中的属性， 每一行相当于对象</p><p><img src="https://img-blog.csdnimg.cn/8be32587e3dc49f88d283b41c11d4537.png"></p><p>‘%’会过滤掉空值：</p><p>SELECT * FROM XS;</p><p>SELECT * FROM XS WHERE REMARKS LIKE ‘%’;</p><h1 id="2022-3-30"><a href="#2022-3-30" class="headerlink" title="2022-3-30"></a>2022-3-30</h1><pre class="line-numbers language-none"><code class="language-none">--2022-3-30create index idx_xs_sname on xs(sname);--索引只创建，不自己使用，由系统调用select * FROM XS WHERE SNAME LIKE &#39;_%&#39;;--视图：安全（设置用户权限），简化使用，保存的是查询语句--视图(VIEW)也被称作虚表，即虚拟的表，是一组数据的逻辑表示,其本质是对应于一条SELECT语句，--结果集被赋予一个名字，即视图名字。视图本身并不包含任何数据，它只包含映射到基表的一个查询语句，--当基表数据发生变化，视图数据也随之变化。SELECT * FROM XS WHERE DEPT&#x3D;&#39;计算机&#39;;--创建视图--计算区分度SELECT count (DISTINCT(SNAME))&#x2F;count(*) FROM XS;--计算区分度--WITH CHECK OPTION 子句强制所有数据修改语句均根据视图执行，--以符合定义视图的 SELECT 语句中所设的条件。--WITH CHECK OPTION的作用?--1.对于update,有with check option，要保证update后，数据要被视图查询出来；--2.对于delete,有无with check option都一样；--4.对于insert,有with check option，要保证insert后，数据要被视图查询出来；--5.对于没有where 子句的视图，使用with check option是多余的。 SELECT *FROM XS;CREATE VIEW DEPT3ASSELECT *FROM XS WHERE TOTALCREDIT&gt;70 WITH CHECK OPTION;UPDATE DEPT3SET TOTALCREDIT&#x3D;60WHERE SNAME&#x3D;&#39;林一帆&#39;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="PL-x2F-SQL"><a href="#PL-x2F-SQL" class="headerlink" title="PL&#x2F;SQL:"></a>PL&#x2F;SQL:</h1><p>PL&#x2F;SQL也是一种程序语言，叫做过程化SQL语言（Procedural Language&#x2F;SQL）。PL&#x2F;SQL是Oracle数据库对SQL语句的扩展。在普通SQL语句的使用上增加了编程语言的特点，所以PL&#x2F;SQL就是把数据操作和查询语句组织在PL&#x2F;SQL代码的过程性单元中，通过逻辑判断、循环等操作实现复杂的功能或者计算的程序语言。PL&#x2F;SQL是Oracle对标准数据库语言SQL的过程化扩充，它将数据库技术和过程化程序设计语言联系起来（通俗的说，SQL与编程语言的混血儿），是一种应用开发语言，可使用循环，分支处理数据，将SQL的数据操纵功能与过程化语言数据处理功能结合起来.PL&#x2F;SQL的使用，使SQL成为一种高级程序设计语言，支持高级语言的块操作，条件判断，循环语句，嵌套等，与数据库核心的数据类型集成，使SQL 的程序设计效率更高.</p><h1 id="select-选择了一些列之后，如果里面有聚合函数，后面一定要有group函数否则会报错，原因如下："><a href="#select-选择了一些列之后，如果里面有聚合函数，后面一定要有group函数否则会报错，原因如下：" class="headerlink" title="select 选择了一些列之后，如果里面有聚合函数，后面一定要有group函数否则会报错，原因如下："></a>select 选择了一些列之后，如果里面有聚合函数，后面一定要有group函数否则会报错，原因如下：</h1><p>最近写SQL的时候，有遇到过报出 ORA-00937的问题。</p><p>解释：</p><p>select 列表项中除了包含聚合函数外，还包含了表的某些列，那么你将必须使用group by语句，否则语法通不过。</p><p>例如：</p><p>SQL&gt;</p><p>1 select deptno,job,avg(sal)</p><p>2 from emp</p><p>3 ;</p><p>ERROR 位于第 1 行:</p><p>ORA-00937: 非单组分组函数</p><p>其实这里也非常容易理解，你既然指定了聚合函数，又同时制定了其他列，还想不按照指定的列来分组，你到底想让oracle怎么做呢？</p><p>这根本就得不出结果。就像你需要统计班上男女生的人数，但是又不能分组，只能在一条数据里表示出来，怎么能办得到呢？</p><p>所以这里的group by是必须的。</p><p>上面的错误纠正为：</p><p>select deptno,job,avg(sal) from emp group by deptno,job;</p><p>就OK了</p><p>原文链接：<a href="https://blog.csdn.net/linwei_1029/article/details/5868082">聚合函数与列同时选择，需要Group</a></p><pre class="line-numbers language-none"><code class="language-none">create sequence table1_idminvalue 1             --自增字段最小值nomaxvalue           --最大值 没有就算nomaxvalueincrement by 1      --每次增值1start with 1           --起始值nocache;             --不缓存CREATE SEQUENCE TABLE_ID--创建顺序表MINVALUE 1--最小值NOMAXVALUE--无最大值INCREMENT BY 1--递增量START WITH 1--起始值NOCACHE;--无缓存--第三步：创建触发器create or replace trigger SCORE1triggerbefore insert on SCORE1 for each rowbeginselect table1_id.nextval into:new.sid from dual;end SCORE1trigger;Mysql中：create table UserTable (USERID INT(4) PRIMARY KEY AUTO_INCREMENT NOT NULL,UNAME VARCHAR(20) NOT NULL,UPASSWARD VARCHAR(20) NOT NULL)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="2022-4-2实验四总结"><a href="#2022-4-2实验四总结" class="headerlink" title="2022-4-2实验四总结"></a>2022-4-2实验四总结</h1><p> 在本次实验中，我首先遇到的问题是创建视图时，带上WITH CHECK OPTION选项与不带的区别：如果根据视图来更改数据，一定要符合创建视图的时候的where 的条件。第二个是创建两个字段的视图 grade_avg_view，select 选择了一些列之后，如果里面有聚合函数，后面一定要有group函数否则会报错。最后一个是设置自增型的主键，在mysql中使用AUTO_INCREMENT 可以直接创建，但是在Oracle中要先创建一个递增序列，然后再创建一个触发器才可以。</p><h1 id="索引，范式和锁"><a href="#索引，范式和锁" class="headerlink" title="索引，范式和锁"></a>索引，范式和锁</h1><p>索引：每个表如果设置了主键就会有有一个主键索引，在Mysql中，使用的时InnoDB引擎，每一个索引就是一颗B+树，也可以创建非主键索引，二级索引，二级索引和主键索引的不同之处在于其叶子节点上保存的值不一样，表中所有字段的值都被完整的保存在主键索引的叶子节点上，但是二级索引的叶子节点只保存对应主键的值。这里的叶子节点上只保存了主键的值，所以还需要通过获得的主键 ID 值再回到主键索引上查出所有字段的值，这个过程称作回表。</p><ul><li>数据库方面，能会基本的增删改查即可，外带一些基本概念，比如事务怎么处理，JDBC里批处理怎么处理。</li></ul><p><img src="https://img-blog.csdnimg.cn/10a6d9b39c07447986018076661b827f.png"></p><p>创建表时，凡是能通过计算出来的字段都不要把它当成属性列；</p><h1 id="创建函数、过程"><a href="#创建函数、过程" class="headerlink" title="创建函数、过程"></a>创建函数、过程</h1><p>存储过程不一定要有返回值，函数一定要有</p><p>注意存储过程in out inout 三种参数类型，而函数只有in</p><p> 创建函数：</p><pre class="line-numbers language-none"><code class="language-none">CREATE OR REPLACE FUNCTION COUNT_CREDIT(STUNO in VARCHAR2) RETURN NUMBERASCRED NUMBER:&#x3D;0;TOTAL_CRED NUMBER:&#x3D;0;BEGINFOR STUCUR IN(SELECT SNO, CNO, GRADE FROM cj WHERE SNO&#x3D;STUNO AND GRADE&gt;&#x3D;60) LOOPSELECT CREDIT INTO CRED FROM KC WHERE CNO&#x3D;STUCUR.CNO;TOTAL_CRED:&#x3D;TOTAL_CRED+CRED;END LOOP;RETURN TOTAL_CRED;END COUNT_CREDIT;作业create or replace function count_credit(stuno in varchar2) return varchar2as cred number:&#x3D;0;total_cred number:&#x3D;0;begin  for stucur in(select sno, cno, grade from score where sno&#x3D;stuno and grade &gt;60) loop    select credit into cred from course where cno&#x3D;stucur.cno;    total_cred:&#x3D;total_cred+cred;  end loop;  return total_cred;end count_credit;函数的执行：1、select COUNT_CREDIT(&#39;96001&#39;) as total_credit from dual;2、variable a number(10, 0)--声明变量begin:a:&#x3D;COUNT_CREDIT(&#39;96001&#39;);end;&#x2F;后面加上一句：print a;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>创建过程：</p><pre class="line-numbers language-none"><code class="language-none">create or replace procedure count_credi(stusno in varchar2 , creditj out number )--warning：in outascred number:&#x3D;0;total_cred number:&#x3D;0;beginfor cjcur in (select * from cj where sno&#x3D; stusno) loopselect credit into cred from kc where cno&#x3D;cjcur.cno;total_cred:&#x3D;total_cred+cred*cjcur.grade;end loop;creditj:&#x3D;total_cred&#x2F;count_credit(stusno);end count_credi;作业create or replace procedure pro_findname(tmpname in VARCHAR2) asbegin  for stucur in(select sno,sname from student where sname like tmpname ) loop   dbms_output.put_line(stucur.sno || &#39;&#39; ||stucur.sname);--   end loop;  null;end pro_findname;set serveroutput off1、set serveroutput onbegin  pro_findname(&#39;%马%&#39;);end;&#x2F;2、exec pro_findname(&#39;%马%&#39;);--注意这里的调用时使用%，而不是在存储过程中<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>触发器：</p><p>触发器的用法</p><p>触发器与存储过程和函数不同，函数和存储过程需要用户显示调用，触发器时在某个事件发生时，自动的隐式的完成，所以叫触发或者点火（firing）</p><pre class="line-numbers language-none"><code class="language-none">create or replace trigger sum_credit after insert on  scorefor each rowbegin  update student   set TOTALCREDIT&#x3D;TOTALCREDIT+(select credit from course where cno&#x3D;:new.cno)  where sno&#x3D;:new.sno and :new.grade&gt;60;  null;end;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>触发器的语法 </p><pre class="line-numbers language-none"><code class="language-none">create trigger &lt;触发器名称&gt;&#123; before | after&#125;          # 之前或者之后出发insert | update | delete   # 指明了激活触发程序的语句的类型on &lt;表名&gt;                   # 操作哪张表for each row  # 触发器的执行间隔，for each row--通知触发器每隔一行执行一次动作，--而不是对整个表执行一次。&lt;触发器SQL语句&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="dbms-output-put-line的用法"><a href="#dbms-output-put-line的用法" class="headerlink" title="dbms_output.put_line的用法"></a>dbms_output.put_line的用法</h1><p>涉及到的知识点如下： 1、enable：在serveroutput on的情况下，用来使dbms_output生效(默认即打开) 2、disable：在serveroutput on的情况下，用来使dbms_output失效 3、put：将内容写到内存，等到put_line时一起输出 4、put_line：不用多说了，输出字符 5、new_line：作为一行的结束，可以理解为写入buffer时的换行符 6、get_line(value, index)：获取缓冲区的单行信息 7、get_lines(array, index)：以数组形式来获取缓冲区的多行信息</p><p>oracle系统包—-dbms_output用法</p><p><a href="https://blog.51cto.com/u_15127666/3474569">博客</a></p><h1 id="E-R图转关系模式"><a href="#E-R图转关系模式" class="headerlink" title="E-R图转关系模式"></a>E-R图转关系模式</h1><p><img src="https://img-blog.csdnimg.cn/ac4a564dfda445f3a03983b6da03a28f.png"></p><p>转为关系模式</p><p><img src="https://img-blog.csdnimg.cn/ab43348e9ad3416c88a04333ed7af6bb.png"></p><p> </p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql索引优化</title>
      <link href="/2023/06/20/mysql-suo-yin-you-hua/"/>
      <url>/2023/06/20/mysql-suo-yin-you-hua/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="Mysql索引分类"><a href="#Mysql索引分类" class="headerlink" title="Mysql索引分类"></a>Mysql索引分类</h2><p><img src="https://img-blog.csdnimg.cn/06214fd7ae2040dd973af7b6316b1b2b.png"></p><p><img src="https://img-blog.csdnimg.cn/c5213620e0dc448fbbd9df27f2c50d79.png"></p><p><img src="https://img-blog.csdnimg.cn/98e3fa0f9b404b729ad2742866740cec.png"></p><h2 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h2><p><img src="https://img-blog.csdnimg.cn/7f070dcd225941d5afd2f0a97bc4fa62.png"></p><p><img src="https://img-blog.csdnimg.cn/d0d2640627a045aa91f9a3f8f8188103.png"></p><p><img src="https://img-blog.csdnimg.cn/99282b1cdb584c9aaec1e7d8091c1580.png"></p><p>查看执行计划：possible keys，key，主要看table以后的数据</p><p><img src="https://img-blog.csdnimg.cn/4863bb8d00b549509f3f5bafb2576da9.png"></p><p><img src="https://img-blog.csdnimg.cn/c41ba2a28fb742fdae0759e134356ec0.png"></p><p>越往下越差。</p><p><img src="https://img-blog.csdnimg.cn/8adbddf6b3e04a629c24466bfb0a20d2.png"></p><p><img src="https://img-blog.csdnimg.cn/6427916d35e345da89a12ae2e9a023a2.png"></p><h2 id="优化策略"><a href="#优化策略" class="headerlink" title="优化策略"></a>优化策略</h2><p><img src="https://img-blog.csdnimg.cn/d2f5b7a5b20c4130904b1d9b6e50fc1e.png"></p><p><img src="https://img-blog.csdnimg.cn/4d23b7cc5a77485999f555d3a220b2d6.png"></p><p><img src="https://img-blog.csdnimg.cn/48f4227505d746778fe0ce3aa3486c91.png"></p><p><img src="https://img-blog.csdnimg.cn/9ff64e5768d240d1acc3bdc07fb9bcea.png"></p><p><img src="https://img-blog.csdnimg.cn/79bd0d750c0a4409add7fd5ff8ed7f2b.png"></p><p><img src="https://img-blog.csdnimg.cn/c51c0ab7f5904e8ca6e1b5b9e7163f16.png"></p><p><img src="https://img-blog.csdnimg.cn/1f84cfcf848d435ba26e2535fc0d06f3.png"></p><p><img src="https://img-blog.csdnimg.cn/ee16ab87fe264f0ebb6adb9d76621ed1.png"></p><p><img src="https://img-blog.csdnimg.cn/ddb9ac0d7565479aa30a7216c826a333.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maven基础</title>
      <link href="/2023/06/20/maven-ji-chu/"/>
      <url>/2023/06/20/maven-ji-chu/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="Maven简介"><a href="#Maven简介" class="headerlink" title="Maven简介"></a>Maven简介</h2><p><img src="https://img-blog.csdnimg.cn/b7e371e0409a48a2822253737d342140.png"></p><p> 简要来说就是将几个不同的软件下面本来都不同的目录结构都用统一的目录结构，让所有的IDE在建立Maven项目的时候都使用同一个标准，构建流程也是相同的。</p><p><strong>其中最厉害的还是依赖管理机制：</strong>依赖管理机制就是我们之前在使用一个包的时候要去手动下载和添加，利用Maven可以使用定位坐标来直接导入jar包，非常的方便</p><p><img src="https://img-blog.csdnimg.cn/b6eb56ff047c42c4893b43aa54b2ff4f.png"></p><p>当你写好了定位之后，他就会在电脑上面安装的Maven里面的仓库找到对应的jar包。 </p><p> <br><img src="https://img-blog.csdnimg.cn/52a27bf0247849708341e4b847764e1a.png"></p><p>仓库也分为了好多种，如果本地仓库没有jar，就会去中央仓库下载（比较慢），中央仓库的东西都是开源的jar包， </p><p> <br><img src="https://img-blog.csdnimg.cn/8449d1dc5e5e4fc798c0e06ca3b20cb0.png"></p><p>Idea下配置Maven： </p><p> <br><img src="https://img-blog.csdnimg.cn/d943c8d86f67496292e53a518a55dec1.png"></p><p>Maven坐标 </p><p> <br><img src="https://img-blog.csdnimg.cn/555413f1792e47fca958ce8a0a491c15.png"></p><p> </p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux文件描述符</title>
      <link href="/2023/06/20/linux-wen-jian-miao-shu-fu/"/>
      <url>/2023/06/20/linux-wen-jian-miao-shu-fu/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="简单来说"><a href="#简单来说" class="headerlink" title="简单来说"></a>简单来说</h2><p>就是一个非负整数，用以标明每一个被进程所打开的文件和socket，表示一个指向文件的引用。</p><h2 id="维基百科"><a href="#维基百科" class="headerlink" title="维基百科"></a>维基百科</h2><p><a href="https://zh.m.wikipedia.org/zh-cn/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6">文件描述符</a>在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。<strong>当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。</strong>在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。但是文件描述符这一概念往往只适用于Unix、Linux这样的操作系统。</p><h2 id="默认分配的文件描述符"><a href="#默认分配的文件描述符" class="headerlink" title="默认分配的文件描述符"></a>默认分配的文件描述符</h2><p>启动一个进程就会有有一个对应的虚拟地址空间，虚拟地址空间分成了内核区与用户区。</p><ul><li>内核区：所有进程的内核区通过CPU 中的内存管理单元 MMU（Memory Management Unit）会将虚拟地址映射到同一块物理内存（内核只有一个），而且不允许不允许应用程序读写该区域的内容或直接调用内核代码定义的函数。+ 用户区：存储应用程序的数据，比如堆区（new），栈区（非静态变量等）等。</li></ul><p>启动一个进程之后，内核 PCB 的文件描述符表中就已经分配了三个文件描述符。默认支持打开的最大文件数为 1024。</p><p>三个针对控制台Console标准流，0、1、2，都可以通过close()函数来关闭：</p><ul><li>STDIN_FILENO：标准输入，可以通过这个文件描述符将数据输入到终端文件中，宏值为 0。+ STDOUT_FILENO：标准输出，可以通过这个文件描述符将数据通过终端输出出来，宏值为 1。+ STDERR_FILENO：标准错误，可以通过这个文件描述符将错误信息通过终端输出出来，宏值为 2。</li></ul><p>因此，这个进程给新打开的文件的文件描述符是从3，开始增长的。</p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>Linux、Unix的大部分系统调用都是基于文件描述符(window是基于句柄)。</p><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>当一个进程系统调用过多的时候，此时的文件描述符可能会不够用，可能会出现bug“Too many open files”，这样这个进程就会消耗完所有的文件资源，这时还需要一个限制，就是最大打开文件数。这个是文件描述符的系统级限制，可以使用sysctl命令或在proc文件系统中查看，表示所有用户能够打开的文件描述符的总和，还有一个是用户级限制，使用命令ulimit查看。</p><h2 id="与文件描述符的产生相关的操作"><a href="#与文件描述符的产生相关的操作" class="headerlink" title="与文件描述符的产生相关的操作"></a>与文件描述符的产生相关的操作</h2><p>socket(), open(), pipe(),         read(), write(), recv(), send(),         select(), poll(), epoll(), </p><p>与套接字相关的操作,<a href="http://c.biancheng.net/view/2123.html">socket是什么？套接字是什么？</a></p><ul><li>connect()+ bind()+ listen()+ accept()+ getsockname()+ getpeername()+ getsockopt(), setsockopt()+ shutdown()</li></ul><h2 id="三个命令查看文件描述符"><a href="#三个命令查看文件描述符" class="headerlink" title="三个命令查看文件描述符"></a>三个命令查看文件描述符</h2><p>系统级：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sysctl</span> <span class="token parameter variable">-a</span> <span class="token operator">|</span> <span class="token function">grep</span> <span class="token parameter variable">-i</span> file-max <span class="token parameter variable">--clolr</span><span class="token function">cat</span> /proc/sys/fs/file-max<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>用户级：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">ulimit</span> <span class="token parameter variable">-n</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/27689bf9d2b84ae0ad3b1cbe35e1768e.png"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/cywosp/article/details/38965239">每天进步一点点——Linux中的文件描述符与打开文件之间的关系_cywosp的博客-CSDN博客</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux网络编程</title>
      <link href="/2023/06/20/linux-wang-luo-bian-cheng/"/>
      <url>/2023/06/20/linux-wang-luo-bian-cheng/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p><strong>目录</strong></p><p><a href="#IP%E7%AB%AF%E6%A0%BC%E5%BC%8F">IP端格式</a></p><p><a href="#%C2%A0C/S%E5%92%8CB/S%E6%A8%A1%E5%BC%8F"> C&#x2F;S和B&#x2F;S模式</a></p><p><a href="#%E7%BD%91%E7%BB%9C%E5%AD%97%E8%8A%82%E5%BA%8F%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0">网络字节序转换函数</a></p><p><a href="#inet_pton%E5%87%BD%E6%95%B0">inet_pton函数</a></p><p><a href="#%E6%97%B6%E9%97%B4%E8%BD%AE">时间轮</a></p><p><a href="#Socket%EF%BC%9AC/S%E6%A8%A1%E5%BC%8F%EF%BC%8Cclient%20server">Socket：C&#x2F;S模式，client server</a></p><p><a href="#socket%E5%87%BD%E6%95%B0">socket函数</a></p><p><a href="#perror(const%20char*%20str)">perror(const char* str)</a></p><p><a href="#INADDR_ANY">INADDR_ANY</a></p><p><a href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B">函数调用流程</a></p><p><a href="#%E4%B8%87%E6%81%B6%E7%9A%84%E7%BB%93%E6%9E%84%E4%BD%93sockaddr%E3%80%81sockaddr_in%E3%80%81in_addr%E3%80%81hostent">万恶的结构体sockaddr、sockaddr_in、in_addr、hostent</a></p><p><a href="#hostent">hostent</a></p><p><a href="#%E4%B8%BB%E6%9C%BA%E5%AD%97%E8%8A%82%E5%BA%8F%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%AD%97%E8%8A%82%E5%BA%8F">主机字节序与网络字节序</a></p><p><a href="#listen%E3%80%81accept%E3%80%81connect%E5%87%BD%E6%95%B0%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB">listen、accept、connect函数之间的关系</a></p><p><a href="#listen%E5%87%BD%E6%95%B0">listen函数</a></p><p><a href="#connect%E5%87%BD%E6%95%B0">connect函数</a></p><p><a href="#accept%E5%87%BD%E6%95%B0">accept函数</a></p><p><a href="#TCP%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B">TCP的三次握手</a></p><p><a href="#send%E3%80%81%E5%92%8Crecv%E5%87%BD%E6%95%B0">send、和recv函数</a></p><p><a href="#TCP%E6%8A%A5%E6%96%87%E5%88%86%E5%8C%85%E5%92%8C%E7%B2%98%E5%8C%85">TCP报文分包和粘包</a></p><p><a href="#Writen%E3%80%81Readn%E5%87%BD%E6%95%B0%EF%BC%9Afreecplus%E5%B0%81%E8%A3%85%E7%9A%84%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F">Writen、Readn函数：freecplus封装的报文格式</a></p><p><a href="#TcpWrite%E3%80%81TcpRead%EF%BC%9Afreecplus%E5%B0%81%E8%A3%85%E7%9A%84%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F">TcpWrite、TcpRead：freecplus封装的报文格式</a></p><p><a href="#%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1">进程间通信</a></p><p><a href="#%E9%81%BF%E5%85%8D%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B">避免僵尸进程</a></p><p><a href="#C/C++%E6%9C%8D%E5%8A%A1%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%BF%90%E8%A1%8C%E6%97%A5%E5%BF%97">C&#x2F;C++服务程序的运行日志</a></p><p><a href="#linux%E5%A4%9A%E8%BF%9B%E7%A8%8B%EF%BC%9Afork%E5%87%BD%E6%95%B0">linux多进程：fork函数</a></p><p><a href="#Linux%E4%BF%A1%E5%8F%B7%E7%9A%84%E4%BD%BF%E7%94%A8">Linux信号的使用</a></p><p><a href="#Linux%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E7%9A%84%E5%87%BD%E6%95%B0">Linux共享内存的函数</a></p><p><a href="#Linux%E5%A4%9A%E7%BA%BF%E7%A8%8B">Linux多线程</a></p><p><a href="#%E5%8A%A8%E6%80%81%E5%BA%93%E4%B8%8E%E9%9D%99%E6%80%81%E5%BA%93">动态库与静态库</a></p><p><a href="#argc%E4%B8%8Eargv%C2%A0">argc与argv </a></p><p><a href="#Makefile%C2%A0">Makefile </a></p><p><a href="#GDB%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8">GDB的简单使用</a></p><p><a href="#Tcp%E9%95%BF%E8%BF%9E%E6%8E%A5%E4%B8%8E%E7%9F%AD%E8%BF%9E%E6%8E%A5">Tcp长连接与短连接</a></p><p><a href="#%E7%BD%91%E7%BB%9C%E6%9C%8D%E5%8A%A1%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95">网络服务性能测试</a></p><p><a href="#I/O%E5%A4%8D%E7%94%A8">I&#x2F;O复用</a></p><p><a href="#select">select</a></p><p><a href="#poll">poll</a></p><p><a href="#epoll">epoll</a></p><p><a href="#ET%E5%92%8CLT">ET和LT</a></p><p><a href="#%E5%8F%82%E8%80%83">参考</a></p><h1 id="IP端格式"><a href="#IP端格式" class="headerlink" title="IP端格式"></a>IP端格式</h1><p><img src="https://img-blog.csdnimg.cn/b42480313f464402a487678706b27b3d.png"></p><p><img src="https://img-blog.csdnimg.cn/569097a03d034a9fa5084f418e0e380c.png"></p><h1 id="C-x2F-S和B-x2F-S模式"><a href="#C-x2F-S和B-x2F-S模式" class="headerlink" title="C&#x2F;S和B&#x2F;S模式"></a>C&#x2F;S和B&#x2F;S模式</h1><p><img src="https://img-blog.csdnimg.cn/7dc13a914cfd48519e368a14e0302f6f.png"></p><h1 id="网络字节序转换函数"><a href="#网络字节序转换函数" class="headerlink" title="网络字节序转换函数"></a>网络字节序转换函数</h1><p>在通信过程中，套接字是成对出现的</p><p><img src="https://img-blog.csdnimg.cn/cb2a5edf6a0f423ca87e4688e45f48fa.png"></p><h1 id="inet-pton函数"><a href="#inet-pton函数" class="headerlink" title="inet_pton函数"></a>inet_pton函数</h1><p>IP地址开始是点分十进制形式的，是一个字符串，如192.168.1.100，所以要将它转换为网络字节序地址需要这个inet_pton函数：本地字节序–&gt;网络字节序</p><p><img src="https://img-blog.csdnimg.cn/9e082d53710a4a6b9802705c0edda703.png"></p><h1 id="时间轮"><a href="#时间轮" class="headerlink" title="时间轮"></a>时间轮</h1><p>回到时间轮定时器，它主要解决的是升序链表插入效率比较低的问题，根据相关链表算法的理论，因为在有序链表插入节点的时间复杂度为O(n)，而且是单链表，意味着链表越长，插一个节点所要找到合适位置的时间开销就会越大，这样下来，时间效率是比较低的。</p><p>  时间轮定时器算法有点hash的思想，插入节点是采用【取模+头插法】的方式，将插入的平均时间复杂度控制器到了O(1)，极大节省了时间开销。</p><p>  不过呢，升序链表定时器虽然在插入时间复杂度上为O(n)，但是在处理超时定时器时遍历链表的效率还是要比时间轮定时器好的，时间轮定时器需要将对应槽上的链表从头到尾全部判断一次，而链表则是从头开始处理，一旦遇到未超时的，则直接结束遍历就好。但综合效率来说，时间轮还是比升序链表好很多的。</p><p><img src="https://img-blog.csdnimg.cn/c7eba5257da249c8a8da1db985dd0916.png"></p><h1 id="Socket：C-x2F-S模式，client-server"><a href="#Socket：C-x2F-S模式，client-server" class="headerlink" title="Socket：C&#x2F;S模式，client server"></a>Socket：C&#x2F;S模式，client server</h1><p><a href="https://www.cnblogs.com/skynet/archive/2010/12/12/1903949.html">Linux Socket编程</a></p><h1 id="socket函数"><a href="#socket函数" class="headerlink" title="socket函数"></a>socket函数</h1><p>int socket(int domain, int type, int protocol);</p><p>domain是协议族，type指的是socket的类型，protocol：指定协议。</p><p>第一个参数只能填AF_INET，第二个参数只能填SOCK_STREAM，第三个参数只能填0。</p><p>除非系统资料耗尽，socket函数一般不会返回失败。</p><p>不要忽略任何一个警告(socklen_t*) &amp;socklen）</p><h1 id="perror-const-char-str"><a href="#perror-const-char-str" class="headerlink" title="perror(const char* str)"></a>perror(const char* str)</h1><p>先输出str: ，再输出错误信息</p><h1 id="INADDR-ANY"><a href="#INADDR-ANY" class="headerlink" title="INADDR_ANY"></a>INADDR_ANY</h1><p>说明指定的是任意的ip地址</p><h1 id="函数调用流程"><a href="#函数调用流程" class="headerlink" title="函数调用流程"></a>函数调用流程</h1><p>服务端函数调用的流程</p><p>socket-&gt;bind-&gt;listen-&gt;accept-&gt;recv&#x2F;send-&gt;close</p><p>客户端函数调用的流程</p><p>socket-&gt;connect-&gt;send&#x2F;recv-&gt;close</p><p>其中send&#x2F;recv可以进行多次交互。</p><p>无论是客户端还是服务端都要创建socket</p><h1 id="万恶的结构体sockaddr、sockaddr-in、in-addr、hostent"><a href="#万恶的结构体sockaddr、sockaddr-in、in-addr、hostent" class="headerlink" title="万恶的结构体sockaddr、sockaddr_in、in_addr、hostent"></a>万恶的结构体sockaddr、sockaddr_in、in_addr、hostent</h1><p><img src="https://img-blog.csdnimg.cn/f78938e3d83141988c8f3b6371c8a80e.png"></p><h1 id="hostent"><a href="#hostent" class="headerlink" title="hostent"></a>hostent</h1><p><img src="https://img-blog.csdnimg.cn/ff2528fdc17143f7ab6d721e18c1dc52.png"></p><p><img src="https://img-blog.csdnimg.cn/9d3c88331c9b4e5e9aaf9c202eb00c0f.png"></p><h1 id="主机字节序与网络字节序"><a href="#主机字节序与网络字节序" class="headerlink" title="主机字节序与网络字节序"></a>主机字节序与网络字节序</h1><p><img src="https://img-blog.csdnimg.cn/87aae97487c84854845b85d137496729.png"></p><h1 id="listen、accept、connect函数之间的关系"><a href="#listen、accept、connect函数之间的关系" class="headerlink" title="listen、accept、connect函数之间的关系"></a>listen、accept、connect函数之间的关系</h1><p><img src="https://img-blog.csdnimg.cn/91644dd71fbb42c596571f99c751de7f.png"></p><h1 id="listen函数"><a href="#listen函数" class="headerlink" title="listen函数"></a>listen函数</h1><p>listen(listenfd, 5);&#x2F;&#x2F;把socket设置为监听模式，第二个参数比较复杂</p><p>如果在listen前面加上sleep，结果发现不能连接上</p><p><img src="https://img-blog.csdnimg.cn/60b5d714084e40749789d72c343a75e5.png"></p><p><img src="https://img-blog.csdnimg.cn/38205cc98a4f48699893c9cc4c6a4fe9.png"></p><p>如果在listen后面加上sleep，可以连接上</p><p><img src="https://img-blog.csdnimg.cn/b27ad15f8405418382c1756d9a823917.png"></p><p><img src="https://img-blog.csdnimg.cn/7efce7d888a04777834be5d6300b13f4.png"></p><p>原因是：服务端在调用listen之前，客户端不能向服务端发起连接请求。</p><h1 id="connect函数"><a href="#connect函数" class="headerlink" title="connect函数"></a>connect函数</h1><p>connect(sockfd, (struct sockaddr *)&amp;servaddr,sizeof(servaddr))</p><p>向服务端发起连接请求</p><h1 id="accept函数"><a href="#accept函数" class="headerlink" title="accept函数"></a>accept函数</h1><p>clientfd&#x3D;accept(listenfd,(struct sockaddr <em>)&amp;clientaddr,(socklen_t</em>)&amp;socklen);</p><p>三个客户端连接，accept是从连接的一个队列里面取出来，如果队列里面没有，会阻塞。</p><p><img src="https://img-blog.csdnimg.cn/436858fc94da46ac91a1db2b44266a15.png"></p><p>把这个用死循环，才可以多客户端连接</p><p><img src="https://img-blog.csdnimg.cn/905a883a82f3493991a9ec73d60e45ce.png"></p><h1 id="TCP的三次握手"><a href="#TCP的三次握手" class="headerlink" title="TCP的三次握手"></a>TCP的三次握手</h1><p><img src="https://img-blog.csdnimg.cn/4b9ec7c9fe1c4c5ea0f4fbc608c9eca0.png"></p><p>使用netstat -na | more命令查询端口的连接状态，</p><p>在listen后面睡眠1000秒，此时启动服务端，就可以查看到ESTABLISHED状态</p><p><img src="https://img-blog.csdnimg.cn/ab553db304b04e9c87fc4e03a045060a.png"></p><h1 id="send、和recv函数"><a href="#send、和recv函数" class="headerlink" title="send、和recv函数"></a>send、和recv函数</h1><p><a href="https://www.cnblogs.com/jianqiang2010/archive/2010/08/20/1804598.html">Socket send函数和recv函数详解 - 世道 - 博客园</a></p><p>int send(Socket s, const char* buf, int len, int flags);</p><p>int recv(Socket s, char * buf, int len, int flags);</p><p>都需要通过socket套接字来实现数据的接受与发送，而不是通过send、recv函数来实现。</p><p>其实这两个函数也有不成功的时候，当缓冲区满了之后，就不能正常的接收了。</p><p>在发送端使用正常代码，注释掉接受的代码，只用来发送</p><p>客户端注释掉发送的代码，只用来接受，而且在接受后面</p><p>usleep(10000);&#x2F;&#x2F;睡眠微秒，结果在接受了八万多条数据之后，缓冲区满了，send函数在发送端阻塞了，等客户端又取出了一些数据之后才继续接受数据。</p><p><img src="https://img-blog.csdnimg.cn/fa9d57ae968c438c82427ff6fcf17ca7.png"></p><p><img src="https://img-blog.csdnimg.cn/66f5ddb4a1504994ad1f402cee4d207e.png"></p><h1 id="TCP报文分包和粘包"><a href="#TCP报文分包和粘包" class="headerlink" title="TCP报文分包和粘包"></a>TCP报文分包和粘包</h1><p><img src="https://img-blog.csdnimg.cn/73501f88e76741b98b6e5a1b4d07a22b.png"></p><p>粘包：粘包是指TCP协议中，发送方发送的若干包数据到接收方接收时粘成一包，从接收缓冲区看，后一包的数据的头紧接着前一包数据的尾。TCP是面向字节流的协议，就是没有界限的一串数据，本没有“包”的概念，“粘包”和“拆包”一说是为了有助于形象地理解这两种现象。为什么 UDP没有粘包由于UDP有消息保护边界，不会发生粘包拆包问题，因此粘包拆包问题只发生在TCP协议中。</p><p>对于粘包和拆包问题，常见的解决方案有四种：</p><ul><li>1）发送端将每个包都封装成固定的长度，比如100字节大小。如果不足100字节可通过补0或空等进行填充到指定长度；+ 2）发送端在每个包的末尾使用固定的分隔符，例如\r\n。如果发生拆包需等待多个包发送过来之后再找到其中的\r\n进行合并；例如，FTP协议；+ 3）将消息分为头部和消息体，头部中保存整个消息的长度，只有读取到足够长度的消息之后才算是读到了一个完整的消息；+ 4）通过自定义协议进行粘包和拆包的处理。</li></ul><p>第三种方法是最常用的方法。</p><h1 id="Writen、Readn函数：freecplus封装的报文格式"><a href="#Writen、Readn函数：freecplus封装的报文格式" class="headerlink" title="Writen、Readn函数：freecplus封装的报文格式"></a>Writen、Readn函数：freecplus封装的报文格式</h1><p>这两个函数指的是recv函数和send函数都存在读取的数据报文不完整的情况</p><p><img src="https://img-blog.csdnimg.cn/48750a9aa42f4398a9ecd86cdc031e84.png"></p><p><img src="https://img-blog.csdnimg.cn/db81aff3f9fd43468f773859e672ffd4.png"></p><h1 id="TcpWrite、TcpRead：freecplus封装的报文格式"><a href="#TcpWrite、TcpRead：freecplus封装的报文格式" class="headerlink" title="TcpWrite、TcpRead：freecplus封装的报文格式"></a>TcpWrite、TcpRead：freecplus封装的报文格式</h1><p><img src="https://img-blog.csdnimg.cn/6264f37e6f624fcc831e1f7911d55935.png"></p><p>报文长度+报文内容，这个就是Tcp粘包的一种最常见的解决方法。</p><p>这两个函数的参数的详细解释：</p><p><img src="https://img-blog.csdnimg.cn/78be6cf7cff9412fbb9389d3b8f46d86.png"></p><h1 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h1><p><a href="https://blog.csdn.net/qq_34827674/article/details/107678226?app_version=5.7.0&code=app_1562916241&csdn_share_tail=%7B%22type%22:%22blog%22,%22rType%22:%22article%22,%22rId%22:%22107678226%22,%22source%22:%22m0_67623521%22%7D&uLinkId=usr1mkqgl919blen&utm_source=app">进程间通信</a></p><p><img src="https://img-blog.csdnimg.cn/bd5ffdf56f9a48f4ad79ad566ff4a382.png"></p><p><a href="https://www.freecplus.net/d95f4eaf18eb46d19b82383519126dec.html">Linux进程间通信</a></p><p>六种方式，前两者不经常使用，共享内存没有加锁的机制，所以经常与信号灯结合一起来使用，在高性能的网络服务端程序中，可以用共享内存作为的数据缓存（cache）。</p><h1 id="避免僵尸进程"><a href="#避免僵尸进程" class="headerlink" title="避免僵尸进程"></a>避免僵尸进程</h1><p><a href="https://zh.m.wikipedia.org/zh-cn/%E7%88%B6%E8%BF%9B%E7%A8%8B">僵尸进程、孤儿进程</a>，<a href="https://www.cnblogs.com/anker/p/3271773.html">两种进程的解决办法、分别模拟产生</a></p><p><strong>僵尸进程：</strong>进程退出的时候，unix将该进程的所有资源释放，但是仍然为其保留一定的信息，包括进程号（process identify），退出状态，运行时间。这个是一种机制，可以让父进程任何时候想知道子进程的状态信息的时候都可以调出来。这些信息的资源需要直到父进程调用wait&#x2F;waitpid来取信息的时候才释放，但是如果父进程不去调用wait&#x2F;waitpid，它的进程号就会一直占用，如果大量的产生僵尸进程，将因为没有可用的进程号而导致系统不能产生新的进程. 此即为僵尸进程的危害，应当避免。</p><p><strong>孤儿进程</strong>是没有父进程的进程，孤儿进程这个重任就落到了init进程身上，init进程就好像是一个民政局，专门负责处理孤儿进程的善后工作。每当出现一个孤儿进程的时候，内核就把孤儿进程的父进程设置为init，而init进程会循环地wait()它的已经退出的子进程。这样，当一个孤儿进程凄凉地结束了其生命周期的时候，init进程就会代表党和政府出面处理它的一切善后工作。因此孤儿进程并不会有什么危害。</p><p>两种解决方式：</p><p><img src="https://img-blog.csdnimg.cn/096e5fdce86547a3892667ff067a130a.png"></p><p><img src="https://img-blog.csdnimg.cn/65ae655429574b4da4de465797be3996.png"></p><p><img src="https://img-blog.csdnimg.cn/af2aeb7866444e1196f7b7ea5a9e9a96.png"></p><p>僵尸进程是指系统将进程退出的信息保存下来，此时占用一个进程编号，除非调用wait&#x2F;waitpid，将其释放，否则如果出现过多的僵尸进程会将进程号使用完，孤儿进程是指该进程没有父进程，从而被init进程管理，可以回收资源。</p><p>我后面才知道没有模拟出僵尸进程的原因，需要多个客户端连接，使用多进程或者多线程，多进程需要fork函数才可以实现，</p><p><img src="https://img-blog.csdnimg.cn/489863e0c4c644c9b870b9506346a632.png"></p><p>有标志的进程就是僵尸进程。</p><p>如果按Ctrl+c终止book250后，父进程退出，僵尸进程随之消失。</p><p>有时使用ctrl+c的命令结束主进程是不对的，需要kill+pid。</p><h1 id="C-x2F-C-服务程序的运行日志"><a href="#C-x2F-C-服务程序的运行日志" class="headerlink" title="C&#x2F;C++服务程序的运行日志"></a>C&#x2F;C++服务程序的运行日志</h1><p>tail -f demo47.log 查看日志文件，获取内容</p><p>mirac@ubuntu:~&#x2F;Desktop&#x2F;网络编程$ tar zxvf freecplus_20200615.tgz -C .&#x2F;</p><p>先解压文件</p><h1 id="linux多进程：fork函数"><a href="#linux多进程：fork函数" class="headerlink" title="linux多进程：fork函数"></a>linux多进程：fork函数</h1><p>进程是操作系统进行资源分配和调度的一个基本单位。</p><p>fork调用后，子进程与父进程是否共享变量：</p><p><a href="https://blog.csdn.net/weixin_39578364/article/details/78995433">fork调用后，子进程与父进程是否共享变量_浅浅的i的博客-CSDN博客</a></p><p>不会真的共享变量，虽然地址是一样的，但是这个地址是给程序员看的虚拟地址，真正通过内核映射到实际的物理地址是不一样的。</p><p>fork多个子进程：</p><p><a href="https://blog.csdn.net/weixin_42929607/article/details/116426096">fork创建多个子进程_XV_的博客-CSDN博客_fork多个子进程</a></p><h1 id="Linux信号的使用"><a href="#Linux信号的使用" class="headerlink" title="Linux信号的使用"></a>Linux信号的使用</h1><p><a href="https://www.freecplus.net/eec5c39aa63b45ad946f1cc08134d9f9.html">Linux信号 (freecplus.net)</a></p><p>当服务程序运行在后台的时候，直接使用Ctrl+c让程序直接退出是不好的，因为程序突然退出，还有资源没有释放，这个时候signal函数就起作用了。</p><p>使用信号函数：sighandler_t signal(int signum, sighandler_t handler);</p><p>第一个参数是指signum是信号的编号，第二个参数是指处理信号的函数（可以在里面编写释放资源的代码）。</p><p>不需要清楚返回值。</p><p>程序员关心的信号有三个：SIGINT、SIGTERM和SIGKILL。</p><p>按Ctrl+c，发出SIGINT信号，信号编号是2。</p><p>采用“kill 进程编号”或“killall 程序名”，发出的是SIGTERM信号，编号是15。</p><p>采用“kill -9 进程编号”，发出的是SIGKILL信号，编号是9，此信号不能被忽略，也无法捕获，程序将突然死亡。</p><p>所以，程序员只要设置SIGINT和SIGTERM两个信号的处理函数就可以了，这两个信号可以使用同一个处理函数，函数的代码是释放资源。</p><p>demo:signal.cpp</p><p><img src="https://img-blog.csdnimg.cn/3b97ff370226457a81df802f3ea26e9d.png"></p><h1 id="Linux共享内存的函数"><a href="#Linux共享内存的函数" class="headerlink" title="Linux共享内存的函数"></a>Linux共享内存的函数</h1><p><a href="https://www.freecplus.net/6cb9ad02d7d64d6eb2f8e241b1158aed.html">共享内存</a></p><p>头文件：#include &lt;sys&#x2F;ipc.h&gt; #include &lt;sys&#x2F;shm.h&gt;</p><p>1、shmget：获取或创建共享内存</p><p>2、shmat：把共享内存连接到当前进程的地址空间</p><p>3、shmdt：该函数用于将共享内存从当前进程中分离，相当于shmat函数的反操作。</p><p>4、shmctl：删除共享内存</p><p>要使用ipcs -m查看共享内存的信息</p><p>一旦运行了程序，使用 ipcrm -m shmid，来删除共享内存，否则会一直存在</p><h1 id="Linux多线程"><a href="#Linux多线程" class="headerlink" title="Linux多线程"></a>Linux多线程</h1><p><a href="https://www.freecplus.net/c893ece166b94df4b2e185fa6f1c920c.html">多线程的函数使用、以及多线程socket</a></p><p>在Linux下，采用pthread_create函数来创建一个新的线程，函数声明：</p><p>函数声明：int pthread_create(pthread_t *thread, const pthread_attr_t *attr,void *(*start_routine) (void *), void *arg);</p><h1 id="动态库与静态库"><a href="#动态库与静态库" class="headerlink" title="动态库与静态库"></a>动态库与静态库</h1><p><a href="https://www.cnblogs.com/skynet/p/3372855.html">C++静态库与动态库 </a></p><p>在使用的时候，都是尽量的在使用动态库，因为静态库占用空间大，静态库是将所有相关的目标文件与牵涉到的函数库被链接合成一个可执行文件，其中一个文件修改，整个项目都要重新编译以及用户也要重新下载（最大的缺点）。</p><h1 id="argc与argv"><a href="#argc与argv" class="headerlink" title="argc与argv"></a>argc与argv</h1><p>.&#x2F;在终端运行代码时，加入的参数存储在argc、argv中，argc是参的个数，argv是参数的值</p><h1 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h1><p><a href="https://www.ruanyifeng.com/blog/2015/02/make.html">Makefile</a>， Makefile</p><h1 id="GDB的简单使用"><a href="#GDB的简单使用" class="headerlink" title="GDB的简单使用"></a>GDB的简单使用</h1><p>首先g++中加入-g参数，然后file+可执行文件的名字，run，b，c，一直使用n，最后使用quit退出。如果需要设置参数使用set args</p><p><img src="https://img-blog.csdnimg.cn/0174c5ac5f254dde91e3d18f7611c9f2.png"></p><p><img src="https://img-blog.csdnimg.cn/1b5ea4464d5e40f383b54505ca5a0781.png"></p><p>例子：</p><p><a href="https://juejin.cn/post/6984368713940074532">GDB的例子</a>，通过测试了两个易错的面试题， int a[5]&#x3D;{0,1,2,3,4},&amp;a+1的地址是a+1的地址，即数组的后面一个位置（想象成二维数组）</p><h1 id="Tcp长连接与短连接"><a href="#Tcp长连接与短连接" class="headerlink" title="Tcp长连接与短连接"></a>Tcp长连接与短连接</h1><p>长连接：建立了一次连接之后需要长时间的保持住，双方需要互相发送检测的包，</p><p>流程：三次握手建立连接–》传输数据–》保持连接(心跳)–》发送数据–》保持连接(心跳)……–》4次挥手断开连接。</p><p>短连接：建立一次连接，发送完数据之后就断开连接。</p><p>流程：3次握手建立连接–》传输数据–》4次挥手断开连接。</p><p>由于在建立连接与断开连接的过程中要消耗资源和时间的，所以在不同的场景需要使用不同的方式。</p><p>对于服务器来说，服务器里的这些个长连接其实很有数据库连接池的味道，大家都是为了节省连接重复利用嘛。</p><p><a href="https://segmentfault.com/a/1190000021696056">（史上最通俗！）http请求怎样实现TCP长连接，以及长轮询和短轮询的区别。</a></p><p>长轮询和短轮询（针对淘宝的库存量的显示的场景）</p><h1 id="网络服务性能测试"><a href="#网络服务性能测试" class="headerlink" title="网络服务性能测试"></a>网络服务性能测试</h1><p>主要的性能指标：</p><p>1、服务端的并发能力</p><p>2、服务端的业务处理能力</p><p>3、客户端接收响应的时效</p><p>4、网络带宽</p><h1 id="I-x2F-O复用"><a href="#I-x2F-O复用" class="headerlink" title="I&#x2F;O复用"></a>I&#x2F;O复用</h1><p><a href="https://juejin.cn/post/6882984260672847879">彻底理解 IO 多路复用实现机制</a></p><p>有三种模式：select、poll、epoll，各有适合的应用场景。</p><p>env | grep LANG&#x2F;&#x2F;查看使用的编码格式</p><p><a href="https://www.51cto.com/article/702199.html">彻底搞懂 Select &#x2F; Poll &#x2F; Epoll，就这篇了！</a></p><h1 id="select"><a href="#select" class="headerlink" title="select"></a>select</h1><p>socket的集合fd_set用于存放多个socket，使用select来阻塞程序，而不是在分别的recv、read、send、accept阻塞。</p><p><img src="https://img-blog.csdnimg.cn/a5c7ef0fd1444f0d959e868e18fe1595.png"></p><p>在tcpSelect.cpp中while(1)循环里面fd_set使用的是temp_set，因为会改变原来的read_set，只做了一个基本的了解，时间可以的话要在听一遍。</p><p><img src="https://img-blog.csdnimg.cn/7b2a3663acfd43b5a21287cc400d72ed.png"></p><h1 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h1><p>优化了参数的设置，较为简单，但是不能跨平台，效率与select差不多</p><p><img src="https://img-blog.csdnimg.cn/76d6df755d374959bb6be762dbd502d0.png"></p><p>不需要备份fd_set,原因就在结构体pollfd中，有一个revent（return event）作为备份。</p><p><img src="https://img-blog.csdnimg.cn/ad85870369e744798eb795f92bf37520.png"></p><h1 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h1><p>结构体</p><p><img src="https://img-blog.csdnimg.cn/50a5bc0052f043aa9f29307cae802f95.png"></p><h1 id="ET和LT"><a href="#ET和LT" class="headerlink" title="ET和LT"></a>ET和LT</h1><p><img src="https://img-blog.csdnimg.cn/75df840aa325426d984f3916715a5e26.png"></p><p>测试水平触发：</p><ul><li>事件没有处理：int xx&#x3D;0; 作为计数器，指定xx&#x3D;2的时候continue，然后这个事件就没有处理，看看epoll的处理方式（默认是水平触发，所以会立即报告）。+ 事件只处理了一般：read函数sizeof(buffer)，设置成小于它的数字，这个时候缓冲区就会剩余数据没有处理完，epoll也会立即处理完。</li></ul><p>一样的测试方法：</p><p><img src="https://img-blog.csdnimg.cn/e97712c241c6488d82e362321b3c93b7.png"></p><p>需要将accept函数设置为非阻塞的模式setnoblocking</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.freecplus.net/index.html">C语言技术网 - 首页</a></p><p><a href="https://www.bilibili.com/video/BV11Z4y157RY/?spm_id_from=333.1007.top_right_bar_window_custom_collection.content.click&vd_source=b99c7e40ffa0f64b68b706f2af755c8e">C&#x2F;C++网络编程，从socket到epoll_哔哩哔哩_bilibili</a>  </p><p><a href="https://www.freecplus.net/0047ac4059b14d52bcc1d4df6ae8bb83.html">网络通信基础socket</a></p><p><strong>上面的大部分代码都改自于</strong><a href="https://www.freecplus.net/0047ac4059b14d52bcc1d4df6ae8bb83.html">网络通信基础socket</a> </p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令之top</title>
      <link href="/2023/06/20/linux-ming-ling-zhi-top/"/>
      <url>/2023/06/20/linux-ming-ling-zhi-top/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="Linux命令之top"><a href="#Linux命令之top" class="headerlink" title="Linux命令之top"></a>Linux命令之top</h1><p>显示进程占用cpu以及内存的情况<br> 1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>  -d: 表示每一次刷新的时间间隔<br>-c: 显示整个命令行（包括参数）而不只是显示命令名<br>-p: 只显示具体的进程，不显示所有的进程<br>在top的显示过程中，还可以输入命令进行交互：<br>M：以内存的占有率进行排序<br>P：CPU占有率进行排序<br>T：运行时间进行排序<br>d：改变刷新时间</p><p>示例：<br> 1<br>2<br>3<br>4<br>5<br>  top   &#x2F;&#x2F;每隔5秒显式所有进程的资源占用情况<br>top -d 2  &#x2F;&#x2F;每隔2秒显式所有进程的资源占用情况<br>top -c  &#x2F;&#x2F;每隔5秒显式进程的资源占用情况，并显示进程的命令行参数(默认只有进程名)<br>top -p 12345 -p 6789&#x2F;&#x2F;每隔5秒显示pid是12345和pid是6789的两个进程的资源占用情况<br>top -d 2 -c -p 123456 &#x2F;&#x2F;每隔2秒显示pid是12345的进程的资源使用情况，并显式该进程启动的命令行参数</p><p> </p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java中switch的高级用法</title>
      <link href="/2023/06/20/java-zhong-switch-de-gao-ji-yong-fa/"/>
      <url>/2023/06/20/java-zhong-switch-de-gao-ji-yong-fa/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="switch语句的用法"><a href="#switch语句的用法" class="headerlink" title="switch语句的用法"></a>switch语句的用法</h2><h3 id="用法一："><a href="#用法一：" class="headerlink" title="用法一："></a><strong>用法一：</strong></h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">String</span> fruit <span class="token operator">=</span> <span class="token string">"apple"</span><span class="token punctuation">;</span>        <span class="token keyword">switch</span> <span class="token punctuation">(</span>fruit<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">case</span> <span class="token string">"apple"</span><span class="token operator">:</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Selected apple"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> <span class="token string">"pear"</span><span class="token operator">:</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Selected pear"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> <span class="token string">"mango"</span><span class="token operator">:</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Selected mango"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">default</span><span class="token operator">:</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"No fruit selected"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意点：要记得写break（case语句具有穿透效应，如果不写的话，后面的会继续执行）；要记得写default（都不匹配的情况）；</p><h3 id="简洁的用法："><a href="#简洁的用法：" class="headerlink" title="简洁的用法："></a><strong>简洁的用法：</strong></h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">public class Main<span class="token punctuation">&#123;</span>    public static void main<span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        String <span class="token assign-left variable">fruit</span><span class="token operator">=</span><span class="token string">"ban"</span><span class="token punctuation">;</span>        switch <span class="token punctuation">(</span>fruit<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">case</span> <span class="token string">"apple"</span>-<span class="token operator">></span>System.out.println<span class="token punctuation">(</span><span class="token string">"select a"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">case</span> <span class="token string">"banana"</span>-<span class="token operator">></span>System.out.println<span class="token punctuation">(</span><span class="token string">"select b"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">case</span> <span class="token string">"mango"</span>-<span class="token operator">></span>System.out.println<span class="token punctuation">(</span><span class="token string">"select mango"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            default -<span class="token operator">></span>System.out.println<span class="token punctuation">(</span><span class="token string">"select none"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        // System.out.println<span class="token punctuation">(</span><span class="token string">"哈哈哈"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>直接使用箭头来表示switch的返回值，没有了写很多break的繁琐</p><p>这种简介的写法还可以直接返回值：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">public class Main <span class="token punctuation">&#123;</span>    public static void main<span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        String fruit <span class="token operator">=</span> <span class="token string">"a"</span><span class="token punctuation">;</span>        int option <span class="token operator">=</span> switch <span class="token punctuation">(</span>fruit<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">case</span> <span class="token string">"a"</span> -<span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">case</span> <span class="token string">"p"</span>, <span class="token string">"m"</span> -<span class="token operator">></span> <span class="token number">2</span><span class="token punctuation">;</span>            default -<span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">;</span> // 注意使用赋值语句要以<span class="token punctuation">;</span>结束        System.out.println<span class="token punctuation">(</span><span class="token string">"opt = "</span> + option<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="使用yield来返回值："><a href="#使用yield来返回值：" class="headerlink" title="使用yield来返回值："></a><strong>使用yield来返回值：</strong></h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">public class Main <span class="token punctuation">&#123;</span>    public static void main<span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        String fruit <span class="token operator">=</span> <span class="token string">"orange"</span><span class="token punctuation">;</span>        int opt <span class="token operator">=</span> switch <span class="token punctuation">(</span>fruit<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">case</span> <span class="token string">"apple"</span> -<span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">case</span> <span class="token string">"pear"</span>, <span class="token string">"mango"</span> -<span class="token operator">></span> <span class="token number">2</span><span class="token punctuation">;</span>            default -<span class="token operator">></span> <span class="token punctuation">&#123;</span>                int code <span class="token operator">=</span> fruit.hashCode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                yield code<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>        String <span class="token assign-left variable">c</span><span class="token operator">=</span><span class="token string">"a"</span><span class="token punctuation">;</span>        System.out.println<span class="token punctuation">(</span>c.hashCode<span class="token punctuation">(</span><span class="token punctuation">))</span><span class="token punctuation">;</span>        System.out.println<span class="token punctuation">(</span><span class="token string">"opt = "</span> + opt<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>说明：</strong>其中使用了String的hashcode方法，<strong>这个方法是以31为权，每一位为字符的ASCII值进行运算，用自然溢出来等效取模，得到一个不容易重复的数字，</strong>hashcode源码如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">public int <span class="token function-name function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    int h <span class="token operator">=</span> <span class="token builtin class-name">hash</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>h <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> value.length <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        char val<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> value<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>int i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> value.length<span class="token punctuation">;</span> i++<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            h <span class="token operator">=</span> <span class="token number">31</span> * h + val<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token builtin class-name">hash</span> <span class="token operator">=</span> h<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token builtin class-name">return</span> h<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后还使用了yield来返回值，注意<strong>只有switch使用-&gt;的简洁写法才可以使用yield返回值。</strong></p><h2 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a><strong>参考资料：</strong></h2><p><a href="https://blog.csdn.net/claram/article/details/53770830?ops_request_misc=&request_id=&biz_id=102&utm_term=java%20string%E7%9A%84hashcode%E6%96%B9%E6%B3%95&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-2-53770830.142%5Ev13%5Epc_search_result_control_group,157%5Ev14%5Enew_3&spm=1018.2226.3001.4187">Java编程：String 类中 hashCode() 方法详解_志波同学的博客-CSDN博客_string.hashcode()</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java知识要点</title>
      <link href="/2023/06/20/java-zhi-shi-yao-dian/"/>
      <url>/2023/06/20/java-zhi-shi-yao-dian/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="第1章-Java概述"><a href="#第1章-Java概述" class="headerlink" title="第1章 Java概述"></a>第1章 Java概述</h1><p>重要特性：</p><p><strong>Write Once Run Anyway</strong></p><p>简单性：相比C++移除指针、运算符重载、多重继承等，垃圾自动回收。</p><p>平台无关性：Java引进虚拟机（JVM，Java Virtual Machine）概念。</p><p>安全性：没有指针，内存由系统分配。</p><p>动态转载：类运行时是动态装载的。</p><p>编译过程：<br><img src="https://img-blog.csdnimg.cn/fa3f9661e063421d96d0a8c57d16ff19.png"></p><p>JRE： Java Runtime Environment JDK：Java Development Kit</p><p>JRE和JDK的区别：<a href="https://www.cnblogs.com/mark5/p/11063047.html">https://www.cnblogs.com/mark5/p/11063047.html</a></p><h1 id="第2章-Java语言基础"><a href="#第2章-Java语言基础" class="headerlink" title="第2章 Java语言基础"></a>第2章 Java语言基础</h1><p>数据类型名称位长字节型byte8短整型short16整型int32长整型long64单精度型float32双精度型double64字符型char16布尔型boolean1</p><p>数据输入：类<code>Scanner</code>，<code>import java.util.Scanner</code>;<br>方法nextBoolean()nextDouble()nextFloat()nextInt()nextLine()next()</p><h1 id="第3章-程序流程控制"><a href="#第3章-程序流程控制" class="headerlink" title="第3章 程序流程控制"></a>第3章 程序流程控制</h1><p>声明多维数组：int array[][]，int[][] array</p><p><strong>和其他高级编程语言不同，Java多维数组不必须是规则矩阵形式。</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">12</span><span class="token punctuation">;</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">111</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>a<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> j<span class="token operator">&lt;</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token string">"\t"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>数组复制：<code>System.arraycopy(src, srcPos, dest, destPos, length);</code>；</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span> array<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>i<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> array1<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> array1<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">:</span>array1<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token string">"\t"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>数组排序：<code>import java.util.Random; import static java.util.Arrays.sort;</code>；</p><p>Random的使用：<a href="http://c.biancheng.net/view/867.html">http://c.biancheng.net/view/867.html</a></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Random</span> r <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> array<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>r<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">100</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">sort</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//Arrays类中的sort()使用的是“经过调优的快速排序法”</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>array<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>array<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token string">"\t"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="第4章-类与对象"><a href="#第4章-类与对象" class="headerlink" title="第4章.类与对象"></a>第4章.类与对象</h1><p>用关键字<strong>static修饰</strong>的方法称为类方法，又称为静态方法。不用static修饰的方法称为实例方法，又称为对象方法。</p><p><strong>类方法只能操作类变量，不能操作实例变量。</strong></p><p>Java的值传递还是引用传递：<a href="https://www.jianshu.com/p/457bfc91df79%EF%BC%8Chttps://www.javadude.com/articles/passbyvalue.htm">https://www.jianshu.com/p/457bfc91df79，https://www.javadude.com/articles/passbyvalue.htm</a></p><p>“primitives are passed by value, objects are passed by reference”.</p><p>java常用的包：<strong>看看就行了</strong><br>序号包名功能描述1java.langjava的核心类库，包含了运行java程序必不可少的系统类，如基本数据类型、基本数学函数、字符串处理、线程、异常处理类等，系统缺省加载这个包。2java.iojava语言的标准输入&#x2F;输出类库，如基本输入&#x2F;输出流、文件输入&#x2F;输出、过滤输入&#x2F;输出流等等。3java.utilJava的实用工具类库Java.util包。在这个包中，Java提供了一些实用的方法和数据结构。例如，Java提供日期(Data)类、日历(Calendar)类4java.awt.image处理和操纵来自于网上的图片的java工具类库。5java.net实现网络功能的类库有Socket类、ServerSocket类。6java.awt构建图形用户界面(GUI)的类库，低级绘图操作Graphics类，图形界面组件和布局管理7java.awt.eventGUI事件处理包 。8java.sql实现JDBC的类库。</p><p>import的使用：当定义包后，<strong>在同一个包中的类是默认隐式导入的。</strong>但如果一个类访问来自另一个包中的类，则前者必须显示通过import语句导入后者后才能使用。</p><p>基本类型的封装类：<strong>使用范型数据的时候只能使用封装的类。</strong><br>原始类型封装类静态的常用方法booleanBooleanBoolean.parseBoolean(String str)charCharacterisDigit(char ch);isLetter(char ch);isLowerCase(char ch);toLowerCase(char ch)byteByteByte.parseByte(String str)shortShortShort.parseShort(String str)intIntegerInteger.parseInt(String str)longLongLong.parseLong(String str)floatFloatFloat.parseFloat(String str)doubleDoubleDouble.parseDouble(String str)</p><h1 id="第5章面向对象高级特性"><a href="#第5章面向对象高级特性" class="headerlink" title="第5章面向对象高级特性"></a>第5章面向对象高级特性</h1><p>实操：<a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1255943520012800">https://www.liaoxuefeng.com/wiki/1252599548343744/1255943520012800</a></p><p>下面都是概念</p><p>需要掌握的知识点：</p><ul><li>继承（extends）+ 关键字this和super+ final关键字+ 转型和多态+ 抽象类（abstract class ）和接口（interface）+ 内部类+ 匿名对象和类+ 异常类+ 泛型类</li></ul><p><strong>转型与多态：</strong></p><ul><li>上转型：子类对象到父类对象的类型转换，即把创建的子类对象放到父类的对象变量中，该过程是自动完成的，有些像基本类型的自动类型转换。 +  下转型：父类对象到子类对象的转换，必须使用强制转换。 +  多态：是指同一个操作被不同类型对象调用时可能产生不同的行为。</li></ul><p><strong>final关键字：</strong></p><p>final的本义是“最终”，final可以修饰变量、一般方法和类 。</p><p>final修饰变量，表示变量一旦获取了初始值就不能被修改；</p><p>final修饰方法，表示该方法在派生子类中不能被重写，只能引用；</p><p>final修饰类，表示该类不能派生出子类。</p><p><strong>抽象类（abstract class ）和接口（interface）：</strong></p><p>相同点有：</p><ul><li>都包含抽象方法，这些方法在继承抽象类或实现接口的类中都要具体实现，<strong>如果有一个不实现，该类就是抽象类，还是不能创建实例对象。</strong> +  抽象类和接口都包含抽象方法，不能用new创建对象实例，两者都可以通过上转型对象或接口回调方式实现多态机制。</li></ul><p>不同点有：</p><ul><li>声明方式不同，接口使用interface关键字，而抽象类使用abstract class关键字。 +  成员变量不同，接口中只能有静态常量，而抽象类中不受限制。 +  成员方法不同，接口中的方法均是public abstract；而抽象类中抽象方法必须加上修饰符abstract。另外，接口中不能定义静态方法，而抽象类可以。</li></ul><p><strong>内部类：</strong></p><p>如果一个类A的内部定义了一个类B，那么类A称为外部类或外嵌类，而类B称为内部类或内嵌类 。</p><p><strong>匿名对象和类：</strong></p><p>new 类名（[实参列表]）{&#x2F;&#x2F;；类体</p><p>继承“类名”的子类</p><p>}</p><p>对象只能使用一次。</p><p><strong>异常：</strong></p><p>try catch final（<strong>final块一定会执行</strong>）</p><p>常用异常类：</p><p>空指针异常类：NullPointerException</p><p>类型强制转换异常：ClassCastException</p><p>数组负下标异常：NegativeArrayException</p><p>数组下标越界异常：ArrayIndexOutOfBoundsException</p><h1 id="第6章-OOP程序设计的基本原则"><a href="#第6章-OOP程序设计的基本原则" class="headerlink" title="第6章.OOP程序设计的基本原则"></a>第6章.OOP程序设计的基本原则</h1><p>知识点：了解就行</p><ul><li>对象的抽象+ 单一职责原则+ 迪米特原则+ 接口隔离原则+ 开放-封闭原则+ 里氏替换原则+ 合成&#x2F;聚合复用原则</li></ul><h1 id="第7章-常用类"><a href="#第7章-常用类" class="headerlink" title="第7章 常用类"></a>第7章 常用类</h1><p>常用的方法在java.md里面有。</p><p>知识点：</p><ul><li>String类+ StringBuffer类+ String类与StringBuffer类比较+ StringTokenizer类+ 日期类（Date、Calendar）</li></ul><p><strong>String类和StringBuffer类：</strong></p><p>String类定义字符串<strong>常量</strong>对象，可以直接定义，也可以用构造方法定义。StringBuffer类对象必须使用构造方法定义。</p><p>String的内容<strong>一旦声明不可改变</strong>，如果要改变，改变的是String的引用地址。</p><p>用StringBuffer创建的字符串对象<strong>可以修改</strong>。并且所有的修改都直接发生在包含该字符串的缓冲区上。</p><p><strong>日期类（Date、Calendar）：</strong></p><p>Date类可以得到一个完整的日期，但是日期格式不符合平常看到的格式，时间也不能精确到毫秒，要想按照用户自己的格式显示时间可以使用Calender类完成操作。Date类取得的时间是一个正确的时间，但显示格式不符合习惯，可以利用DateFormat类进行格式化。</p><p>Calender可以将取得的时间精确到毫秒，但是此类是抽象类，要想使用抽象类，必须依靠对象的多态性，通过子类进行父类得实例化操作，其子类是GregorianCalender，在Calender中提供了部分常量，分别表示日期的各个数字。</p><h1 id="第8章-图形界面设计"><a href="#第8章-图形界面设计" class="headerlink" title="第8章 图形界面设计"></a>第8章 图形界面设计</h1><p>不考，java swing</p><h1 id="第9章-Java输入和输出"><a href="#第9章-Java输入和输出" class="headerlink" title="第9章 Java输入和输出"></a>第9章 Java输入和输出</h1><p>知识点：代码见java.md</p><ul><li>文件操作：File+ 字节流：InputStream和OutputStream+ 字符流：Reader和Writer</li></ul><h1 id="第10章多线程"><a href="#第10章多线程" class="headerlink" title="第10章多线程"></a>第10章多线程</h1><p>见Java.md：Java并发编程、wait、notify、notifyAll，JDBC</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java继承</title>
      <link href="/2023/06/20/java-ji-cheng/"/>
      <url>/2023/06/20/java-ji-cheng/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Student</span> s <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">"hahaha"</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">89</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">protected</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>    <span class="token keyword">protected</span> <span class="token keyword">int</span> age<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token keyword">int</span> age<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token keyword">extends</span> <span class="token class-name">Person</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">protected</span> <span class="token keyword">int</span> score<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token keyword">int</span> age<span class="token punctuation">,</span> <span class="token keyword">int</span> score<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>score <span class="token operator">=</span> score<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的代码编译会出错，原因是父类没有合适的构造方法来调用初始化三个参数的构造函数。</p><p>在继承的时候，如果不显式指定父类的构造方法，会自动调用super()方法；</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token keyword">extends</span> <span class="token class-name">Person</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">protected</span> <span class="token keyword">int</span> score<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token keyword">int</span> age<span class="token punctuation">,</span> <span class="token keyword">int</span> score<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> age<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>score <span class="token operator">=</span> score<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>改为这样就可以运行了。</p><h2 id="阻止继承"><a href="#阻止继承" class="headerlink" title="阻止继承"></a>阻止继承</h2><h3 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h3><p><strong>1、sealed关键字：</strong>下面的就是说明了Person只可以由Man，和Woman两个类继承，不可以随便继承</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">public sealed class Person permits Man, Women <span class="token punctuation">&#123;</span>    <span class="token punctuation">..</span>.<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>2、 final关键字：</strong>Man是最后的儿子，他不可以被其他类继承。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">public final class Man extends Penson<span class="token punctuation">&#123;</span>    <span class="token punctuation">..</span>.<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="向上转型（upcasting）"><a href="#向上转型（upcasting）" class="headerlink" title="向上转型（upcasting）"></a>向上转型（upcasting）</h2><p>比如上面的Person：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Person</span> p<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Student</span> stu <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Person</span> p1<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// upcasting, ok</span><span class="token class-name">Object</span> ob1<span class="token operator">=</span>p<span class="token punctuation">;</span> <span class="token comment">// upcasting, ok</span><span class="token class-name">Object</span> ob2<span class="token operator">=</span>stu<span class="token punctuation">;</span> <span class="token comment">// upcasting, ok</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这种指向是可以的，父类指向子类（反过来是不可以的）。</p><p><strong>注意：上面的例子的继承树是这样子的：Student&gt;Person&gt;object（所以叫做向上转型），在java中所有的类都是继承于object。</strong></p><h2 id="向下转型（downcasting）"><a href="#向下转型（downcasting）" class="headerlink" title="向下转型（downcasting）"></a>向下转型（downcasting）</h2><p>例子：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Person</span> p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// upcasting, ok</span><span class="token class-name">Person</span> p2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Student</span> stu1 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Student</span><span class="token punctuation">)</span> p1<span class="token punctuation">;</span> <span class="token comment">// ok</span><span class="token class-name">Student</span> stu2 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Student</span><span class="token punctuation">)</span> p2<span class="token punctuation">;</span> <span class="token comment">// runtime error! ClassCastException!</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="instanceof操作符"><a href="#instanceof操作符" class="headerlink" title="instanceof操作符"></a><code>instanceof</code>操作符</h2><p>为了避免向下转型出错，Java提供了<code>instanceof</code>操作符，可以先判断一个实例究竟是不是某种类型：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Person p <span class="token operator">=</span> new Person<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System.out.println<span class="token punctuation">(</span>p instanceof Person<span class="token punctuation">)</span><span class="token punctuation">;</span> // <span class="token boolean">true</span>System.out.println<span class="token punctuation">(</span>p instanceof Student<span class="token punctuation">)</span><span class="token punctuation">;</span> // <span class="token boolean">false</span>Student s <span class="token operator">=</span> new Student<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System.out.println<span class="token punctuation">(</span>s instanceof Person<span class="token punctuation">)</span><span class="token punctuation">;</span> // <span class="token boolean">true</span>System.out.println<span class="token punctuation">(</span>s instanceof Student<span class="token punctuation">)</span><span class="token punctuation">;</span> // <span class="token boolean">true</span>Student n <span class="token operator">=</span> null<span class="token punctuation">;</span>System.out.println<span class="token punctuation">(</span>n instanceof Student<span class="token punctuation">)</span><span class="token punctuation">;</span> // <span class="token boolean">false</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>instanceof</code>实际上判断一个变量所指向的实例是否是指定类型，或者这个类型的子类。如果一个引用变量为<code>null</code>，那么对任何<code>instanceof</code>的判断都为<code>false</code>。</p><p>利用<code>instanceof</code>，在向下转型前可以先判断：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Person p <span class="token operator">=</span> new Student<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>p instanceof Student<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    // 只有判断成功才会向下转型:    Student s <span class="token operator">=</span> <span class="token punctuation">(</span>Student<span class="token punctuation">)</span> p<span class="token punctuation">;</span> // 一定会成功<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础之args参数（命令行参数）</title>
      <link href="/2023/06/20/java-ji-chu-zhi-args-can-shu-ming-ling-xing-can-shu/"/>
      <url>/2023/06/20/java-ji-chu-zhi-args-can-shu-ming-ling-xing-can-shu/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="String-args"><a href="#String-args" class="headerlink" title="String[] args"></a>String[] args</h2><p>Java程序的入口是main方法，而且main方法要接受一个<strong>命令行参数</strong>，它是一个String[]数组，这个命令由JVM接受用户并且传给main方法。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// System.out.println(args[0]);</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">String</span> arg <span class="token operator">:</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token string">"-version"</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"v 1.0"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们可以利用这个参数来打印java -version，实现的效果就是打印v 1.0；</p><p>要利用args参数要在<strong>终端窗口</strong>运行：</p><p>1、首先在Main.java的目录下打开终端</p><p>2、输入命令：<strong>javac Main.java</strong>，生成Main.class</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ javac Main.java<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>3、再次输入命令：<strong>java Main -version，</strong>就可以打印v 1.0，这里就相当于执行的时候给Main传入了参数-version给args。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">java</span> Main <span class="token parameter variable">-version</span><span class="token function">v</span> <span class="token number">1.0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这个是<strong>我的终端</strong>下的运行情况。 </p><p><img src="https://img-blog.csdnimg.cn/2f9aa7269d614bd09e74476911b10ce6.png"></p><p> </p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java的输入和输出</title>
      <link href="/2023/06/20/java-de-shu-ru-he-shu-chu/"/>
      <url>/2023/06/20/java-de-shu-ru-he-shu-chu/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><p><strong>写在前面：</strong></p><p>最近在切换平台来记录我的学习，而且马上期末考试了，复习的任务有点重，要抓紧复习，所以写博客的时间大大减少了。But I will continue to study. </p><p>1、在java代码中总是出现System.out.println(xxx);其实println是print line的缩写，表示的意思是输出并且换行。</p><p>2、如果输出后不想换行，可以使用print();</p><h2 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h2><p>1、由于计算机能看懂的我们不一定可以看懂所以就有了格式化的输出，让我们很好的知道输出的是什么。</p><p>（1）使用println来实现格式化输出。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token number">12800000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//输出：1.28E7</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>（2）还有可以使用像c语言类似的函数printf(“%?\n”,xxx)；</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span><span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">double</span> pi<span class="token operator">=</span><span class="token number">3.141592654</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%.2f\n"</span><span class="token punctuation">,</span> pi<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//显示2位小数,3.14</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%.5f\n"</span><span class="token punctuation">,</span> pi<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//显示5位小数,3.14159</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>格式化输出</strong><br><strong>占位符****说明</strong>%d格式化输出整数%x格式化输出16进制数%f格式化输出浮点数%e格式化输出以科学计数法表示的数%s格式化输出字符串</p><p>详细的格式化参数可以去参考JDK文档<a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Formatter.html#syntax">java.util.Formatter</a>。</p><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><p>输入对比输出就比较复杂了，我们直接看一个例子</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Scanner</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span><span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token class-name">Scanner</span> scanner <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Scanner</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//创建Scanner对象</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Input your name: "</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//打印提示</span>        <span class="token class-name">String</span> name <span class="token operator">=</span> scanner<span class="token punctuation">.</span><span class="token function">nextLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//读取一行并获取字符串保存在name变量中</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Input your age: "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> age <span class="token operator">=</span> scanner<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//读取一行并保存信息在age中</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Hi, %s, you are %d\n"</span><span class="token punctuation">,</span> name<span class="token punctuation">,</span> age<span class="token punctuation">)</span><span class="token punctuation">;</span>格式化输出    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>首先，我们通过<code>import</code>语句导入<code>java.util.Scanner</code>，<code>import</code>是导入某个类的语句，必须放到Java源代码的开头，现在我还没有学习到。</p><p>然后，创建<code>Scanner</code>对象并传入<code>System.in</code>。<code>System.out</code>代表标准输出流，而<code>System.in</code>代表标准输入流。直接使用<code>System.in</code>读取用户输入虽然是可以的，但需要更复杂的代码，而通过<code>Scanner</code>就可以简化后续的代码。</p><p>有了<code>Scanner</code>对象后，要读取用户输入的字符串，使用<code>scanner.nextLine()</code>，要读取用户输入的整数，使用<code>scanner.nextInt()</code>。<code>Scanner</code>会自动转换数据类型，因此不必手动转换。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript知识点(根据例子来学习)</title>
      <link href="/2023/06/20/javascript-zhi-shi-dian-gen-ju-li-zi-lai-xue-xi/"/>
      <url>/2023/06/20/javascript-zhi-shi-dian-gen-ju-li-zi-lai-xue-xi/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="立即执行函数"><a href="#立即执行函数" class="headerlink" title="立即执行函数"></a>立即执行函数</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token punctuation">(</span><span class="token function">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>document<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">"通常将匿名函数与事件处理程序一起使用"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="input标签、rowspan"><a href="#input标签、rowspan" class="headerlink" title="input标签、rowspan"></a>input标签、rowspan</h2><pre class="line-numbers language-none"><code class="language-none">&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;meta charset&#x3D;&quot;utf-8&quot;&gt;    &lt;title&gt;shiyan&lt;&#x2F;title&gt;    &lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;.&#x2F;page1.css&quot;&gt;&lt;&#x2F;head&gt;&lt;body&gt;    id 前台拿数据，name 后台拿数据    时间：&lt;input type&#x3D;&quot;time&quot; placeholder&#x3D;&quot;请输入时间&quot; autofocus&gt;&lt;br&gt;    日期：&lt;input type&#x3D;&quot;date&quot; placeholder&#x3D;&quot;请输入日期&quot;&gt;&lt;br&gt;    数字：&lt;input type&#x3D;&quot;number&quot; placeholder&#x3D;&quot;输入数字&quot; value&#x3D;&quot;0&quot; max&#x3D;&quot;100&quot; min&#x3D;&quot;-100&quot; step&#x3D;&quot;20&quot;&gt;&lt;br&gt;    日期时间:&lt;input type&#x3D;&quot;datetime_local&quot; placeholder&#x3D;&quot;日期时间&quot;&gt;    搜索：&lt;input type&#x3D;&quot;search&quot; required pattern&#x3D;&quot;[0-9][a-z]&#123;2&#125;&quot;&gt;!!!!!!!!!!!!!!    邮箱：&lt;input type&#x3D;&quot;email&quot;&gt;    网址：&lt;input type&#x3D;&quot;url&quot;&gt;    滑块：&lt;input type&#x3D;&quot;range&quot;&gt;    颜色：&lt;input type&#x3D;&quot;color&quot;&gt;    音频:loop autopaly, muted    (10.21)：&lt;audio src&#x3D;&quot;&quot; controls&gt;&lt;&#x2F;audio&gt;    视频：    &lt;video src&#x3D;&quot;&quot; controls&gt;&lt;&#x2F;video&gt;    &lt;table border&#x3D;&quot;1&quot; &gt;        &lt;tr&gt;            &lt;th&gt;分类&lt;&#x2F;th&gt;            &lt;th&gt;技能&lt;&#x2F;th&gt;            &lt;th&gt;分数&lt;&#x2F;th&gt;        &lt;&#x2F;tr&gt;        &lt;tr&gt;            &lt;td rowspan&#x3D;&quot;3&quot;&gt;编程语言&lt;&#x2F;td&gt;            &lt;td&gt;JavaScript&lt;&#x2F;td&gt;            &lt;td&gt;8&lt;&#x2F;td&gt;        &lt;&#x2F;tr&gt;        &lt;tr&gt;            &lt;td&gt;C++&lt;&#x2F;td&gt;            &lt;td&gt;7&lt;&#x2F;td&gt;        &lt;&#x2F;tr&gt;        &lt;tr&gt;            &lt;td&gt;Swift&lt;&#x2F;td&gt;            &lt;td&gt;8&lt;&#x2F;td&gt;        &lt;&#x2F;tr&gt;        &lt;tr&gt;            &lt;td rowspan&#x3D;&quot;2&quot;&gt;产品设计&lt;&#x2F;td&gt;            &lt;td&gt;PhotoShop&lt;&#x2F;td&gt;            &lt;td&gt;6&lt;&#x2F;td&gt;        &lt;&#x2F;tr&gt;        &lt;tr&gt;            &lt;td&gt;Axure&lt;&#x2F;td&gt;            &lt;td&gt;5&lt;&#x2F;td&gt;        &lt;&#x2F;tr&gt;        &lt;tr&gt;            &lt;td rowspan&#x3D;&quot;2&quot;&gt;销售&lt;&#x2F;td&gt;            &lt;td&gt;社交媒体&lt;&#x2F;td&gt;            &lt;td&gt;3&lt;&#x2F;td&gt;        &lt;&#x2F;tr&gt;        &lt;tr&gt;            &lt;td&gt;C++&lt;&#x2F;td&gt;            &lt;td&gt;7&lt;&#x2F;td&gt;        &lt;&#x2F;tr&gt;    &lt;&#x2F;table&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="选择器、伪类选择器a-hover"><a href="#选择器、伪类选择器a-hover" class="headerlink" title="选择器、伪类选择器a:hover"></a>选择器、伪类选择器a:hover</h2><pre class="line-numbers language-none"><code class="language-none">&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;style&gt;        p &#123;            background-color: orange;        &#125;        #p2 &#123;            color: red;            background-color: cadetblue;        &#125;        .para &#123;            color: blue;        &#125;        p.para2 &#123;            color: aliceblue;        &#125;        #div h2&#123;            color:aqua;            background:gray;        &#125;        &#x2F;* 未访问前 *&#x2F;        a:link&#123;            color:pink;        &#125;        &#x2F;* 访问以后 *&#x2F;        a:visited&#123;            color:aqua;        &#125;        &#x2F;* 鼠标悬停 *&#x2F;        a:hover&#123;            color:firebrick;            font-size: 30px;        &#125;        &#x2F;* 点中时 *&#x2F;        a:active&#123;            color:red;        &#125;            &lt;&#x2F;style&gt;&lt;&#x2F;head&gt;&lt;body&gt;        &lt;p id&#x3D;&quot;p1&quot;&gt;这是一个段落&lt;&#x2F;p&gt;    &lt;hr&gt;    &lt;p class&#x3D;&quot;para&quot; id&#x3D;&quot;p2&quot;&gt;这是第二个段落&lt;&#x2F;p&gt;    &lt;hr&gt;    &lt;p class&#x3D;&quot;para2&quot;&gt;这是三个段落&lt;&#x2F;p&gt;    &lt;div id&#x3D;&quot;div&quot;&gt;        &lt;h2&gt;标题1&lt;&#x2F;h2&gt;        &lt;h2&gt;标题1&lt;&#x2F;h2&gt;        &lt;h2&gt;标题1&lt;&#x2F;h2&gt;        &lt;h2&gt;标题1&lt;&#x2F;h2&gt;    &lt;&#x2F;div&gt;    &lt;a href&#x3D;&quot;https:&#x2F;&#x2F;www.baidu.com&quot;&gt;百度链接&lt;&#x2F;a&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><pre class="line-numbers language-none"><code class="language-none">&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset&#x3D;&quot;utf-8&quot;&gt;&lt;title&gt;&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;函数1、函数定义 与调用2、函数参数 、arguments3、return 返回值 结束4、作用域  ：全局变量 、局部变量&lt;br&gt;&lt;button name&#x3D;&quot;button&quot; id&#x3D;&#39;btn1&#39;&gt;点击&lt;&#x2F;button&gt;&lt;br&gt;&lt;br&gt;&lt;script&gt;&#x2F;&#x2F;1 定义 方法1 &#x2F;&#x2F; document.write(&quot;123&quot;);&#x2F;&#x2F;方法2  函数表达式  (匿名函数)var w&#x3D;function()&#123;document.write(&quot;通常将匿名函数与事件处理程序一起使用&quot;)&#125;&#x2F;&#x2F; w();&#x2F;&#x2F; document.write(&quot;123&quot;)&#x2F;&#x2F;通常将匿名函数与事件处理程序一起使用btn1.onlick&#x3D;function()&#123;w();&#125;;&#x2F;&#x2F;自调用函数-立即执行函数(function()&#123;document.write(&quot;通常将匿名函数与事件处理程序一起使用&quot;)&#125;)();document.write(&quot;&lt;br&gt;&quot;)&#x2F;&#x2F;2 函数参数  直接写形参名字function write(name1, name)&#123;document.write(&quot;hello,&quot;+name1+&quot;&lt;br&gt;&quot;);document.write(&quot;hello,&quot;+name+&quot;&lt;br&gt;&quot;);&#125;write(123,23)&#x2F;&#x2F;实参个数多于形参:只出现前面的&#x2F;&#x2F; write(1,2,3,4)&#x2F;&#x2F;实参少于形参:出现undefined&#x2F;&#x2F; write(123)&#x2F;&#x2F; arguments 对象&#x2F;&#x2F; 函数有一个名为 arguments 的内置对象。实参赋给形参使用这个参数来接收.&#x2F;&#x2F;arguments 对象类似于数组的结构（可以遍历，可以用下标访问）。&#x2F;&#x2F;如果函数调用的参数太多，则可以使用 arguments 对象来得到这些参数。function f(a, b)&#123;&#x2F;&#x2F; document.write(arguments.length+&quot;&lt;br&gt;&quot;)&#x2F;&#x2F; document.write(arguments[0]+&quot;&lt;br&gt;&quot;)&#x2F;&#x2F; document.write(arguments[1]+&quot;&lt;br&gt;&quot;)&#x2F;&#x2F; document.write(arguments[3])var max&#x3D;arguments[0]for(var i&#x3D;1; i&lt;arguments.length; i++)&#123;if(arguments[i]&gt;max)max&#x3D;arguments[i]&#125;document.write(max)&#125;f(1,2,234,3)document.write(&quot;&lt;br&gt;&quot;)var m &#x3D; new Map([[1, &#39;x&#39;], [2, &#39;y&#39;], [3, &#39;z&#39;]]);m.forEach(function (value, key, map) &#123;document.write(value+key+map+&quot;&lt;br&gt;&quot;);&#125;);&lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h2><pre class="line-numbers language-none"><code class="language-none">&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset&#x3D;&quot;utf-8&quot;&gt;&lt;title&gt;&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;JavaScript 中，变量的作用域有 全局作用域 和 局部作用域 两种。1、全局变量   函数外定义的变量   没有用 var定义的变量(let)   window对象定义的变量(window.c&#x3D;1)2、局部变量  函数内用var定义的变量              形参变量的生命周期全局变量活得和您的应用程序（窗口、网页）一样久。局部变量活得不长。它们在函数调用时创建，在函数完成后被删除。&lt;script&gt;&#x2F;&#x2F;1  全局变量var str1&#x3D;&quot; 1我是全局&quot;document.write(str1)function fn1()&#123;var str2&#x3D;&quot;我是局部&quot;  &#x2F;&#x2F;2  局部变量  使用var在函数内部定义的变量let s&#x3D;&quot;123&quot;&#125;fn1();console.log(str1);&#x2F;&#x2F; console.log(s);&#x2F;&#x2F;6  以下程序运行结果是:&#x2F;&#x2F;对Js而言，只要变量是在同一个范围（函数）里，就视为已经声明，&#x2F;&#x2F;哪怕是在变量声明前就使用&#x2F;* var num1&#x3D;10;function fn2()&#123;&#x2F;&#x2F;因为num1是局部的 fn1内部的。所以提升到fn1函数最前面声明console.log(num1);&#x2F;&#x2F;输出？undefinedvar num1&#x3D;20;&#125;fn2()*&#x2F;var a&#x3D;&quot;1111&quot;function fn3()&#123;console.log(a);var a&#x3D;&quot;2222&quot;console.log(a);&#125;fn3();&lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="获取元素"><a href="#获取元素" class="headerlink" title="获取元素"></a>获取元素</h2><pre class="line-numbers language-none"><code class="language-none">&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset&#x3D;&quot;utf-8&quot;&gt;&lt;title&gt;&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;查找元素方法：1 通过 id 查找元素&lt;br&gt;&lt;p id&#x3D;&quot;intro&quot;&gt;Hello!&lt;&#x2F;p&gt;&lt;button name&#x3D;&quot;button&quot; id&#x3D;&#39;btn0&#39;&gt;确定&lt;&#x2F;button&gt;&lt;script&gt;var p &#x3D; document.getElementById(&quot;para&quot;);&#x2F;&#x2F; document.write();var btn0 &#x3D; document.getElementById(&quot;btn0&quot;);btn0.click &#x3D; function () &#123;document.write(&quot;nihao&quot;);&#125;&lt;&#x2F;script&gt;&lt;hr&gt;2、通过标签名查找元素&lt;br&gt;&lt;ul&gt;&lt;li&gt;【#回应何时开学#】&lt;&#x2F;li&gt;&lt;li&gt;【#回应何时开学#】&lt;&#x2F;li&gt;&lt;li&gt;【#回应何时开学#】&lt;&#x2F;li&gt;&lt;li&gt;【#回应何时开学#】&lt;&#x2F;li&gt;&lt;li&gt;【#回应何时开学#】&lt;&#x2F;li&gt;&lt;li&gt;【#回应何时开学#】&lt;&#x2F;li&gt;&lt;&#x2F;ul&gt;&lt;script&gt;var lis &#x3D; document.getElementsByTagName(&#39;li&#39;);console.log(lis);for (var i &#x3D; 0; i &lt; lis.length; i++) &#123;if (i % 2 &#x3D;&#x3D; 0) &#123;lis[i].style.background &#x3D; &quot;blue&quot;;&#125;&#125;&lt;&#x2F;script&gt;&lt;hr&gt;3 html5新增的 通过 CSS 选择器查找 HTML 元素:&lt;br&gt;querySelectorAll() 方法 :查找匹配指定 CSS 选择器（id、类名、标签等）的所有 HTML 元素&lt;br&gt;querySelector() 方法 :查找匹配指定 CSS 选择器的第一个 HTML 元素&lt;br&gt;&lt;p id&#x3D;&quot;p1&quot;&gt;Hello!&lt;&#x2F;p&gt;&lt;button name&#x3D;&quot;button&quot; id&#x3D;&#39;btn1&#39;&gt;确定&lt;&#x2F;button&gt;&lt;p class&#x3D;&quot;imp&quot;&gt;Hello!&lt;&#x2F;p&gt;&lt;p class&#x3D;&quot;imp&quot;&gt;world!&lt;&#x2F;p&gt;&lt;script&gt;&#x2F;&#x2F;querySelectorAll() 方法  获得class为imp的元素   .不能少var p1 &#x3D; document.querySelectorAll(&#39;.imp&#39;)console.log(p1)&#x2F;&#x2F;querySelector（）方法   获得id为btn1的元素 #不能少var p2 &#x3D; document.querySelector(&#39;#btn1&#39;)console.log(p2)var ps &#x3D; document.querySelectorAll(&quot;.imp&quot;);console.log(ps);ps[1].innerHTML &#x3D; &quot;123456789&quot;;&lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><pre class="line-numbers language-none"><code class="language-none">&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset&#x3D;&quot;utf-8&quot;&gt;&lt;title&gt;面向对象&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;1、什么是JavaScript对象？对象是有(属性)和(方法)的集合。2、创建对象的三种方式：&lt;br&gt;01、使用new object()方式&lt;script&gt;&#x2F;&#x2F;创建var person &#x3D; new Object();&#x2F;&#x2F; console.log(person)&#x2F;&#x2F; console.log(typeof(person))&#x2F;&#x2F;设置属性和方法 person.name&#x3D;&quot;123&quot;person.age &#x3D; 18;&#x2F;&#x2F;设置方法 person.say&#x3D;function()&#123;console.log(&quot;say&quot;)&#125;&#x2F;&#x2F;访问属性&#x2F;&#x2F; console.log(person.name)&#x2F;&#x2F; console.log(person.age)&#x2F;&#x2F;调用方法&#x2F;&#x2F; person.say()&lt;&#x2F;script&gt;&lt;br&gt; 01 使用字面量定义var 对象&#x3D;&#123;&#x2F;&#x2F;键值对的形式  键 属性名 ：值 属性值，属性名 ：值，&#x2F;&#x2F;方法 冒号后面跟着一个匿名函数。方法:function()&#123;&#125;&#125;&lt;script&gt;var person &#x3D; &#123;name:&quot;123&quot;,age:123,say:function()&#123;console.log(&quot;say&quot;)&#125;&#125;&#x2F;&#x2F; person.say()&lt;&#x2F;script&gt;&lt;br&gt;3、使用自定义的构造函数声明多个类型特点一致的对象&#x2F;&#x2F;构造函数的语法格式：&#x2F;&#x2F; function 构造函数名()&#123;&#x2F;&#x2F; this.属性&#x3D;值;&#x2F;&#x2F; this.方法&#x3D;function()&#123;&#125;&#x2F;&#x2F; &#125;&#x2F;&#x2F;new 构造函数名(); 函数名首字母要大写&lt;script&gt;&#x2F;&#x2F;1创建构造函数function Person(name, age)&#123;&#x2F;&#x2F; console.log(this);this.name &#x3D; name;this.age &#x3D; age;this.say&#x3D;function()&#123;console.log(&quot;say&quot;)&#125;&#125;&#x2F;&#x2F;2通过构造函数new对象var p1 &#x3D; new Person(&quot;hzy&quot;, 18)var p2 &#x3D; new Person(&quot;hhh&quot;, 21)&#x2F;&#x2F; console.log(p1.say())&#x2F;&#x2F; p2.say()&#x2F;&#x2F;3属性访问访问2:[&#39;属性名&#39;]&#x2F;&#x2F; console.log(p1[&#39;name&#39;])&#x2F;&#x2F;01什么时候 必须用[&#39;属性名&#39;]&#x2F;&#x2F;属性名里包含特殊字符:var obj&#x3D;&#123;&#125;obj[&#39;content-type&#39;]&#x3D;&#39;text&#x2F;css&#39;&#x2F;&#x2F; obj.c-c&#x3D;&#39;123&#39;&#x2F;&#x2F;错误&#x2F;&#x2F;属性名不确定var Name&#x3D;&#39;123&#39;obj.Name&#x3D;20;&#x2F;&#x2F; console.log(obj.Name)&#x2F;&#x2F; for in 遍历属性&#x2F;&#x2F;for(变量 in 对象)&#123;&#x2F;&#x2F;&#125;&#x2F;&#x2F; for(var i in obj)&#123;&#x2F;&#x2F; console.log(&#39;&#x3D;&#x3D;&#x3D;&#x3D;&#39;, i, obj.i)&#x2F;&#x2F;undefine&#x2F;&#x2F; console.log(&#39;&#x3D;&#x3D;&#x3D;&#x3D;&#39;, i, obj[i])&#x2F;&#x2F; &#125;&lt;&#x2F;script&gt;4、相关问题-对象赋值与引用内存：栈：局部变量  全局变量堆：对象&lt;script&gt;&#x2F;&#x2F;01基本数据类型 在内存中的存储var a&#x3D;10var b&#x3D;ab&#x3D;20;console.log(a)&lt;&#x2F;script&gt;&lt;script&gt;&#x2F;&#x2F;02复杂数据类型 在内存中存储var obj1&#x3D;&#123;name:&quot;Tom&quot;&#125;var obj2&#x3D;obj1obj1.name&#x3D;&#39;123&#39;console.log(obj2.name)&lt;&#x2F;script&gt;&lt;script&gt;&#x2F;&#x2F;03基本数据类型作为函数参数&lt;&#x2F;script&gt;&lt;script&gt;&#x2F;&#x2F;04复杂数据类型作为函数参数&lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Math库"><a href="#Math库" class="headerlink" title="Math库"></a>Math库</h2><pre class="line-numbers language-none"><code class="language-none">&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset&#x3D;&quot;utf-8&quot;&gt;&lt;title&gt;&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;Math 对象Math 对象用于执行数学任务。&lt;br&gt;使用 Math 的属性和方法的语法：&lt;br&gt;var pi_value&#x3D;Math.PI;var sqrt_value&#x3D;Math.sqrt(15);&lt;br&gt;&lt;br&gt;&lt;hr&gt;&lt;script&gt;var i;i&#x3D;Math.round(5&#x2F;2) &#x2F;&#x2F;四舍五入&#x2F;&#x2F;取整 向下取整i&#x3D;Math.floor(5&#x2F;2)&#x2F;&#x2F;绝对值Math.abs(-100)&#x2F;&#x2F;随机数 0-1之间i&#x3D;Math.random()&#x2F;&#x2F;产生0-10之间的随机数？i&#x3D;Math.random()*10&#x2F;&#x2F;产生5-10之间的随机数？i&#x3D;Math.random()*5+5&#x2F;&#x2F;公式：取x到y之间的随机数:;&#x2F;&#x2F;Math.random()*(y-x)+x&#x2F;&#x2F;问题：如何产生0到10之间的随机整数？&#x2F;&#x2F;方法：先产生0-    之间的随机数 然后        .document.write(i);&#x2F;&#x2F;alert(i);&#x2F;*练习  写一个随机点菜的小程序1 创建一个数组 2 随机产生数组下标3 将下标对应的数组元素 输出来.js中定义数组:var arr&#x3D;[&quot;鱼头豆腐&quot;,&quot;红烧排骨&quot;,&quot;土豆丝&quot;,&quot;西红柿鸡蛋汤&quot;,&quot;鸦片鱼头&quot;,&quot;小鸡炖蘑菇&quot;]*&#x2F;&lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h2><pre class="line-numbers language-none"><code class="language-none">&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset&#x3D;&quot;utf-8&quot;&gt;&lt;title&gt;&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;1、静态成员&lt;script&gt;function Person(name, age) &#123;this.name &#x3D; name;this.age &#x3D; age;&#x2F;&#x2F;静态属性 类名.属性if (!Person.count) &#123;Person.count &#x3D; 0;&#125;Person.count++;&#125;&#x2F;*设置一个属性 计算创建出多少对象  需要静态成员-判定在构造函数上的属性和方法*&#x2F;Person.print &#x3D; function()&#123;alert(&quot;创建了&quot;+Person.count+&quot;对象&quot;)&#125;var p1&#x3D;new Person(&#39;qwe&#39;, 123)var p2 &#x3D; new Person(&#39;qw&#39;, 1)console.log(Person.count)Person.print()&lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="特殊的引用类型：Boolean、Number-和-String"><a href="#特殊的引用类型：Boolean、Number-和-String" class="headerlink" title="特殊的引用类型：Boolean、Number 和 String"></a>特殊的引用类型：Boolean、Number 和 String</h2><pre class="line-numbers language-none"><code class="language-none">&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset&#x3D;&quot;utf-8&quot;&gt;&lt;title&gt;&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;为了便于操作基本类型值，js还提供了 3 个特殊的引用类型：Boolean、Number 和 String。Number 对象：基本包装类型  提供数字的对象（包括整数、浮点数等）1、NaN属性：非数字（(Not a Number)。）2、isNaN（）函数：判断是否为非数字3、toString()：把数字转为字符串4、把变量转换为数值这三种 JavaScript 方法可用于将变量转换为数字：Number() 方法  可用于把其他类型转换为数值parseInt() 方法 解析一段字符串并返回整型数值。允许空格。只返回首个数字：parseFloat() 方法  解析一段字符串并返回数值。允许空格。只返回首个数字：&lt;br&gt;&lt;br&gt;&lt;hr&gt;&lt;br&gt;&lt;script&gt;&#x2F;&#x2F;1 NaN属性&#x2F;&#x2F;document.writeln(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&lt;br&gt;&quot;)&#x2F;&#x2F;2  isNaN 判断是否为非数字&#x2F;&#x2F;3、toString()：把数字转为字符串&#x2F;&#x2F;n不是数字吗？怎么会有方法&#x2F;&#x2F; 4 Number() 方法  可用于把 其它类型转换为数值    &#x2F;&#x2F;布尔类型    &#x2F;&#x2F;数字组成的字符串&#x2F;&#x2F;日期对象 &#x2F;&#x2F;字母+数字字符串 &#x2F;&#x2F;5 parseInt() 方法 解析一段字符串并返回整型数值。允许空格。只返回首个数字&lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="静态成员-1"><a href="#静态成员-1" class="headerlink" title="静态成员"></a>静态成员</h2><pre class="line-numbers language-none"><code class="language-none">&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset&#x3D;&quot;utf-8&quot;&gt;&lt;title&gt;&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;1、静态成员&lt;script&gt;function Person(name, age) &#123;this.name &#x3D; name;this.age &#x3D; age;&#x2F;&#x2F;静态属性 类名.属性if (!Person.count) &#123;Person.count &#x3D; 0;&#125;Person.count++;&#125;&#x2F;*设置一个属性 计算创建出多少对象  需要静态成员-判定在构造函数上的属性和方法*&#x2F;Person.print &#x3D; function()&#123;alert(&quot;创建了&quot;+Person.count+&quot;对象&quot;)&#125;var p1&#x3D;new Person(&#39;qwe&#39;, 123)var p2 &#x3D; new Person(&#39;qw&#39;, 1)console.log(Person.count)Person.print()&lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="原型prototype"><a href="#原型prototype" class="headerlink" title="原型prototype"></a>原型prototype</h2><pre class="line-numbers language-none"><code class="language-none">&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset&#x3D;&quot;utf-8&quot;&gt;&lt;title&gt;&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;2、构造函数问题：存在浪费内存空间问题&lt;script&gt;function Person(name,age)&#123;this.name&#x3D;name;this.age&#x3D;age;this.say&#x3D;function()&#123;console.log(&#39;hello&#39;);&#125;&#125;&#x2F;&#x2F;浪费内存空间问题var p1 &#x3D; new Person(&#39;abc&#39;, 123)var p2 &#x3D; new Person(&#39;ab&#39;, 12)&#x2F;&#x2F; console.log(p1)&#x2F;&#x2F; console.log(p2)&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;严格相等&#x2F;&#x2F;如果两个值都引用同一个对象或是函数，那么相等，否则不相等&#x2F;&#x2F; console.log(p1.say&#x3D;&#x3D;&#x3D;p2.say)&lt;&#x2F;script&gt;3 构造函数原型prototype 通过原型来实现所有对象共享方法。&lt;script&gt;function Person(name,age)&#123;this.name&#x3D;name;this.age&#x3D;age;&#125;&#x2F;&#x2F;每个构造函数 都有一个prototype属性,指向另外一个对象.console.dir(Person)&#x2F;&#x2F;我们可以把共有的方法,直接定义在prototype对象上,让所有对象实例共享.&#x2F;&#x2F;通过原型添加方法Person.prototype.say &#x3D; function()&#123;alert(&quot;hello&quot;)&#125;var p1&#x3D;new Person(&quot;tom&quot;,10);var p2&#x3D;new Person(&quot;jerry&quot;,10);console.log(p1.say&#x3D;&#x3D;&#x3D;p2.say)&lt;&#x2F;script&gt;&lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="基于原型链的继承"><a href="#基于原型链的继承" class="headerlink" title="基于原型链的继承"></a>基于原型链的继承</h2><pre class="line-numbers language-none"><code class="language-none">&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset&#x3D;&quot;utf-8&quot;&gt;&lt;title&gt;&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;1 基于原型链的继承&lt;script&gt;function Person(age)&#123;this.age&#x3D;age&#125;Person.prototype.say&#x3D;function()&#123;alert(&#39;hello world&#39;);&#125;function Student()&#123;&#125;&#x2F;&#x2F;继承&#x2F;&#x2F;1 构造父类的实例var p1&#x3D;new Person(20)&#x2F;&#x2F;2 设置为子类的原型对象Student.prototype&#x3D;p1问题：Student.prototype.constructor指向哪个构造函数&#x2F;&#x2F; console.log(Student.prototype.constructor&#x3D;&#x3D;&#x3D;p1.constructor)&#x2F;&#x2F;3 修复子类函数原型的constructor指针即可Student.prototype.constructor&#x3D;Student;var stu1&#x3D;new Student()&#x2F;&#x2F; stu1.say()&#x2F;&#x2F; console.log(stu1.age)&lt;&#x2F;script&gt;&lt;br&gt;2 存在问题：实例共享引用类型，新创建的对象都有“玩游戏”这个变量，如p1、p2&lt;script&gt;function Parent() &#123;  this.newArr &#x3D; [&quot;唱歌&quot;, &quot;跑步&quot;];&#125;function Child() &#123;  this.name &#x3D; &quot;abc&quot;;&#125;Child.prototype &#x3D; new Parent()Child.prototype.constructor &#x3D; Child&#x2F;&#x2F; 对于属性不希望继承var p1 &#x3D; new Child()p1.newArr.push(&quot;玩游戏&quot;)&#x2F;&#x2F; console.log(p1.newArr);&#x2F;&#x2F;&#x2F;var p2 &#x3D; new Child();&#x2F;&#x2F; console.log(p2.newArr)&lt;&#x2F;script&gt;&lt;br&gt;3 call函数&lt;script&gt;&#x2F;&#x2F;call函数var demo1&#x3D;&#123;name:&#39;好人:&#39;,showABC:function(param1,param2)&#123;console.log(this.name,param1,param2)&#125;&#125;demo1.showABC(&#39;张三&#39;,&#39;李四&#39;)var demo2&#x3D;&#123;name:&#39;坏人&#39;&#125;&#x2F;&#x2F;call来让demo2对象 借用demo1的showABC方法demo1.showABC.call(demo2, &quot;1&quot;, &#39;2&#39;)&lt;&#x2F;script&gt;&lt;br&gt;4 利用构造函数继承属性&lt;script&gt;function Father(uname,age)&#123;this.uname&#x3D;uname;this.age&#x3D;age;console.log(uname, age)&#125;&#x2F;&#x2F; Son想要继承Father的属性function Son(name, age)&#123;Father.call(this, name, age)&#125;console.log(Son(12, 2))&lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="对象原型proto"><a href="#对象原型proto" class="headerlink" title="对象原型proto"></a>对象原型proto</h2><pre class="line-numbers language-none"><code class="language-none">&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset&#x3D;&quot;utf-8&quot;&gt;&lt;title&gt;&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;4 对象原型__proto__请问为什么对象 可以访问原型里的方法？原因：每个对象都有一个属性__proto__指向原型prototype,所以可以使用原型对象里的方法&lt;script&gt;function Person(name,age)&#123;this.name&#x3D;name;this.age&#x3D;age;&#125;Person.prototype.sayHello &#x3D; function()&#123;alert(&quot;Hello&quot;)&#125;var p1&#x3D;new Person(&quot;tom&quot;,10);var p2&#x3D;new Person(&quot;jerry&quot;,10);&#x2F;&#x2F; 输出__proto__属性&#x2F;&#x2F; console.log(p1.__proto__)&#x2F;&#x2F; console.log(p1.__proto__&#x3D;&#x3D;&#x3D;p2.__proto__)&lt;&#x2F;script&gt;&lt;br&gt;5 原型对象的constructor构造函数原型对象里面都有一个属性constructor属性,constructor我们称为构造函数因为它指回构造函数本身.&lt;script&gt;&#x2F;&#x2F; console.log(Person.prototype.constructor)&#x2F;&#x2F;有时候 我们需要用写代码让constructor指向原来的构造函数Person.prototype &#x3D; &#123;eat: function()&#123;&#125;,study:function()&#123;&#125;,toString:function()&#123;&#125;&#125;&#x2F;&#x2F; Person.prototype.toString &#x3D; function()&#123;&#x2F;&#x2F; alert(&quot;alert&quot;)&#x2F;&#x2F; &#125;&#x2F;&#x2F;打印 constructor指向了?&#x2F;&#x2F; consoel.log(Person.prototype.constructor)&#x2F;&#x2F;可以手动让constructor指向原来的构造函数&#x2F;&#x2F; 父亲的父亲的父亲&#x2F;&#x2F; null 继承console.log(p1.__proto__.toString()&#x3D;&#x3D;&#x3D;p1.__proto__.__proto__.toString())console.log(p1.__proto__.__proto__.toString())&lt;&#x2F;script&gt;&lt;br&gt;6 原型对象的应用  扩展内置对象方法  数组也有原型对象&lt;script&gt;Array.prototype.sun &#x3D; function()&#123;var sum&#x3D;0for(var i&#x3D;0; i&gt;this.length; i++)&#123;sum+&#x3D;i;&#125;console.log(&#39;sum: &#39;+sum)return sum&#125;var arr &#x3D; [1, 2, 3, 4, 5]console.log(arr.__proto__)&lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="ES6的类"><a href="#ES6的类" class="headerlink" title="ES6的类"></a>ES6的类</h2><pre class="line-numbers language-none"><code class="language-none">&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;    &lt;title&gt;上课&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;    1、箭头函数    &lt;script&gt;        var fn &#x3D; function()&#123;            console.log(&quot;1&quot;)        &#125;        var fn1&#x3D;()&#x3D;&gt;&#123;            console.log(&quot;fn1&quot;)        &#125;        &#x2F;&#x2F; fn()        &#x2F;&#x2F; fn1()    &lt;&#x2F;script&gt;    &lt;br&gt;    2、es6中标准的类    &lt;script&gt;        class Person&#123;            name&#x3D;&quot;23&quot;            age&#x3D;&quot;20&quot;            &#x2F;&#x2F; say&#x3D;function()&#123;            &#x2F;&#x2F;     console.log(name, age)            &#x2F;&#x2F; &#125;            &#x2F;&#x2F;将函数直接添加到原型Prototype上面            say()&#123;                console.log(name, age)            &#125;        &#125;        var p1 &#x3D; new Person()        &#x2F;&#x2F; console.log(p1)        &#x2F;&#x2F; console.log(p1.prototype&#x3D;&#x3D;&#x3D;p1.__proto__)    &lt;&#x2F;script&gt;    &lt;br&gt;    3、静态成员    &lt;script&gt;        class Student&#123;            name&#x3D;&quot;2&quot;            static count&#x3D;0            static doCount()&#123;                if(!Student.count)&#123;                    Student.count&#x3D;0                &#125;                Student.count++                console.log(&quot;当前对象的个数是&quot;+Student.count)            &#125;        &#125;        var s1 &#x3D; new Student();        &#x2F;&#x2F; Student.doCount()        var s1&#x3D;new Student();        &#x2F;&#x2F; Student.doCount()        &#x2F;&#x2F; console.log(s1&#x3D;&#x3D;&#x3D;s1)    &lt;&#x2F;script&gt;    &lt;br&gt;    4、类中的构造函数    &lt;script&gt;        class Teacher&#123;            &#x2F;&#x2F; name&#x3D;&quot;tea&quot;            &#x2F;&#x2F; age&#x3D;999            &#x2F;&#x2F;私有属性 #+属性名            #name            #age            getAge()&#123;                return this.#age            &#125;            set age(age)&#123;                if(age&gt;0 &amp;&amp; age&lt;200)                    this.#age&#x3D;age                else                    console.log(&quot;数据错误&quot;)            &#125;            get name()&#123;                return this.#name            &#125;            set name(name)&#123;                this.#name&#x3D;name            &#125;            constructor(name, age)&#123;&#x2F;&#x2F;可以不用写属性                this.#name&#x3D;name                this.#age&#x3D;age            &#125;            &#x2F;&#x2F; Uncaught SyntaxError: A class may only have one constructor            &#x2F;&#x2F; constructor(name, age, ls)&#123;            &#x2F;&#x2F;     this.name&#x3D;name            &#x2F;&#x2F;     this.age&#x3D;age            &#x2F;&#x2F;     this.ls &#x3D; ls            &#x2F;&#x2F; &#125;            say()&#123;                console.log(this.name, this.age, this.#name, this.#age)&#x2F;&#x2F;            &#125;        &#125;        var t1 &#x3D; new Teacher(&quot;t&quot;, 123, &quot;2&quot;,&#39;23&#39;)        &#x2F;&#x2F; console.log(t1.getAge())        &#x2F;&#x2F; t1.say()        &#x2F;&#x2F; t1.age&#x3D;10        &#x2F;&#x2F; t1.say()        &#x2F;&#x2F; console.log(t1.age2)    &lt;&#x2F;script&gt;    &lt;br&gt;    5、继承    &lt;script&gt;        class S extends Teacher&#123;            constructor(name, age)&#123;                super(name, age)                            &#125;            say()&#123;                console.log(this.age)            &#125;        &#125;        var s &#x3D; new S(&#39;2&#39;, &#39;3&#39;)        &#x2F;&#x2F; s.say()        console.log(S.prototype)        console.log(S.__proto__)        console.log(S.__proto__.__proto__)        console.log(S.__proto__.__proto__.__proto__)        console.log(S.__proto__.__proto__.__proto__.__proto__)    &lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h2><pre class="line-numbers language-none"><code class="language-none">&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset&#x3D;&quot;utf-8&quot;&gt;&lt;title&gt;&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;BOM:浏览器对象模型 window对象 顶级对象1、window对象的方法：setInterval(调用函数，毫秒数)  定时器方法可按照指定的周期（以毫秒计）来调用函数或计算表达式。注意：调用函数有3中写法：  函数        函数名       字符串（&#39;函数名（）&#39;）&lt;br&gt;&lt;script&gt;&#x2F;&#x2F;1 函数 js函数可以作为参数&#x2F;&#x2F;window可以省略&#x2F;&#x2F; setInterval(function()&#123;&#x2F;&#x2F; console.log(&quot;hello&quot;)&#x2F;&#x2F; &#125;, 3000)&#x2F;&#x2F;2 函数名function sayHello()&#123;alert(&#39;hello&#39;);&#125;&#x2F;&#x2F; setInterval(sayHello, 3000)&#x2F;&#x2F;3 字符串（&#39;函数名（）&#39;)var tid &#x3D; setInterval(&quot;alert(&#39;hello&#39;)&quot;, 3000)&lt;&#x2F;script&gt;2、取消定时器： clearInterval() 由 setInterval() 返回的 ID 值可用作 clearInterval() 方法的参数。&lt;br&gt;&lt;button id&#x3D;&#39;btn1&#39;&gt;开启&lt;&#x2F;button&gt;&lt;button id&#x3D;&#39;btn2&#39;&gt;关闭&lt;&#x2F;button&gt;&lt;script&gt;var btn2&#x3D;document.getElementById(&quot;btn2&quot;);var btn1&#x3D;document.querySelector()btn2.onclick&#x3D;function()&#123;clearInterval(tid)&#125;&lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="函数中this指针"><a href="#函数中this指针" class="headerlink" title="函数中this指针"></a>函数中this指针</h2><pre class="line-numbers language-none"><code class="language-none">&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset&#x3D;&quot;utf-8&quot;&gt;&lt;title&gt;&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;1、this是什么？函数中的this指函数的实际调用对象。&lt;hr&gt;&lt;script&gt;&#x2F;&#x2F; console.log(this)&#x2F;&#x2F; var obj&#x3D;&#123;name:&quot;123&quot;&#125;&#x2F;&#x2F; obj.fn &#x3D; function()&#123;&#x2F;&#x2F; console.log(this)&#x2F;&#x2F; console.log(this.name)&#x2F;&#x2F; &#125;&#x2F;&#x2F; &#x2F;&#x2F; obj.fn()&#x2F;&#x2F; &#x2F;&#x2F; setTimeout(obj.fn, 1000)&#x2F;&#x2F; console.log(typeof(obj))&lt;&#x2F;script&gt;2、箭头函数的this箭头函数没有自己的this,它的this是外层作用域的this&lt;hr&gt;&lt;script&gt;function fn1()&#123;console.log(&quot;fn1-&quot;,this);&#125;var fn2&#x3D;()&#x3D;&gt;&#123;console.log(&quot;fn2&quot;,this);&#125;&#x2F;&#x2F; fn1()&#x2F;&#x2F; fn2()var obj1&#x3D;&#123;name:&quot;124&quot;,fn1,fn2,fn3:()&#x3D;&gt;&#123;console.log(this)&#125;&#125;&#x2F;&#x2F; obj1.fn1()&#x2F;&#x2F;类的this&#x2F;&#x2F; obj1.fn2()&#x2F;&#x2F;外部的window&#x2F;&#x2F; obj1.fn3()&#x2F;&#x2F;同样也是外部的windowvar obj2&#x3D;&#123;obj1&#125;console.log(obj2.obj1.fn1())console.log(obj2.obj1.fn2())console.log(obj2.obj1.fn3())&lt;&#x2F;script&gt;3、 函数是Function类的实例可以通过new Function动态创建函数对象。&lt;script&gt;var add&#x3D; new Function(&quot;x&quot;, &quot;y&quot;, &quot;return x+y&quot;)console.log(add(1, 2))&lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><pre class="line-numbers language-none"><code class="language-none">&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset&#x3D;&quot;utf-8&quot;&gt;&lt;title&gt;&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;1、js中函数可以作为参数传递&lt;br&gt;&lt;script&gt;function say (str) &#123;alert(str);&#125;&#x2F;&#x2F;01方法函数作为参数&#x2F;&#x2F; 高阶函数function fn(fun, str)&#123;fun(str)&#125;&#x2F;&#x2F; fn(say, &quot;123&quot;)&#x2F;&#x2F; setInterval(say, 3000, &quot;1&quot;)&#x2F;&#x2F;02直接将匿名函数作为参数传递给fn1方法&#x2F;&#x2F; fn(function(str)&#123;&#x2F;&#x2F; alert(str)&#x2F;&#x2F; &#125;, &quot;1111111&quot;)&lt;&#x2F;script&gt;&lt;br&gt;2、函数作为返回值&lt;script&gt;&#x2F;*希望test1函数执行时，可以记录一条日志开闭原则：对扩展开放，对修改关闭在不修改原函数的基础上，增加此功能。可以通过函数作为返回值 来动态生成一个新函数*&#x2F;function test1()&#123;var str&#x3D;&quot;heollo&quot;console.log(str)&#125;function outer(fun)&#123;return ()&#x3D;&gt;&#123;console.log(&quot;添加日志------------&quot;)fun()&#125;&#x2F;&#x2F;返回值是函数&#125;outer(test1)&#x2F;&#x2F;返回值是函数var f1&#x3D;outer(test1)&#x2F;&#x2F;接受返回值f1()&lt;&#x2F;script&gt;3、什么高阶函数&lt;br&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><pre class="line-numbers language-none"><code class="language-none">&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset&#x3D;&quot;utf-8&quot;&gt;&lt;title&gt;&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;闭包01 什么是闭包：函数A中 有一个函数B，函数B中可以访问函数A中定义的变量或者数据，此时就形成了闭包。02 闭包的功能： 使函数内部的变量在函数执行完后，仍然存活在内存中（延长了局部变量的生命周期）让函数外部可以操作函数内部的数据&lt;script&gt;&#x2F;&#x2F;1定义一个闭包function A()&#123;var num&#x3D;123function B()&#123;console.log(num)&#125;B()&#125;&#x2F;&#x2F; A()&#x2F;&#x2F;打断点之后会出现，Closure (A)，闭包&#x2F;&#x2F; console.log(num)&#x2F;&#x2F;2 在f1 外部来访问n;function f1()&#123;var n&#x3D;10return function()&#123;console.log(n)return n;&#125;&#125;&#x2F;&#x2F; console.log(n);&#x2F;&#x2F;console.log(&quot;函数外 输出局部变量n的值：&quot;+ );&#x2F;*闭包的功能： 使函数内部的变量在函数执行完后，仍然存活在内存中（延长了局部变量的生命周期）让函数外部可以操作函数内部的数据*&#x2F;&#x2F;&#x2F;3 函数执行完后 局部变量就自动释放了 ？为什么还能访问？var f2&#x3D;f1()f2()&#x2F;&#x2F;延长了n的作用周期&lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="闭包案例"><a href="#闭包案例" class="headerlink" title="闭包案例"></a>闭包案例</h2><pre class="line-numbers language-none"><code class="language-none">&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset&#x3D;&quot;utf-8&quot;&gt;&lt;title&gt;&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;1、案例一&lt;br&gt;&lt;script&gt;&#x2F;*function f1()&#123;var num&#x3D;10;num++;console.log(num);&#125;&#x2F;&#x2F;运行结果是？f1()  &#x2F;&#x2F;11f1()  &#x2F;&#x2F;11 12f1()*&#x2F;&lt;&#x2F;script&gt;如何实现累加？-闭包&lt;script&gt;function f2() &#123;var n &#x3D; 10return function () &#123;n++return n&#125;&#125;var ff &#x3D; f2()&#x2F;&#x2F; console.log(ff())&#x2F;&#x2F; console.log(ff())&#x2F;&#x2F; console.log(ff())&lt;&#x2F;script&gt;&lt;hr&gt;2、案例二：下来3个按钮，点击其中一个，提示&quot;点击的是第n个按钮&quot;：&lt;br&gt;&lt;button&gt;桔子1&lt;&#x2F;button&gt;&lt;button&gt;苹果2&lt;&#x2F;button&gt;&lt;button&gt;梨子3&lt;&#x2F;button&gt;&lt;script&gt;&#x2F;&#x2F;html5 通过css选择器获得页面元素var btns &#x3D; document.querySelectorAll(&quot;button&quot;)&#x2F;&#x2F; console.log(btns)&#x2F;&#x2F; for(var i&#x3D;0; i&lt;btns.length; i++)&#123;&#x2F;&#x2F; btns[i].index&#x3D;i+1;&#x2F;&#x2F; &#x2F;&#x2F; 注册事件&#x2F;&#x2F; btns[i].οnclick&#x3D;function()&#123;&#x2F;&#x2F; alert(&quot;点击了第&quot;+this.index+&quot;个按钮&quot;)&#x2F;&#x2F; &#125;&#x2F;&#x2F; &#125;&#x2F;&#x2F; console.log(i)&#x2F;&#x2F;闭包来获得按钮的索引for (var i &#x3D; 0; i &lt; btns.length; i++) &#123;(function (index) &#123;btns[index].onclick &#x3D; function () &#123;alert(&quot;点击了第&quot; + (index+1) + &quot;个按钮&quot;)&#125;&#125;)(i + 1);&#125;&lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>闭包：实现可以持续分别点赞。</p><pre class="line-numbers language-none"><code class="language-none">&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;meta charset&#x3D;&quot;utf-8&quot;&gt;    &lt;title&gt;&lt;&#x2F;title&gt;    &lt;style&gt;        h1&#123;            color: aquamarine;        &#125;    &lt;&#x2F;style&gt;&lt;&#x2F;head&gt;&lt;body&gt;    3、案例三&lt;hr&gt;    &lt;h1&gt;请给下列新闻投票&lt;&#x2F;h1&gt;    &lt;ul&gt;        &lt;li&gt;北京冬奥会火种抵达北京&lt;button&gt;投票&lt;&#x2F;button&gt;&lt;&#x2F;li&gt;        &lt;li&gt;31省区市新增本土确诊17例。&lt;button&gt;投票&lt;&#x2F;button&gt;&lt;&#x2F;li&gt;        &lt;li&gt;互联网公司校招名额大幅增加 核心岗位首次开放&lt;button&gt;投票&lt;&#x2F;button&gt;&lt;&#x2F;li&gt;        &lt;li&gt;多地取暖用煤价格涨超2倍&lt;button&gt;投票&lt;&#x2F;button&gt;&lt;&#x2F;li&gt;    &lt;&#x2F;ul&gt;    &lt;script&gt;        var count &#x3D; new Array()        count[0]&#x3D;0        count[1]&#x3D;0        count[2]&#x3D;0        count[3]&#x3D;0        var buttons &#x3D; document.querySelectorAll(&quot;button&quot;)        &#x2F;&#x2F; 闭包方法1        &#x2F;&#x2F; function clickCount(i)&#123;        &#x2F;&#x2F;     var n&#x3D;count[i];        &#x2F;&#x2F;     return function add()&#123;        &#x2F;&#x2F;         count[i]++;        &#x2F;&#x2F;         n++;        &#x2F;&#x2F;         return n        &#x2F;&#x2F;     &#125;        &#x2F;&#x2F; &#125;        &#x2F;&#x2F; for(var i&#x3D;0; i&lt;buttons.length; i++)&#123;        &#x2F;&#x2F;     let add1&#x3D;clickCount(i)        &#x2F;&#x2F;     buttons[i].οnclick&#x3D;function()&#123;        &#x2F;&#x2F;         this.innerHTML&#x3D;add1()+&quot;票&quot;        &#x2F;&#x2F;     &#125;        &#x2F;&#x2F; &#125;        &#x2F;&#x2F; 闭包方法2        &#x2F;&#x2F; for(var i&#x3D;0; i&lt;buttons.length; i++)&#123;        &#x2F;&#x2F;     (function(i)&#123;        &#x2F;&#x2F;         var n&#x3D;0        &#x2F;&#x2F;         buttons[i].οnclick&#x3D;function()&#123;        &#x2F;&#x2F;             n++        &#x2F;&#x2F;             this.innerHTML&#x3D;n+&quot;票&quot;        &#x2F;&#x2F;         &#125;        &#x2F;&#x2F;     &#125;)(i)        &#x2F;&#x2F; &#125;        &#x2F;&#x2F; 闭包方法3        for(var i&#x3D;0, j&#x3D;1; i&lt;buttons.length; i++)&#123;            (function(num)&#123;                buttons[i].onclick&#x3D;function()&#123;                    this.innerHTML&#x3D;num+&quot;票&quot;                    num++;                &#125;            &#125;)(j)        &#125;    &lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><pre class="line-numbers language-none"><code class="language-none">&lt;script&gt;        var rex &#x3D; new RegExp(&#x2F;abc&#x2F;);        var f1&#x3D;rex.test(&#39;abc&#39;)        var f2&#x3D;rex.test(&quot;abcdd&quot;)        console.log(f1, f2)        var reg&#x3D;&#x2F;abb&#x2F;        var s&#x3D;reg.exec(&#39;abbbbb&#39;)&#x2F;&#x2F;搜索字符串并且返回已找到的文本        console.log(s)        var rg&#x3D;&#x2F;[a-z]&#x2F;        var reg&#x3D;&#x2F;[a-zA-Z]&#123;2&#125;&#x2F;        var s&#x3D;reg.exec(&#39;a1a1v1b&#39;)        console.log(s)        var reg&#x3D;&#x2F;[zo*]&#x2F; &#x2F;&#x2F;贪婪模式 ?结束贪婪模式        var reg&#x3D;&#x2F;a&#123;3&#125;$&#x2F;        var reg&#x3D;&#x2F;s&#x2F;        var s&#x3D;reg.exec(&quot;vaaa&quot;)        console.log(s)    &lt;&#x2F;script&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="事件监听"><a href="#事件监听" class="headerlink" title="事件监听"></a>事件监听</h2><pre class="line-numbers language-none"><code class="language-none">&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset&#x3D;&quot;utf-8&quot;&gt;&lt;title&gt;&lt;&#x2F;title&gt;&lt;style&gt;#div1 &#123;width: 200px;height: 200px;background: beige;&#125;&lt;&#x2F;style&gt;&lt;&#x2F;head&gt;&lt;body&gt;1、event事件对象：是浏览器在事件触发时所创建的对象。这个对象封装了事件相关的各种信息。-通过事件对象 可以获取事件的各种信息。&lt;hr&gt;2、Dom中存在着多种不同类型的时间对象-他们的父对象都是Event&lt;hr&gt;&lt;div id&#x3D;&#39;div1&#39;&gt;&lt;&#x2F;div&gt;&lt;br&gt;&lt;button id&#x3D;&#39;btn1&#39;&gt;按钮1&lt;&#x2F;button&gt;&lt;script&gt;var div1 &#x3D; document.getElementById(&#39;div1&#39;);var div1 &#x3D; document.getElementById(&quot;div1&quot;)var btn1 &#x3D; document.getElementById(&quot;btn1&quot;)&#x2F;&#x2F; console.log(div1, btn1)div1.onclick&#x3D;function(event)&#123;&#x2F;&#x2F; console.log(event)&#x2F;&#x2F;target 触发事件的对象console.log(event.target)&#x2F;&#x2F;this&#x2F;&#x2F; console.log(this)div1.textContext&#x3D;event.clientX+&quot;  &quot;+event.clientY&#125;&#x2F;&#x2F;事件的另外一种方式:监听事件 绑定多个方法btn1.addEventListener(&#39;click&#39;, function()&#123;alert(&quot;1234&quot;)&#125;)btn1.addEventListener(&#39;click&#39;, function()&#123;alert(&quot;12345&quot;)&#125;)&lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h2><pre class="line-numbers language-none"><code class="language-none">&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset&#x3D;&quot;utf-8&quot;&gt;&lt;title&gt;&lt;&#x2F;title&gt;&lt;style&gt;#div1 &#123;width: 300px;height: 300px;background: red;&#125;#div2&#123;width: 200px;height:100px;background-color: aqua;&#125;&lt;&#x2F;style&gt;&lt;&#x2F;head&gt;&lt;body&gt;3、 事件冒泡:(bubble)是指事件向上传导当元素的事件被触发后，其父元素上的相同事件也同时触发。事件冒泡的存在简化了代码的编写，但是有时我们并不希望冒泡存在。取消事件冒泡：event.stopPropagation()&lt;div id&#x3D;&#39;div1&#39;&gt;&lt;div id&#x3D;&quot;div2&quot;&gt;&lt;&#x2F;div&gt;&lt;&#x2F;div&gt;&lt;br&gt;&lt;script&gt;var div1 &#x3D; document.getElementById(&#39;div1&#39;);div1.onclick &#x3D; function (ev) &#123;alert(&quot;div1&quot;)&#125;var div2 &#x3D; document.getElementById(&#39;div2&#39;);div2.onclick &#x3D; function (ev) &#123;&#x2F;&#x2F; 取消默认行为ev.stopPropagation()alert(&quot;div123&quot;)&#125;&lt;&#x2F;script&gt;4 取消默认行为。&lt;a id&#x3D;&#39;a1&#39; href&#x3D;&quot;https:&#x2F;&#x2F;www.ahut.edu.cn&quot;&gt;安工大&lt;&#x2F;a&gt;&lt;script&gt;var a1 &#x3D; document.getElementById(&#39;a1&#39;);a1.onclick&#x3D;function(ev)&#123;alert(&quot;安工大&quot;)&#x2F;&#x2F;取消跳转的默认行为&#x2F;&#x2F; 1.return false&#x2F;&#x2F; 2.ev.preventDefault()&#125;&lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="实现光标跟随效果"><a href="#实现光标跟随效果" class="headerlink" title="实现光标跟随效果"></a>实现光标跟随效果</h2><pre class="line-numbers language-none"><code class="language-none">&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;  &lt;meta charset&#x3D;&quot;utf-8&quot;&gt;  &lt;title&gt;实验四&lt;&#x2F;title&gt;  &lt;style&gt;    div &#123;      width: 20px;      height: 20px;      background-color: bisque;      position: absolute;    &#125;  &lt;&#x2F;style&gt;&lt;&#x2F;head&gt;&lt;body&gt;  &lt;div class&#x3D;&quot;div&quot;&gt;&lt;&#x2F;div&gt;  &lt;div class&#x3D;&quot;div&quot;&gt;&lt;&#x2F;div&gt;  &lt;div class&#x3D;&quot;div&quot;&gt;&lt;&#x2F;div&gt;  &lt;div class&#x3D;&quot;div&quot;&gt;&lt;&#x2F;div&gt;  &lt;div class&#x3D;&quot;div&quot;&gt;&lt;&#x2F;div&gt;  &lt;div class&#x3D;&quot;div&quot;&gt;&lt;&#x2F;div&gt;  &lt;div class&#x3D;&quot;div&quot;&gt;&lt;&#x2F;div&gt;  &lt;div class&#x3D;&quot;div&quot;&gt;&lt;&#x2F;div&gt;  &lt;div class&#x3D;&quot;div&quot;&gt;&lt;&#x2F;div&gt;  &lt;div class&#x3D;&quot;div&quot;&gt;&lt;&#x2F;div&gt;  &lt;div class&#x3D;&quot;div&quot;&gt;&lt;&#x2F;div&gt;  &lt;div class&#x3D;&quot;div&quot;&gt;&lt;&#x2F;div&gt;  &lt;div class&#x3D;&quot;div&quot;&gt;&lt;&#x2F;div&gt;  &lt;div class&#x3D;&quot;div&quot;&gt;&lt;&#x2F;div&gt;  &lt;div class&#x3D;&quot;div&quot;&gt;&lt;&#x2F;div&gt;  &lt;div class&#x3D;&quot;div&quot;&gt;&lt;&#x2F;div&gt;  &lt;script&gt;    var divs&#x3D;document.querySelectorAll(&quot;.div&quot;)     &#x2F;&#x2F; console.log(divs.length)    document.onmousemove &#x3D; function (ev) &#123;        divs[0].style.left&#x3D;ev.clientX+&quot;px&quot;      divs[0].style.top&#x3D;ev.clientY+&quot;px&quot;      for(var i&#x3D;15; i&gt;0; i--)&#123;        divs[i].style.left&#x3D;divs[i-1].style.left        divs[i].style.top&#x3D;divs[i-1].style.top      &#125;      &#x2F;&#x2F; for(var i&#x3D;1; i&lt;16; i++)&#123;      &#x2F;&#x2F;   divs[i].style.left&#x3D;divs[i-1].style.left      &#x2F;&#x2F;   divs[i].style.top&#x3D;divs[i-1].style.top      &#x2F;&#x2F; &#125;    &#125;    &lt;&#x2F;script&gt;  解题思路：    1. 多个div跟随光标，第一个div的位置 始终是 光标移动到的位置。    2. 第二个div，当移动的过程中，会到第一个div之前的位置，第三个div 会到第二个div 之前的位置。    3.前一个div的位置赋给当前的div  :  obj.offsetTop 指 obj 相对于父元素上侧位置，整型     obj.offsetLeft 指 obj 相对于父元素左侧位置，整型             4.最后开始，在第一个div 还没移动的时候，第10个去到第9个，第9个去到第8个的位置......最后再把第一个移动到光标的位置。    标签: JS&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>I/O多路复用（select/poll/epoll）</title>
      <link href="/2023/06/20/io-duo-lu-fu-yong-selectpollepoll/"/>
      <url>/2023/06/20/io-duo-lu-fu-yong-selectpollepoll/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h2><p>这三种模式是为了在一个线程下面尽可能多的管理很多个socket。这三种模式在不同的需求下，有着各自的优势，select和poll差不多，但并不一定是说epoll是最好的。比如我们就写个简单的几个client连接下的情况，这个时候用select就很香，代码更少一点，如果是在真实的生产环境下，肯定是用epoll好。</p><h2 id="select"><a href="#select" class="headerlink" title="select"></a>select</h2><p>select管理多个socket的fd（文件描述符，通过这个可以找到socket），在这期间select会监听所有的socket。如果没有一个socket有事件发生，这个线程会让出cpu的阻塞等待，即让该线程可以去做别的事情。如果使用普通的conncet()、accept()、recv()或recvfrom()这种函数，如果没有事件发生，就必须要阻塞，直到事件发生。</p><p>如果有事件发生，select会在他的睡眠队列里设置一个entry，当 socket 接收到网卡的数据后，就会去它的睡眠队列里遍历 entry，调用 entry 设置的 callback 方法，这个 callback 方法里就能唤醒 select !</p><p><strong>select函数原型：</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/select.h></span></span><span class="token keyword">struct</span> <span class="token class-name">timeval</span> <span class="token punctuation">&#123;</span>    time_t      tv_sec<span class="token punctuation">;</span>         <span class="token comment">/* seconds */</span>    suseconds_t tv_usec<span class="token punctuation">;</span>        <span class="token comment">/* microseconds */</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">select</span><span class="token punctuation">(</span><span class="token keyword">int</span> nfds<span class="token punctuation">,</span> fd_set <span class="token operator">*</span>readfds<span class="token punctuation">,</span> fd_set <span class="token operator">*</span>writefds<span class="token punctuation">,</span>           fd_set <span class="token operator">*</span>exceptfds<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">timeval</span> <span class="token operator">*</span> timeout<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> <strong>参数介绍：</strong></p><ul><li><p>nfds：委托给内核处理的后面三个fd_set的最大值+1，也是遍历的时候的最大值。+ readfds：传入内核处理文件描述符的读集合，内核只需要检测这些文件描述符的读缓冲区。 </p></li><li><p>传入传出参数</p></li><li><p>writefds：传入内核处理文件描述符的读集合，内核只需要检测这些文件描述符的写缓冲区。 </p></li><li><p>传入传出参数</p></li><li><p>exceptfds：文件描述符的集合，内核检测集合中文件描述符是否有异常状态 </p></li><li><p>传入传出参数</p></li><li><p>timeout：设置超时的时间，可以强制操作select()函数的阻塞状态。 </p></li><li><p>NULL：没有事件就会一直阻塞。+ 秒数：等待时间。+ 0：不等待。</p></li></ul><p><strong>返回值：</strong></p><ul><li>-1：函数调用失败了+ 0：监听的所有的socket_fd里面没有发生事件的socket_fd。+ &gt;0：返回已经就绪的socket_fd。</li></ul><p><strong>与fd_set配合的操作函数：</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 将文件描述符fd从set中删除，即把set中fd对应的标志位置0</span><span class="token keyword">void</span> <span class="token function">FD_CLR</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> fd_set<span class="token operator">*</span> set<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 将文件描述符fd添加到set中，即把set中fd对应的标志位置1</span><span class="token keyword">void</span> <span class="token function">FD_SET</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> fd_set<span class="token operator">*</span> set<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 判断文件描述符fd是否在set中，即判断文件描述符fd在set中的标志位是否为1</span><span class="token keyword">void</span> <span class="token function">FD_ISSET</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> fd_set<span class="token operator">*</span> set<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 清空set，即全部置0，用于初始化set</span><span class="token keyword">void</span> <span class="token function">FD_ZERO</span><span class="token punctuation">(</span>fd_set<span class="token operator">*</span> set<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注：fd_set 是一个128个字节的数组（位图Bitmap），128*8&#x3D;1024 bit，在操作fd_set的时候，实际上操作的是每一位bit，置0还是置1，与内核中的文件描述符表的每一位都对应。</p><ul><li>0代表不检测这个文件描述符的状态（读缓冲区，写缓冲区等）+ 1代表检测这个文件描述符的状态（读缓冲区，写缓冲区等）</li></ul><p><strong>从这里可以看出select的缺点：</strong></p><ul><li>具有O(n)的无差别轮询复杂度，需要一直遍历1024位fd_set的各个位的状态+ 每次select都需要将fd_set拷贝到内核空间，开销比较大+ 需要轮询fd_set，消耗时间多+ 能够检测的最大文件描述符是1024个，这个在内核写死了</li></ul><h2 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h2><p>相对于【select】，它不使用【Bitmap】来保存已经连接的文件描述符，使用的是链表来管理，没有了1024的限制，当然还会受到系统文件描述符限制。</p><p><strong>poll的函数原型：</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;poll.h></span></span><span class="token comment">// 每个委托poll检测的fd都对应这样一个结构体</span><span class="token keyword">struct</span> <span class="token class-name">pollfd</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span>   fd<span class="token punctuation">;</span>         <span class="token comment">/* 委托内核检测的文件描述符 */</span>    <span class="token keyword">short</span> events<span class="token punctuation">;</span>     <span class="token comment">/* 委托内核检测文件描述符的什么事件 */</span>    <span class="token keyword">short</span> revents<span class="token punctuation">;</span>    <span class="token comment">/* 文件描述符实际发生的事件 -> 传出 */</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">pollfd</span> myfd<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">poll</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">pollfd</span> <span class="token operator">*</span>fds<span class="token punctuation">,</span> nfds_t nfds<span class="token punctuation">,</span> <span class="token keyword">int</span> timeout<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>函数参数介绍：</strong></p><ul><li><p>fds: 这是一个 struct pollfd 类型的数组，里边存储了待检测的文件描述符的信息，这个数组中有三个成员： </p></li><li><p>fd：委托内核检测的文件描述符+ events：委托内核检测的 fd 事件（输入、输出、错误），每一个事件有多个取值+ revents：这是一个<strong>传出参数</strong>，数据由内核写入，存储内核检测之后的结果 </p></li><li><p>读事件：POLLIN+ 写事件：POLLOUT+ 错误事件：POLLERR</p></li><li><p>nfds: 这是第一个参数数组中最后一个有效元素的下标 + 1（也可以指定参数 1 数组的元素总个数）+ timeout: 指定 poll 函数的阻塞时长 </p></li><li><p>-1：一直阻塞，直到检测的集合中有就绪的文件描述符（有事件产生）解除阻塞+ 0：不阻塞，不管检测集合中有没有已就绪的文件描述符，函数马上返回+ 大于 0：阻塞指定的毫秒（ms）数之后，解除阻塞</p></li></ul><p><strong>函数返回值：</strong></p><ul><li>失败： 返回 - 1+ 成功：返回一个大于 0 的整数，表示检测的集合中已就绪的文件描述符的总个数</li></ul><p><strong>操作函数：</strong></p><ul><li>只需要poll函数：revent中包含了这个文件描述符的事件</li></ul><p><strong>从上面可以总结出poll的特点：</strong></p><ul><li><p>对比select，使用起来更加方便（将相关的文件描述符封装到了pollfd中），但是不能跨平台，只能在Linux平台 </p></li><li><p>events参数对应select中的readfds、writefds、exceptfds的传入状态+ revents参数对应select中的readfds、writefds、exceptfds的传出状态</p></li><li><p>与select相差不大，需要的时间复杂度一样</p></li></ul><h2 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h2><p><strong>epoll的操作函数：</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/epoll.h></span></span><span class="token comment">// 创建epoll实例，通过一棵红黑树管理待检测集合</span><span class="token keyword">int</span> <span class="token function">epoll_create</span><span class="token punctuation">(</span><span class="token keyword">int</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">epoll_create1</span><span class="token punctuation">(</span><span class="token keyword">int</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//flag可以是::EPOLL_CLOEXEC</span><span class="token comment">// 管理红黑树上的文件描述符(添加、修改、删除)</span><span class="token keyword">int</span> <span class="token function">epoll_ctl</span><span class="token punctuation">(</span><span class="token keyword">int</span> epfd<span class="token punctuation">,</span> <span class="token keyword">int</span> op<span class="token punctuation">,</span> <span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">epoll_event</span> <span class="token operator">*</span>event<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 检测epoll树中是否有就绪的文件描述符</span><span class="token keyword">int</span> <span class="token function">epoll_wait</span><span class="token punctuation">(</span><span class="token keyword">int</span> epfd<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">epoll_event</span> <span class="token operator">*</span> events<span class="token punctuation">,</span> <span class="token keyword">int</span> maxevents<span class="token punctuation">,</span> <span class="token keyword">int</span> timeout<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在select&#x2F;poll中低效的原因之一是它们将“添加&#x2F;修改任务列表”与“等待任务列表”放在一起处理。在大部分情况下，需要监听的socket比较确定，这个时候检测去任务列表是多余的。epoll将两个步骤分开，epoll_ctl用来管理任务列表，并且使用的是红黑树结构，这种结构有利于增加、删除或修改，然后用epoll_wait检测任务列表（文件描述符）是否有事件发生，这样实现了解耦，效率大大提高。</p><p><strong>epoll_create(int size):</strong></p><ul><li><p>参数：一般指定为大于0的数就可以+ 返回值： </p></li><li><p>失败：-1，创建错误+ 成功：一个文件描述符，通过这个就可以访问epoll实例</p></li><li><p>用法：int epfd &#x3D; epoll_create(100);</p></li></ul><p><strong>epoll_create1(int flags):</strong></p><ul><li>参数：flags 可以设置为0 或者EPOLL_CLOEXEC，为0时函数表现与epoll_create一致，设置为EPOLL_CLOEXEC标志与open 时的O_CLOEXEC 标志类似，即进程被替换时会关闭文件描述符。+ 返回值：与epoll_create类似</li></ul><p>*<em>epoll_ctl(int epfd, int op, int fd, struct epoll_event <em>event):</em></em></p><ul><li><p>参数： </p></li><li><p>epfd是epoll_crate的返回值，操作epoll实例+ op是一个枚举值，控制函数执行什么类型的操作 </p></li><li><p>EPOLL_CTL_ADD：添加一个fd+ EPOLL_CTL_DEL：删除一个fd+ EPOLL_CTL_MOD：修改一个fd</p></li><li><p>fd是文件描述符，即要添加 &#x2F; 修改 &#x2F; 删除的文件描述符+ event是epoll 事件，用来修饰第三个参数对应的文件描述符的，指定检测这个文件描述符的什么事件 </p></li><li><p>events：委托 epoll 检测的事件 </p></li><li><p>EPOLLIN：读事件，接收数据，检测读缓冲区，如果有数据该文件描述符就绪+ EPOLLOUT：写事件，发送数据，检测写缓冲区，如果可写该文件描述符就绪+ EPOLLERR：异常事件</p></li><li><p>data：用户数据变量，这是一个联合体类型，通常情况下使用里边的 fd 成员，用于存储待检测的文件描述符的值，在调用 epoll_wait() 函数的时候这个值会被传出。</p></li></ul><p><strong>看一下epoll_ctl的epoll_event结构体：</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 联合体, 多个变量共用同一块内存        </span><span class="token keyword">typedef</span> <span class="token keyword">union</span> epoll_data <span class="token punctuation">&#123;</span> <span class="token keyword">void</span>        <span class="token operator">*</span>ptr<span class="token punctuation">;</span><span class="token keyword">int</span>          fd<span class="token punctuation">;</span><span class="token comment">// 通常情况下使用这个成员, 和epoll_ctl的第三个参数相同即可</span><span class="token keyword">uint32_t</span>     u32<span class="token punctuation">;</span><span class="token keyword">uint64_t</span>     u64<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> epoll_data_t<span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">epoll_event</span> <span class="token punctuation">&#123;</span><span class="token keyword">uint32_t</span>     events<span class="token punctuation">;</span>      <span class="token comment">/* Epoll events */</span>epoll_data_t data<span class="token punctuation">;</span>        <span class="token comment">/* User data variable */</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">epoll_ctl</span><span class="token punctuation">(</span><span class="token keyword">int</span> epfd<span class="token punctuation">,</span> <span class="token keyword">int</span> op<span class="token punctuation">,</span> <span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">epoll_event</span> <span class="token operator">*</span>event<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>**epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout); **</p><ul><li><p>函数参数： </p></li><li><p>epfd：epoll_create () 函数的返回值，通过这个参数找到 epoll 实例+ events：传出参数，这是一个结构体数组的地址，里边存储了已就绪的文件描述符的信息+ maxevents：修饰第二个参数，结构体数组的容量（元素个数）+ timeout：如果检测的 epoll 实例中没有已就绪的文件描述符，该函数阻塞的时长，单位 ms 毫秒 </p></li><li><p>0：函数不阻塞，不管 epoll 实例中有没有就绪的文件描述符，函数被调用后都直接返回+ 大于 0：如果 epoll 实例中没有已就绪的文件描述符，函数阻塞对应的毫秒数再返回+ -1：函数一直阻塞，直到 epoll 实例中有已就绪的文件描述符之后才解除阻塞</p></li><li><p>函数返回值： </p></li><li><p>成功： </p></li><li><p>等于 0：函数是阻塞被强制解除了，没有检测到满足条件的文件描述符+ 大于 0：检测到的已就绪的文件描述符的总个数</p></li><li><p>失败：返回 - 1</p></li></ul><p><strong>epoll的两种模式 LT 和 ET</strong></p><p>二者的差异在于 level-trigger 模式下只要某个socket处于 readable&#x2F;writable 状态，无论什么时候进行 epoll_wait 都会返回该 socket；而 edge-trigger 模式下只有某个 socket 从 unreadable 变为 readable 或从unwritable 变为 writable 时，epoll_wait 才会返回该 socket。</p><p>所以, 在epoll的ET模式下, 正确的读写方式为:</p><p>读: 只要可读, 就一直读, 直到返回0, 或者 errno &#x3D; EAGAIN</p><p>写: 只要可写, 就一直写, 直到数据发送完, 或者 errno &#x3D; EAGAIN</p><p>Wikipedia：<a href="https://en.wikipedia.org/wiki/Epoll">https://en.wikipedia.org/wiki/Epoll</a></p><p>Man手册：<a href="https://man7.org/linux/man-pages/man7/epoll.7.html">epoll(7) - Linux manual page</a></p><p>Epoll详细解释系列：<a href="https://zhuanlan.zhihu.com/p/63179839">如果这篇文章说不清epoll的本质，那就过来掐死我吧！ （1） - 知乎</a></p><p><a href="https://zhuanlan.zhihu.com/p/64138532">如果这篇文章说不清epoll的本质，那就过来掐死我吧！ （2） - 知乎</a></p><p><a href="https://zhuanlan.zhihu.com/p/64138532">如果这篇文章说不清epoll的本质，那就过来掐死我吧！ （2） - 知乎</a></p><p><a href="https://subingwen.cn/linux/epoll/">IO多路转接（复用）之epoll | 爱编程的大丙</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Idea通过jdbc连接Mysql8.0，JDBC的API使用</title>
      <link href="/2023/06/20/idea-tong-guo-jdbc-lian-jie-mysql80jdbc-de-api-shi-yong/"/>
      <url>/2023/06/20/idea-tong-guo-jdbc-lian-jie-mysql80jdbc-de-api-shi-yong/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p><strong>目录</strong></p><p><a href="#%E9%A6%96%E5%85%88%E4%B8%8B%E8%BD%BDjar%E5%8C%85%EF%BC%8C%E7%82%B9%E5%87%BB%E4%B8%8B%E9%9D%A2%E7%9A%84%E5%AE%98%E7%BD%91%E9%93%BE%E6%8E%A5%E4%B8%8B%E8%BD%BD">首先下载jar包，点击下面的官网链接下载</a></p><p><a href="#%E8%BF%9E%E6%8E%A5%E7%9A%84%E4%BB%A3%E7%A0%81%EF%BC%9A%EF%BC%88Mysql5.0%E4%BB%A5%E5%90%8E%EF%BC%8C%E5%8F%AF%E4%BB%A5%E7%9C%81%E7%95%A5%E6%B3%A8%E5%86%8C%E9%A9%B1%E5%8A%A8%E9%82%A3%E4%B8%80%E6%AD%A5%EF%BC%89">连接的代码：（Mysql5.0以后，可以省略注册驱动那一步）</a></p><p><a href="#DriverManager%C2%A0">DriverManager </a></p><p><a href="#%C2%A0%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86"> 事务处理</a></p><p><a href="#Statement%C2%A0">Statement </a></p><p><a href="#PrepareStatement">PrepareStatement</a></p><h2 id="首先下载jar包，点击下面的官网链接下载"><a href="#首先下载jar包，点击下面的官网链接下载" class="headerlink" title="首先下载jar包，点击下面的官网链接下载"></a>首先下载jar包，点击下面的官网链接下载</h2><p><a href="https://dev.mysql.com/downloads/connector/j/">MySQL :: Download Connector&#x2F;J</a></p><p>下载完成后记得在项目里面Add as library。</p><p>JDBC的步骤：</p><p><img src="https://img-blog.csdnimg.cn/41851a67bdf347999af145599d9fabdc.png"> </p><h2 id="连接的代码：（Mysql5-0以后，可以省略注册驱动那一步）"><a href="#连接的代码：（Mysql5-0以后，可以省略注册驱动那一步）" class="headerlink" title="连接的代码：（Mysql5.0以后，可以省略注册驱动那一步）"></a>连接的代码：（Mysql5.0以后，可以省略注册驱动那一步）</h2><p>jar包里面包含了注册的代码</p><p><img src="https://img-blog.csdnimg.cn/015df4e78e544fbcb38112d8c41a184d.png"></p><p><img src="https://img-blog.csdnimg.cn/3eb5653027484d63afddee0f7f8246fe.png"></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>itheima<span class="token punctuation">.</span>jdbc</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>sql<span class="token punctuation">.</span></span><span class="token class-name">Connection</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>sql<span class="token punctuation">.</span></span><span class="token class-name">DriverManager</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>sql<span class="token punctuation">.</span></span><span class="token class-name">Statement</span></span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">JDBCDemo</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span><span class="token punctuation">&#123;</span>        <span class="token comment">//注册驱动</span><span class="token comment">//        Class.forName("com.mysql.cj.jdbc.Driver");</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"哈哈哈"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//        String url="jdbc:mysql://localhost:3306/student&amp;ussl=false";</span>        <span class="token class-name">String</span> url <span class="token operator">=</span> <span class="token string">"jdbc:mysql://localhost:3306/student?useSSL=false&amp;serverTimezone=UTC"</span><span class="token punctuation">;</span>        <span class="token class-name">String</span> username<span class="token operator">=</span><span class="token string">"root"</span><span class="token punctuation">;</span>        <span class="token class-name">String</span> password<span class="token operator">=</span><span class="token string">"123456"</span><span class="token punctuation">;</span>        <span class="token comment">//获取连接</span>        <span class="token class-name">Connection</span> connection <span class="token operator">=</span> <span class="token class-name">DriverManager</span><span class="token punctuation">.</span><span class="token function">getConnection</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span> username<span class="token punctuation">,</span> password<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">String</span> sql <span class="token operator">=</span> <span class="token string">"select * from admin"</span><span class="token punctuation">;</span>        <span class="token comment">//获取执行对象</span>        <span class="token class-name">Statement</span> stat <span class="token operator">=</span> connection<span class="token punctuation">.</span><span class="token function">createStatement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">boolean</span> execute <span class="token operator">=</span> stat<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>sql<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//        while()</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>execute<span class="token punctuation">)</span><span class="token punctuation">;</span>        stat<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        connection<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 打印成功的信息 </p><p><img src="https://img-blog.csdnimg.cn/f63449695f6f49f59f89c957546fb42f.png"></p><h2 id="DriverManager"><a href="#DriverManager" class="headerlink" title="DriverManager"></a>DriverManager</h2><p><img src="https://img-blog.csdnimg.cn/cfcb67744b31484b91eddf993e349246.png"></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Class</span><span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"com.mysql.cj.jdbc.Driver"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p> 这个是最常见的注册驱动的方法，但是要注意版本（<strong>尤其注意cj加与不加</strong>）。</p><p>另外一种注册驱动的方法：</p><p><strong>System.setProperty(“jdbc.drivers”,”com.mysql.jdbc.Driver”);</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">setProperty</span><span class="token punctuation">(</span><span class="token string">"jdbc.driver"</span><span class="token punctuation">,</span><span class="token string">"com.mysql.jdbc.Driver"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//系统属性指定数据库驱动  </span><span class="token class-name">String</span> url<span class="token operator">=</span><span class="token string">"jdbc:mysql://localhost:3306/databasename"</span><span class="token punctuation">;</span><span class="token comment">//数据库连接子协议  </span><span class="token class-name">Connection</span> conn<span class="token operator">=</span><span class="token class-name">DriverManager</span><span class="token punctuation">.</span><span class="token function">getConnection</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span><span class="token string">"username"</span><span class="token punctuation">,</span><span class="token string">"password"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>可以同时导入多个jdbc驱动，中间用冒号“：”分开</p><p>比如System.setProperty(“jdbc.drivers”,”XXXDriver:XXXDriver:XXXDriver”);</p><p>这样就一次注册了三个数据库驱动</p><h2 id="事务处理"><a href="#事务处理" class="headerlink" title="事务处理"></a>事务处理</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>itheima<span class="token punctuation">.</span>jdbc</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>sql<span class="token punctuation">.</span></span><span class="token class-name">Connection</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>sql<span class="token punctuation">.</span></span><span class="token class-name">DriverManager</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>sql<span class="token punctuation">.</span></span><span class="token class-name">SQLException</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>sql<span class="token punctuation">.</span></span><span class="token class-name">Statement</span></span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">JDBCDemo</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span><span class="token punctuation">&#123;</span>        <span class="token comment">//注册驱动</span><span class="token comment">//        Class.forName("com.mysql.cj.jdbc.Driver");</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"哈哈哈"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//        String url="jdbc:mysql://localhost:3306/student&amp;ussl=false";</span>        <span class="token class-name">String</span> url <span class="token operator">=</span> <span class="token string">"jdbc:mysql://localhost:3306/student?useSSL=false&amp;serverTimezone=UTC"</span><span class="token punctuation">;</span>        <span class="token class-name">String</span> username<span class="token operator">=</span><span class="token string">"root"</span><span class="token punctuation">;</span>        <span class="token class-name">String</span> password<span class="token operator">=</span><span class="token string">"123456"</span><span class="token punctuation">;</span>        <span class="token comment">//获取连接</span>        <span class="token class-name">Connection</span> connection <span class="token operator">=</span> <span class="token class-name">DriverManager</span><span class="token punctuation">.</span><span class="token function">getConnection</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span> username<span class="token punctuation">,</span> password<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">String</span> sql0<span class="token operator">=</span><span class="token string">"update admin set password=123456 where id=1"</span><span class="token punctuation">;</span>        <span class="token class-name">String</span> sql <span class="token operator">=</span> <span class="token string">"update admin set password=12345 where id=2"</span><span class="token punctuation">;</span>        <span class="token comment">//获取执行对象</span>        <span class="token class-name">Statement</span> stat <span class="token operator">=</span> connection<span class="token punctuation">.</span><span class="token function">createStatement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        connection<span class="token punctuation">.</span><span class="token function">setAutoCommit</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//执行sql</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> count1 <span class="token operator">=</span> stat<span class="token punctuation">.</span><span class="token function">executeUpdate</span><span class="token punctuation">(</span>sql0<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>count1<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token operator">/</span><span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> count2 <span class="token operator">=</span> stat<span class="token punctuation">.</span><span class="token function">executeUpdate</span><span class="token punctuation">(</span>sql<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>count2<span class="token punctuation">)</span><span class="token punctuation">;</span>            connection<span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            connection<span class="token punctuation">.</span><span class="token function">rollback</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        stat<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        connection<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里故意抛出1&#x2F;0的错误，看看是否执行了roolback()，结果证明是正确的。try块里面的数据都没有成功执行，回滚了。 </p><h2 id="Statement"><a href="#Statement" class="headerlink" title="Statement"></a>Statement</h2><p><img src="https://img-blog.csdnimg.cn/63dabf743f204232b8e37a00d024b8e4.png"></p><p><img src="https://img-blog.csdnimg.cn/9a999cd5dd264ed6953a3da5a6190ddf.png">  </p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>itheima<span class="token punctuation">.</span>jdbc</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>sql<span class="token punctuation">.</span></span><span class="token operator">*</span></span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">JDBCDemo</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span><span class="token punctuation">&#123;</span>        <span class="token comment">//注册驱动</span>        <span class="token comment">//Class.forName("com.mysql.cj.jdbc.Driver");</span>        <span class="token comment">//String url="jdbc:mysql://localhost:3306/student&amp;ussl=false";</span>        <span class="token class-name">String</span> url <span class="token operator">=</span> <span class="token string">"jdbc:mysql://localhost:3306/student?useSSL=false&amp;serverTimezone=UTC"</span><span class="token punctuation">;</span>        <span class="token class-name">String</span> username<span class="token operator">=</span><span class="token string">"root"</span><span class="token punctuation">;</span>        <span class="token class-name">String</span> password<span class="token operator">=</span><span class="token string">"123456"</span><span class="token punctuation">;</span>        <span class="token comment">//获取连接</span>        <span class="token class-name">Connection</span> connection <span class="token operator">=</span> <span class="token class-name">DriverManager</span><span class="token punctuation">.</span><span class="token function">getConnection</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span> username<span class="token punctuation">,</span> password<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">String</span> sql0<span class="token operator">=</span><span class="token string">"select * from admin"</span><span class="token punctuation">;</span><span class="token comment">//        String sql = "update admin set password=12345 where id=2";</span>        <span class="token comment">//获取执行对象</span>        <span class="token class-name">Statement</span> stat <span class="token operator">=</span> connection<span class="token punctuation">.</span><span class="token function">createStatement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">ResultSet</span> res<span class="token operator">=</span>stat<span class="token punctuation">.</span><span class="token function">executeQuery</span><span class="token punctuation">(</span>sql0<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>res<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//            Account a=new Account();</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"id="</span> <span class="token operator">+</span> res<span class="token punctuation">.</span><span class="token function">getInt</span><span class="token punctuation">(</span><span class="token string">"id"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"name="</span> <span class="token operator">+</span> res<span class="token punctuation">.</span><span class="token function">getString</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"password="</span> <span class="token operator">+</span> res<span class="token punctuation">.</span><span class="token function">getString</span><span class="token punctuation">(</span><span class="token string">"password"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">long</span> now <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>now<span class="token punctuation">)</span><span class="token punctuation">;</span>        res<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        stat<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        connection<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">boolean</span> <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">SQLException</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>注意ResultSet （结果集）的next的方法返回值是boolean类型，表示还有数据的话即输出来。</p><h2 id="PrepareStatement"><a href="#PrepareStatement" class="headerlink" title="PrepareStatement"></a>PrepareStatement</h2><p>作用：预编译SQL语句并且执行，预防SQL注入问题，继承于Statement。</p><p>SQL注入问题：通过操作事先设置好的SQL语句，用以达到执行代码对服务器进行攻击的方法。</p><p>常见的就是如下图所示的代码，只要输入的密码是下面那种情况的，都可以登录成功，不管你有没有那个用户名。</p><p><img src="https://img-blog.csdnimg.cn/6fbed2f983824e34be0cbd9724212d5f.png"></p><p> 演示：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>itheima<span class="token punctuation">.</span>jdbc</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">com<span class="token punctuation">.</span>mysql<span class="token punctuation">.</span>cj<span class="token punctuation">.</span>protocol<span class="token punctuation">.</span></span><span class="token class-name">Resultset</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>sql<span class="token punctuation">.</span></span><span class="token operator">*</span></span><span class="token punctuation">;</span><span class="token comment">/** * 模拟SQL注入问题 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">JDBCDemo</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span><span class="token punctuation">&#123;</span><span class="token comment">//        String url = "jdbc:mysql://localhost:3306/student?useSSL=false&amp;serverTimezone=UTC";</span>        <span class="token class-name">String</span> url <span class="token operator">=</span> <span class="token string">"jdbc:mysql://localhost:3306/student?useSSL=false&amp;serverTimezone=UTC"</span><span class="token punctuation">;</span>        <span class="token class-name">String</span> user <span class="token operator">=</span> <span class="token string">"root"</span><span class="token punctuation">;</span>        <span class="token class-name">String</span> pwd <span class="token operator">=</span> <span class="token string">"123456"</span><span class="token punctuation">;</span>        <span class="token class-name">Connection</span> conn <span class="token operator">=</span> <span class="token class-name">DriverManager</span><span class="token punctuation">.</span><span class="token function">getConnection</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span> user<span class="token punctuation">,</span> pwd<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">String</span> name<span class="token operator">=</span><span class="token string">"124"</span><span class="token punctuation">;</span>        <span class="token class-name">String</span> pas <span class="token operator">=</span> <span class="token string">"' or '1' = '1"</span><span class="token punctuation">;</span>        <span class="token class-name">String</span> sql <span class="token operator">=</span> <span class="token string">"select * from admin where name='"</span><span class="token operator">+</span>name<span class="token operator">+</span><span class="token string">"' and password = '"</span><span class="token operator">+</span>pas<span class="token operator">+</span><span class="token string">"'"</span><span class="token punctuation">;</span>        <span class="token class-name">Statement</span> stat <span class="token operator">=</span> conn<span class="token punctuation">.</span><span class="token function">createStatement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">ResultSet</span> res <span class="token operator">=</span> stat<span class="token punctuation">.</span><span class="token function">executeQuery</span><span class="token punctuation">(</span>sql<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>res<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token class-name">String</span> id<span class="token operator">=</span> res<span class="token punctuation">.</span><span class="token function">getString</span><span class="token punctuation">(</span><span class="token string">"id"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">String</span> name1 <span class="token operator">=</span> res<span class="token punctuation">.</span><span class="token function">getString</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">String</span> pass <span class="token operator">=</span> res<span class="token punctuation">.</span><span class="token function">getString</span><span class="token punctuation">(</span><span class="token string">"password"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            a<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token operator">=</span>id<span class="token punctuation">;</span>            a<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token operator">=</span>name1<span class="token punctuation">;</span>            a<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token operator">=</span>pass<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>a<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        res<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        stat<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        conn<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 输出结果：</p><p><img src="https://img-blog.csdnimg.cn/e56976874cea4e399b3e5768c33a3389.png"></p><p> 数据库里面的数据：</p><p><img src="https://img-blog.csdnimg.cn/c2fd18457e304f66bcadcdabbbf7310f.png"></p><p> 明明是密码错误，怎么会输出数据呢？</p><p>我们打印一下sql语句：</p><pre class="line-numbers language-none"><code class="language-none">select * from admin where name&#x3D;&#39;124&#39; and password &#x3D; &#39;&#39; or &#39;1&#39; &#x3D; &#39;1&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>原来where的条件一直显示为真，所以相当于：</p><pre class="line-numbers language-none"><code class="language-none">select * from admin<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>解决办法： </p><p><img src="https://img-blog.csdnimg.cn/8b5e0cddfb03400da4d6b240d73f290b.png"></p><p> 示例：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>itheima<span class="token punctuation">.</span>jdbc</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">com<span class="token punctuation">.</span>mysql<span class="token punctuation">.</span>cj<span class="token punctuation">.</span>protocol<span class="token punctuation">.</span></span><span class="token class-name">Resultset</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>sql<span class="token punctuation">.</span></span><span class="token operator">*</span></span><span class="token punctuation">;</span><span class="token comment">/** * 模拟SQL注入问题 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">JDBCDemo</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span><span class="token punctuation">&#123;</span><span class="token comment">//        String url = "jdbc:mysql://localhost:3306/student?useSSL=false&amp;serverTimezone=UTC";</span>        <span class="token class-name">String</span> url <span class="token operator">=</span> <span class="token string">"jdbc:mysql://localhost:3306/student?useSSL=false&amp;serverTimezone=UTC"</span><span class="token punctuation">;</span>        <span class="token class-name">String</span> user <span class="token operator">=</span> <span class="token string">"root"</span><span class="token punctuation">;</span>        <span class="token class-name">String</span> pwd <span class="token operator">=</span> <span class="token string">"123456"</span><span class="token punctuation">;</span>        <span class="token class-name">Connection</span> conn <span class="token operator">=</span> <span class="token class-name">DriverManager</span><span class="token punctuation">.</span><span class="token function">getConnection</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span> user<span class="token punctuation">,</span> pwd<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">String</span> name<span class="token operator">=</span><span class="token string">"124"</span><span class="token punctuation">;</span>        <span class="token class-name">String</span> pas <span class="token operator">=</span> <span class="token string">"' or '1' = '1"</span><span class="token punctuation">;</span>        <span class="token class-name">String</span> sql <span class="token operator">=</span> <span class="token string">"select * from admin where name=? and password =?"</span><span class="token punctuation">;</span>        <span class="token class-name">PreparedStatement</span> stat <span class="token operator">=</span> conn<span class="token punctuation">.</span><span class="token function">prepareStatement</span><span class="token punctuation">(</span>sql<span class="token punctuation">)</span><span class="token punctuation">;</span>        stat<span class="token punctuation">.</span><span class="token function">setString</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>        stat<span class="token punctuation">.</span><span class="token function">setString</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> pas<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">ResultSet</span> res <span class="token operator">=</span> stat<span class="token punctuation">.</span><span class="token function">executeQuery</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>res<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token class-name">String</span> id<span class="token operator">=</span> res<span class="token punctuation">.</span><span class="token function">getString</span><span class="token punctuation">(</span><span class="token string">"id"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">String</span> name1 <span class="token operator">=</span> res<span class="token punctuation">.</span><span class="token function">getString</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">String</span> pass <span class="token operator">=</span> res<span class="token punctuation">.</span><span class="token function">getString</span><span class="token punctuation">(</span><span class="token string">"password"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            a<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token operator">=</span>id<span class="token punctuation">;</span>            a<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token operator">=</span>name1<span class="token punctuation">;</span>            a<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token operator">=</span>pass<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>sql<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>a<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        res<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        stat<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        conn<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行结果：</p><p><img src="https://img-blog.csdnimg.cn/061484020c594aceb11c8dbfcde8279b.png"></p><p> 使用? 号当作sql的占位符就可以完美解决SQL注入的问题。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>idea连接安装在虚拟机ubuntu的redis</title>
      <link href="/2023/06/20/idea-lian-jie-an-zhuang-zai-xu-ni-ji-ubuntu-de-redis/"/>
      <url>/2023/06/20/idea-lian-jie-an-zhuang-zai-xu-ni-ji-ubuntu-de-redis/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="Redis的安装与开启"><a href="#Redis的安装与开启" class="headerlink" title="Redis的安装与开启"></a>Redis的安装与开启</h1><h3 id="1、Redis数据库安装过程"><a href="#1、Redis数据库安装过程" class="headerlink" title="1、Redis数据库安装过程"></a>1、Redis数据库安装过程</h3><p>    打开虚拟机（Ubuntu）</p><h3 id="2、安装-redis"><a href="#2、安装-redis" class="headerlink" title="2、安装 redis"></a>2、安装 redis</h3><pre class="line-numbers language-none"><code class="language-none">$ sudo apt-get update     $ sudo apt-get install redis-server<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="3、启动redis"><a href="#3、启动redis" class="headerlink" title="3、启动redis"></a>3、启动redis</h3><pre class="line-numbers language-none"><code class="language-none">$ sudo service redis-server restart<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="4、查看运行状态"><a href="#4、查看运行状态" class="headerlink" title="4、查看运行状态"></a>4、查看运行状态</h3><pre class="line-numbers language-none"><code class="language-none">$ sudo ps -aux|grep redis<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/5ce600e5203e4b17895c781a5969d401.png"></p><h3 id="5、进入-redis-客户端"><a href="#5、进入-redis-客户端" class="headerlink" title="5、进入 redis 客户端"></a>5、进入 redis 客户端</h3><pre class="line-numbers language-none"><code class="language-none">$ redis-cli<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id=""><a href="#" class="headerlink" title=""></a></h1><p><img src="https://img-blog.csdnimg.cn/0b5e0f06166c48e888a0ded798a0ae33.png"> </p><h1 id="Redis数据库Java连接"><a href="#Redis数据库Java连接" class="headerlink" title="Redis数据库Java连接"></a>Redis数据库Java连接</h1><h3 id="1、查找redis-conf文件位置"><a href="#1、查找redis-conf文件位置" class="headerlink" title="1、查找redis.conf文件位置"></a>1、查找redis.conf文件位置</h3><pre class="line-numbers language-none"><code class="language-none">$ whereis redis.conf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="2、修改文件配置项"><a href="#2、修改文件配置项" class="headerlink" title="2、修改文件配置项"></a>2、修改文件配置项</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">cd</span> /etc/redis$ <span class="token function">vim</span> redis.conf<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="1、注释掉bind"><a href="#1、注释掉bind" class="headerlink" title="1、注释掉bind"></a>1、注释掉bind</h3><p><img src="https://img-blog.csdnimg.cn/a41dbfca34894caa80793bc51e4936f9.png"></p><p>在56行前面加个#，注释掉 </p><h3 id="2、找到protected-mode设置为no"><a href="#2、找到protected-mode设置为no" class="headerlink" title="2、找到protected-mode设置为no"></a>2、找到protected-mode设置为no</h3><p><img src="https://img-blog.csdnimg.cn/c2fdf41cd5d54ddba9e1412f17026ffa.png"></p><p>把88行最后的 yes改为no。</p><h3 id="3、添加auth的密码"><a href="#3、添加auth的密码" class="headerlink" title="3、添加auth的密码"></a>3、添加auth的密码</h3><p><img src="https://img-blog.csdnimg.cn/d6029e1f6ff14dbbb72e9d3d44d06af6.png"></p><p>加上requirepass 123456 这一行</p><h3 id="4、安装防火墙"><a href="#4、安装防火墙" class="headerlink" title="4、安装防火墙"></a>4、安装防火墙</h3><p><a href="https://www.cnblogs.com/RedStand/p/13228346.html#:~:text=1%EF%BC%9A%20sudo%20apt%20install%20firewalld%20%2F%2F%E5%AE%89%E8%A3%85%E9%98%B2%E7%81%AB%E5%A2%99%202%EF%BC%9Asudo%20firewall-cmd,systemctl%20reload%20firewalld%20%2F%2F%E9%87%8D%E5%90%AF%E9%98%B2%E7%81%AB%E5%A2%99%205%EF%BC%9Asudo%20firewall-cmd%20--list-all%20%2F%2F%E6%9F%A5%E7%9C%8B%E9%98%B2%E7%81%AB%E5%A2%99%E5%88%97%E8%A1%A8">Ubuntu防火墙安装与配置 - 红色立场 - 博客园</a></p><p><a href="https://www.cnblogs.com/Adoni/p/12887983.html#:~:text=2.%E5%BC%80%E5%90%AF6379%E7%AB%AF%E5%8F%A3%20%5Broot%40vm-centos-%201%20data%5D%23%20firewall-cmd%20--zone%3D%20public,--add-port%3D%206379%20%2Ftcp%20--%20permanent%20%23%E6%98%BE%E7%A4%BA%20success%203.%E9%87%8D%E5%90%AF%E9%98%B2%E7%81%AB%E5%A2%99">Centos7开启6379端口 - 前线码农 - 博客园</a></p><h3 id="5、重启虚拟机"><a href="#5、重启虚拟机" class="headerlink" title="5、重启虚拟机"></a>5、重启虚拟机</h3><h3 id="6、启动redis"><a href="#6、启动redis" class="headerlink" title="6、启动redis"></a>6、启动redis</h3><h3 id="7、新建maven项目（Windows环境下）"><a href="#7、新建maven项目（Windows环境下）" class="headerlink" title="7、新建maven项目（Windows环境下）"></a>7、新建maven项目（Windows环境下）</h3><p>pom.xml文件</p><pre class="line-numbers language-none"><code class="language-none">&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;redis.clients&lt;&#x2F;groupId&gt;        &lt;artifactId&gt;jedis&lt;&#x2F;artifactId&gt;        &lt;version&gt;3.0.0&lt;&#x2F;version&gt;    &lt;&#x2F;dependency&gt;&lt;&#x2F;dependencies&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="测试文件："><a href="#测试文件：" class="headerlink" title="测试文件："></a>测试文件：</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">import</span> redis.clients.jedis.Jedis<span class="token punctuation">;</span>public class Main <span class="token punctuation">&#123;</span>    public static void main<span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        System.out.println<span class="token punctuation">(</span><span class="token string">"哈哈黑"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Jedis <span class="token assign-left variable">jedis</span><span class="token operator">=</span>new Jedis<span class="token punctuation">(</span><span class="token string">"自己的虚拟机上面的地址"</span>, <span class="token number">6379</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        jedis.auth<span class="token punctuation">(</span><span class="token string">"123456"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String <span class="token assign-left variable">v</span><span class="token operator">=</span>jedis.ping<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System.out.println<span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="运行结果："><a href="#运行结果：" class="headerlink" title="运行结果："></a>运行结果：</h2><p><img src="https://img-blog.csdnimg.cn/bbc8b0ff2abe4456a47f1b4183168282.png"></p><p>至此连接成功了，其他的操作也可以自己试一试了 </p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HyperLogLog（关于基数统计）</title>
      <link href="/2023/06/20/hyperloglog-guan-yu-ji-shu-tong-ji/"/>
      <url>/2023/06/20/hyperloglog-guan-yu-ji-shu-tong-ji/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>今天在复习Redis的一种在Redis 2.8.9 版本更新的结构的时候，知道了这个数据结构是基于一种优秀的算法HyperLogLog，基数统计算法（简单来说就是统计集合中的元素数量，但是对比set有了很大的优化），就去了解了一下这种算法的精妙之处。</p><h2 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h2><p>这种数据结构在Redis这种NoSQL型数据库中可以非常省内存的去统计各种计数，比如注册 IP 数、每日访问 IP 数、页面实时UV、在线用户数，共同好友数等。这个是应用场景。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">127.0</span>.0.1:6379<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">></span> PFADD k1 a b c d <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">4</span> <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">4</span> <span class="token number">5</span><span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span><span class="token number">127.0</span>.0.1:6379<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">></span> PFCOUNT k1<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">9</span><span class="token number">127.0</span>.0.1:6379<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">></span> PFADD k2 a b c d <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span><span class="token number">127.0</span>.0.1:6379<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">></span> PFMERGE k1 k2OK<span class="token number">127.0</span>.0.1:6379<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">></span> PFCOUNT k1<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">9</span><span class="token number">127.0</span>.0.1:6379<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">></span> PFADD k2 a b c <span class="token number">5</span> <span class="token number">6</span> <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">4</span><span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span><span class="token number">127.0</span>.0.1:6379<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">></span> PFCOUNT k2<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">10</span><span class="token number">127.0</span>.0.1:6379<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">></span> keys *<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"k2"</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">"k1"</span><span class="token number">127.0</span>.0.1:6379<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">></span> PFCOUNT k2<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">10</span><span class="token number">127.0</span>.0.1:6379<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">></span> PFCOUNT k1<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">9</span><span class="token number">127.0</span>.0.1:6379<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">></span> PFMERGE k1 k2 OK<span class="token number">127.0</span>.0.1:6379<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">></span> PFCOUNT k1<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">10</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从上面的示例可以看出，有三个操作：PFADD、PFCOUNT、PFMERGE。</p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>1、使用少量内存就可以统计大量的数据，比如在Redis 中一个键为12K，就可以统计2^64的数据量。</p><p>2、统计存在一定的误差，误差率整体较低，标准误差为 0.81%（但是对于一些有一定容错率的业务场景，如IP统计、在线用户数等，这种误差是可以忽略不计的）；</p><p>3、误差可以被设置辅助计算因子进行降低。</p><p>原理：来自于一篇论文<a href="http://algo.inria.fr/flajolet/Publications/FlFuGaMe07.pdf">http://algo.inria.fr/flajolet/Publications/FlFuGaMe07.pdf</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.zhihu.com/column/p/26015890">关于基数统计 - 知乎</a></p><p><a href="https://pdai.tech/md/db/nosql-redis/db-redis-data-type-special.html#hyperloglogs%E5%9F%BA%E6%95%B0%E7%BB%9F%E8%AE%A1">Redis入门 - 数据类型：3种特殊类型详解 | Java 全栈知识体系</a></p><p><a href="https://www.cnblogs.com/traditional/p/13326391.html">11. 优秀的基数统计算法–HyperLogLog - 古明地盆 - 博客园</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++_中explicit的作用及用法</title>
      <link href="/2023/06/20/c-zhong-explicit-de-zuo-yong-ji-yong-fa/"/>
      <url>/2023/06/20/c-zhong-explicit-de-zuo-yong-ji-yong-fa/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p><strong>目录</strong></p><p><a href="#%C2%A0C++explicit%EF%BC%88%E5%AE%98%E7%BD%91%E7%9A%84%E8%AF%B4%E6%B3%95%EF%BC%89"> C++explicit（官网的说法）</a></p><p><a href="#C++explicit%20%E6%B8%85%E6%A5%9A%E7%9A%84%E8%AF%B4%E6%B3%95%EF%BC%88%E5%BB%BA%E8%AE%AE%E8%8B%B1%E6%96%87%E4%B8%8D%E5%A5%BD%E7%9A%84%E4%BB%8E%E8%BF%99%E9%87%8C%E5%BC%80%E5%A7%8B%E9%A3%9F%E7%94%A8%E5%93%A6%EF%BC%89">C++explicit 清楚的说法（建议英文不好的从这里开始食用哦）</a></p><p><a href="#C++explicit%E4%BD%BF%E7%94%A8%E7%9A%84%E4%BE%8B%E5%AD%90%EF%BC%88%E5%BB%BA%E8%AE%AE%E5%96%9C%E6%AC%A2%E8%87%AA%E5%B7%B1%E6%95%B2%E4%BB%A3%E7%A0%81%E5%AE%9E%E9%AA%8C%E7%9A%84%E4%BB%8E%E8%BF%99%E9%87%8C%E5%BC%80%E5%A7%8B%E9%A3%9F%E7%94%A8%E5%93%A6%EF%BC%89">C++explicit使用的例子（建议喜欢自己敲代码实验的从这里开始食用哦）</a></p><p><a href="#%E6%80%BB%E7%BB%93">总结</a></p><h2 id="C-explicit（官网的说法）"><a href="#C-explicit（官网的说法）" class="headerlink" title="C++explicit（官网的说法）"></a>C++explicit（官网的说法）</h2><p><code>explicit</code> specifier：<a href="https://en.cppreference.com/w/cpp/language/explicit">explicit specifier - cppreference.com</a><br><code>**explicit**</code>(1)<code>**explicit (**</code> expression <code>**)**</code>(2)(since C++20)<br>expression-<a href="https://en.cppreference.com/w/cpp/language/constant_expression#Converted_constant_expression">contextually converted constant expression of type bool</a></p><ol><li>Specifies that a constructor or conversion function (since C++11) or deduction guide (since C++17) is explicit, that is, it cannot be used for implicit conversions and copy-initialization.</li></ol><p>翻译：指定构造函数或转换函数 (C++11 起) 或推导指南 (C++17 起) 是显式的，也就是说，它不能用于隐式转换和复制初始化。</p><ol start="2"><li>The explicit specifier may be used with a constant expression. The function is explicit if and only if that constant expression evaluates to true.</li></ol><p>(since C++20) 翻译：显式说明符可以与常量表达式一起使用。当且仅当该常量表达式的计算结果为真时，该函数才是显式的。 </p><p>The explicit specifier may only appear within the decl-specifier-seq of the declaration of a constructor or conversion function (since C++11) within its class definition.</p><p>翻译：显式说明符只能出现在其类定义中的构造函数或转换函数（C++11 起）声明的 decl-specifier-seq 中。</p><h2 id="C-explicit-清楚的说法（建议英文不好的从这里开始食用哦）"><a href="#C-explicit-清楚的说法（建议英文不好的从这里开始食用哦）" class="headerlink" title="C++explicit 清楚的说法（建议英文不好的从这里开始食用哦）"></a>C++explicit 清楚的说法（建议英文不好的从这里开始食用哦）</h2><p><strong>explicit作用:</strong> 在C++中，explicit关键字用来修饰类的构造函数，被修饰的构造函数的类，不能发生相应的隐式类型转换，只能以显式的方式进行类型转换。</p><p><strong>explicit使用注意事项:</strong>       （1）explicit 关键字只能用于类内部的构造函数声明上。</p><p>      （2） explicit 关键字作用于单个参数的构造函数。</p><p>    * 在C++中，explicit关键字用来修饰类的构造函数，被修饰的构造函数的类，不能发生相应的隐式类型转换</p><h2 id="C-explicit使用的例子（建议喜欢自己敲代码实验的从这里开始食用哦）"><a href="#C-explicit使用的例子（建议喜欢自己敲代码实验的从这里开始食用哦）" class="headerlink" title="C++explicit使用的例子（建议喜欢自己敲代码实验的从这里开始食用哦）"></a>C++explicit使用的例子（建议喜欢自己敲代码实验的从这里开始食用哦）</h2><p> 例子</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;bits/stdc++.h></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Circle</span><span class="token punctuation">&#123;</span>    <span class="token keyword">public</span><span class="token operator">:</span>        <span class="token function">Circle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>        <span class="token function">Circle</span><span class="token punctuation">(</span><span class="token keyword">double</span> _a<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">a</span><span class="token punctuation">(</span>_a<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>        <span class="token function">Circle</span><span class="token punctuation">(</span><span class="token keyword">int</span> _b<span class="token punctuation">,</span> <span class="token keyword">int</span> _c<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">b</span><span class="token punctuation">(</span>_b<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">c</span><span class="token punctuation">(</span>_c<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>         <span class="token function">Circle</span><span class="token punctuation">(</span><span class="token keyword">const</span> Circle<span class="token operator">&amp;</span> A<span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            a<span class="token operator">=</span>A<span class="token punctuation">.</span>a<span class="token punctuation">;</span> b<span class="token operator">=</span>A<span class="token punctuation">.</span>b<span class="token punctuation">;</span> c<span class="token operator">=</span>A<span class="token punctuation">.</span>c<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">void</span> <span class="token function">Print</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            cout<span class="token operator">&lt;&lt;</span>a<span class="token operator">&lt;&lt;</span><span class="token string">" "</span><span class="token operator">&lt;&lt;</span>b<span class="token operator">&lt;&lt;</span><span class="token string">" "</span><span class="token operator">&lt;&lt;</span>c<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token keyword">private</span><span class="token operator">:</span>        <span class="token keyword">double</span> a<span class="token punctuation">;</span>        <span class="token keyword">int</span> b<span class="token punctuation">;</span>        <span class="token keyword">int</span> c<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Circle1</span><span class="token punctuation">&#123;</span>    <span class="token keyword">public</span><span class="token operator">:</span>        <span class="token function">Circle1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>        <span class="token keyword">explicit</span> <span class="token function">Circle1</span><span class="token punctuation">(</span><span class="token keyword">double</span> _a<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">a</span><span class="token punctuation">(</span>_a<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>        <span class="token keyword">explicit</span> <span class="token function">Circle1</span><span class="token punctuation">(</span><span class="token keyword">int</span> _b<span class="token punctuation">,</span> <span class="token keyword">int</span> _c<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">b</span><span class="token punctuation">(</span>_b<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">c</span><span class="token punctuation">(</span>_c<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>        <span class="token keyword">explicit</span> <span class="token function">Circle1</span><span class="token punctuation">(</span><span class="token keyword">const</span> Circle1<span class="token operator">&amp;</span> A<span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            a<span class="token operator">=</span>A<span class="token punctuation">.</span>a<span class="token punctuation">;</span> b<span class="token operator">=</span>A<span class="token punctuation">.</span>b<span class="token punctuation">;</span> c<span class="token operator">=</span>A<span class="token punctuation">.</span>c<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">void</span> <span class="token function">Print</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            cout<span class="token operator">&lt;&lt;</span>a<span class="token operator">&lt;&lt;</span><span class="token string">" "</span><span class="token operator">&lt;&lt;</span>b<span class="token operator">&lt;&lt;</span><span class="token string">" "</span><span class="token operator">&lt;&lt;</span>c<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token keyword">private</span><span class="token operator">:</span>        <span class="token keyword">double</span> a<span class="token punctuation">;</span>        <span class="token keyword">int</span> b<span class="token punctuation">;</span>        <span class="token keyword">int</span> c<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    Circle <span class="token function">q1</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Circle <span class="token function">w1</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    q1<span class="token punctuation">.</span><span class="token function">Print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    w1<span class="token punctuation">.</span><span class="token function">Print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">//隐式调用, 不会报错</span>    Circle q2 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">// just like Circle q(1); 调用的是Circle(double _a)</span>    Circle w2 <span class="token operator">=</span> <span class="token number">1.0</span><span class="token punctuation">;</span><span class="token comment">// just like Circle q(1.0); 调用的是Circle(double _a)</span>    Circle e <span class="token operator">=</span> q2<span class="token punctuation">;</span><span class="token comment">// 调用的是Circle(const Circle&amp; A)</span>            <span class="token comment">//隐式调用，会报错，注意Circle1()的构造函数，都有explicit</span>    <span class="token comment">// Circle1 q3 = 1;</span>    <span class="token comment">// Circle1 w3 = 1.0;</span>    <span class="token comment">// Circle1 e1 = q3;</span>    <span class="token comment">// 以上三行都会报错。</span>     <span class="token comment">//显式调用，都不会有问题</span>    Circle1 <span class="token function">q3</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Circle1 <span class="token function">w3</span><span class="token punctuation">(</span><span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Circle1 <span class="token function">e1</span><span class="token punctuation">(</span>q3<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面三行的报错信息：（这个是我原来在另外一个账号写的博客，现在账号转移到这个了）</p><p><img src="https://img-blog.csdnimg.cn/597541d462a9453d918bbb4657e54c68.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5aSc54yr56iL5bqP54y_,size_16,color_FFFFFF,t_70,g_se,x_16"></p><p><img src="https://img-blog.csdnimg.cn/ea541e17239346b9abf52c487615d072.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5aSc54yr56iL5bqP54y_,size_17,color_FFFFFF,t_70,g_se,x_16"> </p><p><img src="https://img-blog.csdnimg.cn/583c79b46bd24c49953bb1a84ba525b1.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5aSc54yr56iL5bqP54y_,size_14,color_FFFFFF,t_70,g_se,x_16">  </p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p> explicit可以抑制内置类型隐式转换，所以在类的构造函数中，最好尽可能多用explicit关键字，防止不必要的隐式转换。  </p>]]></content>
      
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++：前置++和后置++的运算符重载、红黑树的概念、static关键字</title>
      <link href="/2023/06/20/c-qian-zhi-he-hou-zhi-de-yun-suan-fu-chong-zai-hong-hei-shu-de-gai-nian-static-guan-jian-zi/"/>
      <url>/2023/06/20/c-qian-zhi-he-hou-zhi-de-yun-suan-fu-chong-zai-hong-hei-shu-de-gai-nian-static-guan-jian-zi/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="前置-和后置-的运算符重载"><a href="#前置-和后置-的运算符重载" class="headerlink" title="前置++和后置++的运算符重载"></a>前置++和后置++的运算符重载</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>     <span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span> <span class="token keyword">class</span> <span class="token class-name">Interge</span><span class="token punctuation">&#123;</span>     <span class="token keyword">int</span> a<span class="token punctuation">;</span> <span class="token keyword">public</span><span class="token operator">:</span>     <span class="token function">Interge</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">a</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>     <span class="token keyword">int</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">&#123;</span>         <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token operator">-></span>a<span class="token punctuation">;</span>     <span class="token punctuation">&#125;</span>     Interge<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">++</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>         <span class="token keyword">this</span><span class="token operator">-></span>a<span class="token operator">++</span><span class="token punctuation">;</span>         <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>     <span class="token punctuation">&#125;</span>     Interge <span class="token keyword">operator</span><span class="token operator">++</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>         Interge temp<span class="token operator">=</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>         <span class="token keyword">this</span><span class="token operator">-></span>a<span class="token operator">++</span><span class="token punctuation">;</span>         <span class="token keyword">return</span> temp<span class="token punctuation">;</span>     <span class="token punctuation">&#125;</span> ​ <span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>     Interge <span class="token function">i</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">int</span> a<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>     cout<span class="token operator">&lt;&lt;</span>a<span class="token operator">++</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>     cout<span class="token operator">&lt;&lt;</span>i<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>     <span class="token comment">// i++;</span>     cout<span class="token operator">&lt;&lt;</span>i<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>     i<span class="token operator">++</span><span class="token operator">++</span><span class="token punctuation">;</span>     <span class="token comment">// ++i;</span>     cout<span class="token operator">&lt;&lt;</span>i<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>     <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><p><strong>红黑树的特性</strong>:*<em>（1）每个节点或者是黑色，或者是红色。</em><em><strong>（2）根节点是黑色。</strong></em><em>（3）每个叶子节点（NIL）是黑色。 [注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！]<strong><strong>（4）如果一个节点是红色的，则它的子节点必须是黑色的。</strong></strong>（5）从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。</em>*</p><p><strong>红黑树的应用</strong></p><p>红黑树的应用比较广泛，主要是用它来存储有序的数据，它的时间复杂度是O(log2n)，效率非常之高。<strong>例如，Java集合中的<a href="http://www.cnblogs.com/skywang12345/p/3311268.html">TreeSet</a>和<a href="http://www.cnblogs.com/skywang12345/p/3310928.html">TreeMap</a>，C++ STL中的set、map，以及Linux虚拟内存的管理，都是通过红黑树去实现的。</strong></p><h2 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h2><p>总的来说</p><ul><li>（1）修饰变量，static 修饰的静态局部变量只执行初始化一次，延长了局部变量的生命周期，直到程序运行结束以后才释放。 +  （2）修饰全局变量：全局变量只能在本文件中访问，不能在其它文件中访问， <strong>extern 外部声明</strong>也不可以。 +  （3）修饰一个函数，则这个函数的只能在本文件中调用，不能被其他文件调用。static 修饰的变量存放在全局数据区的静态变量区，包括全局静态变量和局部静态变量，都在全局数据区分配内存。初始化的时候自动初始化为 0。 +  （4）不想被释放的时候，可以使用static修饰。比如修饰函数中存放在栈空间的数组，如果不想让这个数组在函数调用结束释放可以使用 static 修饰。 +  （5）考虑到数据安全性（当程序想要使用全局变量的时候应该先考虑使用 static）。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++内存模型、编译过程、gcc命令</title>
      <link href="/2023/06/20/c-nei-cun-mo-xing-bian-yi-guo-cheng-gcc-ming-ling/"/>
      <url>/2023/06/20/c-nei-cun-mo-xing-bian-yi-guo-cheng-gcc-ming-ling/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="c-内存模型"><a href="#c-内存模型" class="headerlink" title="c++内存模型"></a>c++内存模型</h2><p>1、源代码区：存储代码的区域（类似jvm里的方法区） 2、静态区：存储<strong>静态</strong>变量和<strong>全局变量</strong>的区域（类似jvm里的方法区里的方法区） 3、栈区：存储<strong>局部变量</strong>和<strong>参数</strong>的内存区域，<strong>由系统开辟、由系统回收的内存区域</strong> 4、堆区：<strong>程序员开辟</strong>的一块内存区域用来存储对象的区域，由<strong>用户开辟和回收</strong>的内存区域。 5、常量区(字面值区)：存储const常量 指针变量能指向那些区域： 栈区、堆区、静态区、常量区、代码区</p><p><img src="https://img-blog.csdnimg.cn/aacad79859a442289a42a7b8467a614b.png"></p><p>堆区和栈区的注意点：</p><p>1、栈是向下增长，而堆是向上增长。</p><p>2、栈由系统管理，没有内存碎片，每个元素之间都是连续的；堆区存储的是程序员new出来的变量，是动态开辟的。</p><h2 id="c-编译过程"><a href="#c-编译过程" class="headerlink" title="c++编译过程"></a>c++编译过程</h2><ul><li><strong>编译预处理</strong>+ <strong>编译、优化阶段</strong>+ <strong>汇编</strong>+ <strong>链接</strong></li></ul><p><strong>链接过程</strong></p><p>主要是解决在一个文件中引用了另外的一个文件中变量或函数的问题，它将有关的目标文件彼此相连接，使得所有的这些目标文件成为一个能够被操作系统装入执行的统一整体。</p><p>在《编译原理》中我们可以了解到一个编译器对程序代码的编译主要分为下面几个过程：a) 词法分析 b) 语法分析 c) 语义分析 d) 中间代码生成 e) 代码优化 f) 目标代码生成 g) 符号表管理 h) 将多个步骤组合成趟 i) 编译器构造工具</p><h2 id="GCC编译过程"><a href="#GCC编译过程" class="headerlink" title="GCC编译过程"></a>GCC编译过程</h2><p><img src="https://img-blog.csdnimg.cn/img_convert/83d6486e62afc8830623c71b51a32dc1.png"></p><p>在Linux下使用的gcc编译器将上面几个过程捆绑在一起，简化我们的使用，但是我们依然可以通过指定不同的参数，来分别执行各个过程：<br>命令（-o后面都是自己指定的文件名字）工作内容gcc -E hello.c -o hello.i预处理gcc -S hello.c -o hello.s编译gcc hello.s -o hello.o汇编gcc hello.o -o hello链接</p><p>1.cpp的内容</p><p><img src="https://img-blog.csdnimg.cn/37e54de88a0442949d95bfd5983d6a6c.png"></p><p>执行预处理命令后： （文件名是1.cpp）</p><p><img src="https://img-blog.csdnimg.cn/a54b46b64e934fc7ab827dff5d873618.png"></p><p>一步编译运行： </p><p> <br><img src="https://img-blog.csdnimg.cn/72c6d674b3784babb0f0d7fdc3e8fcaf.png"></p><h2 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h2><p><a href="https://paul.pub/cpp-memory-model/">C++ 内存模型</a></p><p><a href="https://www3.ntu.edu.sg/home/ehchua/programming/cpp/gcc_make.html">GCC and Make - A Tutorial on how to compile, link and build C&#x2F;C++ applications</a></p><p><a href="https://blog.csdn.net/Hongwei_1990/article/details/84558733">C&#x2F;C++ 编译流程（预处理、编译、汇编、链接）_deepwater_zone的博客-CSDN博客</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++_多线程：原子操作atomic</title>
      <link href="/2023/06/20/c-duo-xian-cheng-yuan-zi-cao-zuo-atomic/"/>
      <url>/2023/06/20/c-duo-xian-cheng-yuan-zi-cao-zuo-atomic/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="原子操作atomic"><a href="#原子操作atomic" class="headerlink" title="原子操作atomic"></a>原子操作atomic</h2><p><a href="https://juejin.cn/post/7086226046931959838">C++ 多线程：原子类型</a></p><p>有两个线程，一个要写数据，一个读数据，如果不加锁，可能会造成读写值混乱，使用<code>std::mutex</code>程序执行不会导致混乱，<strong>但是每一次循环都要加锁解锁是的程序开销很大。</strong> 为了提高性能，C++11提供了原子类型(<code>std::atomic&lt;T&gt;</code>)，它提供了多线程间的原子操作，可以把原子操作理解成一种： <strong>不需要用到互斥量加锁（无锁）技术的多线程并发编程方式。</strong> 它定义在<code>&lt;atomic&gt;</code>头文件中，原子类型是封装了一个值的类型，它的访问保证不会导致数据的竞争，并且可以用于在不同的线程之间同步内存访问。从效率上来说，原子操作要比互斥量的方式效率要高。</p><p><strong>atomic类型原子操作宣告C++11来到了多线程和并行编程的时代。</strong> 相对于偏于底层的<code>pthread</code>库，C++通过定义原子类型的方式，轻松地化解了互斥访问共享数据的难题。</p><p>atomic的两个方法：load()&#x2F;&#x2F;读取数据 store()&#x2F;&#x2F;存储数据 fetch_add(val)&#x2F;&#x2F;加法 fetch_sub(val)&#x2F;&#x2F;减法 exchange()</p><p>可以用在指针对象上，但是只表示指针是原子类型，指针指向的数据不一定是，atomic&lt;int *&gt; ptr;</p><p>关于load、store的例子：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// atomic::load/store example</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span>       <span class="token comment">// std::cout</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;atomic></span>         <span class="token comment">// std::atomic, std::memory_order_relaxed</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;thread></span>         <span class="token comment">// std::thread</span></span>std<span class="token double-colon punctuation">::</span>atomic<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">foo</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">set_foo</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  foo<span class="token punctuation">.</span><span class="token function">store</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>memory_order_relaxed<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// set value atomically</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">print_foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">int</span> x<span class="token punctuation">;</span>  <span class="token keyword">do</span> <span class="token punctuation">&#123;</span>    x <span class="token operator">=</span> foo<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>memory_order_relaxed<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// get value atomically</span>  <span class="token punctuation">&#125;</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>x<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"foo: "</span> <span class="token operator">&lt;&lt;</span> x <span class="token operator">&lt;&lt;</span> <span class="token char">'\n'</span><span class="token punctuation">;</span>  <span class="token comment">// 10</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  std<span class="token double-colon punctuation">::</span>thread <span class="token function">first</span> <span class="token punctuation">(</span>print_foo<span class="token punctuation">)</span><span class="token punctuation">;</span>  std<span class="token double-colon punctuation">::</span>thread <span class="token function">second</span> <span class="token punctuation">(</span>set_foo<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  first<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  second<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++的智能指针</title>
      <link href="/2023/06/20/c-de-zhi-neng-zhi-zhen/"/>
      <url>/2023/06/20/c-de-zhi-neng-zhi-zhen/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p><strong>目录</strong></p><p><a href="#%E5%89%8D%E8%A8%80">前言</a></p><p><a href="#1%E3%80%81unique_ptr">1、unique_ptr</a></p><p><a href="#2%E3%80%81auto_ptr">2、auto_ptr</a></p><p><a href="#%E5%BC%95%E5%85%A5%E9%97%AE%E9%A2%98">引入问题</a></p><p><a href="#3%E3%80%81shared_ptr">3、shared_ptr</a></p><p><a href="#%E6%8E%A5%E5%8F%A3%EF%BC%9A">接口：</a></p><p><a href="#4%E3%80%81weak_ptr">4、weak_ptr</a></p><p><a href="#%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0%EF%BC%9A">参考文章：</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>C++STL（Standard Template Library）一共提供了四种指针：auto_ptr、unique_ptr、shared_ptr 和 weak_ptr，其中auto_ptr是c++98提供的，C++11 已将其摒弃，并提出了 unique_ptr 替代 auto_ptr。</p><h2 id="1、unique-ptr"><a href="#1、unique-ptr" class="headerlink" title="1、unique_ptr"></a>1、unique_ptr</h2><p>独占的指针，只可以自己使用，它指向的对象只可以他一个人使用，可以使用move将使用权转移，如：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;memory></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">auto</span> ptr1<span class="token operator">=</span><span class="token generic-function"><span class="token function">make_unique</span><span class="token generic class-name"><span class="token operator">&lt;</span>string<span class="token operator">></span></span></span> <span class="token punctuation">(</span><span class="token string">"12345"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cout<span class="token operator">&lt;&lt;</span><span class="token operator">*</span>ptr1<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    <span class="token keyword">auto</span> ptr2<span class="token operator">=</span>std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>ptr1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// cout&lt;&lt;*ptr1&lt;&lt;endl;</span>    cout<span class="token operator">&lt;&lt;</span><span class="token operator">*</span>ptr2<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 12345</span><span class="token comment">// 12345</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>创建智能指针的方法：通过构造函数指定、通过 reset 方法重新指定、通过 release 方法释放所有权、通过移动语义转移所有权（move），unique_ptr 还可能没有对象，这种情况被称为 empty。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#include &lt;iostream></span><span class="token comment">#include &lt;memory></span>using namespace std<span class="token punctuation">;</span>int <span class="token function-name function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    unique_ptr<span class="token operator">&lt;</span>int<span class="token operator">></span> p1<span class="token punctuation">;</span>    p1.reset<span class="token punctuation">(</span>new int<span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">))</span><span class="token punctuation">;</span>    cout<span class="token operator">&lt;&lt;</span>*p<span class="token operator"><span class="token file-descriptor important">1</span>&lt;</span><span class="token operator">&lt;</span>endl<span class="token punctuation">;</span>    unique_ptr<span class="token operator">&lt;</span>int<span class="token operator">></span> p2<span class="token punctuation">(</span>new int<span class="token punctuation">(</span><span class="token number">1234</span><span class="token punctuation">))</span><span class="token punctuation">;</span>    cout<span class="token operator">&lt;&lt;</span>*p<span class="token operator"><span class="token file-descriptor important">2</span>&lt;</span><span class="token operator">&lt;</span>endl<span class="token punctuation">;</span>    int *p3<span class="token operator">=</span>p1.release<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cout<span class="token operator">&lt;&lt;</span>*p<span class="token operator"><span class="token file-descriptor important">3</span>&lt;</span><span class="token operator">&lt;</span>endl<span class="token punctuation">;</span>    unique_ptr<span class="token operator">&lt;</span>int<span class="token operator">></span> <span class="token assign-left variable">p4</span><span class="token operator">=</span>move<span class="token punctuation">(</span>p2<span class="token punctuation">)</span><span class="token punctuation">;</span>    cout<span class="token operator">&lt;&lt;</span>*p<span class="token operator"><span class="token file-descriptor important">4</span>&lt;</span><span class="token operator">&lt;</span>endl<span class="token punctuation">;</span>    <span class="token builtin class-name">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>// <span class="token number">123</span>// <span class="token number">1234</span>// <span class="token number">123</span>// <span class="token number">1234</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2、auto-ptr"><a href="#2、auto-ptr" class="headerlink" title="2、auto_ptr"></a>2、auto_ptr</h2><h3 id="引入问题"><a href="#引入问题" class="headerlink" title="引入问题"></a>引入问题</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">auto_ptr<span class="token operator">&lt;</span> string<span class="token operator">></span> <span class="token function">p1</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">string</span> <span class="token punctuation">(</span><span class="token string">"string1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>auto_ptr<span class="token operator">&lt;</span>string<span class="token operator">></span> p2<span class="token punctuation">;</span>p2<span class="token operator">=</span>p1<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>如果上面的指针是普通的指针，那么就会面临一个问题，就是delete的时候会删除有两次，<strong>解决方案有多种：</strong></p><p>1、重载复制运算符，将其定义为深复制，这样他们俩就会指向不同的地方，缺点是会浪费空间。</p><p>2、建立所有全概念。将指针定义为只可以有一个对象拥有，赋值运算符直接将所有权转移。这就是用于 auto_ptr 和 unique_ptr 的策略，但 unique_ptr 的策略更严格。</p><p>3、创建智能更高的指针，跟踪引用特定对象的智能指针数。这称为引用计数。例如，赋值时，计数将加 1，而指针过期时，计数将减 1,。当减为 0 时才调用 delete。这是 shared_ptr 采用的策略。</p><h2 id="3、shared-ptr"><a href="#3、shared-ptr" class="headerlink" title="3、shared_ptr"></a>3、shared_ptr</h2><p>shared_ptr 是一个标准的共享所有权的智能指针，<strong>允许多个指针指向同一个对象</strong>，定义在 memory 文件中，命名空间为 std。shared_ptr 利用引用计数的方式实现了对所管理的对象的所有权的分享，即允许多个 shared_ptr 共同管理同一个对象。像 shared_ptr 这种智能指针，《Effective C++》称之为“引用计数型智能指针”（reference-counting smart pointer，RCSP）。</p><p>shared_ptr 是为了解决 auto_ptr 在对象所有权上的局限性（auto_ptr 是独占的），在使用引用计数的机制上提供了可以<strong>共享所有权的</strong>智能指针，当然这需要额外的开销： （1）shared_ptr 对象除了包括一个所拥有对象的指针外，还必须包括一个引用计数代理对象的指针； （2）时间上的开销主要在初始化和拷贝操作上， * 和 -&gt; 操作符重载的开销跟 auto_ptr 是一样； （3）开销并不是我们不使用 shared_ptr 的理由,，永远不要进行不成熟的优化，直到性能分析器告诉你这一点。</p><p>可以使用辅助类来实现该智能指针，它的<strong>具体做法</strong>如下： （a）当创建智能指针类的新对象时，初始化指针，<strong>并将引用计数设置为1；</strong> （b）当能智能指针类对象作为另一个对象的副本时，<strong>拷贝构造函数</strong>复制副本的指向辅助类对象的指针，并增加辅助类对象对基础类对象的引用计数（加1）； （c）使用赋值操作符对一个智能指针类对象进行赋值时，处理复杂一点：先使左操作数的引用计数减 1（为何减 1：因为指针已经指向别的地方），如果减1后引用计数为 0，则释放指针所指对象内存。然后增加右操作数所指对象的引用计数（为何增加：因为此时做操作数指向对象即右操作数指向对象）； （d）完成析构函数：调用析构函数时，析构函数先使引用计数减 1，如果减至 0 则 delete 对象。</p><h3 id="接口："><a href="#接口：" class="headerlink" title="接口："></a>接口：</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Point</span> <span class="token punctuation">&#123;</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">int</span> x<span class="token punctuation">,</span> y<span class="token punctuation">;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Point</span><span class="token punctuation">(</span><span class="token keyword">int</span> xVal <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">int</span> yVal <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">x</span><span class="token punctuation">(</span>xVal<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">y</span><span class="token punctuation">(</span>yVal<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    <span class="token keyword">int</span> <span class="token function">getX</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> x<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>    <span class="token keyword">int</span> <span class="token function">getY</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> y<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>    <span class="token keyword">void</span> <span class="token function">setX</span><span class="token punctuation">(</span><span class="token keyword">int</span> xVal<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> x <span class="token operator">=</span> xVal<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>    <span class="token keyword">void</span> <span class="token function">setY</span><span class="token punctuation">(</span><span class="token keyword">int</span> yVal<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> y <span class="token operator">=</span> yVal<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>实现：</strong> </p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">SmartPtr</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span><span class="token comment">//构造函数</span><span class="token function">SmartPtr</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> rp <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token function">SmartPtr</span><span class="token punctuation">(</span>Point <span class="token operator">*</span>ptr<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">rp</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">RefPtr</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token function">SmartPtr</span><span class="token punctuation">(</span><span class="token keyword">const</span> SmartPtr <span class="token operator">&amp;</span>sp<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">rp</span><span class="token punctuation">(</span>sp<span class="token punctuation">.</span>rp<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token operator">++</span>rp<span class="token operator">-></span>count<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"in copy constructor"</span> <span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 重载赋值运算符</span>SmartPtr<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> SmartPtr<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token operator">++</span>rhs<span class="token punctuation">.</span>rp<span class="token operator">-></span>count<span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>rp <span class="token operator">!=</span> <span class="token keyword">nullptr</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">--</span>rp<span class="token operator">-></span>count <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">delete</span> rp<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>rp <span class="token operator">=</span> rhs<span class="token punctuation">.</span>rp<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"in assignment operator"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 重载->操作符</span>Point<span class="token operator">*</span> <span class="token keyword">operator</span><span class="token operator">-></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> rp<span class="token operator">-></span>p<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 重载*操作符</span>Point<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token operator">*</span><span class="token punctuation">(</span>rp<span class="token operator">-></span>p<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token operator">~</span><span class="token function">SmartPtr</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">--</span>rp<span class="token operator">-></span>count <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">delete</span> rp<span class="token punctuation">;</span><span class="token keyword">else</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"还有"</span> <span class="token operator">&lt;&lt;</span> rp<span class="token operator">-></span>count <span class="token operator">&lt;&lt;</span> <span class="token string">"个指针指向基础对象"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">private</span><span class="token operator">:</span>RefPtr<span class="token operator">*</span> rp<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4、weak-ptr"><a href="#4、weak-ptr" class="headerlink" title="4、weak_ptr"></a>4、weak_ptr</h2><p>这个智能指针只能算是一个辅助类的指针，没有重载 operator* 和 operator-&gt; ，因此取名为 weak，表明其是功能较弱的智能指针。<strong>它的最大作用在于协助 shared_ptr 工作，可获得资源的观测权，像旁观者那样观测资源的使用情况。观察者意味着 weak_ptr 只对 shared_ptr 进行引用，而不改变其引用计数，当被观察的 shared_ptr 失效后，相应的 weak_ptr 也相应失效。</strong></p><p>解决循环引用的问题，用法：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">weak_ptr<span class="token operator">&lt;</span>T<span class="token operator">></span> w<span class="token punctuation">;</span> <span class="token comment">//创建空 weak_ptr，可以指向类型为 T 的对象</span>weak_ptr<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">w</span><span class="token punctuation">(</span>sp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//与 shared_ptr 指向相同的对象，shared_ptr 引用计数不变。T必须能转换为 sp 指向的类型</span>w<span class="token operator">=</span>p<span class="token punctuation">;</span><span class="token comment">//p 可以是 shared_ptr 或 weak_ptr，赋值后 w 与 p 共享对象</span>w<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//将 w 置空</span>w<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//返回与 w 共享对象的 shared_ptr 的数量</span>w<span class="token punctuation">.</span><span class="token function">expired</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//若 w.use_count() 为 0，返回 true，否则返回 false</span>w<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//如果 expired() 为 true，返回一个空 shared_ptr，否则返回非空 shared_ptr</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>weak_ptr 对象引用资源时不会增加引用计数，但是它能够通过 lock() 方法来判断它所管理的资源是否被释放。</p><h2 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h2><p><a href="https://blog.csdn.net/K346K346/article/details/81478223?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165743267316781432922953%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=165743267316781432922953&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-81478223-null-null.142%5Ev32%5Eexperiment_2_v1,185%5Ev2%5Econtrol&utm_term=c++%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88&spm=1018.2226.3001.4187">C++ STL 四种智能指针_恋喵大鲤鱼的博客-CSDN博客_智能指针</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSDN_博客导出工具,_用于将_CSDN_博客导出为_Markdown_/_PDF</title>
      <link href="/2023/06/20/csdn-bo-ke-dao-chu-gong-ju-yong-yu-jiang-csdn-bo-ke-dao-chu-wei-markdownpdf/"/>
      <url>/2023/06/20/csdn-bo-ke-dao-chu-gong-ju-yong-yu-jiang-csdn-bo-ke-dao-chu-wei-markdownpdf/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="CSDNExporter"><a href="#CSDNExporter" class="headerlink" title="CSDNExporter"></a>CSDNExporter</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>CSDN 博客导出工具, 用于将 CSDN 博客导出为 Markdown &#x2F; PDF 格式. 比较赞的地方在于, 它 不仅支持一篇博文的导出, 还支持将某个类目下的博文批量导出, 以及将导出的多篇博文汇总为 一篇, 以便用于全局搜索, 具体效果可以查看 .</p><h2 id="运行脚本"><a href="#运行脚本" class="headerlink" title="运行脚本"></a>运行脚本</h2><ul><li>Linux系统运行 启动脚本为 <code>./run.sh</code>, 使用 <code>chmod +x run.sh</code> 增加其可执行权限;(并没有测试)</li><li>Windows系统启动 启动脚本为<code>run.bat</code>, 双击打开或者在cmd中运行<code>run.bat</code>。</li></ul><h2 id="修改的地方"><a href="#修改的地方" class="headerlink" title="修改的地方"></a>修改的地方</h2><p>1、将下载的博客的图片分开保存在title…assets文件中，博客中有图片的时候才会创建图片目录，只会创建一次</p><p>utils.py 增加了一个参数title</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> html<span class="token punctuation">,</span> title<span class="token punctuation">,</span> is_win<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    self<span class="token punctuation">.</span>html <span class="token operator">=</span> html    self<span class="token punctuation">.</span>soup <span class="token operator">=</span> BeautifulSoup<span class="token punctuation">(</span>html<span class="token punctuation">,</span> <span class="token string">'html.parser'</span><span class="token punctuation">)</span>    self<span class="token punctuation">.</span>outputs <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    self<span class="token punctuation">.</span>fig_dir <span class="token operator">=</span> <span class="token string-interpolation"><span class="token string">f'./figures/</span><span class="token interpolation"><span class="token punctuation">&#123;</span>title<span class="token punctuation">&#125;</span></span><span class="token string">'</span></span><span class="token operator">+</span><span class="token string">'.assets'</span>    self<span class="token punctuation">.</span>pre <span class="token operator">=</span> <span class="token boolean">False</span>    self<span class="token punctuation">.</span>equ_inline <span class="token operator">=</span> <span class="token boolean">False</span>    self<span class="token punctuation">.</span>is_win <span class="token operator">=</span> is_win    self<span class="token punctuation">.</span>recursive<span class="token punctuation">(</span>self<span class="token punctuation">.</span>soup<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>recursive(self, soup):</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">recursive</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> soup<span class="token punctuation">)</span><span class="token punctuation">:</span>    …………    <span class="token keyword">elif</span> tag <span class="token operator">==</span> <span class="token string">'img'</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token keyword">not</span> exists<span class="token punctuation">(</span>self<span class="token punctuation">.</span>fig_dir<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment"># 博客中有图片的时候才会创建图片目录，只会创建一次</span>            os<span class="token punctuation">.</span>makedirs<span class="token punctuation">(</span>self<span class="token punctuation">.</span>fig_dir<span class="token punctuation">)</span>    …………<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2、输入用户名就可以直接找到的用户的博客专栏，拿到所有专栏下面的文章</p><p>run.bat 先将所有的categories保存在userName.txt中</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token keyword">if</span> %download_category% <span class="token operator">==</span> <span class="token string">"true"</span> <span class="token punctuation">(</span>  <span class="token builtin class-name">echo</span> <span class="token string">"Obtain blog directory link: save in userName.txt........"</span>  python <span class="token parameter variable">-u</span> link.py %userName%<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>再读取userName.txt文件的链接</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token keyword">for</span> /f <span class="token string">"tokens=* delims="</span> %%a <span class="token keyword">in</span> <span class="token punctuation">(</span>m0_67623521.txt<span class="token punctuation">)</span> <span class="token keyword">do</span> <span class="token punctuation">(</span>  <span class="token builtin class-name">echo</span> %%a  <span class="token keyword">if</span> %download_category% <span class="token operator">==</span> <span class="token string">"true"</span> <span class="token punctuation">(</span>      <span class="token builtin class-name">echo</span> <span class="token string">"Download a category"</span>      python <span class="token parameter variable">-u</span> main.py ^          <span class="token parameter variable">--category_url</span> %%a ^          <span class="token parameter variable">--start_page</span> %start_page% ^          <span class="token parameter variable">--page_num</span> %page_num% ^          <span class="token parameter variable">--markdown_dir</span> %markdown_dir% ^          <span class="token parameter variable">--pdf_dir</span> %pdf_dir% ^          <span class="token parameter variable">--combine_together</span> ^          <span class="token parameter variable">--to_pdf</span> ^          <span class="token parameter variable">--is_win</span> <span class="token number">1</span>          @REM <span class="token parameter variable">--with_title</span> ^          @REM <span class="token parameter variable">--rm_cache</span>   <span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>link.py</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">user <span class="token operator">=</span> sys<span class="token punctuation">.</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token comment"># 拿到命令行下的用户名参数</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将连接写入文件</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">for</span> li <span class="token keyword">in</span> lis<span class="token punctuation">:</span>    <span class="token comment"># print("####")</span>    url <span class="token operator">=</span> li<span class="token punctuation">.</span>find<span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>attrs<span class="token punctuation">[</span><span class="token string">'href'</span><span class="token punctuation">]</span>    title <span class="token operator">=</span> li<span class="token punctuation">.</span>find<span class="token punctuation">(</span><span class="token string">"span"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>attrs<span class="token punctuation">[</span><span class="token string">'title'</span><span class="token punctuation">]</span>    titles<span class="token punctuation">.</span>append<span class="token punctuation">(</span>title<span class="token punctuation">)</span>    infos<span class="token punctuation">[</span>title<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token string">"url"</span><span class="token punctuation">:</span>url<span class="token punctuation">&#125;</span>    <span class="token comment"># print("[+]"+title+url)</span>    <span class="token keyword">with</span> <span class="token builtin">open</span><span class="token punctuation">(</span>user<span class="token operator">+</span><span class="token string">'.txt'</span><span class="token punctuation">,</span><span class="token string">'a+'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> f<span class="token punctuation">:</span>    <span class="token comment">#设置文件对象</span>        f<span class="token punctuation">.</span>write<span class="token punctuation">(</span>url<span class="token punctuation">)</span>        f<span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">'\n'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>另外要说明的是:</p><ul><li>安装必要的 Python 库, 如 <code>httpx</code>, <code>requests</code>, <code>BeautifulSoup</code>, <code>bs4</code>;</li><li>为了解析图片链接, 需要安装 <a href="https://aria2.github.io/">aria2</a>, 并保证能在命令行启动;</li><li>为了转换为 PDF, 需要安装 <a href="https://pandoc.org/">Pandoc</a>，(博主该功能我并没有测试)。</li><li>该博客导出工具再我的需求下就是拿到md文件，现在的功能我还是比较满意</li></ul><h2 id="对于安装aria2的问题"><a href="#对于安装aria2的问题" class="headerlink" title="对于安装aria2的问题"></a>对于安装aria2的问题</h2><p>我参考了以下博文：</p><p><a href="https://blog.csdn.net/weizuer123/article/details/127411328">电脑Windows安装Aria2配置详细教程全能的下载神器</a></p><p><a href="https://www.bilibili.com/read/cv21314846?from=search">Aria2小白入门级部署</a></p><p><a href="https://tomford1986.blogspot.com/2018/01/aria2.html">超简单的Aria2使用教程</a></p><p><a href="https://controlnet.space/2021/06/08/note/aria2-setup/">Aria2傻瓜安装部署指南</a></p><p><a href="http://aria2c.com/usage.html">Aria2 &amp; YAAW 使用说明</a></p><p>如果想要下载配置好的aria2，可以在CSDN私聊<a href="https://blog.csdn.net/m0_67623521?type=blog">我的博客</a> 。</p><h2 id="Author"><a href="#Author" class="headerlink" title="Author"></a>Author</h2><p><a href="https://github.com/allenmirac/CSDNExporter">allenmirac-CSDNExporter</a></p><h1 id="巨人的肩膀"><a href="#巨人的肩膀" class="headerlink" title="巨人的肩膀"></a>巨人的肩膀</h1><p><a href="https://github.com/axzml/CSDNExporter">axzml-CSDNExporter</a></p><p><a href="https://blog.csdn.net/Eric_1993/article/details/104772437">导出 CSDN 博客至 Markdown 或 PDF 格式 (近乎完美)</a></p><p><a href="https://blog.csdn.net/qq_53381910/article/details/130816856">获取指定博主所有专栏链接及博文链接</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CPP指针的种类以及区别</title>
      <link href="/2023/06/20/cpp-zhi-zhen-de-chong-lei-yi-ji-qu-bie/"/>
      <url>/2023/06/20/cpp-zhi-zhen-de-chong-lei-yi-ji-qu-bie/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="CPP指针"><a href="#CPP指针" class="headerlink" title="CPP指针"></a>CPP指针</h1><h2 id="空指针"><a href="#空指针" class="headerlink" title="空指针"></a>空指针</h2><p>在C和C++中，用0和<code>NULL</code>都可以表示空指针</p><p>空指针误操作的后果：如果对空指针解引用，程序会崩溃，<strong>如果对空指针使用 delete 运算符，程序会忽略这个操作，不会出现异常，所以，在内存被释放之后也应该，把指针置为空指针</strong>。</p><p><strong>1、为什么空指针会出现访问异常？</strong></p><p>NULL空指针被分配的区域是一个空闲的区域，没有对应的物理空间与之对应，所以对这段空间来说，任何读操作都是非法的，并且<strong>无论何时</strong>都要保证这个区域都没有与之对应的地址（空指针区域）。</p><p><strong>2、C++ 11 的 nullptr</strong></p><p>由于 使用 0 和 <code>NULL</code> 表示空指针会出现歧义，C++ 11 推荐使用 <code>nullptr</code> ，也就是 <code>(void *)0</code>。</p><p><strong>注意：</strong> 在 Linux 平台下，要使用<code>nullptr </code>编译需要加上 <code>-std=C++11</code>参数</p><h2 id="野指针"><a href="#野指针" class="headerlink" title="野指针"></a>野指针</h2><p>指针只申明，但未初始化，就会出现，<code>int* p</code>，此时p就是野指针。</p><p><strong>规避方法：</strong> 1）指针在定义的时候，如果没地方指，就初始化为 <code>nullptr</code> 。 2）动态分配的内存被释放后，将其置为 <code>nullptr</code> 。 3）不要返回局部变量的地址。 <strong>注意：</strong> 野指针的危害比空指针要大很多，在程序中，如果访问野指针，可能会造成程序的崩溃。是<strong>可能，不是一定（因为你也不知道它初始化到底指向了哪里）</strong>，程序的表现是不稳定，增加了调试程序的难度。</p><h2 id="指针与数组名的区别"><a href="#指针与数组名的区别" class="headerlink" title="指针与数组名的区别"></a>指针与数组名的区别</h2><p>指针是一个地址占4个字节，而数组名是一种数据结构，可以通过 <code>sizeof</code> 体现出来</p><pre class="line-numbers language-none"><code class="language-none">#include&lt;iostream&gt;using namespace std;int main()&#123;  int a[10];  int *a1;  cout&lt;&lt;sizeof(a)&lt;&lt;endl;&#x2F;&#x2F;40  cout&lt;&lt;sizeof(a1)&lt;&lt;endl;&#x2F;&#x2F;4&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但是有一种特殊情况，当数组名作为<strong>函数的参数</strong>来传递的时候，他的高贵的数组结构特性已经失去了，成了一个地地道道的只拥有4个字节的<strong>平民</strong>。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">func1</span><span class="token punctuation">(</span><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    cout<span class="token operator">&lt;&lt;</span><span class="token string">"sizeof(arr): "</span><span class="token operator">&lt;&lt;</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token operator">/</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        cout<span class="token operator">&lt;&lt;</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">func2</span><span class="token punctuation">(</span><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> len<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//所以一定要加上数组的长度。</span>    cout<span class="token operator">&lt;&lt;</span><span class="token string">"sizeof(arr): "</span><span class="token operator">&lt;&lt;</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        cout<span class="token operator">&lt;&lt;</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    cout<span class="token operator">&lt;&lt;</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    <span class="token function">func1</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">func2</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//20</span><span class="token comment">//sizeof(arr): 4</span><span class="token comment">//1</span><span class="token comment">//sizeof(arr): 4</span><span class="token comment">//1</span><span class="token comment">//2</span><span class="token comment">//3</span><span class="token comment">//4</span><span class="token comment">//5</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++_inline关键字</title>
      <link href="/2023/06/20/cinline-guan-jian-zi/"/>
      <url>/2023/06/20/cinline-guan-jian-zi/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="inline关键字"><a href="#inline关键字" class="headerlink" title="inline关键字"></a>inline关键字</h2><p>在函数声明和定义加上，使之称为内联函数。如果一些简单的函数直接在类中声明并且定义，编译器可以将其优化为内联函数。</p><p>注：内联函数可以减少函数的执行时间：原因是它可以在使用时直接进行替换（像宏一样展开），从而避免出现参数压栈、代码生成等操作，但是如果函数体过大，编译器就不会将其作为内联函数，即使加了关键字inline，同时内联函数不能递归。</p><p>inline关键字声明的函数依旧是函数，所以会有类型检查，可以消除C语言宏的一些缺点。</p><p>关键字inline必须与函数定义放在一起才能使函数成为内联函数，仅仅将inline放在函数声明前面不起任何作用。<strong>inline是一种“用于实现”的关键字，而不是一种“用于声明”的关键字。</strong></p><p><strong>示例</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">EXAMPLE_H</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">EXAMPLE_H</span></span> <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;atomic></span></span> <span class="token comment">// function included in multiple source files must be inline</span><span class="token keyword">inline</span> <span class="token keyword">int</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token comment">// variable with external linkage included in multiple source files must be inline</span><span class="token keyword">inline</span> std<span class="token double-colon punctuation">::</span>atomic<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">counter</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"example.h"</span></span> <span class="token keyword">int</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token operator">++</span>counter<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"example.h"</span></span> <span class="token keyword">int</span> <span class="token function">b</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token operator">++</span>counter<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><h3 id="慎用-inline"><a href="#慎用-inline" class="headerlink" title="慎用 inline"></a>慎用 inline</h3><p>内联能提高函数的执行效率，为什么不把所有的函数都定义成内联函数？如果所有的函数都是内联函数，还用得着”内联”这个关键字吗？  内联是以<strong>代码膨胀（复制）</strong>为代价，仅仅省去了函数调用的开销，从而提高函数的执行效率。  如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。</p><p><strong>以下情况不宜使用内联：</strong>  （1）如果函数体内的代码<strong>比较长</strong>，使用内联将导致<strong>内存消耗代价较高</strong>。  （2）如果函数体内出现<strong>循环</strong>，那么执行函数体内代码的时间要比函数调用的开销大。类的构造函数和析构函数容易让人误解成使用内联更有效。要当心<strong>构造函数和析构函数可能会隐藏一些行为</strong>，如”偷偷地”执行了<strong>基类或成员对象</strong>的构造函数和析构函数。所以<strong>不要随便地将构造函数和析构函数的定义体放在类声明中</strong>。一个好的编译器将会根据函数的定义体，自动地取消不值得的内联（这进一步说明了 inline 不应该出现在函数的声明中）。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://baike.baidu.com/item/inline/10566989">百度百科-验证</a></p><p><a href="https://en.cppreference.com/w/cpp/language/inline">inline specifier - cppreference.com</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1020._月饼_(25)-PAT乙级真题</title>
      <link href="/2023/06/20/1020-yue-bing-25pat-yi-ji-zhen-ti/"/>
      <url>/2023/06/20/1020-yue-bing-25pat-yi-ji-zhen-ti/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="1020-月饼"><a href="#1020-月饼" class="headerlink" title="1020. 月饼"></a>1020. 月饼</h2><p>月饼是中国人在中秋佳节时吃的一种传统食品，不同地区有许多不同风味的月饼。现给定所有种类月饼的库存量、总售价、以及市场的最大需求量，请你计算可以获得的最大收益是多少。</p><p>注意：销售时允许取出一部分库存。样例给出的情形是这样的：假如我们有 3 种月饼，其库存量分别为 18、15、10 万吨，总售价分别为 75、72、45 亿元。如果市场的最大需求量只有 20 万吨，那么我们最大收益策略应该是卖出全部 15 万吨第 2 种月饼、以及 5 万吨第 3 种月饼，获得 72 + 45&#x2F;2 &#x3D; 94.5（亿元）。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>每个输入包含一个测试用例。每个测试用例先给出一个不超过 1000 的正整数 N 表示月饼的种类数、以及不超过 500（以万吨为单位）的正整数 D 表示市场最大需求量。随后一行给出 N 个正数表示每种月饼的库存量（以万吨为单位）；最后一行给出 N 个正数表示每种月饼的总售价（以亿元为单位）。数字间以空格分隔。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>对每组测试用例，在一行中输出最大收益，以亿元为单位并精确到小数点后 2 位。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">3</span> <span class="token number">20</span><span class="token number">18</span> <span class="token number">15</span> <span class="token number">10</span><span class="token number">75</span> <span class="token number">72</span> <span class="token number">45</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">94.50</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>代码长度限制:16 KB；时间限制：150 ms；内存限制：64 MB。</p><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;algorithm></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">mooncake</span><span class="token punctuation">&#123;</span>    <span class="token keyword">float</span> num<span class="token punctuation">,</span> price<span class="token punctuation">,</span> unit<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">bool</span> <span class="token function">cmp</span><span class="token punctuation">(</span>mooncake a<span class="token punctuation">,</span> mooncake b<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> a<span class="token punctuation">.</span>unit <span class="token operator">></span> b<span class="token punctuation">.</span>unit<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> n<span class="token punctuation">,</span> need<span class="token punctuation">;</span>    cin<span class="token operator">>></span>n<span class="token operator">>></span>need<span class="token punctuation">;</span>    vector<span class="token operator">&lt;</span>mooncake<span class="token operator">></span> <span class="token function">v</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%f"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%f"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>price<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>unit <span class="token operator">=</span> v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>price<span class="token operator">/</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>num<span class="token punctuation">;</span>    <span class="token function">sort</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> v<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> cmp<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">float</span> sum<span class="token operator">=</span><span class="token number">0.0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>num<span class="token operator">&lt;=</span>need<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            sum<span class="token operator">+=</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>price<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">else</span><span class="token punctuation">&#123;</span>            sum<span class="token operator">+=</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>unit<span class="token operator">*</span>need<span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        need<span class="token operator">-=</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>num<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%.2f"</span><span class="token punctuation">,</span> sum<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 法学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1015_Reversible_Primes（20）</title>
      <link href="/2023/06/20/1015reversibleprimes20/"/>
      <url>/2023/06/20/1015reversibleprimes20/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="1015-Reversible-Primes（20）"><a href="#1015-Reversible-Primes（20）" class="headerlink" title="1015_Reversible_Primes（20）"></a>1015_Reversible_Primes（20）</h1><h3 id="Describe"><a href="#Describe" class="headerlink" title="Describe"></a>Describe</h3><p>A <strong>reversible prime</strong> in any number system is a prime whose “reverse” in that number system is also a prime. For example in the decimal system 73 is a reversible prime because its reverse 37 is also a prime.</p><p>Now given any two positive integers N (&lt;105) and D (1&lt;D≤10), you are supposed to tell if N is a reversible prime with radix D.</p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>The input file consists of several test cases. Each case occupies a line which contains two integers N and D. The input is finished by a negative N.</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, print in one line <code>Yes</code> if N is a reversible prime with radix D, or <code>No</code> if not.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">73</span> <span class="token number">10</span><span class="token number">23</span> <span class="token number">2</span><span class="token number">23</span> <span class="token number">10</span><span class="token parameter variable">-2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">YesYesNo<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>代码长度限制                        16 KB</p><p>时间限制                                400 ms</p><p>内存限制                                64 MB</p><h3 id="Code："><a href="#Code：" class="headerlink" title="Code："></a>Code：</h3><p>刚开始题目都没有看懂，总是不能理解radix是什么意思，做题目做少了（下次看到radix就想到可能需要进制的转换）我很想知道我总是最后一个测试点过不去，刚开始只得到了16分，是因为判断素数的时候没有把1考虑进去，加上之后还是只有18分😭，希望在评论区有大佬可以帮我找到错误。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdlib.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;math.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;string.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;algorithm></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;map></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;unordered_map></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;vector></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;queue></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stack></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;string></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;set></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">bool</span> <span class="token function">isPrime</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>n<span class="token operator">&lt;=</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span> i<span class="token operator">*</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//要加上=号</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>n<span class="token operator">%</span>i<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">ONLINE_JUDGE</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span></span>    <span class="token function">freopen</span><span class="token punctuation">(</span><span class="token string">"1.txt"</span><span class="token punctuation">,</span> <span class="token string">"r"</span><span class="token punctuation">,</span> <span class="token constant">stdin</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>    <span class="token comment">//加入自己的代码</span>    <span class="token keyword">long</span> <span class="token keyword">long</span> n <span class="token punctuation">,</span>d<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>cin<span class="token operator">>></span>n<span class="token operator">>></span>d<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token number">50</span><span class="token punctuation">]</span><span class="token punctuation">,</span> index<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> flag <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>n<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">isPrime</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span>            flag<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">do</span><span class="token punctuation">&#123;</span>            arr<span class="token punctuation">[</span>index<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> n<span class="token operator">%</span>d<span class="token punctuation">;</span>            n<span class="token operator">=</span>n<span class="token operator">/</span>d<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token keyword">while</span><span class="token punctuation">(</span>n<span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>index<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            n<span class="token operator">=</span>n<span class="token operator">*</span>d<span class="token operator">+</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">isPrime</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span>            flag<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>flag<span class="token operator">==</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            cout<span class="token operator">&lt;&lt;</span><span class="token string">"Yes"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>            cout<span class="token operator">&lt;&lt;</span><span class="token string">"No"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这里贴上柳神的代码，思路基本一样的。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstdio></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cmath></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">bool</span> <span class="token function">isprime</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> sqr <span class="token operator">=</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token function">sqrt</span><span class="token punctuation">(</span>n <span class="token operator">*</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> sqr<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">%</span> i <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> n<span class="token punctuation">,</span> d<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>n<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token constant">EOF</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">isprime</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"No\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">continue</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">do</span><span class="token punctuation">&#123;</span>            arr<span class="token punctuation">[</span>len<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> n <span class="token operator">%</span> d<span class="token punctuation">;</span>            n <span class="token operator">=</span> n <span class="token operator">/</span> d<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token keyword">while</span><span class="token punctuation">(</span>n <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>            n <span class="token operator">=</span> n <span class="token operator">*</span> d <span class="token operator">+</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span> <span class="token function">isprime</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token string">"Yes\n"</span> <span class="token operator">:</span> <span class="token string">"No\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 法学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1007_Maximum_Subsequence_Sum(最大连续子段和)</title>
      <link href="/2023/06/20/1007maximumsubsequencesum-zui-da-lian-xu-zi-duan-he/"/>
      <url>/2023/06/20/1007maximumsubsequencesum-zui-da-lian-xu-zi-duan-he/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="1007-Maximum-Subsequence-Sum-最大连续子段和"><a href="#1007-Maximum-Subsequence-Sum-最大连续子段和" class="headerlink" title="1007_Maximum_Subsequence_Sum(最大连续子段和)"></a>1007_Maximum_Subsequence_Sum(最大连续子段和)</h1><p>Given a sequence of K integers { N1​, N2​, …, NK​ }. A continuous subsequence is defined to be { Ni​, Ni+1​, …, Nj​ } where 1≤i≤j≤K. The Maximum Subsequence is the continuous subsequence which has the largest sum of its elements. For example, given sequence { -2, 11, -4, 13, -5, -2 }, its maximum subsequence is { 11, -4, 13 } with the largest sum being 20.</p><p>Now you are supposed to find the largest sum, together with the first and the last numbers of the maximum subsequence.</p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. Each case occupies two lines. The first line contains a positive integer K (≤10000). The second line contains K numbers, separated by a space.</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, output in one line the largest sum, together with the first and the last numbers of the maximum subsequence. The numbers must be separated by one space, but there must be no extra space at the end of a line. In case that the maximum subsequence is not unique, output the one with the smallest indices i and j (as shown by the sample case). If all the K numbers are negative, then its maximum sum is defined to be 0, and you are supposed to output the first and the last numbers of the whole sequence.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">10</span><span class="token parameter variable">-10</span> <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">4</span> <span class="token parameter variable">-5</span> <span class="token parameter variable">-23</span> <span class="token number">3</span> <span class="token number">7</span> <span class="token parameter variable">-21</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">10</span> <span class="token number">1</span> <span class="token number">4</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>代码长度限制        16 KB；时间限制        200 ms；内存限制        64 MB；</p><h3 id="大意："><a href="#大意：" class="headerlink" title="大意："></a>大意：</h3><p>求出最大的子序列的和，以及该最大和序列的首尾元素。</p><h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h3><p>利用num记录序列长度。<strong>关键点：</strong>当sum&lt;0的时候，sum要清零，因为一个小于0的子序列对最大子序列和只有坏处，加上它只会减少。</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream></span> </span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span>  </span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdlib.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;math.h></span>   </span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;string.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;algorithm></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;map></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;unordered_map></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;vector></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;queue></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stack></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;string></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;set></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>   <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">ONLINE_JUDGE</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span>    </span>    <span class="token function">freopen</span><span class="token punctuation">(</span><span class="token string">"1.txt"</span><span class="token punctuation">,</span> <span class="token string">"r"</span><span class="token punctuation">,</span> <span class="token constant">stdin</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span> </span>    <span class="token comment">//加入自己的代码</span>    <span class="token keyword">int</span> n<span class="token punctuation">;</span>    cin<span class="token operator">>></span>n<span class="token punctuation">;</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">v</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">res</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> sum<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> max<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> num<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        cin<span class="token operator">>></span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        sum<span class="token operator">+=</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        num<span class="token operator">++</span><span class="token punctuation">;</span><span class="token comment">//记录序列长度</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>sum<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            sum<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>            num<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>sum<span class="token operator">></span>max<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//最开始这里写的if导致一直有测试点不过！！！</span>            max<span class="token operator">=</span>sum<span class="token punctuation">;</span><span class="token comment">//             cout&lt;&lt;"sum:"&lt;&lt;sum&lt;&lt;endl;</span>            res<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span>v<span class="token punctuation">[</span>i<span class="token operator">-</span>num<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//+1，记得</span>            res<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>max<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        cout<span class="token operator">&lt;&lt;</span><span class="token number">0</span><span class="token operator">&lt;&lt;</span><span class="token string">" "</span><span class="token operator">&lt;&lt;</span>v<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span><span class="token string">" "</span><span class="token operator">&lt;&lt;</span>v<span class="token punctuation">[</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>        cout<span class="token operator">&lt;&lt;</span>max<span class="token operator">&lt;&lt;</span><span class="token string">" "</span><span class="token operator">&lt;&lt;</span>res<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span><span class="token string">" "</span><span class="token operator">&lt;&lt;</span>res<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 法学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>inline关键字</title>
      <link href="/2023/06/19/inline-guan-jian-zi/"/>
      <url>/2023/06/19/inline-guan-jian-zi/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="inline关键字"><a href="#inline关键字" class="headerlink" title="inline关键字"></a>inline关键字</h2><p>在函数声明和定义加上，使之称为内联函数。如果一些简单的函数直接在类中声明并且定义，编译器可以将其优化为内联函数。</p><p>注：内联函数可以减少函数的执行时间：原因是它可以在使用时直接进行替换（像宏一样展开），从而避免出现参数压栈、代码生成等操作，但是如果函数体过大，编译器就不会将其作为内联函数，即使加了关键字inline，同时内联函数不能递归。</p><p>inline关键字声明的函数依旧是函数，所以会有类型检查，可以消除C语言宏的一些缺点。</p><p>关键字inline必须与函数定义放在一起才能使函数成为内联函数，仅仅将inline放在函数声明前面不起任何作用。inline是一种“用于实现”的关键字，而不是一种“用于声明”的关键字。</p><h2 id="慎用-inline"><a href="#慎用-inline" class="headerlink" title="慎用 inline"></a>慎用 inline</h2><p>内联能提高函数的执行效率，为什么不把所有的函数都定义成内联函数？如果所有的函数都是内联函数，还用得着”内联”这个关键字吗？  内联是以<strong>代码膨胀（复制）</strong>为代价，仅仅省去了函数调用的开销，从而提高函数的执行效率。  如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间，是以空间换时间，这是一种常用的手段，因为时间总是更加宝贵的。</p><p><strong>以下情况不宜使用内联：</strong>  （1）如果函数体内的代码<strong>比较长</strong>，使用内联将导致<strong>内存消耗代价较高</strong>。  （2）如果函数体内出现<strong>循环</strong>，那么执行函数体内代码的时间要比函数调用的开销大。类的构造函数和析构函数容易让人误解成使用内联更有效。要当心<strong>构造函数和析构函数可能会隐藏一些行为</strong>，如”偷偷地”执行了<strong>基类或成员对象</strong>的构造函数和析构函数。所以<strong>不要随便地将构造函数和析构函数的定义体放在类声明中</strong>。一个好的编译器将会根据函数的定义体，自动地取消不值得的内联（这进一步说明了 inline 不应该出现在函数的声明中）。</p><h2 id="使用参考"><a href="#使用参考" class="headerlink" title="使用参考"></a>使用参考</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span>  </span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string></span>  </span> <span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span> <span class="token keyword">class</span> <span class="token class-name">Person</span><span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span><span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>string name<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token class-name">Person</span><span class="token double-colon punctuation">::</span><span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"name:"</span> <span class="token operator">&lt;&lt;</span> name <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>Person person<span class="token punctuation">;</span>person<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"Erin"</span><span class="token punctuation">;</span>person<span class="token punctuation">.</span><span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//如果将display直接在类内定义，会被自动关联为inline函数</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>test</title>
      <link href="/2023/06/19/test/"/>
      <url>/2023/06/19/test/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
        <tags>
            
            <tag> QT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/06/19/hello-world/"/>
      <url>/2023/06/19/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
