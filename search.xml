<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>记录一次cmake_minimum_required的思考</title>
      <link href="/2026/01/08/ji-lu-yi-ci-cmake-minimum-required-de-si-kao/"/>
      <url>/2026/01/08/ji-lu-yi-ci-cmake-minimum-required-de-si-kao/</url>
      
        <content type="html"><![CDATA[<h1 id="cmake-minimum-required"><a href="#cmake-minimum-required" class="headerlink" title="cmake_minimum_required"></a>cmake_minimum_required</h1><h2 id="问题起源"><a href="#问题起源" class="headerlink" title="问题起源"></a>问题起源</h2><p>在编译 MyTinySTL 项目时遇到 CMake 错误：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">CMake Error at CMakeLists.txt:1 <span class="token punctuation">(</span>cmake_minimum_required<span class="token punctuation">)</span>:  Compatibility with CMake <span class="token operator">&lt;</span> <span class="token number">3.5</span> has been removed from CMake.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>项目中的 <code>CMakeLists.txt</code> 第一行是：</p><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token keyword">cmake_minimum_required</span><span class="token punctuation">(</span><span class="token property">VERSION</span> <span class="token number">2.8</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>而我的 CMake 版本是 4.0.2，CMake会模拟启用2.8版本的所有默认行为，禁用 2.8 之后的所有新策略，模拟CMake 2.8 的运行环境。</p><h2 id="深入理解-cmake-minimum-required"><a href="#深入理解-cmake-minimum-required" class="headerlink" title="深入理解 cmake_minimum_required"></a>深入理解 cmake_minimum_required</h2><p><code>cmake_minimum_required</code>是CMake中很重要的且要放在第一行的一个命令。它的作用并不是简单的进行版本的检查，最初我误解了<code>cmake_minimum_required</code>作用，以为它只能声明项目能工作的最低cmake版本，实际上CMake通过策略来管理版本间的行为变化，每个策略包括：</p><ul><li>有一个唯一编号</li><li>控制某个特定功能的旧行为和新行为</li><li>每个CMake版本会引入新策略或修改旧策略</li></ul><p>它也告诉CMake：</p><ol><li><strong>行为模式选择器</strong>：告诉 CMake 以哪个版本的行为模式解析脚本</li><li><strong>策略控制器</strong>：启用或禁用特定版本的策略（policies）</li><li><strong>兼容性承诺</strong>：承诺脚本与指定版本兼容</li></ol><h3 id="为什么高版本-CMake-不支持低版本？"><a href="#为什么高版本-CMake-不支持低版本？" class="headerlink" title="为什么高版本 CMake 不支持低版本？"></a>为什么高版本 CMake 不支持低版本？</h3><p>这不是技术限制，而是<strong>有意设计</strong>：</p><ul><li>CMake 4.0 移除了对 3.5 以下版本的兼容代码</li><li>减少维护负担，提高性能</li><li>推动生态进步，淘汰过时实践</li></ul><p>就像 Windows 11 不再支持 Windows 98 程序一样。</p><h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><ol><li>使用范围语法</li></ol><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token keyword">cmake_minimum_required</span><span class="token punctuation">(</span><span class="token property">VERSION</span> <span class="token number">3.16</span>...<span class="token number">3.28</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="相关构建系统知识扩展"><a href="#相关构建系统知识扩展" class="headerlink" title="相关构建系统知识扩展"></a>相关构建系统知识扩展</h2><h3 id="cmake-build-和-make-的区别"><a href="#cmake-build-和-make-的区别" class="headerlink" title="cmake --build . 和 make 的区别"></a><code>cmake --build .</code> 和 <code>make</code> 的区别</h3><p><code>cmake --build .</code>是跨平台抽象命令，自动调用底层构建工具：</p><ul><li>Linux/maxOS: make</li><li>Windows(MSVC): MSBuild</li><li>Windows(MinGW): mingw32-make</li><li>Ninja: ninja</li></ul><h3 id="windows下MSVC的优势"><a href="#windows下MSVC的优势" class="headerlink" title="windows下MSVC的优势"></a>windows下MSVC的优势</h3><ol><li>深度优化：PGO、向量化、CPU特定优化</li></ol><h3 id="MinGW-Makefiles生成器"><a href="#MinGW-Makefiles生成器" class="headerlink" title="MinGW Makefiles生成器"></a>MinGW Makefiles生成器</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">mkdir</span> mingw-build<span class="token builtin class-name">cd</span> mingw-buildcmake <span class="token parameter variable">-G</span> <span class="token string">"MinGW Makefiles"</span>mingw32-make<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><code>-G &quot;MinGW Makefiles&quot;</code> 是<strong>固定名称</strong>，告诉 CMake 生成适用于 MinGW 的 Makefile。</p><h3 id="Ninja-极速构建系统"><a href="#Ninja-极速构建系统" class="headerlink" title="Ninja 极速构建系统"></a>Ninja 极速构建系统</h3><p>它的特点是专注于构建速度</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cmake <span class="token parameter variable">-G</span> Ninja <span class="token punctuation">..</span>ninja <span class="token comment"># 自动启用CPU所有核心</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="常见的一些使用技巧"><a href="#常见的一些使用技巧" class="headerlink" title="常见的一些使用技巧"></a>常见的一些使用技巧</h2><h3 id="多级构建目录"><a href="#多级构建目录" class="headerlink" title="多级构建目录"></a>多级构建目录</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">MyTinySTL/├── CMakeLists.txt├── build-msvc/      <span class="token comment"># Visual Studio 构建</span>├── build-mingw/     <span class="token comment"># MinGW 构建  </span>├── build-ninja/     <span class="token comment"># Ninja 构建</span>└── build-debug/     <span class="token comment"># 调试版本</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="查看可用的生成器"><a href="#查看可用的生成器" class="headerlink" title="查看可用的生成器"></a>查看可用的生成器</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cmake <span class="token parameter variable">-G</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="跨平台的CMakeLists-txt写法"><a href="#跨平台的CMakeLists-txt写法" class="headerlink" title="跨平台的CMakeLists.txt写法"></a>跨平台的CMakeLists.txt写法</h3><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token variable">MSVC</span><span class="token punctuation">)</span><span class="token keyword">add_compile_options</span><span class="token punctuation">(</span>/W4 /WX<span class="token punctuation">)</span><span class="token keyword">elseif</span> <span class="token punctuation">(</span><span class="token variable">MINGW</span> <span class="token operator">OR</span> <span class="token variable">CMAKE_COMPILER_IS_GNUCXX</span><span class="token punctuation">)</span><span class="token comment"># GCC/MinGW 设置</span>    <span class="token keyword">add_compile_options</span><span class="token punctuation">(</span>-Wall -Wextra -Werror<span class="token punctuation">)</span><span class="token keyword">endif</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><ul><li>编译速度：Ninja &gt; Make &gt; MSBuild</li><li>跨平台一致性：MSVC &gt; GCC/MinGW</li></ul><h2 id="学习心得"><a href="#学习心得" class="headerlink" title="学习心得"></a>学习心得</h2><p>通过此次编译错误，重新学习了CMake的编译构建理论</p>]]></content>
      
      
      
        <tags>
            
            <tag> cmake </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RTSPServer&#39;s Net Module</title>
      <link href="/2025/07/18/rtspserver-s-net-module/"/>
      <url>/2025/07/18/rtspserver-s-net-module/</url>
      
        <content type="html"><![CDATA[<h2 id="RTSPServer项目"><a href="#RTSPServer项目" class="headerlink" title="RTSPServer项目"></a>RTSPServer项目</h2><p>这是一个使用类似于libevent、libuv服务器架构来实现服务器，符合事件驱动模型，同时搭配了音视频的解析功能，可以实现RTSP推流。</p><p>主要实现功能</p><blockquote><ul><li>支持 H264、H265、G711A、AAC四种音频格式的转发</li><li>支持同时传输音视频数据</li></ul></blockquote><p>分析其中的网络架构，以及音视频数据的解析与传输，可以很好的理解音视频的推流的实现过程，下面就是关于源码机构的理解。</p><p>源码地址：<a href="https://github.com/allenmirac/RtspServer">RtspServer</a></p><h2 id="net-结构分析"><a href="#net-结构分析" class="headerlink" title="net 结构分析"></a><code>net</code> 结构分析</h2><p>这部分模块负责 <strong>RTSP 服务中的网络通信、事件调度与 I/O 管理</strong>，下面是这些文件的初步功能分析。</p><hr><h3 id="✅-连接的处理模块"><a href="#✅-连接的处理模块" class="headerlink" title="✅ 连接的处理模块"></a>✅ 连接的处理模块</h3><div class="table-container"><table><thead><tr><th>文件名</th><th>功能说明</th></tr></thead><tbody><tr><td><strong>Acceptor.cpp / .h</strong></td><td>管理服务器端 socket 的监听，并与事件循环<code>EventLoop()</code>相结合，实现异步非阻塞的新连接接受处理（将<code>newConnection</code>事件注册到<code>EventLoop</code>中）。</td></tr><tr><td><strong>TcpConnection.cpp / .h</strong></td><td>表示一个客户端连接，负责数据的收发，管理状态和回调。</td></tr><tr><td><strong>TcpServer.cpp / .h</strong></td><td>封装一个 TCP 服务端，内部持有 <code>Acceptor</code> 和连接管理。</td></tr><tr><td><strong>TcpSocket.cpp / .h</strong></td><td>封装 TCP 套接字基本操作，包括连接、发送、接收、关闭等。</td></tr><tr><td><strong>Socket.h</strong></td><td>套接字基础类（底层抽象），用于 UDP/TCP 的通用封装。</td></tr></tbody></table></div><p>TcpSocket：该类是对 Tcp 套接字的一个封装，它抽象出来了<code>socket</code>的基本操作（创建、绑定、监听、连接、接受连接、关闭），并且隐藏了平台差异（Linux + Windows）。值得注意的是，<code>ShutdownWrite()</code>该函数关闭写操作，常用于Tcp的半关闭。</p><p>Acceptor：该类是一个底层组件，持有TcpSocket指针（<code>unique_ptr</code>），只负责监听，并不关心连接之后如何处理，接受连接之后通过回调“通知上层”（TcpServer）。</p><p>TcpConnection：该类是管理客户端连接的核心组件，包括接受数据（HandleRead）、发送数据（Send、HandleWrite）、连接以及断开管理（DisConnect、HandleClose）、注册到事件循环（TaskScheduler）。为什么有了<code>TcpConnection</code>还需要<code>Acceptor</code>。</p><p>TcpServer：该类是RTSP网络框架的控制中枢模块，用于管理整个TCP服务的生命周期，包括监听端口、接收连接、管理连接表（一个<code>unordered_map</code>用于管理所有的<code>TcpConnection</code>）。</p><p>网络通信模块调用流程</p><p>TcpServer::Start()—-&gt;新连接到来—-&gt;Acceptor::OnAccept()—-&gt;TcpSocket::Accept()—-&gt;调用NewConnectionCallback交给TcpServer处理—-&gt;后续sockfd有读、写、关闭等操作就交给TcpConnection的Read、Write、Close的回调函数来处理。</p><hr><h3 id="✅-I-O-缓冲模块"><a href="#✅-I-O-缓冲模块" class="headerlink" title="✅ I/O 缓冲模块"></a>✅ I/O 缓冲模块</h3><div class="table-container"><table><thead><tr><th>文件名</th><th>功能说明</th></tr></thead><tbody><tr><td><strong>BufferReader.cpp / .h</strong></td><td>封装读取缓冲区逻辑，支持流式解析等操作。</td></tr><tr><td><strong>BufferWriter.cpp / .h</strong></td><td>封装写缓冲区逻辑，用于构建和发送数据。</td></tr><tr><td><strong>RingBuffer.h</strong></td><td>环形缓冲区，适合连续读写、高性能传输的情况。</td></tr><tr><td><strong>Pipe.cpp / .h</strong></td><td>提供用于 <code>EventLoop</code> 的“唤醒机制”（如 <code>eventfd</code> / 管道），实现线程安全任务调度。</td></tr></tbody></table></div><p>BufferReader：该类实现了一个环形读缓冲区，用于管理socket读取到的数据，支持HTTP/RTSP 协议中常用的 <code>\r\n</code>、<code>\r\n\r\n</code> 结尾识别。</p><p>BufferWriter：Packet 是一个内部结构体，用来表示待发送的数据块，实现了部分发送（writeIndex）。<code>#if defined(__linux)</code> 编译器在编译时，会自动定义特定平台的宏。</p><p>RingBuffer：该类通过<code>put_pos_</code>、<code>get_pos_</code>、<code>num_datas_</code>这些变量之间的搭配，实现了一个环形队列缓冲区，但是只适合与单线程的环境，或者将其与mutex结合来实现多线程环境下的数据缓冲区。</p><p>该模块可用于缓存服务器的解码帧数据，以及音视频的数据报，也可以减缓生产消费速度不匹配的问题。</p><hr><h3 id="✅-事件驱动与调度模块"><a href="#✅-事件驱动与调度模块" class="headerlink" title="✅ 事件驱动与调度模块"></a>✅ 事件驱动与调度模块</h3><div class="table-container"><table><thead><tr><th>文件名</th><th>功能说明</th></tr></thead><tbody><tr><td><strong>EventLoop.cpp / .h</strong></td><td>核心事件循环类，类似 <code>libevent</code> 中的 loop，对所有事件进行分发。</td></tr><tr><td><strong>EpollTaskScheduler.cpp / .h</strong></td><td>基于 Linux <code>epoll</code> 的事件调度器。</td></tr><tr><td><strong>SelectTaskScheduler.cpp / .h</strong></td><td>基于 <code>select()</code> 的跨平台事件调度器。</td></tr><tr><td><strong>TaskScheduler.cpp / .h</strong></td><td>抽象任务调度接口，<code>Epoll/Select</code> 是其实现类。</td></tr><tr><td><strong>Channel.h</strong></td><td>表示某个 <code>fd</code> 上的读/写事件，用于注册到 <code>EventLoop</code> 中处理。</td></tr></tbody></table></div><p>该模块实现了Reactor的事件驱动方式，符合one loop per thread？(这里问号的原因是，因为在<code>EventLoop::Loop()</code>中并没有实现类似<code>muduo</code>的设计)</p><p>步骤：</p><blockquote><p>在主线程或者子线程：</p><p>EventLoop 不断轮询——&gt;TashScheduler分发任务（EpollTaskScheduler、SelectTaskScheduler）——&gt;Channel管理的<code>fd</code>里面注册的读、写、异常任务回调</p></blockquote><p>事件类型，使用 bitmask 实现，可以组合：</p><blockquote><ul><li>EPOLL_NONE 表示无事件发生</li><li>EPOLL_IN 表示可读事件</li><li>EPOLL_PRI 表示高优先级数据事件</li><li>EPOLL_OUT 表示可写事件</li><li>EPOLL_ERR 表示错误事件</li><li>EPOLL_HUP 表示对端关闭事件</li><li>EPOLL_RDHUP 表示读半关闭事件</li></ul></blockquote><p>有一个形象的比喻，如果将事件调度器比作“雷达”，则 Channel 就是一个监听器，关注的目标是 socket 的 fd上面的事件.每一个<code>Channel</code>都绑定了一个<code>sockfd_</code>，<code>TaskScheduler</code>中的所有<code>scheduler</code>都可以管理<code>Channel</code>，所以下面的问题部分的问题四是需要修改的，以达到负载均衡的目的，实现高并发。</p><p>TaskScheduler作为一个事件分发器，可以添加触发器事件（由RingBuffer实现管理事件队列），也可以通过事件队列处理定时器的任务，以及处理通过其实现类（EpollTaskScheduler、SelectTaskScheduler）实现的HandleEvent，处理到来的IO事件。该类中唤醒事件处理的方式是使用Pipe + Channel实现。</p><p>EventLoop是事件循环处理核心。</p><blockquote><p>在这个模块，有一个问题，关于事件处理机制。在<code>EventLoop::EventLoop(uint32_t num_threads)</code>函数，即构造函数中，调用了<code>void EventLoop::Loop()</code>函数，这并不符合事件循环机制库的常见设计，<code>void EventLoop::Loop()</code>函数应该由用户显示指定，用户设置好所有的资源之后再启动。</p></blockquote><hr><h3 id="✅-工具类模块"><a href="#✅-工具类模块" class="headerlink" title="✅ 工具类模块"></a>✅ 工具类模块</h3><div class="table-container"><table><thead><tr><th>文件名</th><th>功能说明</th></tr></thead><tbody><tr><td><strong>SocketUtil.cpp / .h</strong></td><td>提供与 socket 相关的工具函数，例如设置非阻塞、发送和接受缓冲区大小等。</td></tr><tr><td><strong>Timer.cpp / .h</strong></td><td>定时任务相关类，支持在指定时间执行任务，挂在 <code>EventLoop</code> 上，支持重复设置重复执行的任务（处理重复执行的事件不合理）。</td></tr><tr><td><strong>Logger.cpp / .h</strong></td><td>日志系统的实现类，支持日志输出、级别控制等。</td></tr><tr><td><strong>log.h</strong></td><td>提供简化的宏定义，如 <code>LOG_INFO</code>, <code>LOG_ERROR</code> 等。</td></tr><tr><td><strong>NetInterface.cpp / .h</strong></td><td>封装对上层的网络接口，可能用于统一 API、回调注册等。</td></tr><tr><td><strong>MemoryManager.cpp / .h</strong></td><td>内存池管理器，提高分配效率，避免频繁的 <code>malloc/free</code>。</td></tr></tbody></table></div><p>该模块实现了一些常用的工具类部分。</p><hr><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>在逐步调试以及分析各个模块职能的过程中，发现了一部分问题，需要逐渐修改验证，以及调整，合理分析各个功能分配职责。</p><p>1、<code>TcpSocket::Bind(std::string ip, uint16_t port)</code>,<code>SocketUtil::Bind(SOCKET sockfd, std::string ip, uint16_t port)</code>，但是我也不知道如何去分配职能，在写完<code>Test</code>之后可以去思考。</p><p>2、<code>Logger::~Logger()</code>析构函数添加调用<code>Logger::Exit()</code>.</p><p>3、<code>Timestamp::Localtime()</code>，在Linux平台下使用<code>std::LocalTime()</code>是线程不安全的，使用POSIX提供的<code>localtime_r</code>.</p><p>4、<code>EventLoop::UpdateChannel</code>、<code>EventLoop::RemoveChannel</code>这两个函数都是使用<code>task_scheduler[0]</code>来更新<code>Channel</code>信息，这个职能分配有问题，如果在多线程情况下将多个任务都给了<code>index_==0</code>的任务分配器，需改正。</p><p>5、<code>Timer::SetNextTimeout(timeout)</code>设计问题，<code>TimerQueue</code>是类似于事件驱动的方式来管理定时事件的结构，它本身不会自动运行，需要周期性的调用<code>HandleEvent()</code>来驱动着调用触发事件，所以在<code>test/TimerTest.cpp</code>中的<code>TimerQueueHandleRepeatingTimer</code>，重复调用了多次<code>HandleEvent()</code>。以上实现有一定缺点，比如<strong>重复 timer 不会“补偿遗漏”</strong>，间隔长了会丢失触发次数。</p><p>6、优化TcpSocket类，添加调试信息的输出（包括errno），添加各函数对sockfd的合法性检测。</p><p>7、修改<code>SockUtil::Connect</code>无法处理错误IP地址的问题，同时修改连接的部分处理逻辑（比如默认是未连接状态）。</p><p>8、修改<code>BufferReader</code>类，添加了<code>Append()</code>和<code>EnsureWritableBytes</code>函数接口，以及修改了部分处理逻辑。</p><p>9、修改<code>BufferWriter</code>类，添加了<code>SetMaxQueueLength()</code>、<code>GetMaxQueueLength()</code>、<code>Pop()</code>函数接口，以及修改了部分处理逻辑（如添加<code>static_cast</code>）。</p><p>10、修改<code>EventLoop</code>类，添加<code>SetThreadPriority</code>方法，但是如何修改<code>Loop</code>逻辑，执行一次，一直在线监督，改正不了。</p><h2 id="Test的编写"><a href="#Test的编写" class="headerlink" title="Test的编写"></a>Test的编写</h2><p>使用GTest框架来编写测试模块，测试模块不仅仅是测试工程师的活，也是每一个后端Coder要掌握的。</p><p>继续看Timer的压力测试，以及其中的xop模块，也就是真实的音视频模块，先看完一个整体的思路，再去改进，可能改进的都有问题，无法实现。</p>]]></content>
      
      
      <categories>
          
          <category> 音视频 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 音视频项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>蓝桥杯算法模板与题目推荐</title>
      <link href="/2025/06/11/lan-qiao-bei-suan-fa-mo-ban-yu-ti-mu-tui-jian/"/>
      <url>/2025/06/11/lan-qiao-bei-suan-fa-mo-ban-yu-ti-mu-tui-jian/</url>
      
        <content type="html"><![CDATA[<h1 id="蓝桥杯算法模板与-LeetCode-题目推荐"><a href="#蓝桥杯算法模板与-LeetCode-题目推荐" class="headerlink" title="蓝桥杯算法模板与 LeetCode 题目推荐"></a>蓝桥杯算法模板与 LeetCode 题目推荐</h1><h2 id="🧩-蓝桥杯必学算法模板-amp-LeetCode-题目推荐"><a href="#🧩-蓝桥杯必学算法模板-amp-LeetCode-题目推荐" class="headerlink" title="🧩 蓝桥杯必学算法模板 &amp; LeetCode 题目推荐"></a>🧩 蓝桥杯必学算法模板 &amp; LeetCode 题目推荐</h2><hr><h3 id="1️⃣-枚举（暴力）"><a href="#1️⃣-枚举（暴力）" class="headerlink" title="1️⃣ 枚举（暴力）"></a>1️⃣ 枚举（暴力）</h3><h4 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 枚举两个数对</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span>        <span class="token comment">// do something</span><span class="token comment">// 全排列 next_permutation</span><span class="token function">sort</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> a<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">do</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 使用当前排列</span><span class="token punctuation">&#125;</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">next_permutation</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> a<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="LeetCode-推荐"><a href="#LeetCode-推荐" class="headerlink" title="LeetCode 推荐"></a>LeetCode 推荐</h4><ul><li>46.Permutations</li><li>47.Permutations II</li><li>728.自除数</li><li>996.正方形拼图</li></ul><hr><h3 id="2️⃣-排序-自定义排序"><a href="#2️⃣-排序-自定义排序" class="headerlink" title="2️⃣ 排序 + 自定义排序"></a>2️⃣ 排序 + 自定义排序</h3><h4 id="模板-1"><a href="#模板-1" class="headerlink" title="模板"></a>模板</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">Node</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> x<span class="token punctuation">,</span> y<span class="token punctuation">;</span>    <span class="token keyword">bool</span> <span class="token keyword">operator</span><span class="token operator">&lt;</span><span class="token punctuation">(</span><span class="token keyword">const</span> Node<span class="token operator">&amp;</span> other<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> x <span class="token operator">&lt;</span> other<span class="token punctuation">.</span>x<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">bool</span> <span class="token function">cmp</span><span class="token punctuation">(</span>Node a<span class="token punctuation">,</span> Node b<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> a<span class="token punctuation">.</span>y <span class="token operator">&lt;</span> b<span class="token punctuation">.</span>y<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">sort</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> a<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> cmp<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="LeetCode-推荐-1"><a href="#LeetCode-推荐-1" class="headerlink" title="LeetCode 推荐"></a>LeetCode 推荐</h4><ul><li>56.Merge Intervals</li><li>452.用最少数量的箭引爆气球</li><li>135.分发糖果</li></ul><hr><h3 id="3️⃣-搜索（DFS-BFS）"><a href="#3️⃣-搜索（DFS-BFS）" class="headerlink" title="3️⃣ 搜索（DFS / BFS）"></a>3️⃣ 搜索（DFS / BFS）</h3><h4 id="DFS-模板"><a href="#DFS-模板" class="headerlink" title="DFS 模板"></a>DFS 模板</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">int</span> u<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    visited<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> v <span class="token operator">:</span> graph<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>visited<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token function">dfs</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="BFS-模板"><a href="#BFS-模板" class="headerlink" title="BFS 模板"></a>BFS 模板</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">queue<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> q<span class="token punctuation">;</span>q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>start<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>q<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> cur <span class="token operator">=</span> q<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> q<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> next <span class="token operator">:</span> graph<span class="token punctuation">[</span>cur<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>visited<span class="token punctuation">[</span>next<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            visited<span class="token punctuation">[</span>next<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="LeetCode-推荐-2"><a href="#LeetCode-推荐-2" class="headerlink" title="LeetCode 推荐"></a>LeetCode 推荐</h4><ul><li>200.岛屿数量</li><li>695.岛屿的最大面积</li><li>542.01矩阵</li><li>1091.二进制矩阵中的最短路径</li></ul><hr><h3 id="4️⃣-贪心"><a href="#4️⃣-贪心" class="headerlink" title="4️⃣ 贪心"></a>4️⃣ 贪心</h3><h4 id="LeetCode-推荐-3"><a href="#LeetCode-推荐-3" class="headerlink" title="LeetCode 推荐"></a>LeetCode 推荐</h4><ul><li>122.买卖股票的最佳时机 II</li><li>455.分发饼干</li><li>435.无重叠区间</li><li>134.加油站</li></ul><hr><h3 id="5️⃣-动态规划（DP）"><a href="#5️⃣-动态规划（DP）" class="headerlink" title="5️⃣ 动态规划（DP）"></a>5️⃣ 动态规划（DP）</h3><h4 id="0-1-背包模板"><a href="#0-1-背包模板" class="headerlink" title="0/1 背包模板"></a>0/1 背包模板</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> V<span class="token punctuation">;</span> j <span class="token operator">>=</span> w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token operator">--</span>j<span class="token punctuation">)</span>        dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>j <span class="token operator">-</span> w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">+</span> v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="完全背包模板"><a href="#完全背包模板" class="headerlink" title="完全背包模板"></a>完全背包模板</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> V<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span>        dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>j <span class="token operator">-</span> w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">+</span> v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="LeetCode-推荐-4"><a href="#LeetCode-推荐-4" class="headerlink" title="LeetCode 推荐"></a>LeetCode 推荐</h4><ul><li>70.爬楼梯</li><li>198.打家劫舍</li><li>322.零钱兑换</li><li>139.单词拆分</li></ul><hr><h3 id="6️⃣-前缀和-差分"><a href="#6️⃣-前缀和-差分" class="headerlink" title="6️⃣ 前缀和 / 差分"></a>6️⃣ 前缀和 / 差分</h3><h4 id="一维前缀和"><a href="#一维前缀和" class="headerlink" title="一维前缀和"></a>一维前缀和</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> s<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="二维前缀和"><a href="#二维前缀和" class="headerlink" title="二维前缀和"></a>二维前缀和</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> s<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> s<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="差分数组"><a href="#差分数组" class="headerlink" title="差分数组"></a>差分数组</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">d<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">+=</span> x<span class="token punctuation">;</span>d<span class="token punctuation">[</span>r<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-=</span> x<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="LeetCode-推荐-5"><a href="#LeetCode-推荐-5" class="headerlink" title="LeetCode 推荐"></a>LeetCode 推荐</h4><ul><li>303.区域和检索 - 数组不可变</li><li>370.区间加法</li><li>1094.拼车</li></ul><hr><h3 id="7️⃣-图论基础"><a href="#7️⃣-图论基础" class="headerlink" title="7️⃣ 图论基础"></a>7️⃣ 图论基础</h3><h4 id="建图模板"><a href="#建图模板" class="headerlink" title="建图模板"></a>建图模板</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">graph</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>graph<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="拓扑排序模板"><a href="#拓扑排序模板" class="headerlink" title="拓扑排序模板"></a>拓扑排序模板</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">queue<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> q<span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>indegree<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>q<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> u <span class="token operator">=</span> q<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> q<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> v <span class="token operator">:</span> graph<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">--</span>indegree<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>            q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="LeetCode-推荐-6"><a href="#LeetCode-推荐-6" class="headerlink" title="LeetCode 推荐"></a>LeetCode 推荐</h4><ul><li>207.课程表</li><li>210.课程表 II</li><li>133.克隆图</li></ul><hr><h3 id="8️⃣-并查集（Union-Find）"><a href="#8️⃣-并查集（Union-Find）" class="headerlink" title="8️⃣ 并查集（Union-Find）"></a>8️⃣ 并查集（Union-Find）</h3><h4 id="模板-2"><a href="#模板-2" class="headerlink" title="模板"></a>模板</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> x <span class="token operator">==</span> parent<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">?</span> x <span class="token operator">:</span> parent<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>parent<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">union_set</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    parent<span class="token punctuation">[</span><span class="token function">find</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="LeetCode-推荐-7"><a href="#LeetCode-推荐-7" class="headerlink" title="LeetCode 推荐"></a>LeetCode 推荐</h4><ul><li>547.省份数量</li><li>684.冗余连接</li><li>1319.连通网络的操作次数</li></ul><hr><h3 id="9️⃣-数学-数论"><a href="#9️⃣-数学-数论" class="headerlink" title="9️⃣ 数学 + 数论"></a>9️⃣ 数学 + 数论</h3><h4 id="快速幂模板"><a href="#快速幂模板" class="headerlink" title="快速幂模板"></a>快速幂模板</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">qmi</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">,</span> <span class="token keyword">int</span> mod<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>b<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>b <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">)</span> res <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">long</span> <span class="token keyword">long</span><span class="token punctuation">)</span>res <span class="token operator">*</span> a <span class="token operator">%</span> mod<span class="token punctuation">;</span>        a <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">long</span> <span class="token keyword">long</span><span class="token punctuation">)</span>a <span class="token operator">*</span> a <span class="token operator">%</span> mod<span class="token punctuation">;</span>        b <span class="token operator">>>=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> res<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="LeetCode-推荐-8"><a href="#LeetCode-推荐-8" class="headerlink" title="LeetCode 推荐"></a>LeetCode 推荐</h4><ul><li>50.Pow(x, n)</li><li>231.2的幂</li><li>202.快乐数</li></ul><hr><h3 id="🔟-字符串处理"><a href="#🔟-字符串处理" class="headerlink" title="🔟 字符串处理"></a>🔟 字符串处理</h3><h4 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">s<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">stoi</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">stoll</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">to_string</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">reverse</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> s<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="LeetCode-推荐-9"><a href="#LeetCode-推荐-9" class="headerlink" title="LeetCode 推荐"></a>LeetCode 推荐</h4><ul><li>14.最长公共前缀</li><li>125.验证回文串</li><li>415.字符串相加</li><li>67.二进制求和</li></ul><hr><h3 id="🔚-补充进阶建议"><a href="#🔚-补充进阶建议" class="headerlink" title="🔚 补充进阶建议"></a>🔚 补充进阶建议</h3><ul><li>LeetCode 307.可变区域和（线段树）</li><li>LeetCode 241.区间DP</li><li>LeetCode 698.状压DP</li></ul><h2 id="赛前经验分享"><a href="#赛前经验分享" class="headerlink" title="赛前经验分享"></a>赛前经验分享</h2><p>赛前经验：</p><p>[1. <a href="https://www.cnblogs.com/XiaoMo247/p/18121862">蓝桥杯赛前突击</a>]</p><p>[2. <a href="https://wineee.github.io/post/lanqiaobie/">关于蓝桥杯等算法竞赛的经验总结</a>]</p><p>[3. <a href="https://blog.csdn.net/Supreme7/article/details/137639669">基础数论篇</a>]</p><p>[4. <a href="https://weiambt.blog.csdn.net/article/details/137639097">图论模版篇</a>]</p><p>[5. <a href="https://zhuanlan.zhihu.com/p/489285845">蓝桥杯赛前准备</a>]</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 法学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>音视频基础学习</title>
      <link href="/2025/06/11/yin-shi-pin-ji-chu-xue-xi/"/>
      <url>/2025/06/11/yin-shi-pin-ji-chu-xue-xi/</url>
      
        <content type="html"><![CDATA[<h2 id="学习雷神的博客"><a href="#学习雷神的博客" class="headerlink" title="学习雷神的博客"></a>学习雷神的博客</h2><h3 id="1-RGB、YUV像素级别的数据的转化以及处理"><a href="#1-RGB、YUV像素级别的数据的转化以及处理" class="headerlink" title="1. RGB、YUV像素级别的数据的转化以及处理"></a>1. RGB、YUV像素级别的数据的转化以及处理</h3><p>分离YUV420p像素数据中的Y/U/V三个分量步骤:先读取YUV文件，然后按照YUV的分布特征读取出来并且保存。</p><p>关键读取代码如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>num<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>     <span class="token function">fread</span><span class="token punctuation">(</span>pic<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span>w<span class="token operator">*</span>h<span class="token operator">*</span><span class="token number">3</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">,</span>fp<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//Y</span>    <span class="token function">fwrite</span><span class="token punctuation">(</span>pic<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span>w<span class="token operator">*</span>h<span class="token punctuation">,</span>fp1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//w*h</span>    <span class="token comment">//U</span>    <span class="token function">fwrite</span><span class="token punctuation">(</span>pic<span class="token operator">+</span>w<span class="token operator">*</span>h<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span>w<span class="token operator">*</span>h<span class="token operator">/</span><span class="token number">4</span><span class="token punctuation">,</span>fp2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//w*h的后1/4</span>    <span class="token comment">//V</span>    <span class="token function">fwrite</span><span class="token punctuation">(</span>pic<span class="token operator">+</span>w<span class="token operator">*</span>h<span class="token operator">*</span><span class="token number">5</span><span class="token operator">/</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span>w<span class="token operator">*</span>h<span class="token operator">/</span><span class="token number">4</span><span class="token punctuation">,</span>fp3<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//w*h的5/4的后1/4</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由于我没有找到Y、U、V分量数据保存后的显示软件，就学习并使用了ffmpeg将.y文件转为png之后查看效果。转换过程：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ffmpeg <span class="token parameter variable">-s</span> 256x256 <span class="token parameter variable">-pix_fmt</span> gray <span class="token parameter variable">-f</span> rawvideo <span class="token parameter variable">-i</span> output_420_y.y lena_y.png<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>ffmpeg参数解释：</p><div class="table-container"><table><thead><tr><th style="text-align:left">参数</th><th>含义</th></tr></thead><tbody><tr><td style="text-align:left">-s 256*256</td><td>指定图像分辨，上述示例中为256*256</td></tr><tr><td style="text-align:left">-pix_fmt gray</td><td>制定像素格式为单通道的灰度图（gray）</td></tr><tr><td style="text-align:left">-f rawvideo</td><td>输入的是裸的原始图像数据，没有文件头（Y/U/V）</td></tr><tr><td style="text-align:left">-i xxx</td><td>输入文件路径</td></tr><tr><td style="text-align:left">lena_y.png</td><td>输出文件名字，自动调用PNG编码器保存为PNG图片</td></tr></tbody></table></div><p>接下来分别测试了<code>simplest_yuv420_gray</code>、<code>simplest_yuv420_halfy</code>、<code>simplest_yuv420_border</code>、<code>simplest_yuv420_graybar</code>、<code>simplest_yuv420_psnr</code>这些函数。</p><p>（1）、<code>simplest_yuv420_border</code>函数关键代码</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>num<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">fread</span><span class="token punctuation">(</span>pic<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span>w<span class="token operator">*</span>h<span class="token operator">*</span><span class="token number">3</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">,</span>fp<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//Y</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>h<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>k<span class="token operator">&lt;</span>w<span class="token punctuation">;</span>k<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token generic-function"><span class="token function">k</span><span class="token generic class-name"><span class="token operator">&lt;</span>border<span class="token operator">||</span>k<span class="token operator">></span></span></span><span class="token punctuation">(</span>w<span class="token operator">-</span>border<span class="token punctuation">)</span><span class="token operator">||</span><span class="token generic-function"><span class="token function">j</span><span class="token generic class-name"><span class="token operator">&lt;</span>border<span class="token operator">||</span>j<span class="token operator">></span></span></span><span class="token punctuation">(</span>h<span class="token operator">-</span>border<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                pic<span class="token punctuation">[</span>j<span class="token operator">*</span>w<span class="token operator">+</span>k<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">255</span><span class="token punctuation">;</span><span class="token comment">//修改为白色</span>                <span class="token comment">//pic[j*w+k]=0;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">fwrite</span><span class="token punctuation">(</span>pic<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span>w<span class="token operator">*</span>h<span class="token operator">*</span><span class="token number">3</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">,</span>fp1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>修改w*h周围的border个像素的值，这样就在图片周围加入了白色边框。</p><p>（2）、学习了PSNR，PSNR即峰值信噪比（Peak Signal to Noise Ratio），它是最基本的视频质量评估方法之一，基于图像的像素点，借助均方误差来计算图像失真情况，缺点也很明显，就是不符合人眼的主观感受。还要其他常见的图像质量检测方法如SSIM（<strong>Structural Similarity Index</strong>，<strong>结构相似度</strong>）等，这两篇文章中说的非常详细：<a href="http://zhuanlan.zhihu.com/p/120254892">谈谈图像质量量化评估标准</a>、<a href="https://zhuanlan.zhihu.com/p/32553977">图像质量评估综述</a>。</p><p><code>simplest_yuv420_psnr</code>函数的关键代码：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>num<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">fread</span><span class="token punctuation">(</span>pic1<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span>w<span class="token operator">*</span>h<span class="token punctuation">,</span>fp1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">fread</span><span class="token punctuation">(</span>pic2<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span>w<span class="token operator">*</span>h<span class="token punctuation">,</span>fp2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">double</span> mse_sum<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>mse<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>psnr<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>w<span class="token operator">*</span>h<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        mse_sum<span class="token operator">+=</span><span class="token function">pow</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span><span class="token punctuation">(</span>pic1<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">-</span>pic2<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>pic1<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">-</span>pic2<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"pix1[100], %d; pix2[100], %d\n"</span><span class="token punctuation">,</span> pic1<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> pic2<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    mse<span class="token operator">=</span>mse_sum<span class="token operator">/</span><span class="token punctuation">(</span>w<span class="token operator">*</span>h<span class="token punctuation">)</span><span class="token punctuation">;</span>    psnr<span class="token operator">=</span><span class="token number">10</span><span class="token operator">*</span><span class="token function">log10</span><span class="token punctuation">(</span><span class="token number">255.0</span><span class="token operator">*</span><span class="token number">255.0</span><span class="token operator">/</span>mse<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%5.3f\n"</span><span class="token punctuation">,</span>psnr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//跳过接下来1/2</span>    <span class="token function">fseek</span><span class="token punctuation">(</span>fp1<span class="token punctuation">,</span>w<span class="token operator">*</span>h<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token constant">SEEK_CUR</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">fseek</span><span class="token punctuation">(</span>fp2<span class="token punctuation">,</span>w<span class="token operator">*</span>h<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token constant">SEEK_CUR</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// //U</span>    <span class="token comment">// fwrite(pic+w*h,1,w*h/4,fp2);</span>    <span class="token comment">// //V</span>    <span class="token comment">// fwrite(pic+w*h*5/4,1,w*h/4,fp3);</span>    <span class="token comment">// u和v各占1/4，加起来等于1/2，</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-PCM音频采样数据处理"><a href="#2-PCM音频采样数据处理" class="headerlink" title="2. PCM音频采样数据处理"></a>2. PCM音频采样数据处理</h3><p>PCM，脉冲编码调制，PCM通过对模拟信息进行采样、量化、编码三个过程，将声音的模拟信息（电信号）转为数字信息，交给计算机处理，它有三个最重要的特征：采样率、声道数、采样格式，两大模式：打包模式、平面模式。</p><ol><li>声道布局包括：单声道（Mono，M）和立体声（Stereo，S），</li><li>常见的采样率有：44100、48000、16000，</li><li>采样格式：S16le、S32le、flt、dbl，还有对应的xxxp，p表示平面模式（Plnar）。</li></ol><p>音频数据在传输过程中也有字节顺序，分为大端序（Big Endian，be）和小端序（Little Endian，le）两种。常见的为小端字节序。</p><p>更多详细的介绍内容：<a href="https://blog.csdn.net/wkd_007/article/details/134101976">【音视频 | PCM】PCM格式详解</a></p><p>测试博主的函数：<code>simplest_pcm16le_split</code>、<code>simplest_pcm16le_halfvolumeleft</code>、<code>simplest_pcm16le_doublespeed</code>、<code>simplest_pcm16le_to_pcm8</code>、<code>simplest_pcm16le_cut_singlechannel</code>、<code>simplest_pcm16le_to_wave</code>。改写了一个函数<code>simplest_pcm16le_cut_doublechannel</code>。</p><p>这些处理的数据都是PCM的原始音频数据，比较好处理，确定文件的采样格式之后，就和读取普通文件一样。</p><p>（1）、改善后的<code>simplest_pcm16le_cut_singlechannel</code>函数：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">simplest_pcm16le_cut_singlechannel</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>url<span class="token punctuation">,</span><span class="token keyword">int</span> start_num<span class="token punctuation">,</span><span class="token keyword">int</span> dur_num<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>FILE <span class="token operator">*</span>fp<span class="token operator">=</span><span class="token function">fopen</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span><span class="token string">"rb+"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>FILE <span class="token operator">*</span>fp1<span class="token operator">=</span><span class="token function">fopen</span><span class="token punctuation">(</span><span class="token string">"output_cut.pcm"</span><span class="token punctuation">,</span><span class="token string">"wb+"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>FILE <span class="token operator">*</span>fp_stat<span class="token operator">=</span><span class="token function">fopen</span><span class="token punctuation">(</span><span class="token string">"output_cut.txt"</span><span class="token punctuation">,</span><span class="token string">"wb+"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>sample<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> cnt<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token function">fread</span><span class="token punctuation">(</span>sample<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span>fp<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span><span class="token punctuation">(</span>cnt<span class="token operator">></span>start_num<span class="token operator">&amp;&amp;</span>cnt<span class="token operator">&lt;=</span><span class="token punctuation">(</span>start_num<span class="token operator">+</span>dur_num<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">fwrite</span><span class="token punctuation">(</span>sample<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span>fp1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 1</span><span class="token comment">// short samplenum = sample[1];</span><span class="token comment">// samplenum=samplenum*256;</span><span class="token comment">// samplenum=samplenum+sample[0];</span>                        <span class="token comment">// 2</span><span class="token comment">// short samplenum = sample[1]&lt;&lt;8 + sample[0];</span>            <span class="token comment">// 3</span>            <span class="token keyword">short</span> <span class="token operator">*</span>samplenum <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">short</span> <span class="token operator">*</span><span class="token punctuation">)</span>sample<span class="token punctuation">;</span><span class="token function">fprintf</span><span class="token punctuation">(</span>fp_stat<span class="token punctuation">,</span><span class="token string">"%6d,"</span><span class="token punctuation">,</span><span class="token operator">*</span>samplenum<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>cnt<span class="token operator">%</span><span class="token number">10</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token function">fprintf</span><span class="token punctuation">(</span>fp_stat<span class="token punctuation">,</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>cnt<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">free</span><span class="token punctuation">(</span>sample<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">fclose</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">fclose</span><span class="token punctuation">(</span>fp1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">fclose</span><span class="token punctuation">(</span>fp_stat<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>该函数保存采样值部分的三种数值转换方法都是正确的，第三种是直接让系统自动处理小端字节序问题，按照小端顺序正确解释为short数据，而不需要像前两种一样将[1]位置的数据移动到前面以解释short型数据。</p><p>（2）、<code>simplest_pcm16le_doublespeed</code>函数关键代码</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">feof</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">fread</span><span class="token punctuation">(</span>sample<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span>fp<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>cnt<span class="token operator">%</span><span class="token number">2</span><span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token comment">//L</span>        <span class="token function">fwrite</span><span class="token punctuation">(</span>sample<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span>fp1<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//R</span>        <span class="token function">fwrite</span><span class="token punctuation">(</span>sample<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span>fp1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    cnt<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>该代码保存奇数位置的样本，这样就将播放速度加速，也就是变成了两倍速。同时为了便于更好的检查输出的样本值的波形图变化，使用了ffmpeg库的<code>showwavespic</code>滤镜，生成指定分辨率的音频波形图文件</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ffmpeg <span class="token parameter variable">-i</span> output_l.wav <span class="token parameter variable">-filter_complex</span> <span class="token string">"showwavespic=s=1280x240"</span> <span class="token parameter variable">-c:v</span> png <span class="token parameter variable">-y</span> output_l_waveform.png<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>命令参数解释：</p><div class="table-container"><table><thead><tr><th>命令部分</th><th>说明</th></tr></thead><tbody><tr><td>ffmpeg</td><td>FFmpeg 是一个用于处理多媒体文件的命令行工具，支持音频和视频的转换、处理和滤镜应用。</td></tr><tr><td>-i output_l.wav</td><td>-i 参数指定输入文件，这里是 output_l.wav，一个音频文件（通常为 WAV 格式）。FFmpeg 将使用此文件作为处理源。</td></tr><tr><td>-filter_complex “showwavespic=s=1280x240”</td><td>-filter_complex 用于应用复杂的滤镜处理。 使用 showwavespic 滤镜，从音频生成波形图。 showwavespic 生成一张表示音频波形的静态图像。 s=1280x240 设置输出图像分辨率为 1280 像素宽、240 像素高。</td></tr><tr><td>-c:v png</td><td>-c:v 指定输出视频的编码格式，这里使用 png，表示输出为一张 PNG 图像。 PNG 是一种无损图像格式，非常适合保存波形图。</td></tr><tr><td>-y</td><td>-y 参数指示 FFmpeg 如果输出文件（output_l_waveform.png）已存在，则自动覆盖，无需用户确认。</td></tr><tr><td>output_l_waveform.png</td><td>输出文件的名称，生成一张包含输入音频波形可视化的 PNG 图像。</td></tr></tbody></table></div><p>（3）、<code>simplest_pcm16le_to_pcm8</code>函数：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token function">fread</span><span class="token punctuation">(</span>sample<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span>fp<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">short</span> <span class="token operator">*</span>samplenum16<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> samplenum8<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> samplenum8_u<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">//(-32768-32767)</span>    samplenum16<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">short</span> <span class="token operator">*</span><span class="token punctuation">)</span>sample<span class="token punctuation">;</span>    samplenum8<span class="token operator">=</span><span class="token punctuation">(</span><span class="token operator">*</span>samplenum16<span class="token punctuation">)</span><span class="token operator">>></span><span class="token number">8</span><span class="token punctuation">;</span>    <span class="token comment">//(0-255)</span>    samplenum8_u<span class="token operator">=</span>samplenum8<span class="token operator">+</span><span class="token number">128</span><span class="token punctuation">;</span>    <span class="token comment">//L</span>    <span class="token function">fwrite</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>samplenum8_u<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span>fp1<span class="token punctuation">)</span><span class="token punctuation">;</span>        samplenum16<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">short</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>sample<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    samplenum8<span class="token operator">=</span><span class="token punctuation">(</span><span class="token operator">*</span>samplenum16<span class="token punctuation">)</span><span class="token operator">>></span><span class="token number">8</span><span class="token punctuation">;</span>    samplenum8_u<span class="token operator">=</span>samplenum8<span class="token operator">+</span><span class="token number">128</span><span class="token punctuation">;</span>    <span class="token comment">//R</span>    <span class="token function">fwrite</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>samplenum8_u<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span>fp1<span class="token punctuation">)</span><span class="token punctuation">;</span>    cnt<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>该函数只将左、右声道的16-bit信息的高八位字节保留下来，同时修正了<code>while(!feof(fp))</code>可能多读一帧的风险。</p><p>这里解释为什么保留高八位信息，而不是低八位信息：</p><p>在转换为short型数据之后，高八位信息决定了波形的大致轮廓（<strong>整体形状和方向</strong>），低八位决定波形的细节、微小变化（<strong>精细结构</strong>），这样保留虽然失真，但是依旧可以听清楚原始音频，而保留低八位就只剩下微小抖动，没有了主信息，是不可取的。</p><p>（4）、<code>simplest_pcm16le_to_wave</code>函数，该函数原始代码会出现转码错误，有BUG，改正后的代码如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">pragma</span> <span class="token expression"><span class="token function">pack</span><span class="token punctuation">(</span>push<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span></span></span><span class="token keyword">struct</span> <span class="token class-name">WAVE_HEADER</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">char</span> fccID<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>       <span class="token comment">// "RIFF"</span>    <span class="token keyword">uint32_t</span> dwSize<span class="token punctuation">;</span>     <span class="token comment">// 文件总长度 - 8</span>    <span class="token keyword">char</span> fccType<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>     <span class="token comment">// "WAVE"</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">WAVE_FMT</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">char</span> fccID<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>          <span class="token comment">// "fmt "</span>    <span class="token keyword">uint32_t</span> dwSize<span class="token punctuation">;</span>        <span class="token comment">// 固定为 16</span>    <span class="token keyword">uint16_t</span> wFormatTag<span class="token punctuation">;</span>    <span class="token comment">// 1 = PCM</span>    <span class="token keyword">uint16_t</span> wChannels<span class="token punctuation">;</span>     <span class="token comment">// 通道数</span>    <span class="token keyword">uint32_t</span> dwSamplesPerSec<span class="token punctuation">;</span>   <span class="token comment">// 采样率</span>    <span class="token keyword">uint32_t</span> dwAvgBytesPerSec<span class="token punctuation">;</span> <span class="token comment">// 每秒字节数</span>    <span class="token keyword">uint16_t</span> wBlockAlign<span class="token punctuation">;</span>       <span class="token comment">// 一个采样帧的大小</span>    <span class="token keyword">uint16_t</span> uiBitsPerSample<span class="token punctuation">;</span>   <span class="token comment">// 每个样本的位数</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">WAVE_DATA</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">char</span> fccID<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>       <span class="token comment">// "data"</span>    <span class="token keyword">uint32_t</span> dwSize<span class="token punctuation">;</span>     <span class="token comment">// 数据块大小（单位：字节）</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">pragma</span> <span class="token expression"><span class="token function">pack</span><span class="token punctuation">(</span>pop<span class="token punctuation">)</span></span></span><span class="token comment">/** * Convert PCM16LE raw data to WAVE format * @param pcmpath      Input PCM file. * @param channels     Channel number of PCM file. * @param sample_rate  Sample rate of PCM file. * @param wavepath     Output WAVE file. */</span><span class="token keyword">int</span> <span class="token function">simplest_pcm16le_to_wave</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>pcmpath<span class="token punctuation">,</span><span class="token keyword">int</span> channels<span class="token punctuation">,</span><span class="token keyword">int</span> sample_rate<span class="token punctuation">,</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>wavepath<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span><span class="token punctuation">(</span>channels<span class="token operator">==</span><span class="token number">0</span><span class="token operator">||</span>sample_rate<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>channels <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>sample_rate <span class="token operator">=</span> <span class="token number">44100</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">const</span> <span class="token keyword">int</span> bits_per_sample <span class="token operator">=</span> <span class="token number">16</span><span class="token punctuation">;</span><span class="token keyword">unsigned</span> <span class="token keyword">short</span> m_pcmData<span class="token punctuation">;</span>    FILE <span class="token operator">*</span>fpcm<span class="token punctuation">,</span><span class="token operator">*</span>fpout<span class="token punctuation">;</span>fpcm<span class="token operator">=</span><span class="token function">fopen</span><span class="token punctuation">(</span>pcmpath<span class="token punctuation">,</span><span class="token string">"rb"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>fpcm <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Open pcm file error\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">fclose</span><span class="token punctuation">(</span>fpcm<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>fpout<span class="token operator">=</span><span class="token function">fopen</span><span class="token punctuation">(</span>wavepath<span class="token punctuation">,</span><span class="token string">"wb+"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>fpout <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Create wav file error\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">fclose</span><span class="token punctuation">(</span>fpout<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token comment">//WAVE_HEADER</span>WAVE_HEADER pcmHEADER<span class="token punctuation">;</span>    <span class="token function">memcpy</span><span class="token punctuation">(</span>pcmHEADER<span class="token punctuation">.</span>fccID<span class="token punctuation">,</span><span class="token string">"RIFF"</span><span class="token punctuation">,</span><span class="token function">strlen</span><span class="token punctuation">(</span><span class="token string">"RIFF"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">uint32_t</span> riff_size_placeholder <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>pcmHEADER<span class="token punctuation">.</span>dwSize <span class="token operator">=</span> riff_size_placeholder<span class="token punctuation">;</span>    <span class="token function">memcpy</span><span class="token punctuation">(</span>pcmHEADER<span class="token punctuation">.</span>fccType<span class="token punctuation">,</span><span class="token string">"WAVE"</span><span class="token punctuation">,</span><span class="token function">strlen</span><span class="token punctuation">(</span><span class="token string">"WAVE"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//WAVE_FMT</span>WAVE_FMT pcmFMT<span class="token punctuation">;</span><span class="token function">memcpy</span><span class="token punctuation">(</span>pcmFMT<span class="token punctuation">.</span>fccID<span class="token punctuation">,</span><span class="token string">"fmt "</span><span class="token punctuation">,</span><span class="token function">strlen</span><span class="token punctuation">(</span><span class="token string">"fmt "</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    pcmFMT<span class="token punctuation">.</span>dwSize <span class="token operator">=</span> <span class="token number">16</span><span class="token punctuation">;</span>    pcmFMT<span class="token punctuation">.</span>wFormatTag <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    pcmFMT<span class="token punctuation">.</span>wChannels <span class="token operator">=</span> channels<span class="token punctuation">;</span>    pcmFMT<span class="token punctuation">.</span>dwSamplesPerSec <span class="token operator">=</span> sample_rate<span class="token punctuation">;</span>    pcmFMT<span class="token punctuation">.</span>dwAvgBytesPerSec <span class="token operator">=</span> sample_rate <span class="token operator">*</span> channels <span class="token operator">*</span> bits_per_sample <span class="token operator">/</span> <span class="token number">8</span><span class="token punctuation">;</span>    pcmFMT<span class="token punctuation">.</span>wBlockAlign <span class="token operator">=</span> channels <span class="token operator">*</span> bits_per_sample <span class="token operator">/</span> <span class="token number">8</span><span class="token punctuation">;</span>    pcmFMT<span class="token punctuation">.</span>uiBitsPerSample <span class="token operator">=</span> bits_per_sample<span class="token punctuation">;</span>        <span class="token comment">//WAVE_DATA;</span>WAVE_DATA pcmDATA<span class="token punctuation">;</span>    <span class="token function">memcpy</span><span class="token punctuation">(</span>pcmDATA<span class="token punctuation">.</span>fccID<span class="token punctuation">,</span><span class="token string">"data"</span><span class="token punctuation">,</span><span class="token function">strlen</span><span class="token punctuation">(</span><span class="token string">"data"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    pcmDATA<span class="token punctuation">.</span>dwSize <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">// 统一写入</span><span class="token function">fwrite</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pcmHEADER<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>WAVE_HEADER<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> fpout<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">fwrite</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pcmFMT<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>WAVE_FMT<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> fpout<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">fwrite</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pcmDATA<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>WAVE_DATA<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> fpout<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">uint8_t</span> buffer<span class="token punctuation">[</span><span class="token number">4096</span><span class="token punctuation">]</span><span class="token punctuation">;</span>size_t bytes_read<span class="token punctuation">,</span> total_data_size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>bytes_read <span class="token operator">=</span> <span class="token function">fread</span><span class="token punctuation">(</span>buffer<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span><span class="token punctuation">,</span> fpcm<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">fwrite</span><span class="token punctuation">(</span>buffer<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> bytes_read<span class="token punctuation">,</span> fpout<span class="token punctuation">)</span><span class="token punctuation">;</span>        total_data_size <span class="token operator">+=</span> bytes_read<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>    pcmHEADER<span class="token punctuation">.</span>dwSize <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>WAVE_HEADER<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>WAVE_FMT<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>WAVE_DATA<span class="token punctuation">)</span> <span class="token operator">+</span> pcmDATA<span class="token punctuation">.</span>dwSize <span class="token operator">-</span> <span class="token number">8</span><span class="token punctuation">;</span>pcmDATA<span class="token punctuation">.</span>dwSize <span class="token operator">=</span> total_data_size<span class="token punctuation">;</span><span class="token function">fseek</span><span class="token punctuation">(</span>fpout<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token constant">SEEK_SET</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">fwrite</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pcmHEADER<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>WAVE_HEADER<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> fpout<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">fseek</span><span class="token punctuation">(</span>fpout<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>WAVE_HEADER<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>WAVE_FMT<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token constant">SEEK_SET</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">fwrite</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pcmDATA<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>WAVE_DATA<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> fpout<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">fclose</span><span class="token punctuation">(</span>fpcm<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">fclose</span><span class="token punctuation">(</span>fpout<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在结构体的声明阶段，还使用了<code>#pragma pack</code>，这是由于<code>struct</code> 结构体可能会自动填充对齐字节，加入这个<code>#pragma pack</code>结构，强制为单字节填充，让WAV的文件头格式的每个字段都有固定的大小和位置，编译器也不会对结构体成员进行内存对齐操作。</p><blockquote><p><code>#pragma pack</code> 是一个预处理指令，用于指定数据在内存中的对齐方式，push 是将原来的代码的对齐方式压栈保存，pop 是恢复原本的对齐方式。</p></blockquote><hr><h3 id="3-H-264视频码流解析"><a href="#3-H-264视频码流解析" class="headerlink" title="3. H.264视频码流解析"></a>3. H.264视频码流解析</h3><p>H.264是一种对视频进行编解码的标准，用于将视频数据进行压缩。它是由一个个NALU组成的，每一个NALU之间通过起始码进行分割。对视频数据压缩时，H.264使用I帧、P帧、B帧的方式，I帧可以理解为关键帧（帧内压缩），P帧表示的是这一帧跟之前的一个关键帧（或P帧）的差别，B帧是双向差别帧，也就是B帧记录的是本帧与前后帧的差别（具体比较复杂，有4种情况）。</p><p>详细介绍：<a href="https://github.com/dreamsxin/example/blob/master/codec/H.264%E8%A7%86%E9%A2%91%E7%A0%81%E6%B5%81%E8%A7%A3%E6%9E%90.md">H.264视频码流解析</a></p><hr><h3 id="4-AAC"><a href="#4-AAC" class="headerlink" title="4. AAC"></a>4. AAC</h3><p>AAC原始码流是由一个个的ADTS <a href="https://so.csdn.net/so/search?q=frame&amp;spm=1001.2101.3001.7020">frame</a>（音频数据传输流帧）组成的；每一帧由ADTS头（ADTS Header）和原始数据块（ADTS ES）组成。</p><p>详细介绍：<a href="https://blog.csdn.net/weixin_43796767/article/details/116071306">AAC音频码流解析</a></p><hr><h3 id="5-FLV封装格式解析"><a href="#5-FLV封装格式解析" class="headerlink" title="5. FLV封装格式解析"></a>5. FLV封装格式解析</h3><p>FLV（FLash Video）是一种网络视频格式，用作流媒体格式，依赖于 Adobe Flash 插件进行解析与播放。但是渐渐的被抛弃了，现已被更加开放、兼容性更强的 HTML5 视频技术所替代。</p><p>总体上看，FLV包括文件头（File Header）和文件体（File Body）两部分，其中文件体由一系列的Tag组成。其中，每个Tag前面还包含了Previous Tag Size字段，表示前面一个Tag的大小。Tag的类型可以是视频、音频和Script，每个Tag只能包含以上三种类型的数据中的一种。</p><p>详细介绍：<a href="https://blog.csdn.net/leixiaohua1020/article/details/17934487">FLV封装格式</a>、<a href="https://ffmpeg.xianwaizhiyin.net/base-knowledge/mux-flv.html">FLV封装格式—音视频基础知识</a></p><p>由于原来的代码结构并没有那么清晰，所以我优化了代码结构，simplest_mediadata_flv.cpp。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstdio></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstdlib></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">TAG_TYPE_AUDIO</span> <span class="token expression"><span class="token number">8</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">TAG_TYPE_VIDEO</span> <span class="token expression"><span class="token number">9</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">TAG_TYPE_SCRIPT</span> <span class="token expression"><span class="token number">18</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">pragma</span> <span class="token expression"><span class="token function">pack</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span></span></span><span class="token keyword">struct</span> <span class="token class-name">FLV_HEADER</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">uint8_t</span> signature<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">uint8_t</span> version<span class="token punctuation">;</span>    <span class="token keyword">uint8_t</span> flags<span class="token punctuation">;</span> <span class="token comment">// TypeFlagsReserved(5 bits)+TypeFlagsAudio(1 bit)+TypeFlagsReserved(1 bit)+TypeFlagsVideo(1 bit)</span>    <span class="token keyword">uint32_t</span> header_size<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span><span class="token keyword">uint8_t</span> TagType<span class="token punctuation">;</span><span class="token keyword">uint8_t</span> DataSize<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">uint8_t</span> Timestamp<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">uint8_t</span> TimestampExtended<span class="token punctuation">;</span><span class="token keyword">uint8_t</span> StreamID<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// stream id</span><span class="token punctuation">&#125;</span> TAG_HEADER<span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">pragma</span> <span class="token expression"><span class="token function">pack</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span></span><span class="token keyword">uint32_t</span> <span class="token function">reverse_byte</span><span class="token punctuation">(</span><span class="token keyword">uint8_t</span><span class="token operator">*</span> p<span class="token punctuation">,</span> size_t len<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">uint32_t</span> result <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">uint32_t</span> shift <span class="token operator">=</span> <span class="token number">8</span> <span class="token operator">*</span> <span class="token punctuation">(</span>len <span class="token operator">-</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        result <span class="token operator">|=</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span>p <span class="token operator">+</span> i<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> shift<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> result<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">print_flv_header</span><span class="token punctuation">(</span>FILE<span class="token operator">*</span> out<span class="token punctuation">,</span> FLV_HEADER <span class="token operator">*</span> flv<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">fprintf</span><span class="token punctuation">(</span>out<span class="token punctuation">,</span> <span class="token string">"============== FLV Header ==============\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">fprintf</span><span class="token punctuation">(</span>out<span class="token punctuation">,</span> <span class="token string">"Signature:  0x %c %c %c\n"</span><span class="token punctuation">,</span> flv<span class="token operator">-></span>signature<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> flv<span class="token operator">-></span>signature<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> flv<span class="token operator">-></span>signature<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">fprintf</span><span class="token punctuation">(</span>out<span class="token punctuation">,</span> <span class="token string">"Version:    0x %X\n"</span><span class="token punctuation">,</span> flv<span class="token operator">-></span>version<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">fprintf</span><span class="token punctuation">(</span>out<span class="token punctuation">,</span> <span class="token string">"Flags:      0x %X\n"</span><span class="token punctuation">,</span> flv<span class="token operator">-></span>flags<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">fprintf</span><span class="token punctuation">(</span>out<span class="token punctuation">,</span> <span class="token string">"HeaderSize: 0x %X\n"</span><span class="token punctuation">,</span> <span class="token function">reverse_byte</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">uint8_t</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>flv<span class="token operator">-></span>header_size<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>flv<span class="token operator">-></span>header_size<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">fprintf</span><span class="token punctuation">(</span>out<span class="token punctuation">,</span> <span class="token string">"========================================\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">print_tag_info</span><span class="token punctuation">(</span>FILE<span class="token operator">*</span> out<span class="token punctuation">,</span> TAG_HEADER <span class="token operator">*</span>tag_header<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    string tag_type<span class="token punctuation">;</span>    <span class="token keyword">switch</span><span class="token punctuation">(</span>tag_header<span class="token operator">-></span>TagType<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">case</span> TAG_TYPE_SCRIPT<span class="token operator">:</span> tag_type <span class="token operator">=</span> <span class="token string">"SCRIPT"</span><span class="token punctuation">;</span> <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> TAG_TYPE_AUDIO<span class="token operator">:</span> tag_type <span class="token operator">=</span> <span class="token string">"AUDI0"</span><span class="token punctuation">;</span> <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> TAG_TYPE_VIDEO<span class="token operator">:</span> tag_type <span class="token operator">=</span> <span class="token string">"VIDEO"</span><span class="token punctuation">;</span> <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">default</span><span class="token operator">:</span> tag_type <span class="token operator">=</span> <span class="token string">"UNKNOWN"</span><span class="token punctuation">;</span> <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">int</span> data_size <span class="token operator">=</span> <span class="token punctuation">(</span>tag_header<span class="token operator">-></span>DataSize<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token number">16</span><span class="token punctuation">)</span> <span class="token operator">+</span>                    <span class="token punctuation">(</span>tag_header<span class="token operator">-></span>DataSize<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token number">8</span><span class="token punctuation">)</span> <span class="token operator">+</span>                    tag_header<span class="token operator">-></span>DataSize<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> timestamp <span class="token operator">=</span> <span class="token punctuation">(</span>tag_header<span class="token operator">-></span>Timestamp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token number">16</span><span class="token punctuation">)</span> <span class="token operator">+</span>                    <span class="token punctuation">(</span>tag_header<span class="token operator">-></span>Timestamp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token number">8</span><span class="token punctuation">)</span> <span class="token operator">+</span>                    tag_header<span class="token operator">-></span>Timestamp<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    timestamp <span class="token operator">|=</span> <span class="token punctuation">(</span>tag_header<span class="token operator">-></span>TimestampExtended <span class="token operator">&lt;&lt;</span> <span class="token number">24</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">fprintf</span><span class="token punctuation">(</span>out<span class="token punctuation">,</span> <span class="token string">"[%6s] %6d %6d |"</span><span class="token punctuation">,</span> tag_type<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> data_size<span class="token punctuation">,</span> timestamp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">process_audio_tag</span><span class="token punctuation">(</span>FILE <span class="token operator">*</span>in_file<span class="token punctuation">,</span> FILE <span class="token operator">*</span>audio_file<span class="token punctuation">,</span> TAG_HEADER <span class="token operator">*</span>tag_header<span class="token punctuation">,</span> FILE <span class="token operator">*</span>out<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    string audio_tag<span class="token punctuation">;</span>    <span class="token keyword">uint8_t</span> first_byte <span class="token operator">=</span> <span class="token function">fgetc</span><span class="token punctuation">(</span>in_file<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> audio_format <span class="token operator">=</span> first_byte <span class="token operator">&amp;</span> <span class="token number">0xF0</span><span class="token punctuation">;</span>    audio_format <span class="token operator">>>=</span> <span class="token number">4</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> sample_rate <span class="token operator">=</span> first_byte <span class="token operator">&amp;</span> <span class="token number">0x0c</span><span class="token punctuation">;</span>    sample_rate <span class="token operator">>>=</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> sample_size <span class="token operator">=</span> first_byte <span class="token operator">&amp;</span> <span class="token number">0x02</span><span class="token punctuation">;</span>    sample_size <span class="token operator">>>=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> channel <span class="token operator">=</span> first_byte <span class="token operator">&amp;</span> <span class="token number">0x01</span><span class="token punctuation">;</span>    audio_tag <span class="token operator">+=</span> <span class="token string">"| "</span><span class="token punctuation">;</span>    <span class="token keyword">switch</span><span class="token punctuation">(</span>audio_format<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">case</span> <span class="token number">0</span><span class="token operator">:</span> audio_tag <span class="token operator">+=</span> <span class="token string">"Linear PCM, platform endian"</span><span class="token punctuation">;</span> <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> <span class="token number">1</span><span class="token operator">:</span> audio_tag <span class="token operator">+=</span> <span class="token string">"ADPCM"</span><span class="token punctuation">;</span> <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> <span class="token number">2</span><span class="token operator">:</span> audio_tag <span class="token operator">+=</span> <span class="token string">"MP3"</span><span class="token punctuation">;</span> <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> <span class="token number">3</span><span class="token operator">:</span> audio_tag <span class="token operator">+=</span> <span class="token string">"Linear PCM, little endian"</span><span class="token punctuation">;</span> <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> <span class="token number">4</span><span class="token operator">:</span> audio_tag <span class="token operator">+=</span> <span class="token string">"Nellymoser 16-kHz mono"</span><span class="token punctuation">;</span> <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> <span class="token number">5</span><span class="token operator">:</span> audio_tag <span class="token operator">+=</span> <span class="token string">"Nellymoser 8-kHz mono"</span><span class="token punctuation">;</span> <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> <span class="token number">6</span><span class="token operator">:</span> audio_tag <span class="token operator">+=</span> <span class="token string">"Nellymoser"</span><span class="token punctuation">;</span> <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> <span class="token number">7</span><span class="token operator">:</span> audio_tag <span class="token operator">+=</span> <span class="token string">"G.711 A-law logarithmic PCM"</span><span class="token punctuation">;</span> <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> <span class="token number">8</span><span class="token operator">:</span> audio_tag <span class="token operator">+=</span> <span class="token string">"G.711 mu-law logarithmic PCM"</span><span class="token punctuation">;</span> <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> <span class="token number">9</span><span class="token operator">:</span> audio_tag <span class="token operator">+=</span> <span class="token string">"reserved"</span><span class="token punctuation">;</span> <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> <span class="token number">10</span><span class="token operator">:</span> audio_tag <span class="token operator">+=</span> <span class="token string">"AAC"</span><span class="token punctuation">;</span> <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> <span class="token number">11</span><span class="token operator">:</span> audio_tag <span class="token operator">+=</span> <span class="token string">"Speex"</span><span class="token punctuation">;</span> <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> <span class="token number">14</span><span class="token operator">:</span> audio_tag <span class="token operator">+=</span> <span class="token string">"MP3 8-Khz"</span><span class="token punctuation">;</span> <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> <span class="token number">15</span><span class="token operator">:</span> audio_tag <span class="token operator">+=</span> <span class="token string">"Device-specific sound"</span><span class="token punctuation">;</span> <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">default</span><span class="token operator">:</span> audio_tag <span class="token operator">+=</span> <span class="token string">"UNKNOWN"</span><span class="token punctuation">;</span> <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    audio_tag <span class="token operator">+=</span> <span class="token string">"| "</span><span class="token punctuation">;</span>        <span class="token keyword">switch</span><span class="token punctuation">(</span>sample_rate<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">case</span> <span class="token number">0</span><span class="token operator">:</span> audio_tag <span class="token operator">+=</span> <span class="token string">"5.5-kHz"</span><span class="token punctuation">;</span> <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> <span class="token number">1</span><span class="token operator">:</span> audio_tag <span class="token operator">+=</span> <span class="token string">"1-kHz"</span><span class="token punctuation">;</span> <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> <span class="token number">2</span><span class="token operator">:</span> audio_tag <span class="token operator">+=</span> <span class="token string">"22-kHz"</span><span class="token punctuation">;</span> <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> <span class="token number">3</span><span class="token operator">:</span> audio_tag <span class="token operator">+=</span> <span class="token string">"44-kHz"</span><span class="token punctuation">;</span> <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">default</span><span class="token operator">:</span> audio_tag <span class="token operator">+=</span> <span class="token string">"UNKNOWN"</span><span class="token punctuation">;</span> <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    audio_tag <span class="token operator">+=</span> <span class="token string">"| "</span><span class="token punctuation">;</span>        <span class="token keyword">switch</span><span class="token punctuation">(</span>sample_size<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">case</span> <span class="token number">0</span><span class="token operator">:</span> audio_tag <span class="token operator">+=</span> <span class="token string">"8 bit"</span><span class="token punctuation">;</span> <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> <span class="token number">1</span><span class="token operator">:</span> audio_tag <span class="token operator">+=</span> <span class="token string">"16 bit"</span><span class="token punctuation">;</span> <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">default</span><span class="token operator">:</span> audio_tag <span class="token operator">+=</span> <span class="token string">"UNKNOWN"</span><span class="token punctuation">;</span> <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    audio_tag <span class="token operator">+=</span> <span class="token string">"| "</span><span class="token punctuation">;</span>        <span class="token keyword">switch</span><span class="token punctuation">(</span>channel<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">case</span> <span class="token number">0</span><span class="token operator">:</span> audio_tag <span class="token operator">+=</span> <span class="token string">"Mono"</span><span class="token punctuation">;</span> <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> <span class="token number">1</span><span class="token operator">:</span> audio_tag <span class="token operator">+=</span> <span class="token string">"Stereo"</span><span class="token punctuation">;</span> <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">default</span><span class="token operator">:</span> audio_tag <span class="token operator">+=</span> <span class="token string">"UNKNOWN"</span><span class="token punctuation">;</span> <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">fprintf</span><span class="token punctuation">(</span>out<span class="token punctuation">,</span> <span class="token string">"%s"</span><span class="token punctuation">,</span> audio_tag<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> data_size <span class="token operator">=</span> <span class="token punctuation">(</span>tag_header<span class="token operator">-></span>DataSize<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token number">16</span><span class="token punctuation">)</span> <span class="token operator">|</span>                    <span class="token punctuation">(</span>tag_header<span class="token operator">-></span>DataSize<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token number">8</span><span class="token punctuation">)</span> <span class="token operator">|</span>                    tag_header<span class="token operator">-></span>DataSize<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>audio_file <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">fputc</span><span class="token punctuation">(</span>first_byte<span class="token punctuation">,</span> audio_file<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 写入第一个字节（音频信息）</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> data_size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">fputc</span><span class="token punctuation">(</span><span class="token function">fgetc</span><span class="token punctuation">(</span>in_file<span class="token punctuation">)</span><span class="token punctuation">,</span> audio_file<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token function">fseek</span><span class="token punctuation">(</span>in_file<span class="token punctuation">,</span> data_size <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token constant">SEEK_CUR</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 已读1字节</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">process_video_tag</span><span class="token punctuation">(</span>FILE <span class="token operator">*</span>in_file<span class="token punctuation">,</span> FILE <span class="token operator">*</span>video_file<span class="token punctuation">,</span> TAG_HEADER <span class="token operator">*</span>tag_header<span class="token punctuation">,</span> FLV_HEADER <span class="token operator">*</span>flv<span class="token punctuation">,</span> FILE <span class="token operator">*</span>out<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    string video_tag<span class="token punctuation">;</span>    u_char first_byte <span class="token operator">=</span> <span class="token function">fgetc</span><span class="token punctuation">(</span>in_file<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> frame_type <span class="token operator">=</span> first_byte <span class="token operator">&amp;</span> <span class="token number">0xF0</span><span class="token punctuation">;</span>    frame_type <span class="token operator">>>=</span> <span class="token number">4</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> codec_id <span class="token operator">=</span> first_byte <span class="token operator">&amp;</span> <span class="token number">0x0F</span><span class="token punctuation">;</span>    video_tag <span class="token operator">+=</span> <span class="token string">"| "</span><span class="token punctuation">;</span>        <span class="token keyword">switch</span><span class="token punctuation">(</span>frame_type<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">case</span> <span class="token number">1</span><span class="token operator">:</span> video_tag <span class="token operator">+=</span> <span class="token string">"key frame "</span><span class="token punctuation">;</span> <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> <span class="token number">2</span><span class="token operator">:</span> video_tag <span class="token operator">+=</span> <span class="token string">"inter frame "</span><span class="token punctuation">;</span> <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> <span class="token number">3</span><span class="token operator">:</span> video_tag <span class="token operator">+=</span> <span class="token string">"disposable inter frame "</span><span class="token punctuation">;</span> <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> <span class="token number">4</span><span class="token operator">:</span> video_tag <span class="token operator">+=</span> <span class="token string">"generated keyframe"</span><span class="token punctuation">;</span> <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> <span class="token number">5</span><span class="token operator">:</span> video_tag <span class="token operator">+=</span> <span class="token string">"video info/frame frame"</span><span class="token punctuation">;</span> <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">default</span><span class="token operator">:</span> video_tag <span class="token operator">+=</span> <span class="token string">"UNKNOWN"</span><span class="token punctuation">;</span> <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        video_tag <span class="token operator">+=</span> <span class="token string">"| "</span><span class="token punctuation">;</span>    <span class="token keyword">switch</span><span class="token punctuation">(</span>codec_id<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">case</span> <span class="token number">1</span><span class="token operator">:</span> video_tag <span class="token operator">+=</span> <span class="token string">"JPEG (currently unused)"</span><span class="token punctuation">;</span> <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> <span class="token number">2</span><span class="token operator">:</span> video_tag <span class="token operator">+=</span> <span class="token string">"Sorenson H.263"</span><span class="token punctuation">;</span> <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> <span class="token number">3</span><span class="token operator">:</span> video_tag <span class="token operator">+=</span> <span class="token string">"Screen video"</span><span class="token punctuation">;</span> <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> <span class="token number">4</span><span class="token operator">:</span> video_tag <span class="token operator">+=</span> <span class="token string">"On2 VP6"</span><span class="token punctuation">;</span> <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> <span class="token number">5</span><span class="token operator">:</span> video_tag <span class="token operator">+=</span> <span class="token string">"On2 VP6 with alpha channel"</span><span class="token punctuation">;</span> <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> <span class="token number">6</span><span class="token operator">:</span> video_tag <span class="token operator">+=</span> <span class="token string">"Screen video version 2"</span><span class="token punctuation">;</span> <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> <span class="token number">7</span><span class="token operator">:</span> video_tag <span class="token operator">+=</span> <span class="token string">"AVC"</span><span class="token punctuation">;</span> <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">default</span><span class="token operator">:</span> video_tag <span class="token operator">+=</span> <span class="token string">"UNKNOWN"</span><span class="token punctuation">;</span> <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">fprintf</span><span class="token punctuation">(</span>out<span class="token punctuation">,</span> <span class="token string">"%s"</span><span class="token punctuation">,</span> video_tag<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">fseek</span><span class="token punctuation">(</span>in_file<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token constant">SEEK_CUR</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    size_t data_size <span class="token operator">=</span> <span class="token punctuation">(</span>tag_header<span class="token operator">-></span>DataSize<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token number">16</span><span class="token punctuation">)</span> <span class="token operator">|</span>                    <span class="token punctuation">(</span>tag_header<span class="token operator">-></span>DataSize<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token number">8</span><span class="token punctuation">)</span> <span class="token operator">|</span>                    tag_header<span class="token operator">-></span>DataSize<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>video_file <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">fwrite</span><span class="token punctuation">(</span>tag_header<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>TAG_HEADER<span class="token punctuation">)</span><span class="token punctuation">,</span> video_file<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> data_size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">fputc</span><span class="token punctuation">(</span><span class="token function">fgetc</span><span class="token punctuation">(</span>in_file<span class="token punctuation">)</span><span class="token punctuation">,</span> video_file<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">uint32_t</span> prev_tag_size <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>TAG_HEADER<span class="token punctuation">)</span> <span class="token operator">+</span> data_size<span class="token punctuation">;</span>        <span class="token function">fwrite</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>prev_tag_size<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>prev_tag_size<span class="token punctuation">)</span><span class="token punctuation">,</span> video_file<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token function">fseek</span><span class="token punctuation">(</span>in_file<span class="token punctuation">,</span> data_size<span class="token punctuation">,</span> <span class="token constant">SEEK_CUR</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">simplest_flv_parser1</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> url<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> output_a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> output_v <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    FILE <span class="token operator">*</span>in_file <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">,</span> <span class="token operator">*</span>video_file <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">,</span> <span class="token operator">*</span>audio_file <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>    FILE <span class="token operator">*</span>myout <span class="token operator">=</span> <span class="token constant">stdout</span><span class="token punctuation">;</span>    FLV_HEADER flv<span class="token punctuation">;</span>    TAG_HEADER tag_header<span class="token punctuation">;</span>    <span class="token keyword">uint32_t</span> previous_tag_size<span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>in_file <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span> <span class="token string">"rb"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">fprintf</span><span class="token punctuation">(</span>myout<span class="token punctuation">,</span> <span class="token string">"Cannot open input file: %s\n"</span><span class="token punctuation">,</span> url<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">fread</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>flv<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>FLV_HEADER<span class="token punctuation">)</span><span class="token punctuation">,</span> in_file<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>FLV_HEADER<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">fprintf</span><span class="token punctuation">(</span>myout<span class="token punctuation">,</span> <span class="token string">"Failed to read flvheader.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">fclose</span><span class="token punctuation">(</span>in_file<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">print_flv_header</span><span class="token punctuation">(</span>myout<span class="token punctuation">,</span> <span class="token operator">&amp;</span>flv<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">fseek</span><span class="token punctuation">(</span>in_file<span class="token punctuation">,</span> <span class="token function">reverse_byte</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">uint8_t</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>flv<span class="token punctuation">.</span>header_size<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>flv<span class="token punctuation">.</span>header_size<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token constant">SEEK_SET</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">feof</span><span class="token punctuation">(</span>in_file<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">fread</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>previous_tag_size<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>previous_tag_size<span class="token punctuation">)</span><span class="token punctuation">,</span> in_file<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>previous_tag_size<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">fread</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tag_header<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>TAG_HEADER<span class="token punctuation">)</span><span class="token punctuation">,</span> in_file<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>TAG_HEADER<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token function">print_tag_info</span><span class="token punctuation">(</span>myout<span class="token punctuation">,</span> <span class="token operator">&amp;</span>tag_header<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">switch</span><span class="token punctuation">(</span>tag_header<span class="token punctuation">.</span>TagType<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">case</span> TAG_TYPE_AUDIO<span class="token operator">:</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>output_a <span class="token operator">&amp;&amp;</span> audio_file <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    audio_file <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span><span class="token string">"output.mp3"</span><span class="token punctuation">,</span> <span class="token string">"wb"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                <span class="token function">process_audio_tag</span><span class="token punctuation">(</span>in_file<span class="token punctuation">,</span> audio_file<span class="token punctuation">,</span> <span class="token operator">&amp;</span>tag_header<span class="token punctuation">,</span> myout<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token keyword">case</span> TAG_TYPE_VIDEO<span class="token operator">:</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>output_v <span class="token operator">&amp;&amp;</span> video_file <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    video_file <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span><span class="token string">"output.flv"</span><span class="token punctuation">,</span> <span class="token string">"wb"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>video_file<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                        <span class="token function">fwrite</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>flv<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>FLV_HEADER<span class="token punctuation">)</span><span class="token punctuation">,</span> video_file<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">uint32_t</span> header_tag_size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                        <span class="token function">fwrite</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>header_tag_size<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>header_tag_size<span class="token punctuation">)</span><span class="token punctuation">,</span> video_file<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">&#125;</span>                <span class="token punctuation">&#125;</span>                <span class="token function">process_video_tag</span><span class="token punctuation">(</span>in_file<span class="token punctuation">,</span> video_file<span class="token punctuation">,</span> <span class="token operator">&amp;</span>tag_header<span class="token punctuation">,</span> <span class="token operator">&amp;</span>flv<span class="token punctuation">,</span> myout<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token keyword">default</span><span class="token operator">:</span>                <span class="token keyword">int</span> skip_size <span class="token operator">=</span> <span class="token punctuation">(</span>tag_header<span class="token punctuation">.</span>DataSize<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token number">16</span><span class="token punctuation">)</span> <span class="token operator">|</span>                                <span class="token punctuation">(</span>tag_header<span class="token punctuation">.</span>DataSize<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token number">8</span><span class="token punctuation">)</span> <span class="token operator">|</span>                                tag_header<span class="token punctuation">.</span>DataSize<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token function">fseek</span><span class="token punctuation">(</span>in_file<span class="token punctuation">,</span> skip_size<span class="token punctuation">,</span> <span class="token constant">SEEK_CUR</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token function">fprintf</span><span class="token punctuation">(</span>myout<span class="token punctuation">,</span> <span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>video_file <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token function">fclose</span><span class="token punctuation">(</span>video_file<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>audio_file <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token function">fclose</span><span class="token punctuation">(</span>audio_file<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>in_file <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token function">fclose</span><span class="token punctuation">(</span>in_file<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr>]]></content>
      
      
      <categories>
          
          <category> 音视频 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 音视频基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux文件描述符</title>
      <link href="/2024/12/29/linux-wen-jian-miao-shu-fu/"/>
      <url>/2024/12/29/linux-wen-jian-miao-shu-fu/</url>
      
        <content type="html"><![CDATA[<h2 id="Linux文件描述符"><a href="#Linux文件描述符" class="headerlink" title="Linux文件描述符"></a>Linux文件描述符</h2><p>Linux 系统中，把一切都看做是文件，当进程打开现有文件或创建新文件时，内核向进程返回一个文件描述符（file descriptor，fd）[1, 4]，在windows下面，这玩意儿叫file handle，句柄。</p><p>文件描述符（file descriptor）就是内核为了高效管理这些已经被打开的文件所创建的索引，其是一个非负整数（通常是小整数），用于指代被打开的文件，所有执行I/O操作的系统调用都通过文件描述符来实现。同时还规定系统刚刚启动的时候，0是标准输入，1是标准输出，2是标准错误。这意味着如果此时去打开一个新的文件，它的文件描述符会是3，再打开一个文件文件描述符就是4……[2]。</p><p>可以简单理解成系统维护的文件描述符表是一个数组，下标就是索引（文件描述符），数组内容就是一个个指向文件的指针（如0 -&gt; stdin，1 -&gt; stdout，2-&gt; stderr）。</p><p>掌握它，有助于深入理解 Linux 文件系统、I/O 操作，<br>以及进程间通信（如<strong>管道（pipe）</strong>、<strong>套接字（Socket）</strong>）的实现，可以去Ubuntu系统中简单完成下面的例子。&lt;(￣︶￣)↗[GO!]</p><h2 id="用户程序与内核交互的基本过程"><a href="#用户程序与内核交互的基本过程" class="headerlink" title="用户程序与内核交互的基本过程"></a>用户程序与内核交互的基本过程</h2><h3 id="1-打开文件"><a href="#1-打开文件" class="headerlink" title="1. 打开文件"></a>1. 打开文件</h3><p>当一个用户程序需要访问某个文件时，它会通过系统调用（如 open()）请求内核打开该文件。<br>内核会根据文件路径在文件系统中查找文件，并为该文件分配一个文件描述符。这个文件描述符是一个整数，表示该文件在内核中的唯一标识符。<br>内核维护着一个叫做 文件表（file table）的数据结构，文件描述符实际上就是对这个表中的一个条目的引用。</p><h3 id="2-使用文件描述符读写文件"><a href="#2-使用文件描述符读写文件" class="headerlink" title="2. 使用文件描述符读写文件"></a>2. 使用文件描述符读写文件</h3><p>用户程序使用文件描述符来进行后续的文件操作。例如：<br>读取文件：用户程序调用 read(fd, …) 系统调用，内核通过文件描述符 fd 查找对应的文件，并从磁盘中读取数据，将数据返回给用户程序。<br>写入文件：用户程序调用 write(fd, …) 系统调用，内核通过文件描述符 fd 查找文件，向文件中写入数据。<br>文件描述符使得内核能够识别哪个文件需要被操作，从而实现文件与程序的交互。</p><h3 id="3-文件描述符与文件表"><a href="#3-文件描述符与文件表" class="headerlink" title="3. 文件描述符与文件表"></a>3. 文件描述符与文件表</h3><p>内核通过文件描述符和文件表来管理已打开的文件。每个进程都有一个 文件描述符表，它是一个数组，其中每个索引对应一个文件描述符。这个文件描述符指向内核的文件表项，每个文件表项包含文件的状态信息（例如当前文件指针、文件权限等）。</p><h3 id="4-文件操作的内核层处理"><a href="#4-文件操作的内核层处理" class="headerlink" title="4. 文件操作的内核层处理"></a>4. 文件操作的内核层处理</h3><p>用户程序和内核之间的交互通常通过系统调用来实现，文件描述符是这些系统调用的接口。内核会根据文件描述符执行相应的操作：<br>打开文件时，内核会创建或查找该文件的内核对象，并更新文件描述符。<br>对文件进行读写操作时，内核通过文件描述符在文件表中查找文件对象，然后执行 I/O 操作（例如读取磁盘或写入磁盘）。</p><h3 id="5-关闭文件"><a href="#5-关闭文件" class="headerlink" title="5. 关闭文件"></a>5. 关闭文件</h3><p>当用户程序完成文件操作后，它会通过系统调用 close(fd) 来关闭文件描述符。<br>内核会释放文件描述符所占用的资源，关闭文件的文件表项，并更新进程的文件描述符表。</p><h3 id="通过文件描述符交互的具体例子"><a href="#通过文件描述符交互的具体例子" class="headerlink" title="通过文件描述符交互的具体例子"></a>通过文件描述符交互的具体例子</h3><p>假设一个程序需要从文件中读取数据并进行处理，下面的示例代码：<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;fcntl.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> fd <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span><span class="token string">"example.txt"</span><span class="token punctuation">,</span> O_RDONLY<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>fd <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"open"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">char</span> buffer<span class="token punctuation">[</span><span class="token number">128</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    ssize_t bytesRead <span class="token operator">=</span> <span class="token function">read</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> buffer<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>bytesRead <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"read"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">close</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">write</span><span class="token punctuation">(</span>STDOUT_FILENO<span class="token punctuation">,</span> buffer<span class="token punctuation">,</span> bytesRead<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">close</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>在这个例子中，文件描述符的作用可以从以下几个步骤看到：</p><ul><li>打开文件时，<code>open()</code> 系统调用将返回一个文件描述符（fd），这个文件描述符在内核中表示 example.txt 文件的句柄。</li><li>读取文件时，<code>read()</code> 系统调用使用文件描述符 fd 来访问内核中的文件表项，执行 I/O 操作并将文件数据读取到 buffer 中。</li><li>写入数据时，通过 <code>write(STDOUT_FILENO, ...)</code> 输出数据，STDOUT_FILENO 是标准输出的文件描述符（通常是 1）。</li><li>关闭文件时，<code>close(fd)</code> 系统调用会释放文件描述符所占用的资源，告知内核文件已经关闭。</li></ul><p>通过文件描述符，程序可以与操作系统内核进行有效的通信，完成文件系统和其他 I/O 操作。</p><h2 id="Linux上查看文件描述符列表"><a href="#Linux上查看文件描述符列表" class="headerlink" title="Linux上查看文件描述符列表"></a>Linux上查看文件描述符列表</h2><p>在 Linux 上使用 vim 打开文件时，操作系统通过文件描述符与文件系统进行交互。下面是一个具体例子。</p><h3 id="打开文件（使用-Vim）"><a href="#打开文件（使用-Vim）" class="headerlink" title="打开文件（使用 Vim）"></a>打开文件（使用 Vim）</h3><p>首先，你使用 vim 打开一个文件（例如 <code>helloworld.cpp</code>）：<br><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">vim</span> helloworld.cpp<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br>这时，Vim 会启动并打开 <code>helloworld.cpp</code> 文件。在内核中，Vim 会使用文件描述符来与文件系统交互，即读取和编辑 <code>helloworld.cpp</code> 文件的内容。</p><hr><h3 id="在新-Shell-中查找-Vim-进程的-PID"><a href="#在新-Shell-中查找-Vim-进程的-PID" class="headerlink" title="在新 Shell 中查找 Vim 进程的 PID"></a>在新 Shell 中查找 Vim 进程的 PID</h3><p>接着，你可以打开另一个终端（Shell），通过 <code>pidof</code> 命令获取正在运行的 Vim 进程的进程 ID（PID）：<br><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pidof <span class="token function">vim</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br>假设返回的 PID 是 <code>40133</code>，说明 Vim 进程的进程号是 <code>40133</code>。</p><h3 id="查看-Vim-进程的文件描述符"><a href="#查看-Vim-进程的文件描述符" class="headerlink" title="查看 Vim 进程的文件描述符"></a>查看 Vim 进程的文件描述符</h3><p>Linux 系统中的每个进程都有一个对应的 /proc/[pid]/fd 目录，里面列出了该进程打开的所有文件的文件描述符。你可以通过以下命令查看 Vim 进程所使用的文件描述符列表：<br><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ll /proc/40133/fd<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br>这里，<code>40133</code> 是你之前通过 <code>pidof vim</code> 命令获得的 Vim 进程的 PID。</p><p><code>ll</code> 命令会列出该目录下的文件，其中每个文件都对应着一个打开的文件描述符（文件句柄）。输出会类似于：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">total <span class="token number">0</span>dr-x------ <span class="token number">2</span> allen allen  <span class="token number">0</span> Dec <span class="token number">29</span> <span class="token number">15</span>:58 ./dr-xr-xr-x <span class="token number">9</span> allen allen  <span class="token number">0</span> Dec <span class="token number">29</span> <span class="token number">15</span>:58 <span class="token punctuation">..</span>/lrwx------ <span class="token number">1</span> allen allen <span class="token number">64</span> Dec <span class="token number">29</span> <span class="token number">15</span>:58 <span class="token number">0</span> -<span class="token operator">></span> /dev/pts/8lrwx------ <span class="token number">1</span> allen allen <span class="token number">64</span> Dec <span class="token number">29</span> <span class="token number">15</span>:58 <span class="token number">1</span> -<span class="token operator">></span> /dev/pts/8l-wx------ <span class="token number">1</span> allen allen <span class="token number">64</span> Dec <span class="token number">29</span> <span class="token number">15</span>:58 <span class="token number">19</span> -<span class="token operator">></span> /home/allen/.vscode-server/data/logs/20241229T150828/ptyhost.loglrwx------ <span class="token number">1</span> allen allen <span class="token number">64</span> Dec <span class="token number">29</span> <span class="token number">15</span>:58 <span class="token number">2</span> -<span class="token operator">></span> /dev/pts/8l-wx------ <span class="token number">1</span> allen allen <span class="token number">64</span> Dec <span class="token number">29</span> <span class="token number">15</span>:58 <span class="token number">20</span> -<span class="token operator">></span> /home/allen/.vscode-server/data/logs/20241229T150828/remoteagent.loglrwx------ <span class="token number">1</span> allen allen <span class="token number">64</span> Dec <span class="token number">29</span> <span class="token number">15</span>:58 <span class="token number">21</span> -<span class="token operator">></span> /dev/ptmxlrwx------ <span class="token number">1</span> allen allen <span class="token number">64</span> Dec <span class="token number">29</span> <span class="token number">15</span>:58 <span class="token number">22</span> -<span class="token operator">></span> /dev/ptmxlrwx------ <span class="token number">1</span> allen allen <span class="token number">64</span> Dec <span class="token number">29</span> <span class="token number">15</span>:58 <span class="token number">23</span> -<span class="token operator">></span> /dev/ptmxlrwx------ <span class="token number">1</span> allen allen <span class="token number">64</span> Dec <span class="token number">29</span> <span class="token number">15</span>:58 <span class="token number">4</span> -<span class="token operator">></span> /home/allen/CPP/.helloworld.cpp.swp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里的输出解释如下：</p><ul><li><p>0，1，2：这是标准输入、标准输出和标准错误，它们通常会指向终端设备（如 <code>/dev/pts/8</code>）。这些文件描述符是系统默认打开的，用于处理进程的 I/O 操作。</p></li><li><p>4：这个文件描述符指向你用 Vim 打开的文件 <code>helloworld.cpp</code>。可以看到，<code>/home/allen/CPP/.helloworld.cpp.swp</code> 是文件描述符 4 对应的目标文件。</p></li></ul><p>说明：</p><ul><li>在 Linux 中，每个进程都会为打开的文件、管道、设备、套接字等分配一个文件描述符，文件描述符的值通常是从 0 开始递增的。</li><li>标准输入（0）、标准输出（1）、标准错误（2）是系统自动打开的，而打开的文件 <code>helloworld.cpp</code> 在 Vim 进程中会被分配到文件描述符 3 及以后。</li></ul><p>可以看到新打开的 <code>helloworld.cpp</code> 的文件描述符，竟然是4，而不是从3开始，这里面有一番学问，涉及    <code>vim</code> 的原理。因为vim这种编辑器的原理是先打开源文件并拷贝，然后关闭源文件再打开自己的副本，修改完文件保存的时候直接将副本重命名覆盖源文件。所以打开源文件的时候用的文件描述符3，然后打开自己的副本是时候就该用文件描述符4了，然后关闭源文件，文件描述符3就被释放了，我们查看的时候就只剩下了4，这里它指向的是vim创建的副本文件[3]（这里有更详细的解释，这里是一个通俗的理解）。</p><h3 id="检查文件描述符的具体信息"><a href="#检查文件描述符的具体信息" class="headerlink" title="检查文件描述符的具体信息"></a>检查文件描述符的具体信息</h3><p>可以通过查看符号链接来了解更多细节，例如，可以用 <code>readlink</code> 命令查看文件描述符指向的文件路径：<br><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">readlink /proc/40133/fd/4<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></p><h2 id="深入理解-Linux-中的文件描述符及其背后的数据结构"><a href="#深入理解-Linux-中的文件描述符及其背后的数据结构" class="headerlink" title="深入理解 Linux 中的文件描述符及其背后的数据结构"></a>深入理解 Linux 中的文件描述符及其背后的数据结构</h2><p>要深入理解 Linux 中的文件描述符及其背后的数据结构，我们需要了解内核如何通过三个核心数据结构来管理文件描述符：</p><ol><li><strong>进程级的文件描述符表</strong>（Process File Descriptor Table）</li><li><strong>系统级的打开文件描述符表</strong>（System-wide Open File Table）</li><li><strong>文件系统的 i-node 表</strong>（File System i-node Table）</li></ol><p>这三个数据结构[4]共同工作，使得 Linux 系统能够高效地管理文件 I/O 操作，并确保每个进程对文件的访问是独立且有序的。</p><hr><h3 id="1-进程级的文件描述符表"><a href="#1-进程级的文件描述符表" class="headerlink" title="1. 进程级的文件描述符表"></a>1. 进程级的文件描述符表</h3><p>每个运行中的进程都有一个 <strong>进程控制块（PCB）</strong>，它包含了与进程相关的各种信息。在这个 PCB 中，<strong>文件描述符表</strong>（也称为 <strong>文件描述符数组</strong>）是一个非常重要的数据结构。</p><ul><li><p><strong>文件描述符表的功能</strong>：每个进程的文件描述符表记录着该进程所打开的文件描述符。文件描述符是一个整数，它对应着进程所打开的文件、套接字、管道等资源。</p></li><li><p><strong>表的结构</strong>：文件描述符表是一个数组，每个文件描述符对应数组中的一个位置。例如，标准输入、标准输出、标准错误默认分别对应文件描述符 0、1、2，而其他文件则由内核为每个进程分配一个较大的文件描述符，如 3、4、5 等。</p></li><li><p><strong>进程独立性</strong>：进程级文件描述符表是进程私有的。不同进程之间是独立的，进程 A 使用文件描述符 3 打开的文件，进程 B 如果也打开了一个文件，可能也会被分配文件描述符 3。它们的文件描述符对应的是不同的文件资源。</p></li></ul><p><strong>进程级文件描述符表的关键点</strong>：</p><ul><li>每个进程都维护一个自己的文件描述符表。</li><li>文件描述符表的每个条目对应一个打开的文件或资源。</li><li>文件描述符表存储的只是文件描述符与内核内部文件对象的引用。</li></ul><hr><h3 id="2-系统级的打开文件描述符表"><a href="#2-系统级的打开文件描述符表" class="headerlink" title="2. 系统级的打开文件描述符表"></a>2. 系统级的打开文件描述符表</h3><p>系统级的 <strong>打开文件描述符表</strong> 是内核维护的一个全局数据结构，用来管理系统中所有进程共享的文件资源。每当一个进程打开文件时，内核会在此表中创建一项记录，表示这个文件被打开。</p><p><strong>该表中的每项记录包含以下信息</strong>：</p><ul><li><p><strong>当前文件偏移量</strong>：每个文件都有一个当前的读取或写入位置。当进程执行 <code>read()</code> 或 <code>write()</code> 操作时，内核会根据该文件的偏移量进行相应的读写操作。在每次读取时，偏移量会自动更新，也可以通过 <code>lseek()</code> 系统调用显式地修改偏移量。</p></li><li><p><strong>打开文件时的标识</strong>：由 <code>open()</code> 系统调用的 <code>flags</code> 参数指定，如只读、只写、读写等。内核在打开文件时会记录这些标识，用于后续的访问控制。</p></li><li><p><strong>文件访问模式</strong>：当进程通过 <code>open()</code> 打开文件时，内核会记录文件的访问模式（如只读模式 <code>O_RDONLY</code>，只写模式 <code>O_WRONLY</code>，读写模式 <code>O_RDWR</code>）以及其他访问权限（如 <code>O_APPEND</code>、<code>O_NONBLOCK</code> 等）。</p></li><li><p><strong>与信号驱动相关的设置</strong>：某些文件（如终端设备）可以通过信号驱动模式进行 I/O 操作。这些设置会记录在系统级的打开文件表中，以便内核在合适的时机处理信号。</p></li><li><p><strong>与文件的 i-node 关联</strong>：系统级的打开文件描述符表项会保存指向文件系统 <strong>i-node</strong> 表项的指针。i-node 表项包含了该文件的元数据（如文件大小、权限、时间戳等）。</p></li></ul><p><strong>关键点</strong>：</p><ul><li>每个进程打开文件时，系统级打开文件表会创建相应的记录。</li><li>所有进程共享系统级的打开文件描述符表，通过这个表来管理文件的偏移量和访问模式等信息。</li></ul><hr><h3 id="3-文件系统的-i-node-表"><a href="#3-文件系统的-i-node-表" class="headerlink" title="3. 文件系统的 i-node 表"></a>3. 文件系统的 i-node 表</h3><p><strong>i-node</strong> 是 <strong>索引节点</strong>（Index Node）的缩写，是文件系统用来存储文件元数据的一种数据结构。每个文件都有一个对应的 i-node，i-node 不存储文件的内容，而是存储与文件相关的各种属性和元数据。</p><p><strong>i-node 表包含以下内容</strong>：</p><ul><li><p><strong>文件类型</strong>：例如普通文件、目录文件、符号链接、套接字、FIFO 等。</p></li><li><p><strong>文件权限</strong>：表示文件的访问权限（如读、写、执行权限）。</p></li><li><p><strong>文件大小</strong>：文件的实际大小（字节数）。</p></li><li><p><strong>时间戳</strong>：包括文件的创建时间、修改时间和访问时间（如 <code>ctime</code>、<code>mtime</code>、<code>atime</code> 等）。</p></li><li><p><strong>指向文件数据块的指针</strong>：i-node 会存储指向文件实际数据块的指针（对于小文件直接存储指针，对于大文件使用间接块）。这些指针帮助操作系统在磁盘上定位文件内容。</p></li><li><p><strong>文件锁列表</strong>：如果文件被加锁，i-node 会存储一个指向锁信息的指针。</p></li><li><p><strong>引用计数</strong>：记录有多少个进程或文件描述符正在使用该文件。如果引用计数为 0，则表示该文件可以被删除。</p></li></ul><p><strong>i-node 的关键点</strong>：</p><ul><li>i-node 存储文件的元数据，而不存储文件的实际内容。</li><li>每个文件在文件系统中都有唯一的 i-node。</li><li>文件的内容由磁盘上的数据块来存储，而 i-node 中存储的是指向这些数据块的指针。</li></ul><hr><h3 id="文件描述符如何协同工作"><a href="#文件描述符如何协同工作" class="headerlink" title="文件描述符如何协同工作"></a>文件描述符如何协同工作</h3><p>文件描述符表、系统级的打开文件描述符表和 i-node 表相互协作来管理文件资源：</p><ol><li><p><strong>进程级文件描述符表</strong> 存储进程所打开的文件描述符，它是进程私有的。当进程通过 <code>open()</code> 打开一个文件时，内核会在进程的文件描述符表中分配一个文件描述符，并且该文件描述符指向 <strong>系统级的打开文件描述符表</strong> 中的一个记录。</p></li><li><p><strong>系统级的打开文件描述符表</strong> 存储所有打开文件的状态信息，如文件偏移量、访问模式等，并且每个表项都会指向对应文件的 <strong>i-node</strong>。</p></li><li><p><strong>i-node 表</strong> 存储文件的元数据（如权限、大小等）以及文件内容所在的磁盘位置。每个打开的文件都会通过 i-node 来访问文件的实际数据。</p></li></ol><p>当进程进行文件操作时（如 <code>read()</code>、<code>write()</code>），操作首先通过进程级的文件描述符表查找对应的文件描述符，然后在系统级的打开文件描述符表中查找该文件的状态信息，并通过 i-node 访问文件的实际数据。</p><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><strong>进程级的文件描述符表</strong>：每个进程独立维护，记录当前进程打开的文件描述符。</li><li><strong>系统级的打开文件描述符表</strong>：所有进程共享，记录文件的状态信息和 i-node 引用。</li><li><strong>文件系统的 i-node 表</strong>：记录文件的元数据和实际数据的位置信息。</li></ul><p>这三个数据结构协作，使得 Linux 系统能够高效且灵活地管理文件 I/O 操作，确保进程之间的文件访问独立且有序，并且能够在多进程环境中正确地管理文件资源。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1、<a href="https://zhuanlan.zhihu.com/p/143430585">理解Linux的文件描述符FD与Inode</a>]<br>[2、<a href="https://wiyi.org/linux-file-descriptor.html">理解linux中的file descriptor(文件描述符)</a>]<br>[3、<a href="https://yushuaige.github.io/2020/08/14/%E5%BD%BB%E5%BA%95%E5%BC%84%E6%87%82%20Linux%20%E4%B8%8B%E7%9A%84%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%EF%BC%88fd%EF%BC%89/">彻底弄懂 Linux 下的文件描述符（fd）</a>]<br>[4、<a href="https://c.biancheng.net/view/3066.html">Linux文件描述符到底是什么？</a>]</p>]]></content>
      
      
      <categories>
          
          <category> Linux基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux top指令</title>
      <link href="/2024/12/28/linux-top-zhi-ling/"/>
      <url>/2024/12/28/linux-top-zhi-ling/</url>
      
        <content type="html"><![CDATA[<h2 id="top指令概述"><a href="#top指令概述" class="headerlink" title="top指令概述"></a>top指令概述</h2><p><code>top</code> 是 Linux 系统中用于实时监控系统性能和进程信息的命令，功能强大且灵活。它提供了系统资源的动态视图，包括 CPU、内存、运行中的进程等。</p><p>这个指令可以说是Linux中最基本的工具了，用来监视系统的实时运行状态，类似的程序还有很多，像是<code>htop</code>、<code>gtop</code>，都是衍生版。基本来说，top够用了。</p><p>整理学习的Linux 指令的知识。这种指令也不用完全掌握，知道基本的用法就可以，了解一些快捷键，提高工作效率，自己在Ubuntu或者WSL里面多尝试一些，这才是重要的&lt;(￣︶￣)↗[GO!]。</p><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">top</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>输出会显示系统状态的实时更新列表，按默认的刷新间隔（通常是3秒）更新。</p><h2 id="常见快捷键"><a href="#常见快捷键" class="headerlink" title="常见快捷键"></a>常见快捷键</h2><p>在 top 的界面中，可以使用以下快捷键进行交互操作（注意区分大小写，多多尝试）：</p><h3 id="排序相关"><a href="#排序相关" class="headerlink" title="排序相关"></a>排序相关</h3><p>按下g，可以选择1-4这几种排序字段，下面的都包括了<br>P：按 CPU 使用率排序（默认）。<br>M：按内存使用率排序。<br>T：按运行时间排序。</p><h3 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h3><p>k：终止某个进程，会提示输入 PID。<br>r：重新调整进程优先级（修改 nice 值）。</p><h3 id="显示选项"><a href="#显示选项" class="headerlink" title="显示选项"></a>显示选项</h3><p>h：显示帮助菜单。<br>1：显示每个 CPU 的使用情况。<br>c：显示或隐藏进程的完整命令路径。<br>q：退出 top。</p><h3 id="过滤与搜索"><a href="#过滤与搜索" class="headerlink" title="过滤与搜索"></a>过滤与搜索</h3><p>/：查找特定的进程。<br>n：设置显示的进程数量。</p><h3 id="常用组合推荐"><a href="#常用组合推荐" class="headerlink" title="常用组合推荐"></a>常用组合推荐</h3><p>按内存使用排序：M<br>按 CPU 使用排序：P<br>监控某用户的任务：u + 用户名<br>实时查看多核 CPU 状态：1<br>高亮排序字段：x</p><h2 id="输出字段说明"><a href="#输出字段说明" class="headerlink" title="输出字段说明"></a>输出字段说明</h2><p>top 界面顶部和进程列表分别包含系统摘要和具体进程信息：</p><h3 id="系统摘要"><a href="#系统摘要" class="headerlink" title="系统摘要"></a>系统摘要</h3><p>uptime：系统已运行时间。<br>load average：系统负载（最近1、5、15分钟的平均值）。<br>tasks：任务总数及其状态（运行、睡眠、停止、僵尸等）。<br>%Cpu(s)：CPU 使用情况（用户、系统、空闲等）。<br>Mem 和 Swap：物理内存和交换分区的使用情况。<br>例如下面的信息：<br><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">top</span> - <span class="token number">15</span>:32:32 up <span class="token number">54</span> min,  <span class="token number">1</span> user,  load average: <span class="token number">0.11</span>, <span class="token number">0.09</span>, <span class="token number">0.06</span>Tasks:  <span class="token number">67</span> total,   <span class="token number">1</span> running,  <span class="token number">66</span> sleeping,   <span class="token number">0</span> stopped,   <span class="token number">0</span> zombie%Cpu<span class="token punctuation">(</span>s<span class="token punctuation">)</span>:  <span class="token number">0.3</span> us,  <span class="token number">0.3</span> sy,  <span class="token number">0.0</span> ni, <span class="token number">99.4</span> id,  <span class="token number">0.0</span> wa,  <span class="token number">0.0</span> hi,  <span class="token number">0.1</span> si,  <span class="token number">0.0</span> stMiB Mem <span class="token builtin class-name">:</span>   <span class="token number">7878.3</span> total,   <span class="token number">5671.9</span> free,   <span class="token number">1544.3</span> used,    <span class="token number">662.1</span> buff/cacheMiB Swap:   <span class="token number">2048.0</span> total,   <span class="token number">2048.0</span> free,      <span class="token number">0.0</span> used.   <span class="token number">6035.3</span> avail Mem<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>（1）系统信息<br><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">top</span> - <span class="token number">15</span>:32:32 up <span class="token number">54</span> min, <span class="token number">1</span> user, load average: <span class="token number">0.11</span>, <span class="token number">0.09</span>, <span class="token number">0.06</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></p><ul><li>当前时间：15:32:32 </li><li>系统运行时间：已经运行了 54 分钟。 </li><li>当前登录用户数：1 个用户。 </li><li>负载均值 (load average)：过去 1 分钟：0.11 ; 过去 5 分钟：0.09 ; &gt; 过去 15 分钟：0.06;</li></ul><p>解释：负载均值越低，系统压力越小；当前负载非常低。<br>（2）任务状态<br><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Tasks: <span class="token number">67</span> total, <span class="token number">1</span> running, <span class="token number">66</span> sleeping, <span class="token number">0</span> stopped, <span class="token number">0</span> zombie<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></p><ul><li>总任务数：67 个。 </li><li>运行中的任务：1 个任务处于运行状态。 </li><li>睡眠中的任务：66 个任务处于睡眠状态（等待事件触发）。 </li><li>停止的任务：0 个任务被停止。 </li><li>僵尸任务：0 个僵尸进程。 </li></ul><p>解释：系统大多数任务处于空闲或待机状态，负载轻。<br>（3）CPU使用率<br><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">%Cpu<span class="token punctuation">(</span>s<span class="token punctuation">)</span>: <span class="token number">0.3</span> us, <span class="token number">0.3</span> sy, <span class="token number">0.0</span> ni, <span class="token number">99.4</span> id, <span class="token number">0.0</span> wa, <span class="token number">0.0</span> hi, <span class="token number">0.1</span> si, <span class="token number">0.0</span> st<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></p><ul><li>us（用户空间）：0.3% 的 CPU 用于用户程序。</li><li>sy（系统空间）：0.3% 的 CPU 用于内核操作。</li><li>ni（优先级）：0.0% 的 CPU 用于调整进程优先级。</li><li>id（空闲）：99.4% 的 CPU 处于空闲状态。</li><li>wa（IO等待）：0.0% 的 CPU 等待 IO 操作完成。</li><li>hi（硬中断）：0.0% 的 CPU 用于硬件中断处理。</li><li>si（软中断）：0.1% 的 CPU 用于软件中断处理。</li><li>st（虚拟化偷取时间）：0.0% 的 CPU 被虚拟机占用。</li></ul><p>解释：CPU 使用率非常低，系统大部分时间处于空闲状态。<br>（4）内存使用<br><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">MiB Mem <span class="token builtin class-name">:</span> <span class="token number">7878.3</span> total, <span class="token number">5671.9</span> free, <span class="token number">1544.3</span> used, <span class="token number">662.1</span> buff/cache<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></p><ul><li>总内存：7878.3 MiB。</li><li>空闲内存：5671.9 MiB，约 72% 的内存空闲。</li><li>已用内存：1544.3 MiB，约 19% 的内存正在被使用。</li><li>缓存/缓冲区：662.1 MiB，被系统缓存使用的内存。</li></ul><p>解释：内存利用率较低，系统内存资源充足。</p><p>（5）交换分区 (Swap) 使用<br><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">MiB Swap: <span class="token number">2048.0</span> total, <span class="token number">2048.0</span> free, <span class="token number">0.0</span> used. <span class="token number">6035.3</span> avail Mem<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></p><ul><li>总交换分区大小：2048.0 MiB。</li><li>空闲交换分区：2048.0 MiB。</li><li>已用交换分区：0.0 MiB。</li><li>可用内存：6035.3 MiB，包含物理空闲内存和缓冲内存。</li></ul><p>解释：系统没有使用交换分区，物理内存足以应对当前任务。<br>（6）总结<br>当前系统状态非常轻松：</p><ul><li>CPU 主要处于空闲状态（99.4%）。</li><li>内存和交换分区使用率低，资源充足。</li><li>系统负载非常低（负载均值远低于 1）。</li><li>没有僵尸进程或 IO 瓶颈。</li></ul><h3 id="进程信息"><a href="#进程信息" class="headerlink" title="进程信息"></a>进程信息</h3><p>PID：进程 ID。<br>USER：运行该进程的用户。<br>PR 和 NI：优先级和 nice 值。<br>VIRT、RES、SHR：虚拟内存、常驻内存和共享内存使用情况。<br>%CPU 和 %MEM：进程的 CPU 和内存使用率。<br>TIME+：进程累计使用 CPU 的时间。<br>COMMAND：运行的命令或进程名称。</p><h2 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h2><p>[<a href="https://tigercosmos.xyz/post/2020/04/unix/top-usage/">Unix/Linux TOP 指令使用详解</a>]<br>[<a href="https://www.cnblogs.com/peida/archive/2012/12/24/2831353.html">每天一个linux命令（44）：top命令</a>]<br>[<a href="https://manpages.ubuntu.com/manpages/oracular/en/man1/top.1.html">top manual</a>]</p>]]></content>
      
      
      <categories>
          
          <category> Linux基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>组合数学知识点概括</title>
      <link href="/2024/12/24/zu-he-shu-xue-zhi-shi-dian-gai-gua/"/>
      <url>/2024/12/24/zu-he-shu-xue-zhi-shi-dian-gai-gua/</url>
      
        <content type="html"><![CDATA[<h1 id="组合数学知识点概括"><a href="#组合数学知识点概括" class="headerlink" title="组合数学知识点概括"></a>组合数学知识点概括</h1><p>明天下午组合数学考试，整理一些知识点，课本是：组合数学(第5版)卢开澄卢华明编著</p><h2 id="第一章排列与组合"><a href="#第一章排列与组合" class="headerlink" title="第一章排列与组合"></a>第一章排列与组合</h2><p>允许重复的组合 P20</p><p><img src="https://s2.loli.net/2024/12/24/bKNise2JQUvVDq8.png" alt=""></p><p>线性方程组整数解个数 P21</p><p><img src="https://s2.loli.net/2024/12/24/MuFOdAf4bvs35St.png" alt=""></p><p>圆桌排列的公式，例题，下面的公式有误</p><p><img src="https://s2.loli.net/2024/12/24/lVPbg52KCoU9Wkx.png" alt=""></p><p>例题2</p><p><img src="https://s2.loli.net/2024/12/24/ElPqg9ISHNTGOzU.png" alt=""></p><p>字典序法，画树状图或者使用公式</p><p>数学归纳法证明题，例题</p><p><img src="https://s2.loli.net/2024/12/24/6hQwnyHCfJN9uze.png" alt=""></p><h2 id="第二章递推关系和母函数"><a href="#第二章递推关系和母函数" class="headerlink" title="第二章递推关系和母函数"></a>第二章递推关系和母函数</h2><p>这里题型和内容比较难，需要多做题，熟悉各种题型（给出已知无穷序列求母函数，已知母函数求递推关系或是求它的第一二项a0、a1，递推关系等号右边等于0，递推关系等号右边等于常数，递推关系等号右边等于几的n次方的形式）</p><p>母函数定义 P46</p><p><img src="https://s2.loli.net/2024/12/24/5HiGPRS1jbtm8ON.png" alt=""></p><p>使用的泰勒公式  P47</p><p><img src="https://s2.loli.net/2024/12/24/82Jd3olvnrkFb5V.png" alt=""></p><p>线性常系数齐次递推关系 P55</p><p><img src="https://s2.loli.net/2024/12/24/p2IcMR7eAPzGbuB.png" alt=""></p><p>三种：不同实数根、不同复数根、二重根</p><p>常系数非齐次递推关系 P62、 例题2-17，2-18 P65</p><p><img src="https://s2.loli.net/2024/12/24/bYihmWd26uZ7zO1.png" alt=""></p><p>第一第二类 Strling 公式 P102</p><p><img src="https://s2.loli.net/2024/12/24/yJcaG3PUobHuYRL.png" alt=""></p><p>常用性质：理解记忆（比如第六个性质的证明） P102</p><p><img src="https://s2.loli.net/2024/12/24/CAfZv9qdOaFBtSX.png" alt=""></p><p>上面第六个性质的证明</p><p><img src="https://s2.loli.net/2024/12/24/s9tfewF7ijkvqNR.png" alt=""></p><p>第二类Strling数满足的递推关系 P103</p><p><img src="https://s2.loli.net/2024/12/24/j3t9cNUKbRBanHg.png" alt=""></p><h2 id="第三章容斥原理和鸽巢原理"><a href="#第三章容斥原理和鸽巢原理" class="headerlink" title="第三章容斥原理和鸽巢原理"></a>第三章容斥原理和鸽巢原理</h2><p>容斥原理：韦恩图，<script type="math/tex">A_1, A_2, ...</script>将这些集合的绝对值写出来，交集也写出来，然后画图。被整除的数的数目的注意要留下最小公约数，比如10000能被4和6整除的数的数目：10000/(4<em>6/2)=833（向下取整，floor(10000/(4\</em>6/2))）.</p><p>例题：</p><p><img src="https://s2.loli.net/2024/12/24/wzy8lLpUXoMRWsB.png" alt=""></p><p>鸽巢原理：n+1只鸽子飞向n个鸽巢，一定存在两只鸽子飞向了同一个鸽巢。先划分好集合，可以按个位数、余数、奇偶数……</p><p>证明题很难，如：</p><p><img src="https://s2.loli.net/2024/12/24/fU7L53CTtDMZubE.png" alt="容斥原理证明题"></p><p>棋盘多项式和有限制条件的排列 P130</p><p><img src="https://s2.loli.net/2024/12/24/FfqoxTQbGR1WiDt.png" alt="棋盘多项式的三个公式"></p><p>一些可以手动推导的棋盘多项式 P130</p><p><img src="https://s2.loli.net/2024/12/24/wi4mStejdbYvu7X.png" alt=""></p><p>棋盘多项式的第四个公式：简化计算 P131</p><p><img src="https://s2.loli.net/2024/12/24/NMEPrcbtdZTjWSI.png" alt=""></p><p>有禁区的排列</p><p><img src="https://s2.loli.net/2024/12/24/O46Xbmswk9oayS8.png" alt=""></p><p>例如：<script type="math/tex">1+4x+4x^2+x^3</script>，方案数是：3!-4*2!+4*1!-0!=1种</p><h2 id="第四章Burnside引理和Poyla定理"><a href="#第四章Burnside引理和Poyla定理" class="headerlink" title="第四章Burnside引理和Poyla定理"></a>第四章Burnside引理和Poyla定理</h2><p>前面群和域的概念很难理解</p><p>Poyla定理 P186</p><p><img src="https://s2.loli.net/2024/12/24/pMyVdvoSO1Tfwzt.png" alt=""></p><p>例题，不好理解：</p><p><img src="https://s2.loli.net/2024/12/24/OMNQqZKPBIoearn.png" alt=""></p><h2 id="第五章区组设计"><a href="#第五章区组设计" class="headerlink" title="第五章区组设计"></a>第五章区组设计</h2><p>拉丁方与正交拉丁方，构建正交拉丁方的过程（写出加法和乘法三线表，注意取余操作） P205</p><p><img src="https://s2.loli.net/2024/12/24/tCsZLSEBrMya3qg.png" alt=""></p><p>BIBD，均匀不完全的区组设计，记住两个公式</p><p><img src="https://s2.loli.net/2024/12/24/8M93FiowOgcHrDY.png" alt=""></p><p>每个条件的首字母含义：</p><ol><li>b - <strong>Blocks（区组数）</strong>：区组的总数。</li><li>v - <strong>Varieties（处理数）</strong>：实验中的不同处理种类数目。</li><li>r - <strong>Repetition（重复次数）</strong>：每个处理在所有区组中的出现次数。</li><li>k - <strong>Keys（区组大小）</strong>：每个区组中分配的处理数量。</li><li>λ - <strong>Links（组合频率）</strong>：每对处理组合在区组中共同出现的次数。</li></ol><p>第一个公式代表元素出现的总和 </p><h2 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h2><p>[<a href="https://www.cnblogs.com/mooleetzi/p/11330256.html">组合数学常用公式总结</a>]</p><p>[<a href="https://github.com/allenmirac/StudyinDailyLife">组合数学(第5版)卢开澄卢华明编著</a>]</p><p>[<a href="https://github.com/allenmirac/StudyinDailyLife">组合数学课后习题及历年试题思路与答案</a>]</p>]]></content>
      
      
      <categories>
          
          <category> 组合数学知识点概括 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 组合数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>感知机</title>
      <link href="/2024/12/20/gan-zhi-ji/"/>
      <url>/2024/12/20/gan-zhi-ji/</url>
      
        <content type="html"><![CDATA[<h2 id="感知机"><a href="#感知机" class="headerlink" title="感知机"></a>感知机</h2><p>重新学习了下感知机的基础，自己实现了一遍代码，手算了下面的更新参数的过程，对感知机模型的了解更深入了。感知机学习的对偶形式还没有看完。</p><p>导师上次批评的基础是不是就是指这种，但是这种东西是否考虑的太深入了，不需要了解这么多内容，会用就可以，所以在犹豫是否像下面这样更新《统计学习方法》后续章节（整理要花好久的时间( •̀ ω •́ )✧）。论文任务依旧在压着(┬┬﹏┬┬)，还是继续快速看完书，论文也不能落下&lt;(￣︶￣)↗[GO!]</p><p>感知机学习是机器学习中的一种经典算法，用于线性可分数据的分类，是二分类的线性分类模型，输入时实例的特征向量，输出可以取+1 和 -1二值。</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>以下是一个简单的例子，帮助理解感知机学习的过程：</p><p>假设我们有一个二维平面上的数据集，分为两类：</p><ul><li>类别 +1 （正类）：点 (2,3) 和 (3,4)</li><li>类别 −1 （负类）：点 (1,1) 和 (2,1)</li></ul><p>目标是学习一个直线分类器，将这两类分开。感知机模型的假设形式为：</p><script type="math/tex; mode=display">y = \text{sign}(w_1x_1 + w_2x_2 + b)</script><p>其中：</p><ul><li><script type="math/tex">w_1, w_2</script> 是感知机的权重；</li><li><script type="math/tex">b</script> 是偏置；</li><li><script type="math/tex">{sign}(\cdot)</script> 是符号函数，用于确定分类。</li></ul><hr><h3 id="感知机学习步骤"><a href="#感知机学习步骤" class="headerlink" title="感知机学习步骤"></a><strong>感知机学习步骤</strong></h3><ol><li><p><strong>初始化参数</strong><br> 初始化<script type="math/tex">w_1 = 0, w_2 = 0, b = 0</script>。</p></li><li><p><strong>遍历样本并更新参数</strong><br> 对于每个样本 <script type="math/tex">(x_1, x_2)</script> 和其对应的标签 y，根据以下规则更新权重和偏置：</p><script type="math/tex; mode=display">w \leftarrow w + \eta y x</script><script type="math/tex; mode=display">b \leftarrow b + \eta y</script><p>其中，<script type="math/tex">\eta</script> 是学习率（假设<script type="math/tex">\eta = 1</script>）。</p></li><li><p><strong>循环更新直到分类正确</strong><br> 不断重复以上更新，直到所有样本分类正确。</p></li></ol><h3 id="第1轮更新"><a href="#第1轮更新" class="headerlink" title="第1轮更新"></a>第1轮更新</h3><p>初始参数：</p><script type="math/tex; mode=display">w_1 = 0, \; w_2 = 0, \; b = 0</script><p>遍历样本并逐一更新：</p><ol><li><p><strong>样本 (2,3),y=+1：</strong></p><p>分类错误，更新参数：</p><script type="math/tex; mode=display">w_1 = 0 + 1 \cdot 2 = 2, w_2 = 0 + 1 \cdot 3 = 3, b = 0 + 1 \cdot 1 = 1</script></li><li><p><strong>样本 (1,1),y=−1：</strong></p><p>z=2⋅1+3⋅1+1=6, y′=sign(6)=+1</p><p>预测错误，更新参数：</p><script type="math/tex; mode=display">w_1\leftarrow w_1 + \eta y x_1 = 2 + 1 \cdot (-1) \cdot 1 = 1</script><script type="math/tex; mode=display">w_2\leftarrow w_2 + \eta y x_2 = 3 + 1 \cdot (-1) \cdot 1 = 2</script><script type="math/tex; mode=display">b \leftarrow b + \eta y = 1 + 1 \cdot (-1) = 0</script><p>更新后参数为：</p><script type="math/tex; mode=display">w_1 = 1, \; w_2 = 2, \; b = 0</script></li><li><p><strong>样本 (3,4),y=+1(3, 4), y = +1：</strong></p><p>z=1⋅3+2⋅4+0=11, y′=sign(11)=+1</p><p>预测正确，无需更新。</p></li><li><p><strong>样本 (2,1),y=−1(2, 1), y = -1：</strong></p><p>z=1⋅2+2⋅1+0=4, y′=sign(4)=+1</p><p>预测错误，更新参数：</p><script type="math/tex; mode=display">w_1 \leftarrow w_1 + \eta y x_1 = 1 + 1 \cdot (-1) \cdot 2 = -1</script><script type="math/tex; mode=display">w_2 \leftarrow w_2 + \eta y x_2 = 2 + 1 \cdot (-1) \cdot 1 = 1</script><script type="math/tex; mode=display">b \leftarrow b + \eta y = 0 + 1 \cdot (-1) = -1</script><p>更新后参数为：</p><script type="math/tex; mode=display">w_1 = -1, \; w_2 = 1, \; b = -1</script></li></ol><hr><h3 id="第2轮遍历"><a href="#第2轮遍历" class="headerlink" title="第2轮遍历"></a><strong>第2轮遍历</strong></h3><ol><li><p><strong>样本 (2,3),y=+1(2, 3), y = +1：</strong></p><script type="math/tex; mode=display">z = -1 \cdot 2 + 1 \cdot 3 - 1 = 0, \quad y' = \text{sign}(0) = +1</script><p>预测正确，无需更新。</p></li><li><p><strong>样本 (1,1),y=−1(1, 1), y = -1：</strong></p><script type="math/tex; mode=display">z = -1 \cdot 1 + 1 \cdot 1 - 1 = -1, \quad y' = \text{sign}(-1) = -1</script><p>预测正确，无需更新。</p></li><li><p><strong>样本 (3,4),y=+1(3, 4), y = +1：</strong></p><script type="math/tex; mode=display">z = -1 \cdot 3 + 1 \cdot 4 - 1 = 0, \quad y' = \text{sign}(0) = +1</script><p>预测正确，无需更新。</p></li><li><p><strong>样本 (2,1),y=−1(2, 1), y = -1：</strong></p><script type="math/tex; mode=display">z = -1 \cdot 2 + 1 \cdot 1 - 1 = -2, \quad y' = \text{sign}(-2) = -1</script><p>预测正确，无需更新。</p></li></ol><p>在 <strong>默认情况下</strong>，当 z=0 时，约定 sign(0)=+1。</p><hr><h3 id="分类器收敛"><a href="#分类器收敛" class="headerlink" title="分类器收敛"></a><strong>分类器收敛</strong></h3><p>在第2轮遍历后，所有样本均分类正确，最终分类器参数为：</p><script type="math/tex; mode=display">w_1 = -1, \; w_2 = 1, \; b = -1</script><p><strong>最终分类器：</strong></p><script type="math/tex; mode=display">y = \text{sign}(-x_1 + x_2 - 1)</script><p>对应的分割线为：</p><script type="math/tex; mode=display">x_2 - x_1 - 1 = 0 \quad \text{或} \quad x_2 = x_1 + 1</script><h3 id="更新权重过程的理解"><a href="#更新权重过程的理解" class="headerlink" title="更新权重过程的理解"></a>更新权重过程的理解</h3><p>更新权重的过程实际上是将分类超平面向误分类点的一侧移动，以减少误分类样本的符号距离。具体来说：</p><ol><li><p><strong>误分类点的位置</strong>：</p><ul><li>对于一个误分类点，其符号距离 <script type="math/tex">y_i (\mathbf{w}^\top \mathbf{x}_i + b) \leq 0</script>。这意味着当前分类超平面无法正确划分该点（例如，正类点在超平面负侧，或负类点在超平面正侧）。</li></ul></li><li><p><strong>权重更新公式</strong>：</p><ul><li>更新公式为： <script type="math/tex">\mathbf{w} \leftarrow \mathbf{w} + \eta y_i \mathbf{x}_i</script> 其中，η\etaη 是学习率，<script type="math/tex">y_i</script>是标签，<script type="math/tex">\mathbf{x}_i</script> 是误分类样本的特征。</li></ul></li><li><p><strong>更新的直观含义</strong>：</p><ul><li>如果<script type="math/tex">y_i = 1</script>（正类点被误分类为负类），更新方向为正向移动<script type="math/tex">\mathbf{x}_i</script>，将超平面向该点靠近。</li><li>如果 <script type="math/tex">y_i = -1</script>（负类点被误分类为正类），更新方向为负向移动 <script type="math/tex">\mathbf{x}_i</script>，使超平面远离该点。</li></ul><p>这种调整使得误分类点在更新后更接近正确侧（即符号距离 <script type="math/tex">y_i (\mathbf{w}^\top \mathbf{x}_i + b)</script> 增大）。</p></li><li><p><strong>偏置的作用</strong>：</p><ul><li><p>偏置更新公式为：</p><script type="math/tex; mode=display">b \leftarrow b + \eta y_i</script><ul><li>这相当于平移超平面整体，而不改变其方向。</li><li>偏置调整确保误分类点在更新后更加贴近正确分类侧。</li></ul></li></ul></li><li><p><strong>整体效果</strong>：</p><ul><li>权重更新推动超平面朝向修正误分类点的方向移动。</li><li>通过逐步调整，最终的分类超平面会使误分类样本越来越少，直到所有样本正确分类（或达到停止条件）。</li></ul></li></ol><h3 id="学习策略损失函数"><a href="#学习策略损失函数" class="headerlink" title="学习策略损失函数"></a>学习策略损失函数</h3><p>在上面的例子中，并没有使用损失函数。在感知机学习中，损失函数的选择决定了学习策略的优化目标。感知机使用的是<strong>感知机损失函数</strong>，这是专为线性分类问题设计的一种简单损失函数。</p><p><strong>第一种损失函数</strong>：</p><p>感知机的损失函数为：</p><script type="math/tex; mode=display">L(w, b) = -\sum_{i \in \mathcal{M}} y_i \cdot (w^\top x_i + b)</script><p>其中：</p><ul><li>M是所有被分类错误的样本集合；</li><li><script type="math/tex">y_i</script>是样本 i 的真实标签；</li><li><script type="math/tex">w^\top x_i + b</script>是样本的预测得分。</li></ul><p><strong>关键点：</strong>只有分类错误的样本才会产生损失。</p><p><strong>第二种损失函数</strong>：</p><p>如果感知机的损失函数是所有误分类点到超平面 S的总距离，那么损失函数的形式会与几何距离相关。</p><h3 id="基于误分类点的总距离损失函数"><a href="#基于误分类点的总距离损失函数" class="headerlink" title="基于误分类点的总距离损失函数"></a><strong>基于误分类点的总距离损失函数</strong></h3><p>如果损失函数是误分类点到超平面的总距离，则可以写为：</p><script type="math/tex; mode=display">L(w, b) = \sum_{i \in \mathcal{M}} \frac{-y_i (w^\top x_i + b)}{\|w\|},</script><p>其中：</p><ul><li>M 是所有被误分类的样本集合；</li><li><script type="math/tex">y_i (w^\top x_i + b) \leq 0</script>表示样本 i 被误分类；</li><li>分子部分 <script type="math/tex">-y_i (w^\top x_i + b)</script>是点 <script type="math/tex">x_i</script> 到超平面的符号距离；</li><li>分母 <script type="math/tex">\|w\|</script> 使得距离规范化为几何距离。</li></ul><h3 id="最终代码实现"><a href="#最终代码实现" class="headerlink" title="最终代码实现"></a>最终代码实现</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token keyword">class</span> <span class="token class-name">PerceptronWithPerceptronLoss</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> input_dim<span class="token punctuation">,</span> learning_rate<span class="token operator">=</span><span class="token number">0.01</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>w <span class="token operator">=</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>randn<span class="token punctuation">(</span>input_dim<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">0.01</span> <span class="token comment"># 初始化随机权重</span>        self<span class="token punctuation">.</span>b <span class="token operator">=</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>randn<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">0.01</span> <span class="token comment"># 随机初始化偏置</span>        self<span class="token punctuation">.</span>lr <span class="token operator">=</span> <span class="token number">0.01</span>        <span class="token comment"># margin: 即使所有样本都被正确分类，也会进行少量训练迭代</span>    <span class="token comment"># 这种改动可以让模型在早期训练阶段对靠近分界面的样本进行优化</span>    <span class="token comment"># 提升模型的决策边界稳定性。</span>    <span class="token keyword">def</span> <span class="token function">compute_loss</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> X<span class="token punctuation">,</span> y<span class="token punctuation">,</span> margin<span class="token operator">=</span><span class="token number">1e-5</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        score <span class="token operator">=</span> y <span class="token operator">*</span> <span class="token punctuation">(</span>np<span class="token punctuation">.</span>dot<span class="token punctuation">(</span>X<span class="token punctuation">,</span> self<span class="token punctuation">.</span>w<span class="token punctuation">)</span><span class="token operator">+</span>self<span class="token punctuation">.</span>b<span class="token punctuation">)</span>        mask <span class="token operator">=</span> score <span class="token operator">&lt;=</span> margin        total_loss <span class="token operator">=</span> <span class="token operator">-</span>np<span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span>score<span class="token punctuation">[</span>mask<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> total_loss<span class="token punctuation">,</span> mask        <span class="token keyword">def</span> <span class="token function">update_parameters</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> X<span class="token punctuation">,</span> y<span class="token punctuation">,</span> mask<span class="token punctuation">)</span><span class="token punctuation">:</span>        misclassified_X <span class="token operator">=</span> X<span class="token punctuation">[</span>mask<span class="token punctuation">]</span>        misclassified_y <span class="token operator">=</span> y<span class="token punctuation">[</span>mask<span class="token punctuation">]</span>        self<span class="token punctuation">.</span>w <span class="token operator">+=</span> np<span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span>misclassified_y<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">]</span><span class="token operator">*</span>misclassified_X<span class="token punctuation">,</span> axis<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">*</span> self<span class="token punctuation">.</span>lr        self<span class="token punctuation">.</span>b <span class="token operator">+=</span> np<span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span>misclassified_y<span class="token punctuation">)</span><span class="token operator">*</span>self<span class="token punctuation">.</span>lr        <span class="token keyword">print</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>w<span class="token punctuation">,</span> self<span class="token punctuation">.</span>b<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">fit</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> X<span class="token punctuation">,</span> y<span class="token punctuation">,</span> epochs<span class="token operator">=</span><span class="token number">100</span><span class="token punctuation">,</span> tolerance<span class="token operator">=</span><span class="token number">1e-4</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        prev_loss <span class="token operator">=</span> <span class="token builtin">float</span><span class="token punctuation">(</span><span class="token string">'inf'</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> epoch <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>epochs<span class="token punctuation">)</span><span class="token punctuation">:</span>            loss<span class="token punctuation">,</span> mask <span class="token operator">=</span> self<span class="token punctuation">.</span>compute_loss<span class="token punctuation">(</span>X<span class="token punctuation">,</span> y<span class="token punctuation">)</span>            <span class="token keyword">if</span> loss <span class="token operator">&lt;</span> tolerance <span class="token keyword">or</span> <span class="token builtin">abs</span><span class="token punctuation">(</span>prev_loss <span class="token operator">-</span> loss<span class="token punctuation">)</span> <span class="token operator">&lt;</span> tolerance<span class="token punctuation">:</span>                <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f"Converged at epoch </span><span class="token interpolation"><span class="token punctuation">&#123;</span>epoch<span class="token punctuation">&#125;</span></span><span class="token string">"</span></span><span class="token punctuation">)</span>                <span class="token keyword">break</span>            self<span class="token punctuation">.</span>update_parameters<span class="token punctuation">(</span>X<span class="token punctuation">,</span> y<span class="token punctuation">,</span> mask<span class="token punctuation">)</span>            prev_loss <span class="token operator">=</span> loss            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f"Epoch </span><span class="token interpolation"><span class="token punctuation">&#123;</span>epoch<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">&#125;</span></span><span class="token string">, Loss </span><span class="token interpolation"><span class="token punctuation">&#123;</span>loss<span class="token punctuation">&#125;</span></span><span class="token string">"</span></span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">predict</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> X<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> np<span class="token punctuation">.</span>sign<span class="token punctuation">(</span>np<span class="token punctuation">.</span>dot<span class="token punctuation">(</span>X<span class="token punctuation">,</span> self<span class="token punctuation">.</span>w<span class="token punctuation">)</span><span class="token operator">+</span>self<span class="token punctuation">.</span>b<span class="token punctuation">)</span>    X <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>y <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>model <span class="token operator">=</span> PerceptronWithPerceptronLoss<span class="token punctuation">(</span>input_dim<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span> learning_rate<span class="token operator">=</span><span class="token number">0.01</span><span class="token punctuation">)</span>model<span class="token punctuation">.</span>fit<span class="token punctuation">(</span>X<span class="token punctuation">,</span> y<span class="token punctuation">,</span> epochs<span class="token operator">=</span><span class="token number">50</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Final weights:"</span><span class="token punctuation">,</span> model<span class="token punctuation">.</span>w<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Final bias:"</span><span class="token punctuation">,</span> model<span class="token punctuation">.</span>b<span class="token punctuation">)</span>predicts <span class="token operator">=</span> model<span class="token punctuation">.</span>predict<span class="token punctuation">(</span>X<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Predict:"</span><span class="token punctuation">,</span> predicts<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个实现对原始感知机算法做了一些改进，尤其是引入了 <strong>margin 参数</strong> 来优化模型训练。这可以在训练初期增强模型对靠近决策边界的样本的敏感性，使得模型收敛到更稳健的决策边界。以下是代码运行的关键点和解释：</p><hr><h4 id="关键点解析"><a href="#关键点解析" class="headerlink" title="关键点解析"></a><strong>关键点解析</strong></h4><h5 id="1-随机初始化权重和偏置"><a href="#1-随机初始化权重和偏置" class="headerlink" title="1. 随机初始化权重和偏置"></a>1. <strong>随机初始化权重和偏置</strong></h5><pre class="line-numbers language-python" data-language="python"><code class="language-python">self<span class="token punctuation">.</span>w <span class="token operator">=</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>randn<span class="token punctuation">(</span>input_dim<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">0.01</span>self<span class="token punctuation">.</span>b <span class="token operator">=</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>randn<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">0.01</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>权重 w 和偏置 b被随机初始化为较小值，通常服从标准正态分布再乘以 0.01。</li><li>这样的初始化避免了原始实现中全零初始化导致的梯度为零问题，同时确保初始状态具有足够的小扰动。</li></ul><hr><h5 id="2-加入-margin-参数"><a href="#2-加入-margin-参数" class="headerlink" title="2. 加入 margin 参数"></a>2. <strong>加入 margin 参数</strong></h5><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">compute_loss</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> X<span class="token punctuation">,</span> y<span class="token punctuation">,</span> margin<span class="token operator">=</span><span class="token number">1e-5</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    score <span class="token operator">=</span> y <span class="token operator">*</span> <span class="token punctuation">(</span>np<span class="token punctuation">.</span>dot<span class="token punctuation">(</span>X<span class="token punctuation">,</span> self<span class="token punctuation">.</span>w<span class="token punctuation">)</span> <span class="token operator">+</span> self<span class="token punctuation">.</span>b<span class="token punctuation">)</span> <span class="token comment"># 误分类之后才会出现负数的情况</span>    mask <span class="token operator">=</span> score <span class="token operator">&lt;=</span> margin <span class="token comment"># 表示误分类的位置</span>    total_loss <span class="token operator">=</span> <span class="token operator">-</span>np<span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span>score<span class="token punctuation">[</span>mask<span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> total_loss<span class="token punctuation">,</span> mask<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>作用：<ul><li>即使所有样本都被正确分类（score &gt; 0），margin 的存在确保决策边界仍然对靠近边界的样本进行优化。</li><li>这可以提升模型的泛化能力，使得决策边界更加稳健。</li></ul></li></ul><hr><h5 id="3-参数更新"><a href="#3-参数更新" class="headerlink" title="3. 参数更新"></a>3. <strong>参数更新</strong></h5><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">update_parameters</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> X<span class="token punctuation">,</span> y<span class="token punctuation">,</span> mask<span class="token punctuation">)</span><span class="token punctuation">:</span>    misclassified_X <span class="token operator">=</span> X<span class="token punctuation">[</span>mask<span class="token punctuation">]</span>    misclassified_y <span class="token operator">=</span> y<span class="token punctuation">[</span>mask<span class="token punctuation">]</span>    self<span class="token punctuation">.</span>w <span class="token operator">+=</span> np<span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span>misclassified_y<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">]</span> <span class="token operator">*</span> misclassified_X<span class="token punctuation">,</span> axis<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">*</span> self<span class="token punctuation">.</span>lr    self<span class="token punctuation">.</span>b <span class="token operator">+=</span> np<span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span>misclassified_y<span class="token punctuation">)</span> <span class="token operator">*</span> self<span class="token punctuation">.</span>lr<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>作用：</strong><ul><li>仅对误分类或边界附近的样本（由 maskmask 定义）进行权重和偏置更新，提升计算效率。</li><li>更新公式遵循感知机规则，即朝误分类样本方向调整决策边界。</li></ul></li></ul><hr><h5 id="4-训练收敛条件"><a href="#4-训练收敛条件" class="headerlink" title="4. 训练收敛条件"></a>4. <strong>训练收敛条件</strong></h5><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">if</span> loss <span class="token operator">&lt;</span> tolerance <span class="token keyword">or</span> <span class="token builtin">abs</span><span class="token punctuation">(</span>prev_loss <span class="token operator">-</span> loss<span class="token punctuation">)</span> <span class="token operator">&lt;</span> tolerance<span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f"Converged at epoch </span><span class="token interpolation"><span class="token punctuation">&#123;</span>epoch<span class="token punctuation">&#125;</span></span><span class="token string">"</span></span><span class="token punctuation">)</span>    <span class="token keyword">break</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>作用：<ul><li>当总损失 loss低于设定阈值 tolerance，或者当前损失和上一轮损失的变化幅度小于阈值时，认为模型已收敛。</li><li>这种方法可以防止训练陷入无限迭代。</li></ul></li></ul><hr><h5 id="5-预测"><a href="#5-预测" class="headerlink" title="5. 预测"></a>5. <strong>预测</strong></h5><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">predict</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> X<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">return</span> np<span class="token punctuation">.</span>sign<span class="token punctuation">(</span>np<span class="token punctuation">.</span>dot<span class="token punctuation">(</span>X<span class="token punctuation">,</span> self<span class="token punctuation">.</span>w<span class="token punctuation">)</span> <span class="token operator">+</span> self<span class="token punctuation">.</span>b<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>作用：<ul><li>根据当前权重和偏置计算每个样本的得分，并通过符号函数 sign(z) 将得分转换为类别标签。</li></ul></li></ul><hr><h4 id="运行结果分析"><a href="#运行结果分析" class="headerlink" title="运行结果分析"></a><strong>运行结果分析</strong></h4><ol><li><p><strong>初始权重和偏置：</strong> 随机初始化导致每次运行结果可能不同，但 margin 的引入确保即便初始值不同，最终模型的表现会较为稳健。</p></li><li><p><strong>训练过程：</strong></p><ul><li>输出的权重 w 和偏置 b 会逐渐调整，直到所有样本正确分类，或者靠近边界的样本满足 margin 要求。</li><li>如果所有样本早期就满足要求，训练过程可能会提前终止。</li></ul></li><li><p><strong>预测结果：</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">Predict<span class="token punctuation">:</span> <span class="token punctuation">[</span> <span class="token number">1.</span> <span class="token operator">-</span><span class="token number">1.</span>  <span class="token number">1.</span> <span class="token operator">-</span><span class="token number">1.</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>说明模型成功学习到数据的线性分割规则。</li></ul></li></ol><hr><h4 id="改进后的优点"><a href="#改进后的优点" class="headerlink" title="改进后的优点"></a><strong>改进后的优点</strong></h4><ul><li><strong>稳健性提升：</strong> margin 确保模型在早期对靠近决策边界的样本进行优化，增强了分界面的鲁棒性。</li><li><strong>防止陷入局部最优：</strong> 随机初始化避免权重和偏置均为零时模型无法更新的问题。</li><li><strong>高效性：</strong> 每次仅更新误分类样本，有效减少无关计算。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><ul><li><strong>每次随机初始化会导致训练结果不同，主要因为初始参数影响了优化路径和决策边界的位置。</strong></li><li><strong>可以通过固定随机种子、正则化、多次训练取平均等方法减小这种随机性。</strong></li><li>如果数据线性可分，不同的随机初始化只会影响最终分界面的具体位置，但所有分界面都能正确分类数据。如果数据不可线性分割，随机初始化的影响会更大，因此可以考虑正则化或改用其他方法。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Deep Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DL基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CPP 的this指针辨析</title>
      <link href="/2024/12/19/cpp-de-this-zhi-zhen-bian-xi/"/>
      <url>/2024/12/19/cpp-de-this-zhi-zhen-bian-xi/</url>
      
        <content type="html"><![CDATA[<h2 id="C-的-this-指针"><a href="#C-的-this-指针" class="headerlink" title="C++ 的 this 指针"></a>C++ 的 this 指针</h2><p>指针在这里面是非常难理解的东西，所以要根据例子，自己实践。<br>在你没有去具体了解之前，不要轻易下结论。<br>最近，看了《在山的那边》，又有一点新感悟( •̀ ω •́ )✧</p><h3 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h3><p>调用成员函数时，成员函数通过一个名为 this 的隐式参数来访问调用它的那个对象，用请求该函数的对象地址初始化 this ，this 的指向总是自己这个对象，所以 this 是一个常量指针</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Box<span class="token operator">*</span> <span class="token function">get_address</span><span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token comment">//得到this的地址</span><span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>Box<span class="token operator">*</span> <span class="token function">get_address</span><span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token comment">//得到this的地址</span><span class="token punctuation">&#123;</span>Box box<span class="token punctuation">;</span><span class="token keyword">this</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>box<span class="token punctuation">;</span> <span class="token comment">// error: lvalue required as left operand of assignment</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 C++ 中，<code>this</code> 指针是一个隐式传递给非静态成员函数的常量指针，用于指向调用该函数的对象。以下是对你的代码和 <code>this</code> 的特性总结：</p><h4 id="特性："><a href="#特性：" class="headerlink" title="特性："></a>特性：</h4><ol><li><strong><code>this</code> 是一个隐式指针</strong>：<ul><li>每个非静态成员函数都有一个隐式的 <code>this</code> 指针，用来访问调用该成员函数的对象。</li><li><code>this</code> 指针的类型为 <code>ClassName* const</code>，即常量指针，不能被修改。</li></ul></li><li><strong><code>this</code> 指针的用途</strong>：<ul><li>访问成员变量和成员函数。</li><li>返回对象自身的地址。</li><li>在需要对象指针的场景下传递 <code>this</code>。</li></ul></li><li><strong>静态成员函数中没有 <code>this</code> 指针</strong>：<ul><li>静态成员函数不与任何特定对象绑定，因此没有 <code>this</code> 指针。</li></ul></li></ol><hr><h4 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h4><ol><li><p><strong>正确的用法</strong>：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Box<span class="token operator">*</span> <span class="token function">get_address</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 返回当前对象的地址</span><span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>解释</strong>：</p><ul><li>函数中 <code>this</code> 指针指向调用该函数的对象。</li><li>返回 <code>this</code> 时即返回调用该函数的对象地址。</li><li>这是一个有效的用法。</li></ul></li><li><p><strong>错误的用法</strong>：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Box<span class="token operator">*</span> <span class="token function">get_address</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    Box box<span class="token punctuation">;</span>    <span class="token keyword">this</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>box<span class="token punctuation">;</span> <span class="token comment">// 错误: 赋值操作试图修改 `this`</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>错误原因</strong>：</p><ul><li><code>this</code> 是一个常量指针，不能被赋值。</li><li><code>this</code> 的作用是固定指向当前调用对象，任何试图修改 <code>this</code> 都会导致编译错误。</li></ul></li></ol><hr><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li><code>this</code> 指针的值是无法更改的，它始终指向当前对象。</li><li>如果需要返回一个新对象的地址，应该直接返回新对象的地址而不是试图修改 <code>this</code>。</li></ul><p>正确示例：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Box<span class="token operator">*</span> <span class="token function">create_new_box</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    Box<span class="token operator">*</span> box <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Box</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> box<span class="token punctuation">;</span> <span class="token comment">// 返回新对象的地址</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> c++基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>理解正则化来防止模型过拟合以及L1正则化的模拟过程</title>
      <link href="/2024/12/16/li-jie-zheng-ze-hua-lai-fang-zhi-mo-xing-guo-ni-he-yi-ji-l1-zheng-ze-hua-de-mo-ni-guo-cheng/"/>
      <url>/2024/12/16/li-jie-zheng-ze-hua-lai-fang-zhi-mo-xing-guo-ni-he-yi-ji-l1-zheng-ze-hua-de-mo-ni-guo-cheng/</url>
      
        <content type="html"><![CDATA[<h2 id="理解正则化来防止模型过拟合以及L1正则化的模拟过程"><a href="#理解正则化来防止模型过拟合以及L1正则化的模拟过程" class="headerlink" title="理解正则化来防止模型过拟合以及L1正则化的模拟过程"></a>理解正则化来防止模型过拟合以及L1正则化的模拟过程</h2><p>其实这个是第二次看了，重新在看另外一本书，《统计学习方法》。<br>迷茫，不知道看这些还有什么用，但是去看训练代码还是看不懂，到底怎么回事啊，不知道为什么要加那些模块，害(┬┬﹏┬┬)<br>快速过一遍这本书，然后回到论文上面来    &lt;(￣︶￣)↗[GO!]</p><h2 id="如何理解正则化来防止模型过拟合"><a href="#如何理解正则化来防止模型过拟合" class="headerlink" title="如何理解正则化来防止模型过拟合"></a>如何理解正则化来防止模型过拟合</h2><p>理解正则化如何防止模型过拟合，可以从以下几个方面进行分析：</p><h3 id="1-过拟合的概念"><a href="#1-过拟合的概念" class="headerlink" title="1. 过拟合的概念"></a>1. <strong>过拟合的概念</strong></h3><p>过拟合是指模型在训练数据上表现良好，但在未见的数据（测试数据）上表现不佳的现象。过拟合通常发生在模型过于复杂时，即模型具有过多的参数或者特征，使其能够“记住”训练数据中的噪声而不是学习到数据的真实模式。</p><h3 id="2-正则化的基本原理"><a href="#2-正则化的基本原理" class="headerlink" title="2. 正则化的基本原理"></a>2. <strong>正则化的基本原理</strong></h3><p>正则化通过在损失函数中加入惩罚项，来限制模型的复杂度。常见的正则化方法有L1（Lasso）和L2（Ridge）正则化，它们分别通过不同方式惩罚模型参数。</p><ul><li><p><strong>L1 正则化</strong>：增加模型参数绝对值的和作为惩罚项，促使一些参数为零，从而进行特征选择。这有助于去除不重要的特征，使模型更加简洁。</p></li><li><p><strong>L2 正则化</strong>：增加模型参数平方和作为惩罚项，鼓励模型参数的整体减小。这意味着即使模型使用了所有特征，参数的值也不会过大，从而减小对训练数据的敏感性。</p></li></ul><h3 id="3-通过增加惩罚项调整损失函数"><a href="#3-通过增加惩罚项调整损失函数" class="headerlink" title="3. 通过增加惩罚项调整损失函数"></a>3. <strong>通过增加惩罚项调整损失函数</strong></h3><p>在正则化的情况下，模型的损失函数通常被修改为：</p><script type="math/tex; mode=display">\text{Loss} = \text{Loss}_{\text{original}} + \lambda \cdot \text{Penalty}</script><p>其中，<script type="math/tex">\lambda</script>是正则化参数，用于控制惩罚项的强度。较大的<script type="math/tex">\lambda</script>值会增加惩罚，使得模型更加简单，从而降低过拟合的风险。</p><h3 id="4-效果和直观理解"><a href="#4-效果和直观理解" class="headerlink" title="4. 效果和直观理解"></a>4. <strong>效果和直观理解</strong></h3><ul><li><p><strong>模型复杂度</strong>：正则化相当于在优化过程中引入了对模型复杂度的约束，促使模型在选择特征和学习参数时更加谨慎。这种谨慎使得模型更有可能学习到更具代表性的特征，而不是训练数据中的偶然模式。</p></li><li><p><strong>泛化能力</strong>：通过正则化，模型的泛化能力得到提升，能更好地适应新的、未见的数据。这是因为正则化帮助模型更关注数据的整体结构，而非个别噪声或异常值。</p></li></ul><h3 id="5-调节与验证"><a href="#5-调节与验证" class="headerlink" title="5. 调节与验证"></a>5. <strong>调节与验证</strong></h3><p>正则化参数的选择至关重要。通过交叉验证等技术，可以找到最佳的<script type="math/tex">\lambda</script>值，使得模型在训练集和验证集上都能保持良好的性能，从而达到防止过拟合的效果。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>正则化通过惩罚模型复杂度，有效降低了模型对训练数据的过度拟合，使得模型在未见数据上表现更加稳健。理解这一过程有助于在实际建模中选择合适的正则化策略，优化模型的性能。</p><h2 id="L1正则化可以让模型参数的值为0的原因"><a href="#L1正则化可以让模型参数的值为0的原因" class="headerlink" title="L1正则化可以让模型参数的值为0的原因"></a>L1正则化可以让模型参数的值为0的原因</h2><p>L1正则化能够促使一些模型参数 <script type="math/tex">w_i</script> 的值为零的原理主要体现在其损失函数的优化过程中。以下是对这一原理的详细解释及示例。</p><h3 id="原理解释"><a href="#原理解释" class="headerlink" title="原理解释"></a>原理解释</h3><p>L1正则化通过在损失函数中加入参数的绝对值之和作为惩罚项，促使模型参数的某些值趋近于零。其损失函数形式为：</p><script type="math/tex; mode=display">\text{Loss} = \text{Loss}_{\text{original}} + \lambda \cdot \sum_{i=1}^{n} |w_i|</script><p>这里，<script type="math/tex">\lambda</script>是正则化强度的超参数，控制惩罚项的影响力。</p><ol><li><p><strong>绝对值的性质</strong>：绝对值函数在原点是不可导的，这意味着当优化算法（如梯度下降）试图更新参数 <script type="math/tex">w_i</script> 时，某些参数可能会直接达到零。这种情况通常发生在参数的更新过程中，惩罚项使得某些参数的更新幅度减小到零。</p></li><li><p><strong>目标函数的几何形状</strong>：L1正则化的惩罚项形成的等高线是菱形（或正方形），与损失函数的等高线相交时，往往会在坐标轴上接触，这意味着模型的某些参数将被推至零。这是因为在最优化过程中，绝对值函数的“尖角”会导致某些参数在最优解处为零。</p></li><li><p><strong>凸优化的效果</strong>：L1正则化的目标函数是一个凸函数，优化时容易收敛到局部最优解，进而有可能出现部分参数被收缩到零的现象。</p></li></ol><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>以下是一个简单的例子，说明如何通过L1正则化促使参数为零。</p><h4 id="例子设定"><a href="#例子设定" class="headerlink" title="例子设定"></a>例子设定</h4><p>假设我们有一个线性回归模型，其模型形式为：</p><script type="math/tex; mode=display">y = w_1 x_1 + w_2 x_2 + b</script><p>我们用一个小的数据集来训练模型：</p><div class="table-container"><table><thead><tr><th><script type="math/tex">x_1</script></th><th><script type="math/tex">x_2</script></th><th><script type="math/tex">y</script></th></tr></thead><tbody><tr><td>1</td><td>2</td><td>3</td></tr><tr><td>2</td><td>3</td><td>5</td></tr><tr><td>3</td><td>4</td><td>7</td></tr><tr><td>4</td><td>5</td><td>9</td></tr><tr><td>5</td><td>6</td><td>11</td></tr></tbody></table></div><h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><ol><li><p><strong>损失函数</strong>：</p><ul><li>原始损失函数（均方误差）为：</li></ul><script type="math/tex; mode=display">\text{Loss}_{\text{original}} = \frac{1}{n} \sum (y_i - (w_1 x_{1,i} + w_2 x_{2,i} + b))^2</script></li><li><p><strong>加入L1正则化</strong>：</p><ul><li>假设我们设置 <script type="math/tex">\lambda = 0.1</script>，那么加入L1正则化后的损失函数为：</li></ul><script type="math/tex; mode=display">\text{Loss} = \frac{1}{n} \sum (y_i - (w_1 x_{1,i} + w_2 x_{2,i} + b))^2 + 0.1 (|w_1| + |w_2|)</script></li><li><p><strong>训练过程</strong>：</p><ul><li>在使用梯度下降等优化算法进行训练时，更新参数 <script type="math/tex">w_1</script> 和 <script type="math/tex">w_2</script> 的步骤包括计算原始损失的梯度和L1惩罚的梯度。</li><li>由于L1正则化的特性，当优化算法调整 <script type="math/tex">w_1</script> 和 <script type="math/tex">w_2</script> 时，某些参数的值可能会被推到零。例如，如果 <script type="math/tex">w_1</script> 的影响相对较小，优化过程中可能会发现保持<script type="math/tex">w_1 = 0</script> 能够显著降低损失。</li></ul></li></ol><h4 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h4><p>经过多次迭代，最终可能得到  <script type="math/tex">w_1 = 0</script> 和<script type="math/tex">w_2 = 2</script>，这意味着在这个特定的训练中，特征 <script type="math/tex">x_1</script> 对目标变量 <script type="math/tex">y</script> 的预测并没有显著贡献，模型将其完全忽略。</p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>L1正则化通过惩罚参数的绝对值，促使某些参数的值为零，这主要源于其损失函数的几何特性和优化过程中的特性。通过训练，模型能够自动选择对预测最有用的特征，从而提高其在未见数据上的泛化能力。</p><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> plt<span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>linear_model <span class="token keyword">import</span> Lasso<span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>linear_model <span class="token keyword">import</span> LinearRegression<span class="token comment"># 生成数据</span>np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>seed<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>X <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>y <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment"># 定义L1正则化强度</span>lambda_l1 <span class="token operator">=</span> <span class="token number">0.1</span><span class="token comment"># 绘制损失函数的等高线</span><span class="token keyword">def</span> <span class="token function">plot_contours</span><span class="token punctuation">(</span>lambdas<span class="token punctuation">)</span><span class="token punctuation">:</span>    w1_range <span class="token operator">=</span> np<span class="token punctuation">.</span>linspace<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span>    w2_range <span class="token operator">=</span> np<span class="token punctuation">.</span>linspace<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span>    W1<span class="token punctuation">,</span> W2 <span class="token operator">=</span> np<span class="token punctuation">.</span>meshgrid<span class="token punctuation">(</span>w1_range<span class="token punctuation">,</span> w2_range<span class="token punctuation">)</span>    <span class="token comment"># 计算损失值</span>    loss <span class="token operator">=</span> np<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span>W1<span class="token punctuation">.</span>shape<span class="token punctuation">)</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>X<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        loss <span class="token operator">+=</span> <span class="token punctuation">(</span>y<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token punctuation">(</span>W1 <span class="token operator">*</span> X<span class="token punctuation">[</span>i<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+</span> W2 <span class="token operator">*</span> X<span class="token punctuation">[</span>i<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">**</span> <span class="token number">2</span>    loss <span class="token operator">=</span> loss <span class="token operator">/</span> <span class="token builtin">len</span><span class="token punctuation">(</span>X<span class="token punctuation">)</span> <span class="token operator">+</span> lambdas <span class="token operator">*</span> <span class="token punctuation">(</span>np<span class="token punctuation">.</span><span class="token builtin">abs</span><span class="token punctuation">(</span>W1<span class="token punctuation">)</span> <span class="token operator">+</span> np<span class="token punctuation">.</span><span class="token builtin">abs</span><span class="token punctuation">(</span>W2<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># 添加L1惩罚</span>    plt<span class="token punctuation">.</span>figure<span class="token punctuation">(</span>figsize<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    contour <span class="token operator">=</span> plt<span class="token punctuation">.</span>contour<span class="token punctuation">(</span>W1<span class="token punctuation">,</span> W2<span class="token punctuation">,</span> loss<span class="token punctuation">,</span> levels<span class="token operator">=</span>np<span class="token punctuation">.</span>logspace<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">,</span> cmap<span class="token operator">=</span><span class="token string">'viridis'</span><span class="token punctuation">)</span>    plt<span class="token punctuation">.</span>clabel<span class="token punctuation">(</span>contour<span class="token punctuation">,</span> inline<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span> fontsize<span class="token operator">=</span><span class="token number">8</span><span class="token punctuation">)</span>    plt<span class="token punctuation">.</span>title<span class="token punctuation">(</span><span class="token string">'Loss Contours with L1 Regularization'</span><span class="token punctuation">)</span>    plt<span class="token punctuation">.</span>xlabel<span class="token punctuation">(</span><span class="token string">'w1'</span><span class="token punctuation">)</span>    plt<span class="token punctuation">.</span>ylabel<span class="token punctuation">(</span><span class="token string">'w2'</span><span class="token punctuation">)</span>    <span class="token comment"># 绘制L1惩罚的约束</span>    plt<span class="token punctuation">.</span>plot<span class="token punctuation">(</span><span class="token punctuation">[</span>lambda_l1<span class="token punctuation">,</span> <span class="token operator">-</span>lambda_l1<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">'r--'</span><span class="token punctuation">,</span> label<span class="token operator">=</span><span class="token string">'L1 constraint'</span><span class="token punctuation">)</span>    plt<span class="token punctuation">.</span>plot<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>lambda_l1<span class="token punctuation">,</span> <span class="token operator">-</span>lambda_l1<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">'r--'</span><span class="token punctuation">)</span>    plt<span class="token punctuation">.</span>fill_betweenx<span class="token punctuation">(</span>np<span class="token punctuation">.</span>linspace<span class="token punctuation">(</span><span class="token operator">-</span>lambda_l1<span class="token punctuation">,</span> lambda_l1<span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">-</span>lambda_l1<span class="token punctuation">,</span> lambda_l1<span class="token punctuation">,</span> alpha<span class="token operator">=</span><span class="token number">0.1</span><span class="token punctuation">,</span> color<span class="token operator">=</span><span class="token string">'red'</span><span class="token punctuation">)</span>    plt<span class="token punctuation">.</span>xlim<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span>    plt<span class="token punctuation">.</span>ylim<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span>    plt<span class="token punctuation">.</span>axhline<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> color<span class="token operator">=</span><span class="token string">'black'</span><span class="token punctuation">,</span> lw<span class="token operator">=</span><span class="token number">0.5</span><span class="token punctuation">)</span>    plt<span class="token punctuation">.</span>axvline<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> color<span class="token operator">=</span><span class="token string">'black'</span><span class="token punctuation">,</span> lw<span class="token operator">=</span><span class="token number">0.5</span><span class="token punctuation">)</span>    plt<span class="token punctuation">.</span>legend<span class="token punctuation">(</span><span class="token punctuation">)</span>    plt<span class="token punctuation">.</span>grid<span class="token punctuation">(</span><span class="token punctuation">)</span>    plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment"># 训练线性回归模型</span>model <span class="token operator">=</span> LinearRegression<span class="token punctuation">(</span><span class="token punctuation">)</span>model<span class="token punctuation">.</span>fit<span class="token punctuation">(</span>X<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f'Linear Regression Coefficients: </span><span class="token interpolation"><span class="token punctuation">&#123;</span>model<span class="token punctuation">.</span>coef_<span class="token punctuation">&#125;</span></span><span class="token string">'</span></span><span class="token punctuation">)</span><span class="token comment"># 训练L1正则化的模型</span>lasso_model <span class="token operator">=</span> Lasso<span class="token punctuation">(</span>alpha<span class="token operator">=</span>lambda_l1<span class="token punctuation">)</span>lasso_model<span class="token punctuation">.</span>fit<span class="token punctuation">(</span>X<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f'L1 Regularization Coefficients: </span><span class="token interpolation"><span class="token punctuation">&#123;</span>lasso_model<span class="token punctuation">.</span>coef_<span class="token punctuation">&#125;</span></span><span class="token string">'</span></span><span class="token punctuation">)</span><span class="token comment"># 绘制等高线</span>plot_contours<span class="token punctuation">(</span>lambda_l1<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Output</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Linear Regression Coefficients: <span class="token punctuation">[</span><span class="token number">1</span>. <span class="token number">1</span>.<span class="token punctuation">]</span>L1 Regularization Coefficients: <span class="token punctuation">[</span><span class="token number">1</span>.9500000e+00 <span class="token number">8</span>.8817842e-17<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这个输出的含义是，经过 <strong>L1 正则化</strong>（Lasso 回归）后，模型的回归系数为：</p><ul><li><strong><code>1.9500000e+00</code></strong>：第一个特征 <script type="math/tex">x_1</script> 的回归系数大约为 <strong>1.95</strong>，表示这个特征对预测目标 <script type="math/tex">y</script> 有较大的影响。</li><li><strong><code>8.8817842e-17</code></strong>：第二个特征 <script type="math/tex">x_2</script> 的回归系数非常接近于 <strong>0</strong>，这个值可以被认为是数值精度误差。实际上，L1 正则化已经将该特征的系数压缩为 <strong>0</strong>，表明 <script type="math/tex">x_2</script> 对目标值 <script type="math/tex">y</script> 几乎没有影响，模型忽略了这个特征。</li></ul><hr><h4 id="为什么第二个系数接近于-0？"><a href="#为什么第二个系数接近于-0？" class="headerlink" title="为什么第二个系数接近于 0？"></a>为什么第二个系数接近于 0？</h4><p>这正是 <strong>L1 正则化</strong> 的作用！</p><ul><li>L1 正则化通过在损失函数中添加 <script type="math/tex">\lambda \sum |w_i|</script> 惩罚项，鼓励不重要的特征权重 <script type="math/tex">w</script> 接近 0 或直接为 0。</li><li>在这个例子中，模型通过正则化发现 <script type="math/tex">x_2</script> 对预测目标 <script type="math/tex">y</script> 的影响较小，因此将其系数 <script type="math/tex">w_2</script>压缩到接近 0。</li></ul><hr><h4 id="数值解释"><a href="#数值解释" class="headerlink" title="数值解释"></a>数值解释</h4><ol><li><p><strong><code>1.9500000e+00</code></strong>：</p><ul><li>指数形式表示 <script type="math/tex">1.95 \times 10^0 = 1.95</script>，说明 <script type="math/tex">w_1</script> 是接近 1.95 的非零值。</li></ul></li><li><p><strong><code>8.8817842e-17</code></strong>：</p><ul><li>指数形式表示 <script type="math/tex">8.88 \times 10^{-17}</script>，非常接近 0，是计算中的浮点数误差。</li><li>实际意义上，它等价于 0，表示模型已经剔除了该特征。</li></ul></li></ol><hr><h4 id="正则化的效果"><a href="#正则化的效果" class="headerlink" title="正则化的效果"></a>正则化的效果</h4><ul><li><p><strong>普通线性回归</strong>：<br>不进行正则化的情况下，两个特征可能都会得到较大的非零系数。例如：</p><pre class="line-numbers language-none"><code class="language-none">Linear Regression Coefficients: [1. 1.]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>表示两个特征对 <script type="math/tex">y</script> 的贡献相等。</p></li><li><p><strong>L1 正则化（Lasso）</strong>：<br>在 L1 正则化下，模型会自动选择对目标值影响大的特征，而忽略其他不重要的特征，可能得到：</p><pre class="line-numbers language-none"><code class="language-none">L1 Regularization Coefficients: [1.95 0.]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>表示 <script type="math/tex">x_2</script> 对 <script type="math/tex">y</script> 几乎没有贡献，被压缩为 0。</p></li></ul><hr><h4 id="模型解释"><a href="#模型解释" class="headerlink" title="模型解释"></a>模型解释</h4><p>最终，带 L1 正则化的模型公式可以写为：</p><script type="math/tex; mode=display">y = 1.95 \cdot x_1 + 0 \cdot x_2</script><p>这说明模型完全依赖 <script type="math/tex">x_1</script> 来预测 <script type="math/tex">y</script>，从而实现了特征选择和模型的简化.</p>]]></content>
      
      
      <categories>
          
          <category> Deep Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++内存布局以及常用关键字</title>
      <link href="/2024/12/05/c-nei-cun-bu-ju-yi-ji-chang-yong-guan-jian-zi/"/>
      <url>/2024/12/05/c-nei-cun-bu-ju-yi-ji-chang-yong-guan-jian-zi/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="C-内存布局以及常用关键字"><a href="#C-内存布局以及常用关键字" class="headerlink" title="C++内存布局以及常用关键字"></a>C++内存布局以及常用关键字</h2><h2 id="C-的内存空间"><a href="#C-的内存空间" class="headerlink" title="C++的内存空间"></a>C++的内存空间</h2><p>代码存储区域：常量区、代码区、静态区（全局区）、堆区、栈区</p><p>栈区向下增长，堆区向上增长。<strong>栈由系统管理，没有内存碎片，每个元素之间都是连续的，大小比较小，8k，可以修改系统参数</strong>，堆区存储动态开辟的变量。</p><p>还有一个内核空间，但是它不与用户直接交互（内核区）。</p><p><img src="https://s2.loli.net/2024/12/05/ThemXq4PYIn5rDZ.png" alt="C++的内存空间"></p><h2 id="常用关键字"><a href="#常用关键字" class="headerlink" title="常用关键字"></a>常用关键字</h2><h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><p>修饰局部变量：局部变量的存储区域改变、变为静态区，生命周期改为程序结束才销毁。</p><p>修饰全局变量：全局变量只能在本文件中访问，不能在其它文件中访问， <strong>extern 外部声明</strong>也不可以。</p><p>修饰成员变量：静态成员变量不属于实体的类对象，要在类外初始化</p><p>修饰成员函数：静态函数<strong>属于类不属于类对象</strong> 需要通过类作用域调用 <strong>函数无this指针</strong>(静态成员函数仅能访问静态的数据成员，不能访问非静态的数据成员，也不能访问非静态的成员函数)</p><h3 id="define"><a href="#define" class="headerlink" title="#define"></a>#define</h3><p>带参数的宏定义可以减少函数调用的开销，在运行时只是简单的展开。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">SQUARE</span><span class="token expression"><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Square of a: "</span> <span class="token operator">&lt;&lt;</span> <span class="token function">SQUARE</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Square of a+1: "</span> <span class="token operator">&lt;&lt;</span> <span class="token function">SQUARE</span><span class="token punctuation">(</span>a <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>代码会被展开为：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Square of a: "</span> <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Square of a+1: "</span> <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>a <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>a <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>同样逻辑使用函数实现：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">inline</span> <span class="token keyword">int</span> <span class="token function">square</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> x <span class="token operator">*</span> x<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>虽然 <code>inline</code> 函数也可能避免函数调用开销，但其行为是在<strong>编译阶段</strong>由编译器决定；而宏定义是在<strong>预处理阶段</strong>直接展开。因此，宏展开比函数调用更加简单直接。</p><h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><p>申明一个常量，在编译期间可以进行类型检查，确保其值在程序运行期间不能被修改。</p><p>它还可以应用于指针、函数形参和成员函数等不同场景。</p><p><strong>基本用法示例</strong></p><ol><li><p><strong>定义常量</strong>：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">const</span> <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token comment">// 定义一个整型常量</span>a <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>           <span class="token comment">// 错误，尝试修改常量的值</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在编译阶段，如果试图修改 <code>a</code> 的值，会报错：<br><em>“assignment of read-only variable ‘a’”</em></p></li><li><p><strong>指针中的 <code>const</code></strong>： <code>const</code> 在指针上下文中非常灵活，具体含义取决于其位置（需要注意理解哦：</p><ul><li><p><strong>指针指向的值不可变</strong>：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">*</span> ptr <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">;</span> <span class="token comment">// 指针指向的内容是只读的</span><span class="token operator">*</span>ptr <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>           <span class="token comment">// 错误</span>ptr <span class="token operator">=</span> <span class="token operator">&amp;</span>b<span class="token punctuation">;</span>            <span class="token comment">// 正确，可以修改指针本身</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p><strong>指针本身不可变</strong>：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span><span class="token operator">*</span> <span class="token keyword">const</span> ptr <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">;</span> <span class="token comment">// 指针本身是常量，不能指向其他地址</span><span class="token operator">*</span>ptr <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>           <span class="token comment">// 正确</span>ptr <span class="token operator">=</span> <span class="token operator">&amp;</span>b<span class="token punctuation">;</span>            <span class="token comment">// 错误</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p><strong>值和指针均不可变</strong>：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">*</span> <span class="token keyword">const</span> ptr <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">;</span> <span class="token comment">// 值和指针都不可更改</span><span class="token operator">*</span>ptr <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>                <span class="token comment">// 错误</span>ptr <span class="token operator">=</span> <span class="token operator">&amp;</span>b<span class="token punctuation">;</span>                 <span class="token comment">// 错误</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul></li><li><p><strong>函数参数中的 <code>const</code></strong>：</p><ul><li><p><strong>传值参数</strong>： 如果函数参数是按值传递，<code>const</code> 修饰没有意义，因为传入的值本身就是副本，修改不会影响原始变量。</p></li><li><p><strong>传引用参数</strong>： 使用 <code>const</code> 修饰引用，可以保护原始数据：</p><pre class="line-numbers language-none"><code class="language-none">cpp复制代码void print(const std::string&amp; str) &#123;    &#x2F;&#x2F; str 是只读的    std::cout &lt;&lt; str &lt;&lt; std::endl;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>好处：</p><ul><li>避免拷贝，提高性能。</li><li>防止函数内部修改传入的数据。</li></ul></li></ul></li><li><p><strong>成员函数中的 <code>const</code></strong>： 当一个成员函数后面添加 <code>const</code> 修饰符时，表示该函数<strong>不会修改对象的任何成员变量</strong>：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">MyClass</span> <span class="token punctuation">&#123;</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">int</span> value<span class="token punctuation">;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> value<span class="token punctuation">;</span> <span class="token comment">// 只读操作</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果尝试在 <code>const</code> 成员函数中修改任何非 <code>mutable</code> 的成员变量，编译会报错。</p></li><li><p><strong><code>const</code> 和数组</strong>： 声明只读的数组：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">const</span> <span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token comment">// 数组的内容是只读的</span>arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>                 <span class="token comment">// 错误</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ol><h3 id="mutable"><a href="#mutable" class="headerlink" title="mutable"></a>mutable</h3><p>mutable为可变的，易变的跟C++中的const是反义词。被mutable修饰的变量(mutable智能用于修饰类的非静态数据成员)<strong>，将永远处于可变的状态</strong>, 即使在一个const函数中</p><p><strong><code>mutable</code> 的用法示例</strong></p><ol><li><strong>普通类的 <code>mutable</code> 成员</strong></li></ol><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span><span class="token keyword">class</span> <span class="token class-name">Logger</span> <span class="token punctuation">&#123;</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">mutable</span> <span class="token keyword">int</span> logCount<span class="token punctuation">;</span>  <span class="token comment">// 用于统计日志记录次数，可变</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Logger</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">logCount</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>        <span class="token keyword">void</span> <span class="token function">logMessage</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span> message<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span>        <span class="token operator">++</span>logCount<span class="token punctuation">;</span>  <span class="token comment">// 即使在 const 函数中，也允许修改</span>        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Log: "</span> <span class="token operator">&lt;&lt;</span> message <span class="token operator">&lt;&lt;</span> <span class="token string">" (Log #"</span> <span class="token operator">&lt;&lt;</span> logCount <span class="token operator">&lt;&lt;</span> <span class="token string">")\n"</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">const</span> Logger logger<span class="token punctuation">;</span>  <span class="token comment">// 声明一个 const对象</span>    logger<span class="token punctuation">.</span><span class="token function">logMessage</span><span class="token punctuation">(</span><span class="token string">"Program started"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 依然可以修改logCount</span>    logger<span class="token punctuation">.</span><span class="token function">logMessage</span><span class="token punctuation">(</span><span class="token string">"Processing data"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>输出</strong>：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Log: Program started <span class="token punctuation">(</span>Log <span class="token comment">#1)</span>Log: Processing data <span class="token punctuation">(</span>Log <span class="token comment">#2)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在上面的例子中：</p><ul><li>类的 <code>logCount</code> 成员变量是用 <code>mutable</code> 修饰的。</li><li>即使 <code>Logger</code> 对象是 <code>const</code>，<code>logCount</code> 仍然可以在 <code>logMessage</code> 函数中被修改。</li></ul><hr><ol><li><strong>在 <code>const</code> 对象中的 <code>mutable</code> 使用</strong></li></ol><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">class</span> <span class="token class-name">MyClass</span> <span class="token punctuation">&#123;</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">mutable</span> <span class="token keyword">int</span> counter<span class="token punctuation">;</span>  <span class="token comment">// 可变成员</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">MyClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">counter</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    <span class="token keyword">void</span> <span class="token function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span>        <span class="token operator">++</span>counter<span class="token punctuation">;</span>  <span class="token comment">// 修改可变成员</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">int</span> <span class="token function">getCounter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> counter<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">const</span> MyClass obj<span class="token punctuation">;</span>  <span class="token comment">// 声明 const 对象</span>    obj<span class="token punctuation">.</span><span class="token function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 修改 mutable 成员</span>    obj<span class="token punctuation">.</span><span class="token function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Counter: "</span> <span class="token operator">&lt;&lt;</span> obj<span class="token punctuation">.</span><span class="token function">getCounter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>输出</strong>：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Counter: <span class="token number">2</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用 <code>mutable</code> 时应明确需求，通常用于辅助性的、不影响对象逻辑状态的数据成员。例如：</p><ul><li>缓存计算值。</li><li>日志或调试计数器。</li></ul><p><strong>与 <code>const_cast</code> 的对比</strong>：</p><ul><li><code>mutable</code> 是在类设计阶段明确指定的“可变性”。</li><li><code>const_cast</code> 是临时移除 <code>const</code> 限制，常用于特殊需求。</li></ul><h3 id="typedef"><a href="#typedef" class="headerlink" title="typedef"></a>typedef</h3><p>用途： 1、为名称复杂的变量创建别名； 2、创建与平台无关的变量，当跨平台时，只要改下 typedef 本身就行，不用对其他源码做任何修改。 另外，因为typedef是定义了一种类型的新别名，不是简单的字符串替换，所以它比宏来得稳健（虽然用宏有时也可以完成以上的用途）。 比如：<a href="https://en.cppreference.com/w/cpp/types/size_t">size_t的介绍</a></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 在vs中，short 2个字节，int 4个，long也是4个，long long 8个</span><span class="token keyword">typedef</span> <span class="token keyword">short</span> <span class="token keyword">int16_t</span><span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">int</span> <span class="token keyword">int32_t</span><span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">long</span> <span class="token keyword">long</span> <span class="token keyword">int64_t</span><span class="token punctuation">;</span><span class="token comment">// 在Linux下，short 2个，int 4 个，long 8个，long long 也是8个</span><span class="token keyword">typedef</span> <span class="token keyword">short</span> <span class="token keyword">int16_t</span><span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">int</span> <span class="token keyword">int32_t</span><span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">long</span> <span class="token keyword">int64_t</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>所以在程序源码中，只使用这些在头文件中声明的别名。 参考：<a href="https://www.cnblogs.com/Solomon-xm/articles/9140576.html">typedef用法详解</a></p><h2 id="总结与建议"><a href="#总结与建议" class="headerlink" title="总结与建议"></a>总结与建议</h2><ul><li><strong>内存管理</strong>：明确堆和栈的用途，动态内存需及时释放，避免内存泄漏。</li><li><strong>关键字使用</strong>：<ul><li>用 <code>static</code> 管理变量作用域和生命周期。</li><li>优先使用 <code>inline</code> 和 <code>constexpr</code> 替代宏定义。</li><li>用 <code>const</code> 提升代码的安全性和优化性能。</li><li>谨慎使用 <code>mutable</code>，仅在必要时放宽 <code>const</code> 限制。</li><li>用 <code>typedef</code> 或现代 <code>using</code> 提高类型定义的灵活性。</li></ul></li></ul><p>村上春树说：“跑步时我什么都不想，只是奔跑。跑步时我只感受跑步本身。”</p><p>编程时亦如此，专注写好每段代码，感受语言的精妙与力量。</p>]]></content>
      
      
      <categories>
          
          <category> c++基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++的智能指针</title>
      <link href="/2024/11/30/c-de-zhi-neng-zhi-zhen/"/>
      <url>/2024/11/30/c-de-zhi-neng-zhi-zhen/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="C-的智能指针"><a href="#C-的智能指针" class="headerlink" title="C++的智能指针"></a>C++的智能指针</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>C++STL（Standard Template Library）一共提供了四种指针：auto_ptr、unique_ptr、shared_ptr 和 weak_ptr，其中auto_ptr是c++98提供的，C++11 已将其摒弃，并提出了 unique_ptr 替代 auto_ptr。</p><h2 id="1、unique-ptr"><a href="#1、unique-ptr" class="headerlink" title="1、unique_ptr"></a>1、unique_ptr</h2><p>独占的指针，只可以自己使用，它指向的对象只可以他一个人使用，可以使用move将使用权转移，如：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;memory></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">auto</span> ptr1<span class="token operator">=</span><span class="token generic-function"><span class="token function">make_unique</span><span class="token generic class-name"><span class="token operator">&lt;</span>string<span class="token operator">></span></span></span> <span class="token punctuation">(</span><span class="token string">"12345"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cout<span class="token operator">&lt;&lt;</span><span class="token operator">*</span>ptr1<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    <span class="token keyword">auto</span> ptr2<span class="token operator">=</span>std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>ptr1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// cout&lt;&lt;*ptr1&lt;&lt;endl;</span>    cout<span class="token operator">&lt;&lt;</span><span class="token operator">*</span>ptr2<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 12345</span><span class="token comment">// 12345</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>创建智能指针的方法：通过构造函数指定、通过 reset 方法重新指定、通过 release 方法释放所有权、通过移动语义转移所有权（move），unique_ptr 还可能没有对象，这种情况被称为 empty。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#include &lt;iostream></span><span class="token comment">#include &lt;memory></span>using namespace std<span class="token punctuation">;</span>int <span class="token function-name function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    unique_ptr<span class="token operator">&lt;</span>int<span class="token operator">></span> p1<span class="token punctuation">;</span>    p1.reset<span class="token punctuation">(</span>new int<span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">))</span><span class="token punctuation">;</span>    cout<span class="token operator">&lt;&lt;</span>*p<span class="token operator"><span class="token file-descriptor important">1</span>&lt;</span><span class="token operator">&lt;</span>endl<span class="token punctuation">;</span>    unique_ptr<span class="token operator">&lt;</span>int<span class="token operator">></span> p2<span class="token punctuation">(</span>new int<span class="token punctuation">(</span><span class="token number">1234</span><span class="token punctuation">))</span><span class="token punctuation">;</span>    cout<span class="token operator">&lt;&lt;</span>*p<span class="token operator"><span class="token file-descriptor important">2</span>&lt;</span><span class="token operator">&lt;</span>endl<span class="token punctuation">;</span>    int *p3<span class="token operator">=</span>p1.release<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cout<span class="token operator">&lt;&lt;</span>*p<span class="token operator"><span class="token file-descriptor important">3</span>&lt;</span><span class="token operator">&lt;</span>endl<span class="token punctuation">;</span>    unique_ptr<span class="token operator">&lt;</span>int<span class="token operator">></span> <span class="token assign-left variable">p4</span><span class="token operator">=</span>move<span class="token punctuation">(</span>p2<span class="token punctuation">)</span><span class="token punctuation">;</span>    cout<span class="token operator">&lt;&lt;</span>*p<span class="token operator"><span class="token file-descriptor important">4</span>&lt;</span><span class="token operator">&lt;</span>endl<span class="token punctuation">;</span>    <span class="token builtin class-name">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>// <span class="token number">123</span>// <span class="token number">1234</span>// <span class="token number">123</span>// <span class="token number">1234</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2、auto-ptr"><a href="#2、auto-ptr" class="headerlink" title="2、auto_ptr"></a>2、auto_ptr</h2><h4 id="引入问题"><a href="#引入问题" class="headerlink" title="引入问题"></a>引入问题</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">auto_ptr<span class="token operator">&lt;</span> string<span class="token operator">></span> <span class="token function">p1</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">string</span> <span class="token punctuation">(</span><span class="token string">"string1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>auto_ptr<span class="token operator">&lt;</span>string<span class="token operator">></span> p2<span class="token punctuation">;</span>p2<span class="token operator">=</span>p1<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>如果上面的指针是普通的指针，那么就会面临一个问题，就是delete的时候会删除有两次，<strong>解决方案有多种：</strong></p><p>1、重载复制运算符，将其定义为深复制，这样他们俩就会指向不同的地方，缺点是会浪费空间。</p><p>2、建立所有全概念。将指针定义为只可以有一个对象拥有，赋值运算符直接将所有权转移。这就是用于 auto_ptr 和 unique_ptr 的策略，但 unique_ptr 的策略更严格。</p><p>3、创建智能更高的指针，跟踪引用特定对象的智能指针数。这称为引用计数。例如，赋值时，计数将加 1，而指针过期时，计数将减 1,。当减为 0 时才调用 delete。这是 shared_ptr 采用的策略。</p><h2 id="3、shared-ptr"><a href="#3、shared-ptr" class="headerlink" title="3、shared_ptr"></a>3、shared_ptr</h2><p>shared_ptr 是一个标准的共享所有权的智能指针，<strong>允许多个指针指向同一个对象</strong>，定义在 memory 文件中，命名空间为 std。shared_ptr 利用引用计数的方式实现了对所管理的对象的所有权的分享，即允许多个 shared_ptr 共同管理同一个对象。像 shared_ptr 这种智能指针，《Effective C++》称之为“引用计数型智能指针”（reference-counting smart pointer，RCSP）。</p><p>shared_ptr 是为了解决 auto_ptr 在对象所有权上的局限性（auto_ptr 是独占的），在使用引用计数的机制上提供了可以<strong>共享所有权的</strong>智能指针，当然这需要额外的开销： （1）shared_ptr 对象除了包括一个所拥有对象的指针外，还必须包括一个引用计数代理对象的指针； （2）时间上的开销主要在初始化和拷贝操作上， * 和 -&gt; 操作符重载的开销跟 auto_ptr 是一样； （3）开销并不是我们不使用 shared_ptr 的理由,，永远不要进行不成熟的优化，直到性能分析器告诉你这一点。</p><p>可以使用辅助类来实现该智能指针，它的<strong>具体做法</strong>如下： （a）当创建智能指针类的新对象时，初始化指针，<strong>并将引用计数设置为1；</strong> （b）当能智能指针类对象作为另一个对象的副本时，<strong>拷贝构造函数</strong>复制副本的指向辅助类对象的指针，并增加辅助类对象对基础类对象的引用计数（加1）； （c）使用赋值操作符对一个智能指针类对象进行赋值时，处理复杂一点：先使左操作数的引用计数减 1（为何减 1：因为指针已经指向别的地方），如果减1后引用计数为 0，则释放指针所指对象内存。然后增加右操作数所指对象的引用计数（为何增加：因为此时做操作数指向对象即右操作数指向对象）； （d）完成析构函数：调用析构函数时，析构函数先使引用计数减 1，如果减至 0 则 delete 对象。</p><h4 id="接口："><a href="#接口：" class="headerlink" title="接口："></a>接口：</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Point</span> <span class="token punctuation">&#123;</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">int</span> x<span class="token punctuation">,</span> y<span class="token punctuation">;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Point</span><span class="token punctuation">(</span><span class="token keyword">int</span> xVal <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">int</span> yVal <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">x</span><span class="token punctuation">(</span>xVal<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">y</span><span class="token punctuation">(</span>yVal<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    <span class="token keyword">int</span> <span class="token function">getX</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> x<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>    <span class="token keyword">int</span> <span class="token function">getY</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> y<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>    <span class="token keyword">void</span> <span class="token function">setX</span><span class="token punctuation">(</span><span class="token keyword">int</span> xVal<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> x <span class="token operator">=</span> xVal<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>    <span class="token keyword">void</span> <span class="token function">setY</span><span class="token punctuation">(</span><span class="token keyword">int</span> yVal<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> y <span class="token operator">=</span> yVal<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>实现：</strong> </p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">SmartPtr</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span><span class="token comment">//构造函数</span><span class="token function">SmartPtr</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> rp <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token function">SmartPtr</span><span class="token punctuation">(</span>Point <span class="token operator">*</span>ptr<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">rp</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">RefPtr</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token function">SmartPtr</span><span class="token punctuation">(</span><span class="token keyword">const</span> SmartPtr <span class="token operator">&amp;</span>sp<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">rp</span><span class="token punctuation">(</span>sp<span class="token punctuation">.</span>rp<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token operator">++</span>rp<span class="token operator">-></span>count<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"in copy constructor"</span> <span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 重载赋值运算符</span>SmartPtr<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> SmartPtr<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token operator">++</span>rhs<span class="token punctuation">.</span>rp<span class="token operator">-></span>count<span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>rp <span class="token operator">!=</span> <span class="token keyword">nullptr</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">--</span>rp<span class="token operator">-></span>count <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">delete</span> rp<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>rp <span class="token operator">=</span> rhs<span class="token punctuation">.</span>rp<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"in assignment operator"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 重载->操作符</span>Point<span class="token operator">*</span> <span class="token keyword">operator</span><span class="token operator">-></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> rp<span class="token operator">-></span>p<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 重载*操作符</span>Point<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token operator">*</span><span class="token punctuation">(</span>rp<span class="token operator">-></span>p<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token operator">~</span><span class="token function">SmartPtr</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">--</span>rp<span class="token operator">-></span>count <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">delete</span> rp<span class="token punctuation">;</span><span class="token keyword">else</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"还有"</span> <span class="token operator">&lt;&lt;</span> rp<span class="token operator">-></span>count <span class="token operator">&lt;&lt;</span> <span class="token string">"个指针指向基础对象"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">private</span><span class="token operator">:</span>RefPtr<span class="token operator">*</span> rp<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4、weak-ptr"><a href="#4、weak-ptr" class="headerlink" title="4、weak_ptr"></a>4、weak_ptr</h2><p>这个智能指针只能算是一个辅助类的指针，没有重载 operator<em> 和 operator-&gt; ，因此取名为 weak，表明其是功能较弱的智能指针。<em>*它的最大作用在于协助 shared_ptr 工作，可获得资源的观测权，像旁观者那样观测资源的使用情况。观察者意味着 weak_ptr 只对 shared_ptr 进行引用，而不改变其引用计数，当被观察的 shared_ptr 失效后，相应的 weak_ptr 也相应失效。</em></em></p><p>解决循环引用的问题，用法：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">weak_ptr<span class="token operator">&lt;</span>T<span class="token operator">></span> w<span class="token punctuation">;</span> <span class="token comment">//创建空 weak_ptr，可以指向类型为 T 的对象</span>weak_ptr<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">w</span><span class="token punctuation">(</span>sp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//与 shared_ptr 指向相同的对象，shared_ptr 引用计数不变。T必须能转换为 sp 指向的类型</span>w<span class="token operator">=</span>p<span class="token punctuation">;</span><span class="token comment">//p 可以是 shared_ptr 或 weak_ptr，赋值后 w 与 p 共享对象</span>w<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//将 w 置空</span>w<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//返回与 w 共享对象的 shared_ptr 的数量</span>w<span class="token punctuation">.</span><span class="token function">expired</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//若 w.use_count() 为 0，返回 true，否则返回 false</span>w<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//如果 expired() 为 true，返回一个空 shared_ptr，否则返回非空 shared_ptr</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>weak_ptr 对象引用资源时不会增加引用计数，但是它能够通过 lock() 方法来判断它所管理的资源是否被释放。</p><h2 id="5、share-from-this"><a href="#5、share-from-this" class="headerlink" title="5、share_from_this"></a>5、share_from_this</h2><h2 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h2><p><a href="https://blog.csdn.net/K346K346/article/details/81478223?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165743267316781432922953%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=165743267316781432922953&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-81478223-null-null.142%5Ev32%5Eexperiment_2_v1,185%5Ev2%5Econtrol&amp;utm_term=c%2B%2B%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88&amp;spm=1018.2226.3001.4187">C++ STL 四种智能指针_恋喵大鲤鱼的博客-CSDN博客_智能指针</a></p>]]></content>
      
      
      <categories>
          
          <category> c++进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>吴恩达机器学习</title>
      <link href="/2024/11/16/wu-en-da-ji-qi-xue-xi/"/>
      <url>/2024/11/16/wu-en-da-ji-qi-xue-xi/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="吴恩达机器学习"><a href="#吴恩达机器学习" class="headerlink" title="吴恩达机器学习"></a>吴恩达机器学习</h1><p>写的比较乱，对于一些不懂的问题都记录在下面了</p><p>一个人在不接触对方的情况下，通过一种特殊的方式，和对方进行一系列的问答．如果在相当长时间内，他无法根据这些问题判断对方是人还是计算机，那么就可以认为这个计算机是智能的．<br>                                                                                                                                                                                ——阿兰·图灵（Alan Turing）<br>                                                                                                                                                        《Computing Machinery and Intelligence 》</p><p><img src="https://s2.loli.net/2024/10/02/ypk341ajhPZQoCU.png" alt="人工智能发展史"></p><p>ps: 摘自 邱锡鹏，神经网络与深度学习，机械工业出版社，<a href="https://nndl.github.io/">https://nndl.github.io/</a>, 2020. P5</p><h2 id="代价函数"><a href="#代价函数" class="headerlink" title="代价函数"></a>代价函数</h2><p>cost function，所有样本误差的平均，与损失函数不同的地方是，loss function是定义在单个样本上的误差。</p><p>常用的是<font color=red>平方误差代价函数</font></p><p>这里解释什么是代价，代价就是预测值与实际值之间的差距，对于多个样本来说就是代价之和，但是对于怎么处理这个和，有一定的门道，需要解决<strong>正负值、数据量</strong>与cost之间的关系，最终才采取了下面的函数</p><p><img src="https://s2.loli.net/2024/09/15/UaRFvuoTnki7P9G.png" alt="代价函数"></p><p>其中平方项可以抵消误差值正负数带来的影响，m是样本量，建立了代价（cost）与样本量之间的关系；1/2是为了在对w,b求偏导（partial derivative）可以简化式子。</p><p><a href="https://www.cnblogs.com/geaozhang/p/11442343.html">https://www.cnblogs.com/geaozhang/p/11442343.html</a></p><h2 id="判断梯度下降是否收敛"><a href="#判断梯度下降是否收敛" class="headerlink" title="判断梯度下降是否收敛"></a>判断梯度下降是否收敛</h2><p>观察目标函数的损失函数值的变化情况，</p><ol><li>梯度的范数：当梯度的范数趋近于零时，可以认为算法已经收敛。设置一个阈值。</li><li>目标函数值的变化</li><li>迭代次数，设置最大迭代次数</li><li>收敛曲线图，看图说话</li></ol><h2 id="激活函数"><a href="#激活函数" class="headerlink" title="激活函数"></a>激活函数</h2><p>理解不了为什么要将输出变成非线性的，如何理解为什么需要激活函数？如果你串联几个线性变换，得到的最后依旧是一个线性变换，例如，f(x)=3x+1, g(x)=2x+2,串联这两个函数得到的是一个f(g(x))=6x+7，因此，如果在层之间没有一些非线性，那么即使是深层堆叠也等效于单层，你无法用它解决非常复杂的问题。相反，具有非线性激活的足够大的 DNN 在理论上可以逼近任何连续函数。（这种解释太帅啦，但是还是不能理解串联起来有什么用处，各个神经层次之间为什么需要串联以及串联和求导是什么关系）</p><ol><li>Sigmoid激活函数，也叫S形函数<br><img src="https://bkimg.cdn.bcebos.com/formula/c652f9ceaee0518a93007ca80c51c934.svg" alt="Sigmoid"></li><li><p>ReLu函数<br><img src="https://bkimg.cdn.bcebos.com/formula/061b8705cd0dd363c1752fe0d9db0faa.svg" alt="img"></p></li><li><p>Tanh函数<br><img src="https://bkimg.cdn.bcebos.com/formula/27dc16c40e8ca243c251fe1048fe68a9.svg" alt="img"></p></li></ol><p>Blog：<a href="https://www.cnblogs.com/XDU-Lakers/p/10557496.html">https://www.cnblogs.com/XDU-Lakers/p/10557496.html</a></p><h2 id="设置学习率"><a href="#设置学习率" class="headerlink" title="设置学习率"></a>设置学习率</h2><p>学习率Alpha，就是设置梯度下降的每一步的速率，不能过快也不能过慢</p><h2 id="逻辑回归"><a href="#逻辑回归" class="headerlink" title="逻辑回归"></a>逻辑回归</h2><p>没看懂</p><p>为了使反向传播正常工作，Rumelhart 和他的同事对 MLP 的架构进行了关键更改：他们用逻辑函数替换了阶跃函数，<em>σ</em>(<em>z</em>) = 1 / (1 + exp(–<em>z</em>))，也称为 S 形函数。</p><h2 id="反向传播的工作原理"><a href="#反向传播的工作原理" class="headerlink" title="反向传播的工作原理"></a>反向传播的工作原理</h2><p>在 1970 年，一位名叫 Seppo Linnainmaa 的研究人员在他的硕士论文中介绍了一种自动高效计算所有梯度的技术。这个算法现在被称为<em>反向模式自动微分</em>（或简称<em>反向模式自动微分</em>）。通过网络的两次遍历（<strong>一次前向，一次后向</strong>），它能够计算神经网络中每个模型参数的误差梯度。换句话说，它可以找出如何调整每个连接权重和每个偏差以减少神经网络的误差。然后可以使用这些梯度执行梯度下降步骤。如果重复这个自动计算梯度和梯度下降步骤的过程，神经网络的误差将逐渐下降，直到最终达到最小值。这种反向模式自动微分和梯度下降的组合现在被称为<font color=red><em>反向传播</em></font>（或简称<em>反向传播</em>）。</p><ul><li>它一次处理一个小批量（例如，每个包含 32 个实例），并多次遍历整个训练集。每次遍历称为<em>纪元</em>。</li><li>每个小批量通过输入层进入网络。然后，算法计算小批量中每个实例的第一个隐藏层中所有神经元的输出。结果传递到下一层，计算其输出并传递到下一层，依此类推，直到得到最后一层的输出，即输出层。这是<em>前向传递</em>：它与进行预测完全相同，只是所有中间结果都被保留，因为它们需要用于反向传递。</li><li>接下来，算法测量网络的输出误差（即，使用比较期望输出和网络实际输出的损失函数，并返回一些误差度量）。</li><li>然后计算每个输出偏差和每个连接到输出层的连接对误差的贡献。这是通过应用<em>链式法则</em>（可能是微积分中最基本的规则）进行分析的，使得这一步骤快速而精确。</li><li>然后，算法测量每个下一层中每个连接贡献的误差量，再次使用链式法则，向后工作直到达到输入层。正如前面解释的那样，这个反向传递有效地测量了网络中所有连接权重和偏差的误差梯度，通过网络向后传播误差梯度（因此算法的名称）。</li><li>最后，算法执行梯度下降步骤，调整网络中所有连接权重，使用刚刚计算的误差梯度。</li></ul><p>参考文章：<a href="https://www.cnblogs.com/apachecn/p/18006162">https://www.cnblogs.com/apachecn/p/18006162</a></p><h2 id="numpy-dot-versus-matmul"><a href="#numpy-dot-versus-matmul" class="headerlink" title="numpy dot versus matmul"></a>numpy dot versus matmul</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token comment"># Define two vectors for the dot product</span>vector_a <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span>vector_b <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment"># Calculate the dot product</span>dot_result <span class="token operator">=</span> np<span class="token punctuation">.</span>dot<span class="token punctuation">(</span>vector_a<span class="token punctuation">,</span> vector_b<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f"Dot Product: </span><span class="token interpolation"><span class="token punctuation">&#123;</span>dot_result<span class="token punctuation">&#125;</span></span><span class="token string">"</span></span><span class="token punctuation">)</span><span class="token comment"># Define two matrices for matrix multiplication</span>matrix_a <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>matrix_b <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment"># Perform matrix multiplication</span>matmul_result <span class="token operator">=</span> np<span class="token punctuation">.</span>matmul<span class="token punctuation">(</span>matrix_a<span class="token punctuation">,</span> matrix_b<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Matrix Multiplication:"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>matmul_result<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>result：</p><p>Dot Product: 41<br>Matrix Multiplication:<br>[[ 58  64]<br> [139 154]]</p><p>They serve different purposes and are used for distinct mathematical operations. <code>np.dot()</code> calculates the dot product between two arrays, whereas <code>np.matmul()</code> is specifically designed for matrix multiplication.</p><h2 id="正则化、偏差和方差"><a href="#正则化、偏差和方差" class="headerlink" title="正则化、偏差和方差"></a>正则化、偏差和方差</h2><p><strong>正则化系数的选择</strong></p><p>选择正则化系数λ 的值时也需要思考欠拟合和过拟合的问题。不知道如何理解正规化</p><p><img src="https://i.loli.net/2018/12/01/5c0270d201ec5.png" alt="选择正则化系数"></p><p>通常，我们选择一系列的想要测试的 λ 值，通常是 0-10 之间的呈现 2 倍关系的值（如：0,0.01,0.02,0.04,0.08,0.15,0.32,0.64,1.28,2.56,5.12,10 共 12 个）。 我们同样把数据分为训练集、交叉验证集和测试集。</p><p>之后利用公式（看不懂公式）：</p><p><img src="https://i.loli.net/2018/12/01/5c02716ba966d.png" alt="正则化"></p><p>来选择λ，步骤是：</p><ol><li>使用训练集训练12个不同程度的正则化的模型</li><li>用12个模型分别对交叉验证集计算出交叉验证误差，选择误差最小的模型</li></ol><p>得出的结果图：<a href="https://momodel.github.io/mlbook/09/09-5.html">https://momodel.github.io/mlbook/09/09-5.html</a></p><h2 id="处理倾斜数据集"><a href="#处理倾斜数据集" class="headerlink" title="处理倾斜数据集"></a>处理倾斜数据集</h2><p>数据不平衡，比如处理不合格产品，合格率位96.4%，如果每次预测结果都是合格，准确率就可以达到96.4%，显然这种做法是不对的。</p><p>可以采用混淆矩阵来处理这种分类问题，对于给定的类别， 精确度和召回率的不同组合可以给出不同的意义，还可以使用ROC曲线来预测。</p><p>高质量回答：<a href="https://towardsdatascience.com/handling-imbalanced-datasets-in-machine-learning-7a0e84220f28">https://towardsdatascience.com/handling-imbalanced-datasets-in-machine-learning-7a0e84220f28</a></p><h2 id="决策树"><a href="#决策树" class="headerlink" title="决策树"></a>决策树</h2><p>Decision Tree是一种解决分类问题的算法，监督学习主要有两种任务：分类（连续）、回归（离散）。</p><p>决策树算法采用树结构，层层推理来实现最终的分类。</p><p>决策树学习的三个步骤：特征选择、决策树生成、决策树剪枝（解决过拟合问题，随机森林很大程度减少过拟合）。</p><p>三种典型的决策树算法：ID3（采用信息增益）、C4.5（改进、采用信息增益比）、CART（采用基尼系数，<strong>CART树全称Classification And Regression Trees</strong>）</p><p><strong>关于信息增益的理解：</strong></p><p>熵：表示随机变量的不确定性</p><p>条件熵：在一个条件下、随机变量的不确定性能</p><p>信息增益：熵-条件熵，表示是在一个条件下，信息不确定性减少的程度。</p><p>详细解释：<a href="https://www.zhihu.com/question/22104055">https://www.zhihu.com/question/22104055</a></p><h2 id="One-Hot编码"><a href="#One-Hot编码" class="headerlink" title="One-Hot编码"></a>One-Hot编码</h2><p>独热编码，意思就是如果是相应编码位就是1，如果否相应编码位就是0，比如男女就可以用编码：01、10，再比如操作系统的采用位示图来表示磁盘中一个盘块的使用情况。</p><h2 id="回归树"><a href="#回归树" class="headerlink" title="回归树"></a>回归树</h2><p>构建方式的核心：切分方式与属性选择</p><p> 递归二分法</p><p><a href="https://www.showmeai.tech/article-detail/192">https://www.showmeai.tech/article-detail/192</a></p><h2 id="How-to-understand-clustering"><a href="#How-to-understand-clustering" class="headerlink" title="How to understand clustering"></a>How to understand clustering</h2><p>这是一种非监督学习的算法（与classification最大的区别），将不同性质的数据分成几个相同类型的数据，如何评定相同类型的数据，可以有下面这些标准：Euclidean distance, Cosine similarity, Manhattan distance, etc.</p><p>聚类算法的分类：</p><ol><li>Centroid-based Clustering (Partitioning methods)</li><li>Density-based Clustering (Model-based methods)</li><li>Connectivity-based Clustering (Hierarchical clustering)</li><li>Distribution-based Clustering</li></ol><p><a href="https://www.geeksforgeeks.org/clustering-in-machine-learning/#what-is-clustering-">Clustering in Machine Learning - GeeksforGeeks</a></p><h2 id="异常检测算法"><a href="#异常检测算法" class="headerlink" title="异常检测算法"></a>异常检测算法</h2><p>找到与数据集分布不一致的算法，离群点、异常值检测</p><p>一般针对无监督异常检测，因为异常点常常是没有标签的</p><p>无监督异常检测算法的思想：</p><p>1、基于聚类的算法</p><p>2、基于统计的算法</p><p>3、基于深度的方法</p><p>4、基于分类模型</p><p>5、基于偏差的方法</p><p>6、基于重构的算法</p><p>7、基于神经网络的算法</p><h2 id="丑小鸭定理"><a href="#丑小鸭定理" class="headerlink" title="丑小鸭定理"></a>丑小鸭定理</h2><p>丑小鸭定理（Ugly Duckling Theorem）是1969 年由渡边慧提出的[Watanabe,1969]．“丑小鸭与白天鹅之间的区别和两只白天鹅之间的区别一样大”．这个定理初看好像不符合常识，但是仔细思考后是非常有道理的．因为世界上不存在相似性的客观标准，一切相似性的标准都是主观的．如果从体型大小或外貌的角度来看，丑小鸭和白天鹅的区别大于两只白天鹅的区别；但是如果从基因的角度来看，丑小鸭与它父母的差别要小于它父母和其他白天鹅之间的差别．</p><p>这里的“丑小鸭”是指白天鹅的幼雏，而不是“丑陋的小鸭子”．渡边慧（1910～1993），美籍日本学者，理论物理学家，也是模式识别的最早研究者之一．</p><p>相似性的评定也需要主观标准，训练结果的相似性也要针对具体情况。</p><p>ps: 摘自 邱锡鹏，神经网络与深度学习，机械工业出版社，<a href="https://nndl.github.io/">https://nndl.github.io/</a>, 2020.</p><h2 id="超参数"><a href="#超参数" class="headerlink" title="超参数"></a>超参数</h2><p>超参数（Hyperparameter）是机器学习和深度学习中需要在训练模型之前设置的参数，而不是通过模型训练自动学习的参数。它们影响模型的训练过程和性能表现，通常需要通过实验和调优来选择最佳值。</p><p>超参数和模型参数的区别是：</p><ul><li><strong>模型参数</strong>：模型训练过程中从数据中学习得到的参数，例如线性回归中的权重或神经网络中的权重和偏置。</li><li><strong>超参数</strong>：在训练之前设定的参数，决定了模型的结构和训练过程，如学习率、批量大小（batch size）、隐藏层的数量等。</li></ul><p>常见的超参数包括：</p><ol><li><strong>学习率（Learning Rate）</strong>：控制每次更新模型参数的步长。</li><li><strong>批量大小（Batch Size）</strong>：每次更新模型时使用的样本数量。</li><li><strong>优化器类型（Optimizer）</strong>：用于更新模型参数的方法，如SGD、Adam等。</li><li><strong>正则化参数（Regularization Parameter）</strong>：控制模型复杂度的参数，用于防止过拟合。</li><li><strong>隐藏层数量和单元数量</strong>：对于神经网络，定义每层隐藏层的神经元数量和隐藏层的个数。</li></ol><p>调优超参数通常通过交叉验证或网格搜索等技术进行，以找到模型性能的最佳配置。</p><h2 id="梯度下降算法"><a href="#梯度下降算法" class="headerlink" title="梯度下降算法"></a>梯度下降算法</h2><p>在具体使用梯度下降法的过程中，主要有以下几种不同的变种，即：batch、mini-batch、Stochastic。其主要区别是不同的变形在训练数据的选择上。</p><p><strong>批量梯度下降法</strong>(Batch Gradient Descent)针对的是整个数据集，通过对所有的样本的计算来求解梯度的方向。在每次迭代时需要计算每个样本上损失函数的梯度并求和。当训练集中的样本数量𝑁 很大时，空间复杂度比较高，每次迭代的计算开销也很大。</p><p>mini-batch GD：在上述的批梯度的方式中每次迭代都要使用到所有的样本，对于数据量特别大的情况，如大规模的机器学习应用，每次迭代求解所有样本需要花费大量的计算成本。是否可以在每次的迭代过程中<strong>利用部分样本代替所有的样本</strong>呢？基于这样的思想，便出现了mini-batch的概念。</p><p>BGD和SGD的对比：<strong>批量梯度下降法</strong>相当于是从真实数据分布中采集𝑁 个样本，并由它们计算出来的经验风险的梯度来近似期望风险的梯度．为了减少每次迭代的计算复杂度，我们也可以在每次迭代时只采集一个样本，计算这个样本损失函数的梯度并更新参数，即<strong>随机梯度下降法</strong>。在<strong>非凸优化问题</strong>中，随机梯度下降更容易逃离局部最优点。</p><p>SGD也有一些缺点，比如可能会导致收敛不稳定和收敛速度较慢。因此，许多研究者和工程师会使用 SGD 的变种，如 <strong>动量（Momentum）</strong>、<strong>Nesterov 加速梯度（Nesterov Accelerated Gradient）</strong>、<strong>Adam</strong> 等优化器，来克服这些缺点。</p><p><strong>计算梯度的过程</strong>：在神经网络中，反向模式、前向模式都是都是应用链式法则的梯度累计方式，反向模式是更为有效的计算模式。在计算时，前向传播时会有一个计算图保存着所有操作节点的及其之间的关系，这样在反向传播计算梯度时（即调用backwrad函数），PyTorch 从损失函数（通常是计算图的最后一个节点）开始，沿着计算图向后遍历。在每个节点，PyTorch 会计算当前节点的输出对输入节点的导数（即梯度），并将这些梯度累加到每个输入的 <code>.grad</code> 属性中。</p><p>对于复合函数 <script type="math/tex">f(x; w,b)=\frac{1}{e^{-(wx+b)}+1}</script> 的计算图如下：</p><p><img src="https://s2.loli.net/2024/10/27/J5zfGqeyHURiSVo.png" alt="计算图"></p><p>参考：邱锡鹏，神经网络与深度学习，机械工业出版社，<a href="https://nndl.github.io/">https://nndl.github.io/</a>, 2020.</p><p>Blog：<a href="https://blog.csdn.net/cs24k1993/article/details/79120579">批梯度下降法(Batch Gradient Descent )，小批梯度下降 (Mini-Batch GD)，随机梯度下降 (Stochastic GD)</a>，里面有几张非常形象的图片</p><p><a href="https://paperswithcode.com/method/sgd-with-momentum">SGD with Momentum</a> 没看完</p><p><a href="https://blog.csdn.net/weixin_53765658/article/details/136668114">深度学习笔记:详解优化器之随机梯度下降（SGD）</a> 没看完</p><h2 id="非凸优化问题"><a href="#非凸优化问题" class="headerlink" title="非凸优化问题"></a>非凸优化问题</h2><p>在优化问题中，目标是找到使目标函数达到最小值或最大值的变量集。凸优化问题涉及的函数具有凸性质，即函数图像上的两点连线在函数图像的上方。这种情况下，局部最小值也是全局最小值，优化问题相对较为简单。然而，非凸优化问题涉及的函数图像可能出现上下凹凸，存在多个局部极小/大值，从而使问题变得复杂而有趣。</p><h2 id="神经网络的三个概念：Batch、Epoch、Iteration"><a href="#神经网络的三个概念：Batch、Epoch、Iteration" class="headerlink" title="神经网络的三个概念：Batch、Epoch、Iteration"></a>神经网络的三个概念：Batch、Epoch、Iteration</h2><p>Batch表示批次，Iteration表示迭代，Epoch表示一代</p><p>Batch：batch_size将影响到模型的优化程度，选择batch_size是为了在内存效率和内存容量之间进行权衡，</p><p>batch_size选择总结：过小，训练数据会难以收敛，从而导致underfitting；增大，相对处理速度加快，所需内存容量增加。所以需要权衡，找到一个合适的batch_size。</p><p>Epoch：是指将全部的样本（所以的batch）都完成一次forward+一次backward，通常情况下，一个epoch是不够的，在多个epoch后，模型的weight和bias会逐渐的更新，达到理想状态。  </p><p>Iteration：一个<code>iteration</code>包括了一个<code>step</code>中前向传播、损失计算、反向传播和参数更新的流程，有<code>batch_size</code>个iteration。</p><p>举个栗子：训练样本数量10000，batch_size=100，一共100个Batch，一个Batch有100个Iteration，一个Epoch有100个Barch的训练过程，但是在每个Batch都会去更新weight和bias。</p><p>参考：<a href="https://www.zhihu.com/question/43673341">https://www.zhihu.com/question/43673341</a></p><h2 id="梯度消失与梯度爆炸问题"><a href="#梯度消失与梯度爆炸问题" class="headerlink" title="梯度消失与梯度爆炸问题"></a>梯度消失与梯度爆炸问题</h2><h3 id="问题产生的原因"><a href="#问题产生的原因" class="headerlink" title="问题产生的原因"></a>问题产生的原因</h3><p>循环神经网络（Recurrent Neural Network，RNN）是一类具有短期记忆能力的神经网络．在循环神经网络中，神经元不但可以接受其他神经元的信息，也可以接受自身的信息，形成具有环路的网络结构。</p><p>在RNN中，梯度计算时需要沿时间步反向传播（BPTT，Backpropagation Through Time），这个算法即按照时间的逆序将梯度信息一步步地往前传递．当输入序列比较长时了，时间步展开导致的<strong>长链乘积</strong>会存在梯度爆炸和消失问题，也称为长程依赖问题。</p><p><img src="https://s2.loli.net/2024/11/06/53eNQXLIskyMFW6.png" alt="简单的前馈神经网络"></p><p>上图是一个简单的循环神经网络，只有一个隐藏层的神经网络，<script type="math/tex">𝒉_𝑡</script> 不仅和当前时刻的输入<script type="math/tex">𝒙_𝑡</script> 相关，也和上一个时刻的隐藏层状态<script type="math/tex">𝒉_{𝑡−1}</script>相关</p><p><img src="https://s2.loli.net/2024/11/06/tJHswL5PTy1G6Oi.png" alt="梯度消失与爆炸"></p><h3 id="分析步骤"><a href="#分析步骤" class="headerlink" title="分析步骤"></a>分析步骤</h3><p><img src="https://s2.loli.net/2024/11/06/THbBFXl3ghcQN5w.png" alt="分析步骤"></p><p>分析：</p><p>1、使用了一个4层的前馈神经网络来模拟展开的RNN。</p><p>2、若激活函数是Sigmoid，求梯度的最大值是0.25，可能会导致梯度消失问题，这时候网络就学习不到东西了，即无法更新梯度。</p><p>3、若权重设置过大了，可能出现梯度爆炸问题，梯度变成NaN。</p><p>注：最后等式括号中根据不同的激活函数有不同的导数。</p><p>Blog:</p><p><a href="https://medium.com/metaor-artificial-intelligence/the-exploding-and-vanishing-gradients-problem-in-time-series-6b87d558d22">https://medium.com/metaor-artificial-intelligence/the-exploding-and-vanishing-gradients-problem-in-time-series-6b87d558d22</a></p><p><a href="https://www.linkedin.com/advice/3/how-do-you-deal-vanishing-exploding-gradient">https://www.linkedin.com/advice/3/how-do-you-deal-vanishing-exploding-gradient</a></p><p><a href="https://www.cnblogs.com/XDU-Lakers/p/10557496.html">https://www.cnblogs.com/XDU-Lakers/p/10557496.html</a></p><p><a href="https://www.cnblogs.com/imreW/p/17366268.html">https://www.cnblogs.com/imreW/p/17366268.html</a></p><p><a href="https://www.cnblogs.com/zf-blog/p/12793019.html">https://www.cnblogs.com/zf-blog/p/12793019.html</a></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>主要将平时遇到的问题来记录，并且加以补充和整理，参考了多本书籍，</p><p>如：邱锡鹏，神经网络与深度学习，机械工业出版社，<a href="https://nndl.github.io/">https://nndl.github.io/</a>, 2020.以及 艾伯特深度学习 中文版[aibbt.com]等</p><p>对于许多的博客中比较好理解的内容也进行了摘录(*\^_^*)</p><p>可忙，可闲，可急，可缓。</p><p>张弛之间，便是生活。</p>]]></content>
      
      
      <categories>
          
          <category> Deep Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RNN中的梯度消失与梯度爆炸问题</title>
      <link href="/2024/11/11/rnn-zhong-de-ti-du-xiao-shi-yu-ti-du-bao-zha-wen-ti/"/>
      <url>/2024/11/11/rnn-zhong-de-ti-du-xiao-shi-yu-ti-du-bao-zha-wen-ti/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="梯度消失与梯度爆炸问题"><a href="#梯度消失与梯度爆炸问题" class="headerlink" title="梯度消失与梯度爆炸问题"></a>梯度消失与梯度爆炸问题</h2><p>循环神经网络（Recurrent Neural Network，RNN）是一类具有短期记忆能力的神经网络．在循环神经网络中，神经元不但可以接受其他神经元的信息，也可以接受自身的信息，形成具有环路的网络结构。</p><p>在RNN中，梯度计算时需要沿时间步反向传播（BPTT，Backpropagation Through Time），这个算法即按照时间的逆序将梯度信息一步步地往前传递．当输入序列比较长时了，时间步展开导致的<strong>长链乘积</strong>会存在梯度爆炸和消失问题，也称为长程依赖问题。</p><p><img src="https://i-blog.csdnimg.cn/direct/bb91f1cda5004e5ab6515c0da7a44ba3.png" alt="简单的前馈神经网络"></p><p>上图是一个简单的循环神经网络，只有一个隐藏层的神经网络，𝒉_𝑡不仅和当前时刻的输入𝒙_𝑡 相关，也和上一个时刻的隐藏层状态𝒉_{𝑡−1} 相关</p><p><img src="https://i-blog.csdnimg.cn/direct/e22ce116b84a438d81f7c962133dfe1a.png" alt="梯度消失与爆炸"></p><h3 id="分析步骤"><a href="#分析步骤" class="headerlink" title="分析步骤"></a>分析步骤</h3><p><img src="https://i-blog.csdnimg.cn/direct/fd6a6c3c096747c6893cbd13cc237cc8.png" alt="分析步骤"></p><p>分析：</p><p>1、使用了一个4层的前馈神经网络来模拟展开的RNN。</p><p>2、若激活函数是Sigmoid，求梯度的最大值是0.25，可能会导致梯度消失问题，这时候网络就学习不到东西了，即无法更新梯度。</p><p>3、若权重设置过大了，可能出现梯度爆炸问题，梯度变成NaN。</p><p>注：最后等式括号中根据不同的激活函数有不同的导数。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>从上面的分析过程可以看出，产生梯度爆炸或者梯度消失的原因有以下3个角度：<br> 1、激活函数<br> 2、初始化的权重过大<br> 3、网络层数太深<br> 所以解决方案也是从这三个方面来处理<br> 1、用ReLU、Leaky-ReLU、P-ReLU、R-ReLU、Maxout等替代sigmoid函数<br> 2、用Batch Normalization，批量归一化。<br> 3、LSTM的结构设计也可以改善RNN中的梯度消失问题，每个记忆单元(图中A)中包括细胞状态(Ct)，遗忘门，输入门和输出门。</p><p>以上就是在看完：<br>1、李沐学AI<br>2、邱锡鹏，神经网络与深度学习<br>后对RNN的梯度爆炸与消失的理论分析，接下来可以通过论文以及具体代码来分析</p>]]></content>
      
      
      <categories>
          
          <category> Deep Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++中string底层实现之SSO</title>
      <link href="/2024/11/01/c-zhong-string-di-ceng-shi-xian-zhi-sso/"/>
      <url>/2024/11/01/c-zhong-string-di-ceng-shi-xian-zhi-sso/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="string底层实现之SSO"><a href="#string底层实现之SSO" class="headerlink" title="string底层实现之SSO"></a>string底层实现之SSO</h2><p><a href="https://cplusplus.com/reference/string/string/string/">string的构造函数</a></p><p><a href="https://www.ccppcoding.com/archives/1199">参考资料</a></p><p>Simple String Optimization，最小字符串优化，基本原理是：<strong>当分配的字节数小于16字节的时候，直接从栈上进行进行内存分配，如果大于16字节，则在堆上进行内存分配。</strong></p><p>验证一下：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;stdlib.h&gt;using namespace std;void *operator new(size_t n)&#123;    cout&lt;&lt;&quot;new size&#x3D;&quot;&lt;&lt;n;    return malloc(n);&#125;void operator delete(void* p)&#123;    free(p);&#125;int main()&#123;    for(int i&#x3D;0; i&lt;30; i++)&#123;        cout&lt;&lt;&quot;i&#x3D;&quot;&lt;&lt;i&lt;&lt;&quot;: &quot;&lt;&lt;string(i, &#39;&#x3D;&#39;)&lt;&lt;endl;    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里对new进行了重载，以便我们观察是否调用的new。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@***********************:~<span class="token comment"># g++ -o test test.cpp </span>root@***********************:~<span class="token comment"># ./test</span><span class="token assign-left variable">i</span><span class="token operator">=</span><span class="token number">0</span>: <span class="token assign-left variable">i</span><span class="token operator">=</span><span class="token number">1</span>: <span class="token operator">=</span><span class="token assign-left variable">i</span><span class="token operator">=</span><span class="token number">2</span>: <span class="token operator">==</span><span class="token assign-left variable">i</span><span class="token operator">=</span><span class="token number">3</span>: <span class="token operator">==</span><span class="token operator">=</span><span class="token assign-left variable">i</span><span class="token operator">=</span><span class="token number">4</span>: <span class="token operator">==</span><span class="token operator">==</span><span class="token assign-left variable">i</span><span class="token operator">=</span><span class="token number">5</span>: <span class="token operator">==</span><span class="token operator">==</span><span class="token operator">=</span><span class="token assign-left variable">i</span><span class="token operator">=</span><span class="token number">6</span>: <span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token assign-left variable">i</span><span class="token operator">=</span><span class="token number">7</span>: <span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">=</span><span class="token assign-left variable">i</span><span class="token operator">=</span><span class="token number">8</span>: <span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token assign-left variable">i</span><span class="token operator">=</span><span class="token number">9</span>: <span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">=</span><span class="token assign-left variable">i</span><span class="token operator">=</span><span class="token number">10</span>: <span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token assign-left variable">i</span><span class="token operator">=</span><span class="token number">11</span>: <span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">=</span><span class="token assign-left variable">i</span><span class="token operator">=</span><span class="token number">12</span>: <span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token assign-left variable">i</span><span class="token operator">=</span><span class="token number">13</span>: <span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">=</span><span class="token assign-left variable">i</span><span class="token operator">=</span><span class="token number">14</span>: <span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token assign-left variable">i</span><span class="token operator">=</span><span class="token number">15</span>: <span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">=</span><span class="token assign-left variable">i</span><span class="token operator">=</span><span class="token number">16</span>: new <span class="token assign-left variable">size</span><span class="token operator">=</span><span class="token number">17</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token assign-left variable">i</span><span class="token operator">=</span><span class="token number">17</span>: new <span class="token assign-left variable">size</span><span class="token operator">=</span><span class="token number">18</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">=</span><span class="token assign-left variable">i</span><span class="token operator">=</span><span class="token number">18</span>: new <span class="token assign-left variable">size</span><span class="token operator">=</span><span class="token number">19</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token assign-left variable">i</span><span class="token operator">=</span><span class="token number">19</span>: new <span class="token assign-left variable">size</span><span class="token operator">=</span><span class="token number">20</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">=</span><span class="token assign-left variable">i</span><span class="token operator">=</span><span class="token number">20</span>: new <span class="token assign-left variable">size</span><span class="token operator">=</span><span class="token number">21</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token assign-left variable">i</span><span class="token operator">=</span><span class="token number">21</span>: new <span class="token assign-left variable">size</span><span class="token operator">=</span><span class="token number">22</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">=</span><span class="token assign-left variable">i</span><span class="token operator">=</span><span class="token number">22</span>: new <span class="token assign-left variable">size</span><span class="token operator">=</span><span class="token number">23</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token assign-left variable">i</span><span class="token operator">=</span><span class="token number">23</span>: new <span class="token assign-left variable">size</span><span class="token operator">=</span><span class="token number">24</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">=</span><span class="token assign-left variable">i</span><span class="token operator">=</span><span class="token number">24</span>: new <span class="token assign-left variable">size</span><span class="token operator">=</span><span class="token number">25</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token assign-left variable">i</span><span class="token operator">=</span><span class="token number">25</span>: new <span class="token assign-left variable">size</span><span class="token operator">=</span><span class="token number">26</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">=</span><span class="token assign-left variable">i</span><span class="token operator">=</span><span class="token number">26</span>: new <span class="token assign-left variable">size</span><span class="token operator">=</span><span class="token number">27</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token assign-left variable">i</span><span class="token operator">=</span><span class="token number">27</span>: new <span class="token assign-left variable">size</span><span class="token operator">=</span><span class="token number">28</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">=</span><span class="token assign-left variable">i</span><span class="token operator">=</span><span class="token number">28</span>: new <span class="token assign-left variable">size</span><span class="token operator">=</span><span class="token number">29</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token assign-left variable">i</span><span class="token operator">=</span><span class="token number">29</span>: new <span class="token assign-left variable">size</span><span class="token operator">=</span><span class="token number">30</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">=</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这就说明当字符串长度小于16时，是在栈上面分配内存，大于16的时候，在堆上分配内存，也就是调用了new方法。</p>]]></content>
      
      
      <categories>
          
          <category> c++基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>西瓜书书本内容杂谈</title>
      <link href="/2024/10/19/xi-gua-shu-shu-ben-nei-rong-za-tan/"/>
      <url>/2024/10/19/xi-gua-shu-shu-ben-nei-rong-za-tan/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="西瓜书书本内容杂谈"><a href="#西瓜书书本内容杂谈" class="headerlink" title="西瓜书书本内容杂谈"></a>西瓜书书本内容杂谈</h1><p>把圈子变小，把语速放缓，把心放宽，把生活打理好</p><p>只能说快速过了一遍，花了一个多星期吧，然后后边的内容是一点也看不懂了（能发现前面记得比较详细，到了后边是看不懂一点了，脑壳痛QWQ</p><p>就不像是一本新手的入门书籍，太难受了ಥ_ಥ，了解概念这本书也不适合，还是转为看《邱锡鹏，神经网络与深度学习》和李沐动手学AI课的实践部分，ಠ_ಠ</p><h2 id="第一章-绪论"><a href="#第一章-绪论" class="headerlink" title="第一章 绪论"></a>第一章 绪论</h2><p>1、预预测的值是离散值，这类学习任务叫做“分类”，如“好瓜”，“坏瓜”；若预预测的值是连续值，这类学习任务称为“回归”。</p><p>2、学得模型适用于新样本的能力，叫做“泛化”，泛化能力好，能更好的适用新样本。</p><p>3、西瓜问题的假设空间自顶向下、自底向上。</p><p>4、归纳偏好，对假设空间进行选择的启发式偏好，用一般性的原则来引导偏好，如”奥卡姆剃刀“法（Occam‘s razor）是一种常用的、自然科学研究中最基本的原则，即“若有多个假设与观察一致，则选择最简单的那个”，选择更为平滑的曲线。</p><p>5、不同算法针对不同问题有不同的拟合性，尽管看起来很差的算法（笨拙的算法）也有非常拟合的数据，。</p><p>6、所有算法的期望性能都差不多，E表示期望，下表ote表示训练集外误差（Out of Training set Error），E<sub>ote</sub>(L<sub>a</sub>|X,f)表示的就是给定数据集和真实目标函数的情况下，算法L<sub>a</sub>的训练集外误差的计算方式。（公式真的好难啊，脑壳痛QWQ）</p><p><img src="https://s2.loli.net/2024/09/07/UArh6fMqCBjR8tw.png" alt="学习算法的总误差"></p><p>7、NFL定理（<font color=red>No Free Lunch</font>），针对具体的问题谈论算法的优劣，裁缝做衣服</p><p><img src="https://s2.loli.net/2024/09/07/FblyvzxMQLVcs6A.png" alt="NFL定理"></p><p>8、历史发展过程，逻辑理论推理—&gt;”知识期”(人为的去教电脑知识)—&gt;自主学习知识，二十世纪八十年代是机器学习成为一个独立的学科领域、各种机器学习技术百花齐放。跳棋程序的发展历史：<a href="https://blog.creaders.net/u/5477/202405/487515.html">https://blog.creaders.net/u/5477/202405/487515.html</a></p><p>9、一些闪光的思想，“迁移学习”（Transfer Learning），“类比学习”（Learning By Analogy），“深度学习”（Deeping Learning）</p><p>10、课后习题看的头疼，完全看不懂，习题1.2直接可以用代码来解决了，厉害</p><p>11、机器学习的别称，萨缪尔（研制了一个西洋跳棋程序）将其定义为“<font color=red>不显示编程赋予计算机能力的研究领域</font>”。</p><h2 id="第二章-模型评估与选择"><a href="#第二章-模型评估与选择" class="headerlink" title="第二章 模型评估与选择"></a>第二章 模型评估与选择</h2><ol><li><p>术语：误差（error），训练误差（training error）和经验误差（empirical error）是指学习器在训练集上得到的误差；泛化误差（generalization error）；过拟合（overfitting）是当学习器把训练样本学得“太好”了的时候，很可能已经把训练样本自身的一些特点当作了所有潜在样本都当成了具有的一般性质；相对的是欠拟合（underfitting）。</p></li><li><p>进行模型评估时，需要使用特定的方法来实现训练集S和测试集T的划分，并且训练集与测试集尽可能互斥。模型评估是通过实验测试来对学习器的泛化误差进行评估，在现实任务中往往还会考虑时间开销、存储开销、可解释性等方面的因素，这里暂且只考虑泛化误差。先交叉验证集选择模型，然后训练集训练模型，最后测试集评估模型</p></li><li><p>评估方法：评估方法不能理解，第二次看有了下面的一些理解。<br><strong>训练集（Training Set）</strong>：用于<strong>训练</strong>模型。</p><p><strong>验证集（Validation Set）</strong>：用于<strong>调整和选择</strong>模型。</p><p><strong>测试集（Test Set）</strong>：用于<strong>评估</strong>最终的模型。</p><p>当我们拿到数据之后，一般来说，我们把数据分成这样的三份：训练集（60%），验证集（20%），测试集（20%）。用训练集训练出模型，然后用验证集验证模型，根据情况不断调整模型，选出其中最好的模型，记录最好的模型的各项选择，然后据此再用（训练集+验证集）数据训练出一个新模型，作为最终的模型，最后用测试集<font color='red'>评估</font>最终的模型。</p><ol><li><strong>留一法（Leave One Out Cross Validation，LOOCV）</strong>：m个样本集合，拿出一个作为验证集，剩余m-1个作为训练集，这样进行m次当都的训练和验证，最后将m次验证结果取平均值，作为验证误差。<strong>缺点是计算量大，一般不作为实际使用</strong></li><li><strong>K折交叉验证法（K-Fold Cross Validation）</strong>：把数据集分成K份，每个子集互不相交且大小相同，依次从K份中选出1份作为验证集，其余K-1份作为训练集，这样进行K次单独的模型训练和验证，最后将K次验证结果取平均值，作为此模型的验证误差。当K=m时，就变为留一法。可见留一法是K折交叉验证的<strong>特例</strong>。根据经验，<strong>K一般取10</strong>。（在各种真实数据集上进行实验发现，10折交叉验证在偏差和方差之间取得了最佳的平衡。）</li><li><strong>多次K折交叉验证（Repeated K-Fold Cross Validation）</strong>：每次用不同的划分方式划分数据集，每次划分完后的其他步骤和K折交叉验证一样。例如：10 次 10 折交叉验证，即每次进行10次模型训练和验证，这样一共做10次，也就是总共做100次模型训练和验证，最后将结果平均。这样做的目的是让结果更精确一些。（研究发现，重复K折交叉验证可以提高模型评估的精确度，同时保持较小的偏差。）</li></ol></li><li><p>性能度量：</p><ol><li><p>错误率与精度</p></li><li><p>查准率P与查全率R：一组矛盾的度量，以P为纵轴，R为横轴，得到的曲线为P-R曲线图平衡点（Break Even Point）是查准率=查全率，查准率和查全率是<strong>一对“鱼”与“熊掌”</strong>，一把来说，查准率高时，查全率往往偏低；而查全率高时，查准率往往偏低。</p><p>例如，如果想将垃圾邮件都选取出来，可以将所有邮件都标签为垃圾邮件，那么查全率就接近于1，但这样查准率就会比较低；如果希望分类垃圾邮件的查准率足够高，那么可以让分类器尽可能挑选最有把握的垃圾邮件，但这样往往会有大量的垃圾邮件成为漏网之鱼，此时查全率就会比较低。</p></li><li><p>F1度量：F1是基于查准率与查全率的调和平均(harmonic mean)定义的，能够表达对于查准率和查全率 的不同偏好。<br><img src="https://s2.loli.net/2024/09/12/R6CYgjEoa2yBhqF.png" alt="P-R曲线图"><br><img src="https://i-blog.csdnimg.cn/blog_migrate/8f2cacd1d19ca535ba447d751a1e9fb1.jpeg" alt="F1度量"></p></li><li><p>当β&gt;0时，度量了查全率和查准率的相对重要性。β=1，退化为标准的F1</p></li><li><p>二分类问题得出的分类结果可以得出“混淆矩阵”。</p></li><li><p>ROC曲线和AUC（度量分类中的非均衡性），</p></li><li><p>ROC 关注两个指标：</p><p>TPR（True Positive Rate）表示在所有实际为正例（阳性）的样本中，被正确地判断为正例的比率，即：</p><pre><code>TPR=TP/(TP + FN)</code></pre><p>FPR（ False Positive Rate）表示在所有实际为反例（阴性）的样本中，被错误地判断为正例的比率，即：</p><pre><code>FPR=FP/(FP + TN）</code></pre><p><strong><em>\</em>AUC值**</strong>（Area Unser the Curve）是ROC曲线下的面积</p></li></ol></li></ol><p><img src="https://i-blog.csdnimg.cn/blog_migrate/c6aeafc9bf3e9bb77a73427f37cd4e1b.jpeg" alt="ROC曲线"></p><h2 id="第三章-线性模型"><a href="#第三章-线性模型" class="headerlink" title="第三章 线性模型"></a>第三章 线性模型</h2><ol><li>线性回归（linear regression）：试图完成一条直线f(x)=wx+b，并且使得f(x)接近y，如何衡量他们之间的差距，采用均方误差的方式（最常用的性能度量），在线性回归中，基于均方误差最小化来进行模型求解的方法叫做“最小二乘法”，最小二乘法就是试图找到一条直线，使所有样本到直线的欧式距离之和最小。对应的，多元线性回归（multivariate linear regression）就是对应于多个w和多个x，以向量形式来处理，</li><li>对数几率回归，使用Sigmoid激活函数</li></ol><h2 id="第四章-决策树"><a href="#第四章-决策树" class="headerlink" title="第四章 决策树"></a>第四章 决策树</h2><p>Decision Tree是一种解决分类问题的算法，监督学习主要有两种任务：分类（连续）、回归（离散）。</p><p>决策树算法采用树结构，层层推理来实现最终的分类。</p><p>决策树学习的三个步骤：特征选择、决策树生成、决策树剪枝（解决过拟合问题，随机森林很大程度减少过拟合）。</p><p>三种典型的决策树算法：ID3（采用信息增益）、C4.5（改进、采用信息增益比）、CART（采用基尼系数，<strong>CART树全称Classification And Regression Trees</strong>）</p><p><strong>关于信息增益的理解：</strong></p><p>熵：表示随机变量的不确定性</p><p>条件熵：在一个条件下、随机变量的不确定性能</p><p>信息增益：熵-条件熵，表示是在一个条件下，信息不确定性减少的程度。</p><p>详细解释：<a href="https://www.zhihu.com/question/22104055">信息增益到底怎么理解呢？</a></p><p>剪枝处理，剪枝是决策树学习算法用于对付过拟合的主要手段，基本策略包括预剪枝、后剪枝。这里过拟合是指分支过多，训练结果“太好了”</p><h2 id="第五章-神经网络"><a href="#第五章-神经网络" class="headerlink" title="第五章 神经网络"></a>第五章 神经网络</h2><p>神经网络是一种模仿人脑神经系统的数学模型，称为人工神经网络，简称神经网络．在机器学习领域，神经网络是指由很多人工神经元构成的网络结构模型，这些人工神经元之间的连接强度是可学习的参数．</p><p>人脑神经元结构，典型的神经元结构可以分为细胞体和细胞突起：<br>（1） 细胞体（Soma）中的神经细胞膜上有各种受体和离子通道，胞膜的受体可与相应的化学物质神经递质结合，引起离子通透性及膜内外电位差发生改变，产生相应的生理活动：兴奋或抑制．<br>（2） 细胞突起是由细胞体延伸出来的细长部分，又可分为树突和轴突．<br>a ) 树突（Dendrite）可以接收刺激并将兴奋传入细胞体．每个神经元可以有一或多个树突．<br>b ) 轴突（Axon）可以把自身的兴奋状态从胞体传送到另一个神经元或其他组织．每个神经元只有一个轴突．</p><p><img src="https://s2.loli.net/2024/10/02/oRNp8IiHZY2jaQh.png" alt="典型的神经元结构"></p><p>人工神经网络是为模拟人脑神经网络而设计的一种计算模型，它从结构、实现机理和功能上模拟人脑神经网络．人工神经网络与生物神经元类似，由多个节点（人工神经元）互相连接而成，可以用来对数据之间的复杂关系进行建模。</p><p>神经网络的不同节点的连接被赋予了不同的权重，每个权重代表了一个节点对另一个节点的影响大小，经过权重综合计算，将其输入到一个激活函数中得到一个<font color='red'>新的活性值（兴奋或抑制）</font>。</p><p><img src="https://s2.loli.net/2024/10/02/YsZC9IbMovPrG5d.png" alt="典型的神经元结构"></p><p>参考：邱锡鹏，神经网络与深度学习，机械工业出版社，<a href="https://nndl.github.io/">https://nndl.github.io/</a>, 2020.</p><h2 id="第六章-支持向量机"><a href="#第六章-支持向量机" class="headerlink" title="第六章 支持向量机"></a>第六章 支持向量机</h2><p>支持向量机（Support Vector Machine，SVM）是一个经典的二分类算法，其找到的分割超平面具有更好的鲁棒性。</p><p>首先定义间隔γ表示整个数据集地所有样本到分割超平面地最小距离，γ越大，其分割超平面对两个数据集地划分就越稳定，不容易收到噪声地干扰。支持向量机的目标就是<font color='red'><strong>寻找一个超平面使得γ最大</strong></font>。</p><p><img src="https://s2.loli.net/2024/10/03/ucNXTIil9OGFsx7.png" alt="SVM示例"></p><p>摘自 邱锡鹏，神经网络与深度学习，机械工业出版社，<a href="https://nndl.github.io/">https://nndl.github.io/</a>, 2020.</p><h2 id="第七章-贝叶斯分类器"><a href="#第七章-贝叶斯分类器" class="headerlink" title="第七章 贝叶斯分类器"></a>第七章 贝叶斯分类器</h2><p>贝叶斯分类是一类分类算法的总称，贝叶斯算法是这类算法的核心，</p><p><strong>极大似然估计（Maximum Likelihood Estimation，MLE）和贝叶斯估计（Bayesian Estimation）是统计推断中两种最常用的参数估计方法</strong>，这两种方法，也分别是频率派和贝叶斯派的观点</p><p>机器学习所要实现的是基于有限的训练样本尽可能准确的估计后验概率p(c|x)，有两种方式来获取这个概率：</p><ol><li>判别式模型，通过直接建模来获取后验概率</li><li>生成式模型，通过联合概率模型来建模，然后再获得后验概率，贝叶斯方法就是基于这个模型</li></ol><p>贝叶斯理论模型的<strong>最优</strong>性，选择后验概率中最大的那一个作为预测结果</p><p><strong>分类：</strong>朴素贝叶斯分类器、半朴素贝叶斯分类器（独依赖估计、TAN、AODE）、贝叶斯网。</p><p>通俗来讲，通过先验概率的计算后来获得后验概率的过程，其实就是通过已知的经验来判断后来的事情，经验越多，预测得到的东西也就越准。</p><p>这种分类方式有一定的缺点，根本原因是，在决策过程中假设太强了，而且可能面临维度灾难，要考虑的特征过多。</p><p><a href="https://blog.csdn.net/m0_59596937/article/details/128877355">8种异常检测算法</a></p><p>课后小故事，贝叶斯怎么有这么多谜团，这也能出名，他从事数学研究的目的是为了证明上帝的存在（笑。</p><h2 id="第八章-集成学习"><a href="#第八章-集成学习" class="headerlink" title="第八章 集成学习"></a>第八章 集成学习</h2><p>粗略看了一下</p><p><a href="https://easyai.tech/ai-definition/ensemble-learning/">集成学习</a></p><h2 id="第九章-聚类"><a href="#第九章-聚类" class="headerlink" title="第九章 聚类"></a>第九章 聚类</h2><p>这是一种非监督学习的算法（与classification最大的区别），将不同性质的数据分成几个相同类型的数据，如何评定相同类型的数据，可以有下面这些标准：Euclidean distance, Cosine similarity, Manhattan distance, etc.</p><p>聚类算法的分类：</p><ol><li>Centroid-based Clustering (Partitioning methods)</li><li>Density-based Clustering (Model-based methods)</li><li>Connectivity-based Clustering (Hierarchical clustering)</li><li>Distribution-based Clustering</li></ol><p><a href="https://www.geeksforgeeks.org/clustering-in-machine-learning/#what-is-clustering-">Clustering in Machine Learning - GeeksforGeeks</a></p><h2 id="第十章-降维与度量学习"><a href="#第十章-降维与度量学习" class="headerlink" title="第十章 降维与度量学习"></a>第十章 降维与度量学习</h2><p><a href="https://ins.sjtu.edu.cn/people/xuzhiqin/2020opti/2020machinelearning/%E7%BB%9F%E8%AE%A1%E8%AE%A1%E7%AE%97%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AD%A6%E7%94%9F%E6%95%B4%E7%90%86%E7%9A%84%E8%AE%B2%E4%B9%89/%E7%AC%AC%E5%8D%81%E4%B8%80%E8%AE%B2%E9%99%8D%E7%BB%B4%E4%B8%8E%E5%BA%A6%E9%87%8F%E5%AD%A6%E4%B9%A0.pdf">第十一讲降维与度量学习</a></p><h2 id="第十一章-特征选择与稀疏学习"><a href="#第十一章-特征选择与稀疏学习" class="headerlink" title="第十一章 特征选择与稀疏学习"></a>第十一章 特征选择与稀疏学习</h2><p>在机器学习中特征选择是一个重要的“<strong>数据预处理</strong>”（<strong>data</strong> <strong>preprocessing</strong>）过程，即试图从数据集的所有特征中挑选出与当前学习任务相关的特征子集，接着再利用数据子集来训练学习器；稀疏学习则是围绕着稀疏矩阵的优良性质，来完成相应的学习任务。</p><p>特征选择一般在获得数据之后首先需要进行的，因为在实际任务中经常会遇到维数灾难问题，其中提取的特征过多，大多数可能都是冗余的，所以要提取出重要特征来减少维数。</p><p><a href="https://github.com/Vay-keen/Machine-learning-learning-notes/blob/master/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(13">周志华《Machine Learning》学习笔记(13)—特征选择与稀疏学习</a>—%E7%89%B9%E5%BE%81%E9%80%89%E6%8B%A9%E4%B8%8E%E7%A8%80%E7%96%8F%E5%AD%A6%E4%B9%A0.md)</p><h2 id="第十二章-计算学习理论"><a href="#第十二章-计算学习理论" class="headerlink" title="第十二章 计算学习理论"></a>第十二章 计算学习理论</h2><p>顾名思义，Computational learning theory研究的是关于通过计算来进行学习的理论，分析学习人物的困难本质，为学习算法提供理论保证，并根据分析结果指导算法设计。</p><p>PAC（Probably Approximately Correct，<font color='red'>可能近似正确</font>） 学习可以分为两部分：</p><ol><li>近似正确（Approximately Correct）：泛化错误小于一个界限，一般为1/2，即，0 &lt; 𝜖 &lt;1/2；机器学习中一个很关键的问题是期望错误和经验错误之间的差异，称为泛化错误（Generalization Error）．泛化错误可以衡量一个机器学习模型𝑓 是否可以很好地泛化到未知数据．</li><li>可能（Probably）：一个学习算法<font color='red'>可能</font>以一定的概率学习到这样一个近似正确的假设。</li></ol><h2 id="第十三章-半监督学习"><a href="#第十三章-半监督学习" class="headerlink" title="第十三章 半监督学习"></a>第十三章 半监督学习</h2><p>在许多ML的实际应用中，很容易找到海量的无类标签的样例，但需要使用特殊设备或经过昂贵且用时非常长的实验过程进行人工标记才能得到有类标签的样本，由此产生了极少量的有类标签的样本和过剩的无类标签的样例。因此，人们尝试将大量的无类标签的样例加入到有限的有类标签的样本中一起训练来进行学习，期望能对学习性能起到改进的作用，由此产生了半监督学习(Semi-supervised Learning)。</p><p>在做半监督学习(Semi-supervised Learning)的时候通常的情景如下：</p><ol><li>unlabeled data的数量要远大于label data</li><li>直推半监督学习(Semi-supervised Learning)只处理样本空间内给定的训练数据，利用训练数据中有类标签的样本和无类标签的样例进行训练，预测训练数据中无类标签的样例的类标签</li><li>归纳半监督学习(Semi-supervised Learning)处理整个样本空间中所有给定和未知的样例，同时利用训练数据中有类标签的样本和无类标签的样例，以及未知的测试样例一起进行训练，不仅预测训练数据中无类标签的样例的类标签，更主要的是预测未知的测试样例的类标签。</li></ol><p>半监督学习的需求非常强烈，因为在现实应用中往往能够很容易的收集到大量没有标记的样本。</p><h2 id="第十四章-概率图模型"><a href="#第十四章-概率图模型" class="headerlink" title="第十四章 概率图模型"></a>第十四章 概率图模型</h2><p>概率图模型（probabilistic graphical model, PGM），是一种学习任务的框架描述，它将学习任务归结为计算变量的概率分布，巧妙的结合了图论和概率论。</p><p>按照概率图中变量关系的不同，概率图模型可以大致分为两类：</p><ul><li>贝叶斯网络：有向图模型，使用有向无环图表达关系（通常，变量间存在显式的因果关系）</li><li>马尔科夫网络：无向图模型，使用无图表达关系（通常，变量间存有关系，但是难以显式表达）</li></ul><p><a href="https://longaspire.github.io/blog/%E6%A6%82%E7%8E%87%E5%9B%BE%E6%A8%A1%E5%9E%8B%E6%80%BB%E8%A7%88">概率图模型总览</a></p><h2 id="第十五章-规则学习"><a href="#第十五章-规则学习" class="headerlink" title="第十五章 规则学习"></a>第十五章 规则学习</h2><p>机器学习中的“<strong>规则</strong>”(rule)通常是指语义明确、能描述数据分布所隐含的客观规律或领域概念</p><p>目标是产生一个能覆盖尽可能多的样例的规则集。</p><p>规则集生成的过程是一个贪心搜索的过程，因此为缓解过拟合的风险，最常见的做法就是剪枝（pruning）。</p><p><a href="https://www.cnblogs.com/caolanying/p/16648584.html">规则学习</a></p><h2 id="第十六章-强化学习"><a href="#第十六章-强化学习" class="headerlink" title="第十六章 强化学习"></a>第十六章 强化学习</h2><p>与监督学习不同的是，强化学习不需要带标签的输入输出对，同时也无需对非最优解的精确地纠正。其关注点在于寻找探索（对未知领域的）和利用（对已有知识的）的平衡。在一个学习过程结束后，根据获得的“奖励”来学习，并且进一步预测下面的东西。</p>]]></content>
      
      
      <categories>
          
          <category> Deep Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DL基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深度学习数学基础</title>
      <link href="/2024/10/19/shen-du-xue-xi-shu-xue-ji-chu/"/>
      <url>/2024/10/19/shen-du-xue-xi-shu-xue-ji-chu/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="数学基础"><a href="#数学基础" class="headerlink" title="数学基础"></a>数学基础</h1><p>万丈高楼平地起</p><p>怎么说呢，学的数二对于这些东西还是太陌生了，而且当时学的只会做题，不知道怎么使用/(ㄒoㄒ)/~~</p><p>所以记下来一些不太清楚的前置知识点，主要来自《艾伯特深度学习》，书中内容很多，和《邱锡鹏神经网络与深度学习》内容有点相似</p><h2 id="牛顿-莱布尼茨公式"><a href="#牛顿-莱布尼茨公式" class="headerlink" title="牛顿-莱布尼茨公式"></a>牛顿-莱布尼茨公式</h2><p>揭示了定积分与被积函数的原函数或者不定积分之间的联系。 </p><p><img src="https://bkimg.cdn.bcebos.com/formula/0ee1ed05e107b3c9f50f9bb76c547afa.svg" alt="牛顿莱布尼茨公式"></p><h2 id="泰勒公式"><a href="#泰勒公式" class="headerlink" title="泰勒公式"></a>泰勒公式</h2><p>以直代曲，一点一世界，数值越大高阶的作用越大，但是高阶的作用有时候过大了，所以采用阶乘来抵消一些作用，最终得到的效果就是更好的模拟曲线。</p><p><img src="https://bkimg.cdn.bcebos.com/formula/8e916fa2c76aef2f90a408d6d3206eaa.svg" alt="泰勒展开式"></p><h2 id="拉格朗日乘数法（乘子法）"><a href="#拉格朗日乘数法（乘子法）" class="headerlink" title="拉格朗日乘数法（乘子法）"></a>拉格朗日乘数法（乘子法）</h2><p>求在约束条件下的极值。</p><h2 id="方向导数"><a href="#方向导数" class="headerlink" title="方向导数"></a>方向导数</h2><p>fai 的角度大小要注意</p><p><img src="https://s2.loli.net/2024/09/27/92wdcBpTOhgmUDV.png" alt="方向导数"></p><h2 id="梯度"><a href="#梯度" class="headerlink" title="梯度"></a>梯度</h2><p>蚂蚁跑离有火的地方，沿着梯度方向跑。梯度是一个向量，它的方向与方向导数最大值取得的方向一致。</p><h2 id="概率与信息论的作用"><a href="#概率与信息论的作用" class="headerlink" title="概率与信息论的作用"></a>概率与信息论的作用</h2><p>概率论是用于表明不确定性申明的数学框架，提供的一种<strong>量化不确定性</strong>的方法，也提供了用于<strong>导出新的不确定性声明</strong>的公理。</p><p>概率可以被看作是用于处理不确定性的逻辑扩展。逻辑提供了一套形式化的规则，可以在给定某些命题是真或假的假设下，判断另外一些命题是真的还是假的。概率论提供了一套形式化的规则，可以在给定一些命题的似然后，计算其他命题为真的似然。</p><p>机器学习很多情况下需要处理不确定量，有时也需要处理随机量，随机性和不确定性来自于多方面，如建模系统内在的随机性、不完全观测、不完全建模等。</p><h2 id="边缘概率"><a href="#边缘概率" class="headerlink" title="边缘概率"></a>边缘概率</h2><p>有时候，我们知道了一组变量的联合概率分布，但想要了解其中一个子集的概率分布。这种定义在子集上的概率分布被称为边缘概率分布(marginal probability distribution）</p><h2 id="协方差和标准差"><a href="#协方差和标准差" class="headerlink" title="协方差和标准差"></a>协方差和标准差</h2><h2 id="常用概率分布"><a href="#常用概率分布" class="headerlink" title="常用概率分布"></a>常用概率分布</h2><h2 id="信息论"><a href="#信息论" class="headerlink" title="信息论"></a>信息论</h2><p>主要研究的是对一个信号携带信息量的多少进行量化。</p><h2 id="方差"><a href="#方差" class="headerlink" title="方差"></a>方差</h2><p>偏离期望值的程度的大小</p><p><img src="https://bkimg.cdn.bcebos.com/formula/4b63ab2e13bc1cd3aaa328321b185bd1.svg" alt="方差计算公式"></p><h2 id="大数定理"><a href="#大数定理" class="headerlink" title="大数定理"></a>大数定理</h2><p>重复实验的次数越多，随机事件的概率越接近于它的概率。</p><h2 id="马尔可夫不等式"><a href="#马尔可夫不等式" class="headerlink" title="马尔可夫不等式"></a>马尔可夫不等式</h2><p>将概率与期望建立联系，</p><p><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/f4a5da8aeb446a9b74db9922fdde8568bcef2276" alt="马尔可夫不等式"></p><h2 id="范数"><a href="#范数" class="headerlink" title="范数"></a>范数</h2><p>衡量向量的大小。当p = 2 时，L2 范数被称为欧几里得范数（Euclidean norm）。它表示从原点出发到向量x 确定的点的欧几里得距离。L2 范数在机器学习中出现地十分频繁。</p><p><img src="https://s2.loli.net/2024/09/14/CRLe8gSV79cAKjI.png" alt="范数的定义"></p><h2 id="特征值和特征向量"><a href="#特征值和特征向量" class="headerlink" title="特征值和特征向量"></a>特征值和特征向量</h2><p>找特征向量的过程就是在找是否有一个矩阵左乘这个向量可以让它拉伸或者压缩。特征分解(eigendecomposition)是使用最广的矩阵分解之一，即我们将矩阵分解成一组特征向量和特征值。方阵A的特征向量(eigenvector)是指与A相乘后相当于对该向量进行缩放的非零向量v:<img src="https://bkimg.cdn.bcebos.com/formula/4973e26a6f4a367c9338895ce4471010.svg" alt="特征分解">，只有方阵才可以特征分解。</p><h2 id="奇异值分解"><a href="#奇异值分解" class="headerlink" title="奇异值分解"></a>奇异值分解</h2><p>还有另一种分解矩阵的方法，被称为奇异值分解(singular value decomposition,SVD),将矩阵分解为奇异向量(singular vector)和奇异值(singular value)。通过奇异值分解，我们会得到一些与特征分解相同类型的信息。</p><h2 id="线代实例：主成分分析"><a href="#线代实例：主成分分析" class="headerlink" title="线代实例：主成分分析"></a>线代实例：主成分分析</h2><p>PCA（principle components analysis），一个机器学习算法，可以通过线代的知识推导。见艾伯特深度学习2.12</p>]]></content>
      
      
      <categories>
          
          <category> Deep Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++前置和后置的运算符重载，红黑树的概念以及static关键字</title>
      <link href="/2024/10/16/c-qian-zhi-he-hou-zhi-de-yun-suan-fu-chong-zai-hong-hei-shu-de-gai-nian-yi-ji-static-guan-jian-zi/"/>
      <url>/2024/10/16/c-qian-zhi-he-hou-zhi-de-yun-suan-fu-chong-zai-hong-hei-shu-de-gai-nian-yi-ji-static-guan-jian-zi/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="c-前置和后置的运算符重载，红黑树的概念以及static关键字"><a href="#c-前置和后置的运算符重载，红黑树的概念以及static关键字" class="headerlink" title="c++前置和后置的运算符重载，红黑树的概念以及static关键字"></a>c++前置和后置的运算符重载，红黑树的概念以及static关键字</h1><h3 id="前置-和后置-的运算符重载"><a href="#前置-和后置-的运算符重载" class="headerlink" title="前置++和后置++的运算符重载"></a>前置++和后置++的运算符重载</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Interge</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> a<span class="token punctuation">;</span>    <span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Interge</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">a</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    <span class="token keyword">int</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token operator">-></span>a<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    Interge<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">++</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token operator">-></span>a<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    Interge <span class="token keyword">operator</span><span class="token operator">++</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        Interge temp<span class="token operator">=</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token operator">-></span>a<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> temp<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    Interge <span class="token function">i</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> a<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    cout<span class="token operator">&lt;&lt;</span>a<span class="token operator">++</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    cout<span class="token operator">&lt;&lt;</span>i<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    <span class="token comment">// i++;</span>    cout<span class="token operator">&lt;&lt;</span>i<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    i<span class="token operator">++</span><span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token comment">// ++i;</span>    cout<span class="token operator">&lt;&lt;</span>i<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><p><strong>红黑树的特性</strong>:<strong>（1）每个节点或者是黑色，或者是红色。**</strong>（2）根节点是黑色。<strong><strong>（3）每个叶子节点（NIL）是黑色。 [注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！]</strong></strong>（4）如果一个节点是红色的，则它的子节点必须是黑色的。<strong>**（5）从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。</strong></p><p><strong>红黑树的应用</strong></p><p>红黑树的应用比较广泛，主要是用它来存储有序的数据，它的时间复杂度是O(log2n)，效率非常之高。<strong>例如，Java集合中的<a href="http://www.cnblogs.com/skywang12345/p/3311268.html">TreeSet</a>和<a href="http://www.cnblogs.com/skywang12345/p/3310928.html">TreeMap</a>，C++ STL中的set、map，以及Linux虚拟内存的管理，都是通过红黑树去实现的。</strong></p><h3 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h3><p>总的来说</p><ul><li>（1）修饰变量，static 修饰的静态局部变量只执行初始化一次，延长了局部变量的生命周期，直到程序运行结束以后才释放。 </li><li>（2）修饰全局变量：全局变量只能在本文件中访问，不能在其它文件中访问， <strong>extern 外部声明</strong>也不可以。 </li><li>（3）修饰一个函数，则这个函数的只能在本文件中调用，不能被其他文件调用。static 修饰的变量存放在全局数据区的静态变量区，包括全局静态变量和局部静态变量，都在全局数据区分配内存。初始化的时候自动初始化为 0。 </li><li>（4）不想被释放的时候，可以使用static修饰。比如修饰函数中存放在栈空间的数组，如果不想让这个数组在函数调用结束释放可以使用 static 修饰。 </li><li>（5）考虑到数据安全性（当程序想要使用全局变量的时候应该先考虑使用 static）。 </li></ul>]]></content>
      
      
      <categories>
          
          <category> c++基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>复试经验分享《三、计算机学科专业基础综合》之数据结构</title>
      <link href="/2024/10/13/fu-shi-jing-yan-fen-xiang-san-ji-suan-ji-xue-ke-zhuan-ye-ji-chu-zong-he-zhi-shu-ju-jie-gou/"/>
      <url>/2024/10/13/fu-shi-jing-yan-fen-xiang-san-ji-suan-ji-xue-ke-zhuan-ye-ji-chu-zong-he-zhi-shu-ju-jie-gou/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="复试经验分享"><a href="#复试经验分享" class="headerlink" title="复试经验分享"></a>复试经验分享</h1><p>无善无恶心之体，有善有恶意之动。<br>知善知恶是良知，为善去恶是格物。<br>                                                                                                                       ——《明朝那些事儿》王守仁</p><h1 id="三、计算机学科专业基础综合"><a href="#三、计算机学科专业基础综合" class="headerlink" title="三、计算机学科专业基础综合"></a>三、计算机学科专业基础综合</h1><h1 id="3-1-数据结构"><a href="#3-1-数据结构" class="headerlink" title="3.1 数据结构"></a>3.1 数据结构</h1><h2 id="3-1-1-概念"><a href="#3-1-1-概念" class="headerlink" title="3.1.1 概念"></a>3.1.1 概念</h2><ul><li><p><strong>时间复杂度</strong></p><ul><li>时间复杂度是指执行算法所需要的计算工作量</li><li>一般情况下，按照基本操作次数最多的输入来计算时间复杂度，并且多数情况下我们去最深层循环内的语句所描述的操作作为基本操作。</li><li>一般时间复杂度：常对幂指阶</li><li>算法原地工作是指算法所需辅助空间是常量，即 O（1）</li></ul></li><li><p><strong>算法设计原则</strong></p><ul><li>正确性，可读性，健壮性，高效率和低存储性</li></ul></li></ul><h2 id="3-1-2-链表"><a href="#3-1-2-链表" class="headerlink" title="3.1.2 链表"></a>3.1.2 链表</h2><ul><li>单链表的逆置</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>ListNode<span class="token operator">*</span> <span class="token function">ReverseList</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> pHead<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        ListNode <span class="token operator">*</span>pre <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span><span class="token comment">//前驱</span>        ListNode <span class="token operator">*</span>cur <span class="token operator">=</span> pHead<span class="token punctuation">;</span><span class="token comment">//当前指针</span>        ListNode <span class="token operator">*</span>nex <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span> <span class="token comment">// 后继，这里可以指向nullptr，循环里面要重新指向</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>cur<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            nex <span class="token operator">=</span> cur<span class="token operator">-></span>next<span class="token punctuation">;</span>            cur<span class="token operator">-></span>next <span class="token operator">=</span> pre<span class="token punctuation">;</span><span class="token comment">//当前的后继指向前驱</span>            pre <span class="token operator">=</span> cur<span class="token punctuation">;</span><span class="token comment">//当前即为前驱</span>            cur <span class="token operator">=</span> nex<span class="token punctuation">;</span><span class="token comment">//移动指针到下一个</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> pre<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>头指针 : 指向链表第一个节点的指针，具有标识作用。（必须有，否则就找不到链表，内存泄漏)</p></li><li><p>头节点：第一个节点之前的空节点，方便操作，可有可无</p></li></ul><h2 id="3-1-3-栈"><a href="#3-1-3-栈" class="headerlink" title="3.1.3 栈"></a>3.1.3 栈</h2><p>先进后出</p><h2 id="3-1-4-队列"><a href="#3-1-4-队列" class="headerlink" title="3.1.4 队列"></a>3.1.4 队列</h2><p>先进先出</p><ul><li><strong>循环队列</strong>：解决假溢出问题，空留一个位置，用来判断队空队满。<ul><li>队满条件：（Q.rear+1)%MaxSize\==Q.front<br>队空条件： Q.front==Q.rear</li></ul></li></ul><h2 id="3-1-5-矩阵，串"><a href="#3-1-5-矩阵，串" class="headerlink" title="3.1.5 矩阵，串"></a>3.1.5 矩阵，串</h2><h3 id="3-1-5-1-矩阵的压缩存储"><a href="#3-1-5-1-矩阵的压缩存储" class="headerlink" title="3.1.5.1 矩阵的压缩存储"></a>3.1.5.1 矩阵的压缩存储</h3><ul><li>对称矩阵：只存放主对角线和下三角区的元素（计算得位置）</li><li>三角矩阵：空的不存</li><li>三对角矩阵：行列优先</li><li>稀疏矩阵：三元组法，十字链表法</li></ul><h3 id="3-1-5-2-KMP-模式匹配算法"><a href="#3-1-5-2-KMP-模式匹配算法" class="headerlink" title="3.1.5.2 KMP 模式匹配算法"></a>3.1.5.2 KMP 模式匹配算法</h3><ul><li>改进自简单模式算法，在暴力匹配中，每趟匹配失败都是模式后移一位再从头开始比较。而某趟已匹配相等的字符序列是模式的某个前缀，这种频繁的重复比较相当于模式串在不断地进行自我比较，这就是其低效率的根源。</li><li>因此，可以从分析模式本身的结构着手，如果已匹配相等的前缀序列中有某个后缀正好是模式的前缀，那么就可以将模式向后滑动到与这些相等字符对齐的位置，主串 i 指针无须回溯，并继续从该位置开始进行比较。而模式向后滑动位数的计算仅与模式本身的结构有关，与主串无关。</li></ul><h2 id="3-1-6-树"><a href="#3-1-6-树" class="headerlink" title="3.1.6 树"></a>3.1.6 树</h2><h3 id="3-1-6-1-基本概念"><a href="#3-1-6-1-基本概念" class="headerlink" title="3.1.6.1 基本概念"></a>3.1.6.1 基本概念</h3><ul><li><p>满二叉树：每一层结点数都达到最大值<br>完全二叉树：相比满二叉树，少了最底层，最右侧的一些节点</p></li><li><p>常用性质：</p><ul><li>结点总数 = 总度数 + 1</li><li>路径：树中两个结点之间所经过的结点序列</li></ul></li><li><p>遍历方式：先序遍历，中序遍历、后序遍历，层序遍历</p><ul><li>层序遍历操作：先将根结点入队；左，右子树根结点入队；根出队。每次出队前，将其左右子树根结点入队。</li></ul></li></ul><h3 id="3-1-6-2-二叉排序树"><a href="#3-1-6-2-二叉排序树" class="headerlink" title="3.1.6.2 二叉排序树"></a>3.1.6.2 二叉排序树</h3><ul><li><p>二叉排序树又称二叉查找树，它或者是一颗空树，或者满足一下性质的二叉树 :</p><ul><li><p>①若左子树不空，则左子树上所有结点的值均小于根节点的值 ;</p></li><li><p>②若右子树不空，则右子树上所有结点的值均大于根节点的值 ;</p></li><li><p>③左右子树也分别是二叉排序树。</p></li></ul></li><li><p>二叉查找原理步骤 :</p></li></ul><p>若根结点的关键字值等于查找的关键字，成功。否则，若小于根结点的关键字值，递归查左子树。若大于根结点的关键字值，递归查右子树。若子树为空，查找不成功。</p><ul><li><p>二叉排序树的删除</p><ul><li><p>若为叶子结点，直接删除</p></li><li><p>找到前驱或者后继替代，转换（前驱：左子树的最右下，后继：右子树的最左下）</p></li></ul></li></ul><h3 id="3-1-6-3-平衡二叉树与红黑树"><a href="#3-1-6-3-平衡二叉树与红黑树" class="headerlink" title="3.1.6.3 平衡二叉树与红黑树"></a>3.1.6.3 平衡二叉树与红黑树</h3><ul><li><p>将二叉树的高度控制在一个合理的高度内，减小递归深度，增加查找效率</p></li><li><p>平衡二叉树的左右子树高度差的绝对值不超过 1，且左右子树都为平衡二叉树</p></li><li><p>红黑树：降低要求（平衡二叉树插入新结点后需要调整过多，红黑树随规模增大调整较小规模即可），（根叶黑，不红红，黑路同</p><ul><li>性质 1. 结点是红色或黑色。</li><li>性质 2. 根结点是黑色。</li><li>性质 3. 所有叶子都是黑色。（叶子是 NIL 结点）</li><li>性质 4. 每个红色结点的两个子结点都是黑色。（从每个叶子到根的所有路径上不能有两个连续的红色结点）</li><li>性质 5. 从任一节结点到其每个叶子的所有路径都包含相同数目的黑色结点。</li><li>性质 6. 根结点到叶子结点的最长路径不超过最短路径的两倍</li></ul></li></ul><h3 id="3-1-6-4-哈夫曼树"><a href="#3-1-6-4-哈夫曼树" class="headerlink" title="3.1.6.4 哈夫曼树"></a>3.1.6.4 哈夫曼树</h3><ul><li>哈夫曼树：给定 N 个权值作为 N 个叶子结点，构造一棵二叉树，若该树的带权路径长度达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树(Huffman Tree)。哈夫曼树是带<br>权路径长度最短的树，权值较大的结点离根较近。</li></ul><ul><li>哈夫曼树定义 : 给定 n 个权值作为 n 个叶子结点，构造一棵二叉树，若带权路径长度达到最<br>小的二叉树. 构造方法 : 假设有 n 个权值，则构造出的哈夫曼树有 n 个叶子结点。n 个权值分<br>别设为 w1w2、…、wn,</li><li>则哈夫曼树的构造规则为 :<br>(1)将 w1、w2、…,wn 看成是有 n 棵树的森林(每棵树仅有一个结点);<br>(2)在森林中选出两个根结点的权值最小的树合并，作为一棵新树的左、右子树，且新树的<br>根结点权值为其左、右子树根结点权值之和 ;<br>(3)从森林中删除选取的两棵树，并将新树加入森林 ;<br>(4)重复(2)、(3)步，直到森林中只剩一棵树为止，该树即为所求得的哈夫曼树。特点 : 权值越大的结点，距离根节点越近 ; 树中没有度为一的结点。</li></ul><p>应用: 哈夫曼编码，减少编码的长度。哈夫曼编码就是长度最短的前缀编码。</p><h2 id="3-1-7-图"><a href="#3-1-7-图" class="headerlink" title="3.1.7 图"></a>3.1.7 图</h2><h3 id="3-1-7-1-基本概念"><a href="#3-1-7-1-基本概念" class="headerlink" title="3.1.7.1 基本概念"></a>3.1.7.1 基本概念</h3><ul><li><p>无向图：度，连通，连通分量</p></li><li><p>有向图：入度，出度，强连通图，强连通分量</p></li><li><p>拓扑排序：有向无环图的一个顶点组成的序列称为拓扑序列。（路径）</p></li><li><p>关键路径：顶点表示事件，有向边便是活动，边上的权值表示开销，称为 AOE 网。AOE 网中从源点到汇点的最大路径长度的路径叫做关键路径。</p></li></ul><h3 id="3-1-7-2-图的存储"><a href="#3-1-7-2-图的存储" class="headerlink" title="3.1.7.2 图的存储"></a>3.1.7.2 图的存储</h3><ul><li><p>邻接矩阵 : 是图的顺序存储结构，用两个数组分别存储数据元素（顶点)信息和数据元素之间的关系(边 / 弧）的信息。图的邻接矩阵表示是唯一的，无向图的邻接矩阵是对称的。</p></li><li><p>邻接表 : 是图的链式存储结构，由单链表的表头形成的顶点表和单链表其余结点所形成的边表两部分组成。（多用于无向图）</p></li><li><p>十字链表 : 有向图的另一种链式存储结构。</p></li><li><p>邻接多重表 : 无向图的链式存储结构。</p></li></ul><h3 id="3-1-7-3-最小生成树-普里姆算法和克鲁斯卡尔算法"><a href="#3-1-7-3-最小生成树-普里姆算法和克鲁斯卡尔算法" class="headerlink" title="3.1.7.3 最小生成树 : 普里姆算法和克鲁斯卡尔算法"></a>3.1.7.3 最小生成树 : 普里姆算法和克鲁斯卡尔算法</h3><ul><li><strong>prim 其基本思想为</strong> : 从联通网络 N=V.E)中某一顶点 u0 出发，选择与他关联的最小权值的<br>边，将其顶点加入到顶点集 S 中，此后就从一个顶点在 S 集中，另一个顶点不在 S 集中的所<br>有顶点中选择出权值最小的边，把对应顶点加入到 S 集中，直到所有的顶点都加入到 S 集中<br>为止。</li><li><strong>kruskal 其基本思想为</strong> : 设有一个有 N 个顶点的联通网络 N=V.E, 初试时建立一个只有 N 个顶<br>点，没有边的非连通图 T，T 中每个顶点都看作是一个联通分支，从边集 E 中选择出权值最<br>小的边且该边的两个端点不在一个联通分支中，则把该边加入到 T 中，否则就再从新选择一<br>条权值最小的边，直到所有的顶点都在一个联通分支中为止。</li><li><strong>最小生成树</strong>：一个有 n 个结点的连通图的生成树是原图的极小连通子图，且包含原图中的所<br>有 n 个结点，并且有保持图联通的最少的边。如果在最小生成树添加一条边，必定成一个<br>环。</li></ul><h3 id="3-1-7-4-DFS-与-BFS"><a href="#3-1-7-4-DFS-与-BFS" class="headerlink" title="3.1.7.4 DFS 与 BFS"></a>3.1.7.4 DFS 与 BFS</h3><ul><li><p><strong>深度优先搜索</strong>相当与树的先序遍历；一直访问当前结点的邻接结点，当没有邻接结点的时候，退回，继续访问。</p></li><li><p><strong>广度优先搜索</strong>相当与树的层序遍历；访问当前结点的所有邻接结点，再往邻接结点的邻接结点去访问</p></li></ul><h2 id="3-1-8-排序"><a href="#3-1-8-排序" class="headerlink" title="3.1.8 排序"></a>3.1.8 排序</h2><h3 id="3-1-8-1-快速排序"><a href="#3-1-8-1-快速排序" class="headerlink" title="3.1.8.1 快速排序"></a>3.1.8.1 快速排序</h3><ul><li>算法实现</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">Paritition1</span><span class="token punctuation">(</span><span class="token keyword">int</span> A<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> low<span class="token punctuation">,</span> <span class="token keyword">int</span> high<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> pivot <span class="token operator">=</span> A<span class="token punctuation">[</span>low<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//默认选择第一个元素为枢轴元素</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>low <span class="token operator">&lt;</span> high<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>low <span class="token operator">&lt;</span> high <span class="token operator">&amp;&amp;</span> A<span class="token punctuation">[</span>high<span class="token punctuation">]</span> <span class="token operator">>=</span> pivot<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token operator">--</span>high<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    A<span class="token punctuation">[</span>low<span class="token punctuation">]</span> <span class="token operator">=</span> A<span class="token punctuation">[</span>high<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>low <span class="token operator">&lt;</span> high <span class="token operator">&amp;&amp;</span> A<span class="token punctuation">[</span>low<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> pivot<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token operator">++</span>low<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    A<span class="token punctuation">[</span>high<span class="token punctuation">]</span> <span class="token operator">=</span> A<span class="token punctuation">[</span>low<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    A<span class="token punctuation">[</span>low<span class="token punctuation">]</span> <span class="token operator">=</span> pivot<span class="token punctuation">;</span>    <span class="token keyword">return</span> low<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">QuickSort</span><span class="token punctuation">(</span><span class="token keyword">int</span> A<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> low<span class="token punctuation">,</span> <span class="token keyword">int</span> high<span class="token punctuation">)</span> <span class="token comment">//快排母函数</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>low <span class="token operator">&lt;</span> high<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> pivot <span class="token operator">=</span> <span class="token function">Paritition1</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> low<span class="token punctuation">,</span> high<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">QuickSort</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> low<span class="token punctuation">,</span> pivot <span class="token operator">-</span> <span class="token number">1</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">QuickSort</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> pivot <span class="token operator">+</span> <span class="token number">1</span> <span class="token punctuation">,</span> high<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>算法步骤</p><p>  a. 从数列中挑出一个元素，称为 “基准”（pivot）;<br>  b. 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；<br>  c. 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序；</p></li></ul><ul><li>算法实现</li></ul><ul><li>快排相关问题<ul><li>时间复杂度（最好 <script type="math/tex">n*log_2n</script> ，最差<script type="math/tex">n^2</script> ，平均 <script type="math/tex">n*log_2n</script> ）</li><li>空间复杂度（ <script type="math/tex">log_2n</script> ~ n）</li><li>时间复杂度与两侧平衡差值有关，与处理顺序无关。（递归深度）</li><li>不稳定算法，适用于顺序表</li><li>特征：每完成一轮，都会有至少一个元素出现在正确的位置上。上一个枢轴元素不在两端的话，则下一趟至少有两个出现在正确位置。</li></ul></li></ul><h3 id="3-1-8-2-希尔排序"><a href="#3-1-8-2-希尔排序" class="headerlink" title="3.1.8.2 希尔排序"></a><strong>3.1.8.2</strong> 希尔排序</h3><ul><li>希尔排序就是先将整个待排序列分割成若干子序列，在子序列内分别进行直接插入排序，待整个序列的元素基本有序时，再将全体元素进行一次直接插入排序。</li></ul><ul><li>每趟排序增量递减，增量的初始值是 1，通过 3*h+1 循环计算</li></ul><h3 id="3-1-8-3-内部排序与外部排序"><a href="#3-1-8-3-内部排序与外部排序" class="headerlink" title="3.1.8.3 内部排序与外部排序"></a>3.1.8.3 内部排序与外部排序</h3><p>• 内部排序是排序期间元素全部存放在内存的排序 ; 外部排序是指在排序期间元素无法全部同</p><p>时存放在内存中，必须在排序的过程中根据要求不断的在内外存之间移动的排序。</p><h2 id="3-1-9-查找"><a href="#3-1-9-查找" class="headerlink" title="3.1.9 查找"></a>3.1.9 查找</h2><h3 id="3-1-9-1-哈希查找"><a href="#3-1-9-1-哈希查找" class="headerlink" title="3.1.9.1 哈希查找"></a>3.1.9.1 哈希查找</h3><ul><li><p>哈希查找是通过计算数据元素的存储地址进行查找的一种方法。</p></li><li><p>哈希查找步骤</p><ul><li><p>(1)用给定的哈希函数构造哈希表；</p></li><li><p>(2)根据选择的冲突处理方法解决地址冲突；</p></li><li><p>(3)在哈希表的基础上执行哈希查找。</p></li></ul></li><li><p>哈希函数</p><ul><li><p>直接定址法：线性函数，一一对应</p></li><li><p>数学分析法：选出若干位</p></li><li><p>平方取中法：平方后取中间位</p></li><li><p>除留余数法：除质数看余数</p></li></ul></li><li><p>哈希冲突</p><ul><li><p>开放定址法：线性探测（聚集），二次探测法</p></li><li><p>拉链法：散列地址相同的记录存储在同一个线性表中</p></li><li><p>再哈希法</p></li></ul></li><li><p>建立公共溢出区：基本表 + 溢出表</p></li><li><p>装填因子：填入表中的元素个数 / 散列表的长度。</p><ul><li>冲突是无法避免的，与装填因子无关</li></ul></li></ul><h3 id="3-1-9-2-折半查找"><a href="#3-1-9-2-折半查找" class="headerlink" title="3.1.9.2 折半查找"></a>3.1.9.2 折半查找</h3><ul><li><p>条件 : 有序数组</p></li><li><p>操作 :</p><p>  1)查找过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜素过程结束 ;</p><p>  2)如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。</p><p>  3)如果在某一步骤数组为空，则代表找不到。</p><p>  4)这种搜索算法每一次比较都使搜索范围缩小一半。</p></li></ul><ul><li>时间复杂度 :O(log(n))</li></ul><h3 id="3-1-9-3-B-树"><a href="#3-1-9-3-B-树" class="headerlink" title="3.1.9.3 B 树"></a><strong>3.1.9.3 B</strong> 树</h3><ul><li>B 树和平衡二叉树稍有不同的是 B 树属于多叉树又名平衡多路查找树（查找路径不只两个），数据库索引技术里大量使用者 B 树和 B+ 树的数据结构。所有节点关键字是按递增次序排列，并遵循左小右大原则</li><li>所有叶子节点均在同一层、叶子节点除了包含了关键字和关键字记录的指针外也有指向其子节点的指针只不过其指针地址都为 null 对应下图最后一层节点的空格子 ;</li><li>B 树相对于平衡二叉树的不同是，每个节点包含的关键字增多了，特别是在 B 树应用到数据库中的时候，数据库充分利用了磁盘块的原理（磁盘数据存储是采用块的形式存储的，每个块的大小为 4K，每次 IO 进行数据读取时，同一个磁盘块的数据可以一次性读取出来）把节点大小限制和充分使用在磁盘快大小范围；把树的节点关键字增多后树的层级比原来的二叉树少了，减少数据查找的次数和复杂度 ;</li></ul><h3 id="3-1-9-4-B-树"><a href="#3-1-9-4-B-树" class="headerlink" title="3.1.9.4 B+ 树"></a>3.1.9.4 B+ 树</h3><ul><li><p>B+ 树是 B 树的一个升级版，相对于 B 树来说 B+ 树更充分的利用了节点的空间，让查询速度更加稳定，其速度完全接近于二分法查找。为什么说 B+ 树查找的效率要比 B 树更高、更稳定；</p></li><li><p>对比</p><ul><li><p>1、B+ 树的层级更少：相较于 B 树 B+ 每个非叶子节点存储的关键字数更多，树的层级更少所以查询数据更快；</p></li><li><p>2、B+ 树查询速度更稳定：B+ 所有关键字数据地址都存在叶子节点上，所以每次查找的次数都相同所以查询速度要比 B 树更稳定 ;</p></li><li><p>3、B+ 树天然具备排序功能：B+ 树所有的叶子节点数据构成了一个有序链表，在查询大小区间的数据时候更方便，数据紧密性很高，缓存的命中率也会比 B 树高。</p></li><li><p>4、B+ 树全节点遍历更快：B+ 树遍历整棵树只需要遍历所有的叶子节点即可，，而不需要像 B 树一样需要对每一层进行遍历，这有利于数据库做全表扫描。</p></li></ul></li></ul><p>B 树相对于 B+ 树的优点是，如果经常访问的数据离根节点很近，而 B 树的非叶子节点本身存有关键字其数据的地址，所以这种数据检索的时候会要比 B+ 树快。</p><h2 id="3-1-10-算法"><a href="#3-1-10-算法" class="headerlink" title="3.1.10 算法"></a>3.1.10 算法</h2><h3 id="3-1-10-1-贪心算法"><a href="#3-1-10-1-贪心算法" class="headerlink" title="3.1.10.1 贪心算法"></a>3.1.10.1 贪心算法</h3><ul><li><p>贪心算法(又称贪婪算法）是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，算法得到的是在某种意义上的局部最优解。</p></li><li><p>贪心算法不是对所有问题都能得到整体最优解，关键是贪心策略的选择。</p></li><li><p>贪心算法的一般步骤 :</p><p>  1)将复杂问题分解为多个子问题 ;</p><p>  2)子问题的解是当前所有解中的最优解 ;</p><p>  3）将所有子问题的解合并为原问题的解。</p></li></ul><p>③说明 :</p><p>贪心问题和动态规划较为相似，其中一个较为关键的区别是贪心算法是不可取消的，自顶向下</p><p>求出子问题的当前最优解。而动态规划是每步做出的选择都依赖于子问题的解。</p><h3 id="3-1-10-2-动态规划"><a href="#3-1-10-2-动态规划" class="headerlink" title="3.1.10.2 动态规划"></a>3.1.10.2 动态规划</h3><ul><li><p>动态规划和之前的贪心算法有点类似，都是将一个规模大的问题分解为几个小的问题，通过解决小的问题来得到整体的解。</p></li><li><p>动态规划的核心问题是问题的状态的定义和状态转移方程的求解。</p></li><li><p>动态规划的关键在于，将重复出现的子问题在第一次求解之后就将其保存起来，以后再遇到时不用重复求解。动态规划是按照自底向上的方式计算最优解。</p></li><li><p>算法应用的常用问题 : 当题目求解的是最大值、最小值，可行与否或者方案总数时，考虑使用动态规划问题。算法的一般步骤 : 将问题分解为不同的子问题 ; 定义状态找出初始状态 ; 状态转移方程的求解 ; 求出问题最终的答案。</p></li><li><p>贪心问题和动态规划较为相似，其中一个较为关键的区别是贪心算法是不可取消的，自顶向下求出子问题的当前最优解。而动态规划是每步做出的选择都依赖于子问题的解。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 408 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>复试经验分享</title>
      <link href="/2024/09/25/fu-shi-jing-yan-fen-xiang-yi-wen-da-ti-zi-ce/"/>
      <url>/2024/09/25/fu-shi-jing-yan-fen-xiang-yi-wen-da-ti-zi-ce/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="复试经验分享"><a href="#复试经验分享" class="headerlink" title="复试经验分享"></a>复试经验分享</h1><h2 id="一、问答题目自测"><a href="#一、问答题目自测" class="headerlink" title="一、问答题目自测"></a>一、问答题目自测</h2><h2 id="1-数据结构"><a href="#1-数据结构" class="headerlink" title="1. 数据结构"></a>1. 数据结构</h2><p>1.1 请简述深度优先遍历、广度优先遍历的基本思想 栈、队列。</p><p>1.2 简述满二叉树，完全二叉树，二叉排序树，平衡二叉树的特性 </p><p>1.3 什么是队列的上溢现象和假溢出现象? 解决它们有哪些方法? <strong>Overflow 上溢，真正的溢出；假溢出现象（False Overflow）</strong></p><p>1.4 对单链表设置头节点的作用是什么 ?（至少说出两条好处) <strong>插入和删除、空链表和非空链表的处理</strong></p><p>1.5 若较频繁地对一个线性表进行插入和删除操作 , 该线性表宜采用何种存储结构? 为什么? <strong>链式结构，因为采用顺序结构需要移动大量的元素，采用链式结构可以直接修改指针即可</strong></p><p>1.6 为什么会引入线索二叉树？它有什么优势？<strong>主要是为了解决传统二叉树遍历效率不高的问题，尤其是在没有父指针的情况下，找到任一节点的前驱和后继节点比较困难。利用了二叉树中空的指针，提高了遍历效率，特别是在查找一个节点的前驱或者后继时比较方便，并且也节省了空间</strong></p><p>1.7 循环比递归的效率一定高吗？<strong>各有其优点，循环在空间效率上优于递归，循环是原地操作，递归需要栈的帮助；递归可以让一些算法变得更加简便、清晰、易懂。</strong></p><p>1.8 请比较 AOE 网与 AOV 网？<strong>AOE 网中，通过计算事件的最早发生时间和最迟发生时间，确定关键路径和项目最短工期；而在 AOV 网中，通过计算顶点的最早发生时间和最迟发生时间，确定关键路径和项目最短工期。</strong></p><p>1.9 栈和队列的异同点？<strong>同：线性结构，异：LIFO（栈），FIFO（队列），栈常应用于表达式求值、括号匹配、函数调用，队列常用于任务调度、缓存管理、消息传递。</strong></p><p>1.10 栈在后缀表达式求值的算法思想？ <strong>遇到数字入栈，遇到运算符弹出两个数字进行运算</strong></p><p>1.11Dijkstra 算法和 BFS 求的最短路径有什么区别吗？ <strong>前者是解决带权最短路径问题，后者只能解决无权最短路径（每访问一个节点，路径长度 +1）</strong></p><p>1.12 简述什么是哈夫曼树？<strong>用于编码无损压缩最优编码的方法，编码所得到的带权路径长度最小。</strong></p><p>1.13 时间复杂度为 O(nlogn)的排序方法？<strong>快速排序、归并排序、桶排序</strong></p><p>1.14 排序算法稳定性的定义？有那些不稳定排序？<strong>稳定性是指排序前后相同的元素相对位置保持不变，不稳定排序：快希选堆</strong></p><p>1.15 堆排序是否是一种稳定的排序方法? 为什么? <strong>不是稳定的，建堆过程中可能会让稳定性改变，不可避免</strong></p><p>1.16 树的存储结构有哪些？<strong>双亲表示法、孩子表示法、孩子兄弟表示法。</strong></p><p>1.17 栈在括号匹配中的算法思想？ <strong>遇到左括号入栈，遇到右括号弹栈，此时判断是否匹配</strong></p><p>1.18 贪心算法和动态规划以及分治法的区别？<strong>贪心：每一步达到局部最优解；动态规划：将问题分解成相互重叠的子问题，并且通过记录子问题得到的结果，避免重复计算；分治：将问题分解成相互独立的子问题，如快速排序、归并排序</strong></p><p>1.19 有哪些哈希函数的构造方法，列举一些？<strong>直接定址法、除留余数法</strong></p><p>1.20 如何由遍历序列构造一棵二叉树？<strong>前 + 中，后 + 中。</strong></p><h2 id="2-计算机组成原理"><a href="#2-计算机组成原理" class="headerlink" title="2. 计算机组成原理"></a>2. 计算机组成原理</h2><p>2.1 请说明三级存储体系分别由哪些部分组成，并比较“CACHE—主存”和“主存—辅存”这两个存储层次的相同点和不同点。<strong>从快到慢：寄存器、Cache、主存、辅存；在“CACHE—主存”体系中，缓存用于加速 CPU 对主存的访问；而在“主存—辅存”体系中，主存用于暂时存储辅助存储器中的数据和程序，提供给 CPU 使用。</strong></p><p>2.2 试说明 DMA 的工作流程。<strong>CPU 发起读数据请求，DMA 控制器响应请求，接下来的工作就由 DMA 控制器接管，CPU 可以做别的事情，若数据传输完成，DMA 会发起中断通知 CPU 数据传输完成，这时就由 CPU 来接管工作。</strong></p><p>2.3 什么是 RISC？RISC 指令系统的特点是什么？<strong>精简指令集系统，特点：指令长度固定，适合制定流水线的任务，使用寄存器较多，可以减少访问内存的时间，可以提高系统的性能。</strong></p><p>2.4 请简要说明常见的主机与外围设备之间信息传送的控制方式，并指采用哪种方式 CPU 效率最低，哪种方式效率最高。<strong>程序查询、中断方式、DMA、通道。程序查询效率最低，DMA 效率最高。</strong></p><p>2.5 说明冯诺依曼计算机的基本特征。<strong>采用存储程序的方式方式存储指令，计算机系统由运算器、控制器、输入设备、输出设备和存储器五大部分组成</strong></p><p>2.6 请说明 SRAM 的组成结构，与 SRAM 相比，DRAM 在电路组成上有什么不同之处？<strong>SRAM 是静态随机存储器，DRAM 是动态随机存储器，DARM 需要刷新、SRAM 不需要刷新，SRAM 主要用于 Cache，DRAM 用于主存。</strong></p><p>2.7 简述中断的步骤及中断响应的条件。<strong>步骤：中断请求、中断响应、中断服务程序处理、中断返回，条件：有中断请求信号、处于中断允许状态，并且还要判断中断优先级。</strong></p><p>2.8 试论证在浮点数加减为什么要对阶，对阶原则反过来为什么不行? <strong>对阶的原因：尽量减少误差，因为小阶向大阶对齐，尾数向右移，数值小的尾数可能被丢弃，但是如果反过来对阶，可能会导致数值大的位被丢弃，误差更大，对阶完成后，尾数可以直接相加，简化了运算。</strong></p><p>2.9 与组合逻辑控制方式相比，微程序控制器有何优点？<strong>微程序控制器采用微指令来设计和控制系统，灵活度比较高，修改比较灵活、不需要对整个电路进行修改，易于扩展。</strong></p><p>2.10 一个计算机系统中的总线，大致分为哪几类？<strong>数据总线、控制总线、地址总线。</strong></p><p>2.11 指令和数据均存放在内存中，CPU 如何从时间和空间上区分它们是指令还是数据？<strong>取值周期取出的数据是指令，其他阶段，如执行阶段、间址阶段，取出的就是数据</strong></p><p>2.12 简述多重中断系统中 CPU 响应处理一次中断的步骤？<strong>首先是系统内或者系统外部设备发起中断请求，然后 CPU 响应中断，关中断，保存断点，进行中断服务寻址，转去执行中断服务程序，执行完成后，关中断、恢复现场信息，中断返回。</strong></p><p>2.13 什么是存储器的刷新？刷新有哪些典型的方式？<strong>存储器的刷新是指将数据永久的保存到存储介质中，以确保数据的持久性和安全性，如数据库事务日志刷新</strong></p><p>2.14 何谓“总线仲裁”？<strong>总线仲裁是指当多个设备竞争同一个总线的时候，按照一定的规则分配给各个设备使用总线来完成各自的数据传输任务。</strong></p><p>2.15 浮点数规格化的目的和方法？<strong>目的：提高精度，节约存储空间。方法：有左归和右归，将尾数的最高位始终保存着 1。</strong></p><p>2.16 请说明微指令地址的形成方式主要有哪两种分别是从哪里获得的下一条微指令的微地址的？</p><p>2.17 讲讲啥是存储程序控制方式？<strong>这是冯诺依曼模型的核心之一，存储程序是指将一条条的指令和数据保存在存储器中，要执行某一条指令或者想要取出数据时，将其从存储器中取出来，CPU 可以自动的执行和分析。</strong></p><p>2.18 简述 CPU 的主要功能？<strong>CPU 是计算机的大脑，可控制指令的译码和执行，数据的处理，中断的控制，按序按需的控制计算机的各种设备的正确运行。</strong></p><p>2.19 在计算机系统结构中，什么是编译？什么是解释？<strong>编译是指执行程序前将其编译为可执行文件，即从高级语言翻译为机器语言并保存，如果程序没有改变，无需再次编译。解释是在想要运行程序必须解释一行运行一行，不会生成目标程序。</strong></p><p>2.20 在计算机中，为什么要采用二进制来表示数据？<strong>二进制只有 0 和 1 两种状态，可以很方便的使用电子设备来实现，实现简单，节约成本，并且运算的处理更加简单。</strong></p><p>2.21 向量中断、中断向量、向量地址三个概念是什么关系？</p><h2 id="3-操作系统"><a href="#3-操作系统" class="headerlink" title="3. 操作系统"></a>3. 操作系统</h2><p>3.1 内存管理有哪些主要功能？它们的主要任务是什么？<strong>内存分配与回收、虚拟地址和物理地址的转换</strong></p><p>3.2 试说明引起进程阻塞或被唤醒的主要事件是什么？<strong>所需要的某个资源暂时无法非配给这个阻塞进程，或者是进程需要进行 I/O 操作，需要等待这个资源被其他进程释放，才可以将进程唤醒。</strong></p><p>3.2 分页和分段存储管理有何区别？<strong>分页是分成内存大小一致的空间，而分段存储是根据用户需要来分配的，大小不一致，分成代码段、数据段等。</strong></p><p>3.3 OS 有哪几大特征？其最基本的特征是什么？</p><p>3.4 何谓死锁？产生死锁的原因和必要条件是什么？<strong>死锁就是资源分配不合理出现的一种互相等待资源而又都得不到满足的情况，比如一个进程需要 A 资源自己占有了 B 资源，另一个进程需要 B 资源自己占有了 A 资源，这样就导致两个进程都无法得到满足，导致死锁，解决方法有资源剥夺法、资源预分配法。</strong></p><p>3.5 在创建一个进程时所要完成的主要工作是什么？<strong>为进程分配空间，如代码段、数据段、堆栈段，初始化进程控制块（PCB），分配 IO 资源、IO 设备</strong></p><p>3.6 文件管理有哪些主要功能？<strong>文件是保存在磁盘介质上面的，文件的管理包括文件的增删改查，共享和保护。</strong></p><p>3.7 试说明进程在三个基本状态之间转换的典型原因。<strong>首先进程的三种状态包括就绪态、运行态、等待态，就绪态到运行态：转变是因为进程分配到了 CPU 资源，运行态到就绪态：是分配给进程的时间片用完了，运行态到等待态：IO 请求，等待态到就绪态：IO 事件完成了</strong></p><p>3.8 在解决死锁问题的几个方法中，哪种方法最易于实现？哪种方法使资源利用率最高？<strong>有四种方法：预防、避免、检测和解除</strong></p><p>3.9 高级调度与低级调度的主要任务是什么？</p><p>3.10 分区存储管理中常用哪些分配策略？<strong>分区存储管理是对内存进行分区管理，采用合适的策略给进程分配内存空间，有首次适应算法、最佳适应算法、最坏适应算法、最近使用算法</strong></p><p>3.11 目前广泛采用的目录结构形式是哪种？它有什么优点？<strong>树形目录结构，层次清晰、便于管理、查找效率高。</strong></p><p>3.12 目前常用的磁盘调度算法有哪几种？<strong>首先磁盘调度是指优化了磁盘的请求顺序，来减少磁盘的寻道时间，寻道时间是访问磁盘的时候最耗时的部分，有先来先服调度算法（FCFS）、最短寻道时间优先算法（SSTF）、扫描算法（SCAN）、循环扫描算法（C-SCAN）。</strong></p><p>3.13 设备控制器的组成？</p><p>3.14 试说明 PCB 的作用，为什么说 PCB 是进程存在的惟一标志？<strong>PCB 是进程控制块，系统每创建一个进程就需要为其创建一个进程控制块，进程控制块中包含了进程调度所需要的必要信息，如进程 ID、进程优先级、进程打开文件表等信息，在进行进程调度前需要知道这些信息。</strong></p><p>3.15 试从物理概念上说明记录型信号量 wait 和 signal？<strong>信号量是代表了资源可用的数目，执行 wait 时，表示申请资源，会将信号量减一，表示资源被拿走了一个，若信号量等于零，再使用 wait 需要等待；signal 表示归还一个资源，信号量 +1，那些被信号量阻塞的进程可以进入就绪态等待调用。</strong></p><p>3.16 什么是硬实时任务和软实时任务？</p><p>3.17 简述银行家算法？<strong>银行家算法把系统当成银行家，资源当成资金，进程被视作客户，在分配给客户资源前，先检查系统是否处于安全状态，如果安全，将其非配给客户，从而保证不发生死锁。</strong></p><p>3.18 SPOOLing 技术的特点？<strong>SPOOLing 是假脱机操作，让客户以为自己独占了一个设备，实际上只是在设备申请使用表上面添加了一个请求，这种技术将独占设备改成了共享设备，提高了设备利用率。</strong></p><p>3.19 操作系统的功能？<strong>进程管理、文件管理、磁盘管理、内存管理、设备管理</strong></p><p>3.19 什么是页表和快表，有什么作用？<strong>页表指出逻辑地址中的页号与所占主存块号的对应关系。作用：页式存储管理在用动态重定位方式装入作业时，要利用页表做地址转换工作。快表就是存放在高速缓冲存储器的部分页表。它起页表相同的作用。由于采用页表做地址转换，读写内存数据时 CPU 要访问两次主存。有了快表，有时只要访问一次高速缓冲存储器，一次主存，这样可加速查找并提高指令执行速度。</strong></p><h2 id="4-计算机网络"><a href="#4-计算机网络" class="headerlink" title="4. 计算机网络"></a>4. 计算机网络</h2><p>4.1 简述交换机工作原理。<strong>交换机可以进行 MAC 地址自学习，建立 MAC 地址表，从而实现本地局域网的数据转发，可以隔离冲突域</strong></p><p>4.2 TCP/IP 的核心思想是什么？<strong>将网络通信实现为分层的设计，每个层次负责不同的功能，并且通过这种分层的设计，更容易实现网络的扩展，其中 TCP 协议实现网络的可靠传输，是有连接的，可靠的；IP 协议实现网络中数据包的传输，并且给每个设备定义一个唯一的 IP 地址，是无连接的，不可靠的。</strong></p><p>4.2 什么是曼彻斯特编码和差分曼彻斯特编码？其特点是什么？<strong>曼彻斯特编码和差分曼彻斯特编码是数字通信中常用的编码方式，用于在数据传输过程中进行信号调制以及数据同步。</strong></p><p>4.3 简述转发器、交换机、路由器和网关的工作层次和作用。<strong>转发器工作在物理层，用于放大信号延长传输距离；交换机工作在数据链路层，用于实现局域网内基于目的 MAC 地址的数据转发；路由器工作在网络层，实现不同网络的数据转发，通过路由表来计算转发路径，通过目的 IP 来实现从一个网络到达另外一个网络；网关工作在应用层，是网络的入口。</strong></p><p>4.4 端到端通信和点到点通信有什么区别？<strong>端到端之间的通信是建立在传输层的，因为无论是TCP 还是 UDP 协议，都需要建立发送端和接收端，实现的是应用进程之间的通信；点到点通信是在数据链路层，基于 MAC 地址，只转发给相邻的节点。</strong></p><p>4.5 什么是 CSMA／CD？并论述其发送过程。<strong>一种用于以太网局域网中的介质访问控制方法，用于协调多个设备在共享介质上进行数据传输的过程。</strong></p><p>4.6 简述 TCP 和 UDP 协议的主要特点和应用场合？ <strong>TCP 是面向连接的，在传输数据之前需要建立一条可靠的数据连接，在传输结束后，才会释放连接，可靠传输是通过确认、重传、流量控制、拥塞避免来实现的，应用场景：电子邮件、文件传输、网页浏览；UDP 是无连接的，不提供可靠传输，传输的数据也没有顺序性，应用场景：流媒体、实时视频通讯、语音通话等。</strong></p><p>4.7 什么是多路复用技术？有几种复用方法？<strong>多路复用技术是指一个信道实现多个数据流的传输，以此来提高信道的利用率，通过复用的技术来将一个广播信道逻辑上分为几个互不干扰的子信道，常见的复用方法：频分复用、码分复用、时分复用。</strong></p><p>4.8 什么是域名解析，域名解析中采取了什么措施提高效率？<strong>域名解释是将人们熟知的域名解析为 IP地址，当输入一个网址的时候，计算机需要通过域名获取 IP 地址，然后再建立连接。采取的措施：DNS 缓存，DNS 负载均衡。</strong></p><p>4.9 简述 HTTP 协议的特点和工作过程。<strong>HTTP 是超文本传输协议，常用于 web 的网页传输格式协议，特点：无连接、无状态，可以通过 Cookie、Session 技术来保存用户状态，格式简单，有 GET、POST 等请求格式。</strong></p><p>4.10 SMTP 协议的用途是什么？<strong>SMTP 是简单邮件传输协议，用于传输电子邮件，可以发送、接收、转发，通常接受邮件采用 POP3、IMAP，STMP 有时候也可以接收邮件。</strong></p><p>4.11 简述 ICMP、DHCP 的作用？DHCP 流程？ <strong>ICMP 用于用于检测网络中的状态信息，确保网络可靠，并且提供差错报告；DHCP 是用于给主机动态的分配 IP 地址，DHCP 流程：DHCP Discover、DHCP Offer、DHCP Request、DHCP Acknowledge。</strong></p><p>4.12 面向连接服务与无连接服务各自的特点是什么? <strong>面向连接的服务传输数据前要先建立连接，传输完数据后释放连接，传输的数据可靠、有序，常用于文件传输等可靠性要求高的场景；无连接服务，不需要繁琐的连接过程，但是数据不保证可靠性与有序性，应用场景：常用于实时性要求较高的场景，比如实时通讯、语言通话。</strong></p><p>4.13 比较模拟通信方式与数字通信方式的优缺点？</p><p>4.14 比较 OSI 参考模型与 TCP／IP 参考模型的异同点。<strong>OSI 有 7 层，TCP/IP 有四层，OSI 的模型使用起来比较僵化，并没有得到广泛运用，是一个理论上的模型；TCP/IP 模型更具有灵活性，容易扩展，所以在实际运用中更加广泛。</strong></p><p>4.15 简述选择重传 ARQ 协议的工作原理？</p><p>4.16 为什么 FTP 协议要使用两个独立的连接，即控制连接和数据连接？<strong>使用控制连接来处理连接请求，数据连接来传输数据，能够更加灵活，提高文件传输的并发能力。</strong></p><p>4.17Internet 域名系统的主要用途是什么？<strong>它的交互过程由哪三种实体组成？将用户熟知的域名地址转为计算机可以识别的 IP 地址，交互：DNS 客户端、DNS 服务器、DNS</strong></p><p>4.18 动态路由算法有那些？<strong>距离向量路由算法（RIP），链路状态路由算法（OSPF）</strong></p><p>4.19 为什么要进行流量控制？<strong>防止数据丢失，减轻服务器的压力，减少成本。</strong></p><p>4.20 主机间的通信方式？</p><h2 id="5-数据库"><a href="#5-数据库" class="headerlink" title="5. 数据库"></a>5. 数据库</h2><p> 5.1 事务指的是满足 ACID 特性的一组操作，那 ACID 具体指的是啥？<strong>原子性、一致性、隔离性、持久性</strong></p><p>5.2 事务的并发一致性问题有那些？<strong>幻读、脏读、不可重复读，幻读是指</strong></p><p>5.3 不符合范式的关系，会产生很多异常，主要有那些异常？<strong>数据冗余</strong></p><p>5.4 范式有那些，具体讲讲？<strong>从低到高主要有：1NF、2NF、3NF、BCNF、4NF、5NF。</strong></p><p>5.5 数据的完整性是指数据的正确性和相容性，防止不合语义的数据进入数据库。</p><p>5.6 E-R 图的三种冲突? <strong>E-R 图是实体关系图，用来表示数据库概念模型，包含事物、属性和事物之间的关系。三种冲突包括：属性冲突、命名冲突、结构冲突，冲突是在合并 ER 图的时候发生的。</strong></p><p>5.7 视图的作用？<strong>视图它本身并不包含数据，他只是查看保存在别处的数据的一种操作。作用：简化 SQL 操作，重用 SQL 语句，可以使用它来实现用户权限管理</strong></p><p>5.8 数据库安全性控制的一般方法有那些？<strong>访问控制、加密操作</strong></p><p>5.9 索引的设计原则？</p><p>5.10 数据库故障可分为？</p><p>5.11 自然连接与等值连接的区别？<strong>自然连接是一种特殊的等值连接</strong></p><p>5.12 范式的定义？<strong>范式是数据库表设计时的一种规范，是为了减少数据冗余，提高数据一致性的一种方法，主要有三大范式：1NF、2NF、3NF，其中第一范式是确保数据表的每一列都是原子的，不能再分割；第二范式，再第一范式的基础上，每一张表的非主属性必须完全依赖于候选键，不能只依赖于候选键的一部分；第三范式，在第二范式的基础上，非主属性之间不能含有依赖关系，没有传递依赖，非主属性只能依赖于候选键。</strong></p><p>5.13 索引建的多的好还是少的好？<strong>索引类似目录，Mysql 的 InnoDB 引擎默认使用 B+ 树作为索引，需要额外的空间去保存索引，索引的建立要适度，建立太多了，维护索引表的修改需要太多资源，浪费了，索引建立过少，又不能达到加快检索数据速度的效果。</strong></p><p>5.13.5 为什么 Mysql 采用 B+ 树作为索引，而不是 B 树？<strong>这涉及到了 B+ 树的优点，由于 B+ 树的非叶子节点并不保存数据的具体内容，只保存了一部分查找相关的必要信息，数据库读一次内存可以查找的数据的范围要比 B 树大得多，减少了内存读取次数，并且 B+ 树的叶子节点形成了一个双链表，可以实现范围查找，加快了查找顺序。</strong></p><p>5.14 数据模型有哪几种？</p><h2 id="6-软件工程"><a href="#6-软件工程" class="headerlink" title="6. 软件工程"></a>6. 软件工程</h2><p>6.0 软件工程的认识？</p><p>6.1 软件重用？<strong>软件重用是指在开发软件的过程中，利用已有的软件模块、代码，来开发其他的软件，这样可以节约成本，减少人员的重复劳动，提高软件开发的效率，比如我自己项目中用的muduo 库、Json 库都是别的团队已经开发好的，经历过许多迭代和优化好的库。有几种常见的方法来实现软件重用：模块化开发、设计库和框架、利用设计模式。</strong></p><p>6.2 软件测试类型？<strong>软件测试是指在软件发布前，使用各种方法来测试软件的质量、可行性、安全性，发现软件潜在的问题。类型有：单元测试、集成测试、性能测试、灾难恢复测试等，单元测试是针对软件中最小可测试单元进行测试，通常是一个函数；集成测试：测试多个单元模块组合后交互的测试。性能测试：是测试软件在不同负载能力下的表现，如响应速度、系统吞吐率。灾难恢复性测试：是指测试软件系统在灾难发生时的软件应对能力，如数据备份能力、系统恢复能力。</strong></p><p>6.3 软件工程步骤？<strong>软件生命周期，一般步骤：问题定义、可行性分析、需求分析、软件的开发（设计、实现、测试）、维护（软件上线后肯定是不完美的，需要不断地收集错误反馈，改bug）。</strong></p><p>6.4 UML？<strong><a href="https://refactoringguru.cn/design-patterns/factory-method/cpp/example">https://refactoringguru.cn/design-patterns/factory-method/cpp/example</a> 设计模式没看完</strong></p><h2 id="7-项目"><a href="#7-项目" class="headerlink" title="7. 项目"></a>7. 项目</h2><p>7.1. 项目背景和创新点？</p><p>7.2. 项目用到了哪些技术？</p><p>7.3. 毕业设计(重点)？</p><p>7.4. 项目中的难点以及如何解决？</p><p>7.5. 项目中还有哪些可以继续改进？</p><h2 id="8-其他"><a href="#8-其他" class="headerlink" title="8. 其他"></a>8. 其他</h2><p>8.1 进程和线程的区别与联系？<strong>联系：一个进程必须有一个线程，给进程分配资源，实际运行的是线程，进程内的线程共享进程的各种资源。区别：线程是调度的基本单位，进程是分配资源的基本单位，在撤销进程时，进程内的线程也要被撤销，并且回收其资源，所以撤销进程的开销比撤销线程的开销要大很多。</strong></p><p>8.2 常见的进程调度算法？<strong>先来先服务算法、短作业优先算法、高响应比优先算法、时间片轮转调度算法。</strong></p><p>8.3 页面置换算法？<strong>先进先出页面置换算法，最近最少使用算法</strong></p><p>8.4 什么是虚拟内存？ <strong>将部分数据保存在硬盘中，在实际需要时再调入内存，程序中使用的地址其实都是虚拟内存地址，需要通过内存管理单元（MMU）来实现虚拟地址到物理地址的转换，虚拟存储是为了更好的支持程序的并发执行，让每个进程以为自己独占一片内存空间，但是实际上运行时，只有一部分经常访问的页面保存在内存中（这个是页面管理机制）。</strong></p><p>8.5 常见的查找算法？<strong>顺序查找、二分法查找，插值查找：适合各个值均匀分布的查找算法，通过计算查找的值在查找区间内的比例期望值，得到一个期望的位置，并且这个区间会一直缩小，直到找到该元素。斐波那契查找：通过斐波那契查找算法分割时，分割后的两段也会呈现出黄金分割的特点（这可真是计算机大佬们的硬核审美啊 ~~）</strong></p><p>8.6 浮点数的处理？<strong>通常使用的是 IEEE754 的标准，浮点数的组成：比如 32 位的浮点数，位符号位，8 位指数位，23 位尾数位，浮点数的乘法操作：符号位异或操作处理，指数部分相加，尾数部分相乘，最后进行规格化和舍入操作；浮点数的加法操作：对阶（小阶向大阶对齐），符号🔣相同，尾数相加，不同，尾数相减，最后进行规格化和舍入操作。</strong></p><p>8.7. cache 的作用是什么？<strong>cache 介于 CPU 和内存之间，CPU 的速度远高于内存，为了缓和两者之间的速度差，加入了 cache，暂时保存从内存读取的数据，提高系统的性能。Cache 保存的是最近读取数据的副本，指的是 Cache 中含有的内容，主存中一定会有，利用的是程序的局部性原理，该原理有时间局部性和空间局部性。</strong></p><p>8.9. 解释 TCP 为什么需要三次握手？<strong>TCP 协议是面向连接的协议，过程：第一次客户端发过去，第二次服务器回复，第三次还是客户端回复。三次握手可以保证不出现错误连接，比如旧连接重新发送。在两次握手的情况下，服务端没有中间状态给客户端来阻止历史连接，导致服务端可能建立一个历史连接，造成资源浪费。</strong></p><p>8.10.TCP 如何解决拥塞阻塞？<strong>提供一种基于滑动窗口机制的流量控制协议，当发生拥塞时，拥塞窗口可以动态的变化来调整以适应网络情况，采用了：慢开始算法、拥塞避免算法、快重传、快恢复。</strong></p><p>8.11. 说说快排的过程，时间复杂度？<strong>首先选择一个中轴，然后将元素划分为小于中轴的和大于中轴的，这只是一趟操作，然后下面的每一趟递归的选择左半边、右半边。平均时间复杂度是：O(nlog_2n).</strong></p><p>8.12. 你最常用的语言是什么，为什么？<strong>我最常用的语言是 C++，我最开始接触的是 C 语言，但是但是并没有去深入学习，学完学校课程就抛之脑后了，后面又接触了 Java，发现这个语言真的很方便快速的上手，但是学了一段时间后，总有种模模糊糊的感觉，像是空中楼阁一般，后面接触了 C++，利用它来解一些计算机的底层的世界，用它来学操作系统、计算机网络等专业基础知识。</strong></p><p>8.12.5 为什么说 Java 对比 C++ 是空中楼阁？<strong>首先我们知道 Java 是更安全的，那就是因为它限制了一些系统级的操作，导致的，并且 Java 的内存是由系统自动回收的，而 C++ 程序员可以自动管理内存的分配与释放，虽然手动管理内存很危险，但是可以更加精确的控制内存，性能更好。</strong></p><p>8.13 电脑中的视频是如何保存的？<strong>视频就是会动的画面和声音组成的，通过特定的编码方式保存好图片帧序列和音频序列，实现会动的画面可以通过一秒内连续播放很多张动作连续的图片，可以理解为帧数（60 帧、120 帧），所以视频的保存是按照一定的编码方式保存很多张图片和相对应的音频编码组成。视频在播放的时候需要采用解码算法，将图片帧序列和音频序列解压缩，这样实现视频的清晰度和文件大小的兼顾。</strong></p><p>8.14 电脑中的图片是怎么保存的？<strong>图片由一个个像素点保存，像素点如果是黑白的，是由一个 0-255 之间的数字表示，表黑的程度，如果是有彩色的，加入了 RGB 三个方面的色彩的数字，保存的是一个点阵序列，然后采用特定的解码方式将其显示出来。</strong></p><p>8.15 电脑中的声音是如何保存的？<strong>首先是声音的采集，将声波转为数字信号，然后以特定的编码保存在电脑中。</strong></p><h2 id="9-前沿技术"><a href="#9-前沿技术" class="headerlink" title="9. 前沿技术"></a>9. 前沿技术</h2><p>9.1 对人工智能的了解，强人工智能可实现吗？<strong>人工智能是一种研究如何让机器有类似于人类的能力的学科，在语音识别、图像识别、机器学习等领域有重大意义，强人工智能是指拥有人类思维能力、有一定的情感的机器人，目前的强人工智能，还需要技术和创新。</strong></p><p>9.2 什么是机器学习？讲讲具体的算法？<strong>机器学习旨在让计算机从大量的数据中学习到其中的规律，根据训练方法的不同，分为：监督学习、无监督学习，半监督学习、深度学习，机器学习的流程：收集数据、分析数据、建立模型、开始训练、最后测试结果。</strong></p><p>9.3 什么是大数据？你接触到最大的数据有多少？<strong>大数据就是从大量的数据中获取有价值的东西，因为数据量比较庞大，其实有很多数据是无用的，所以需要通过分析其规律、整合，并且数据量过大，也产生了一些问题，比如存储问题、数据安全问题、数据管理问题。</strong></p><p>9.4 什么是数据挖掘？<strong>应对当前大量数据产生的时代，挖掘大量数据背后的规律、价值，用于业务决策，它可以帮助机构和企业更好地理解他们的数据，从中发现商业机会、优化流程，甚至预测未来趋势。</strong></p><p>9.5 大数据和机器学习之间有什么联系？</p><p>9.6 什么是深度学习？<strong>就把什么梯度下降 反向传播激活函数（看不到）这些基本的学懂就行 然后把所用的深度学习框架了解一下 比如 pytorch</strong></p><p>9.7 梯度下降算法？<strong>梯度下降是一种优化算法，用于将损失函数最小化，损失函数越小，表明模型与数据的拟合程度越小</strong></p><p>9.8 pytorch？<strong>pytorch 可以实现快速训练、构建和调试复杂的神经网络模型。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 408 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>if-else对比switch-case</title>
      <link href="/2024/07/02/if-else-dui-bi-switch-case/"/>
      <url>/2024/07/02/if-else-dui-bi-switch-case/</url>
      
        <content type="html"><![CDATA[<h1 id="if-else对比switch-case"><a href="#if-else对比switch-case" class="headerlink" title="if-else对比switch-case"></a>if-else对比switch-case</h1><p>在听CSAPP的Lecture 06 Machine Level Programming || Control的时候，里面老师回答学生问题时，说到switch-case在汇编层面会建立一个表，然后好奇这个表是什么样子的，查询了一些资料，发现也挺有趣的。</p><h2 id="代码片段"><a href="#代码片段" class="headerlink" title="代码片段"></a>代码片段</h2><p>这里对比使用的代码片段</p><p><a href="https://godbolt.org/z/7ahx7aaxT">https://godbolt.org/z/7ahx7aaxT</a></p><h2 id="if-else分析"><a href="#if-else分析" class="headerlink" title="if-else分析"></a>if-else分析</h2><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">foo_ifelse(char):        push    rbp        mov     rbp, rsp        mov     eax, edi        mov     BYTE PTR [rbp-4], al        cmp     BYTE PTR [rbp-4], 48        je      .L2        cmp     BYTE PTR [rbp-4], 49        jne     .L3.L2:        movzx   eax, BYTE PTR [rbp-4]        add     eax, 1        mov     BYTE PTR [rbp-4], al        jmp     .L4.L3:        cmp     BYTE PTR [rbp-4], 97        je      .L5        cmp     BYTE PTR [rbp-4], 98        jne     .L6.L5:        movzx   eax, BYTE PTR [rbp-4]        add     eax, 2        mov     BYTE PTR [rbp-4], al        jmp     .L4.L6:        cmp     BYTE PTR [rbp-4], 65        je      .L7        cmp     BYTE PTR [rbp-4], 66        jne     .L8.L7:        movzx   eax, BYTE PTR [rbp-4]        add     eax, 3        mov     BYTE PTR [rbp-4], al        jmp     .L4.L8:        movzx   eax, BYTE PTR [rbp-4]        add     eax, 4        mov     BYTE PTR [rbp-4], al.L4:        movsx   eax, BYTE PTR [rbp-4]        pop     rbp        ret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从上面可以看出，if-else是按照值一个一个的对比，重复使用cmp、je、jne等指令，如果满足条件就跳转，否则处理下一个值的分支，并不会对整个对比分支的选项进行整理与优化。</p><p>可以看出，如果处理1000个，甚至10000个连续分支的话，效率是非常低的（并不对其采用二分法、哈希表的优化），这时候还需要注意把命中率高的分支放在前面。</p><h2 id="switch-case分析"><a href="#switch-case分析" class="headerlink" title="switch-case分析"></a>switch-case分析</h2><h3 id="foo-switch1-char-分析："><a href="#foo-switch1-char-分析：" class="headerlink" title="foo_switch1(char)分析："></a>foo_switch1(char)分析：</h3><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">foo_switch1(char):        push    rbp        mov     rbp, rsp        mov     eax, edi        mov     BYTE PTR [rbp-4], al        movsx   eax, BYTE PTR [rbp-4]        cmp     eax, 98        jg      .L11        cmp     eax, 97        jge     .L12        cmp     eax, 49        jg      .L13        cmp     eax, 48        jge     .L14        jmp     .L11.L13:        sub     eax, 65        cmp     eax, 1        ja      .L11        jmp     .L18.L14:        movzx   eax, BYTE PTR [rbp-4]        add     eax, 1        mov     BYTE PTR [rbp-4], al        jmp     .L16.L12:        movzx   eax, BYTE PTR [rbp-4]        add     eax, 2        mov     BYTE PTR [rbp-4], al        jmp     .L16.L18:        movzx   eax, BYTE PTR [rbp-4]        add     eax, 3        mov     BYTE PTR [rbp-4], al        jmp     .L16.L11:        movzx   eax, BYTE PTR [rbp-4]        add     eax, 4        mov     BYTE PTR [rbp-4], al        nop.L16:        movsx   eax, BYTE PTR [rbp-4]        pop     rbp        ret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>首先编译器分析各个分支后，先与最大值进行对比，如果比它大，则直接跳转到default分支；否则，处理其他分支。在同时处理大小写字符时，编译器还有<code>.L13</code>的分支，将小写字母sub 65转化为处理大写字母，这也是一种优化策略。</p><h3 id="foo-switch2-char-分析"><a href="#foo-switch2-char-分析" class="headerlink" title="foo_switch2(char)分析"></a>foo_switch2(char)分析</h3><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">.LC0:        .string &quot;a &#x3D; 1&quot;.LC1:        .string &quot;a &#x3D; 2&quot;.LC2:        .string &quot;a &#x3D; 3&quot;.LC3:        .string &quot;a &#x3D; 4&quot;.LC4:        .string &quot;a &#x3D; 5&quot;.LC5:        .string &quot;a &#x3D; 6&quot;.LC6:        .string &quot;other number&quot;foo_switch2(char):        push    rbp        mov     rbp, rsp        sub     rsp, 32        mov     eax, edi        mov     BYTE PTR [rbp-20], al        mov     DWORD PTR [rbp-4], 2        cmp     DWORD PTR [rbp-4], 6        ja      .L20        mov     eax, DWORD PTR [rbp-4]        mov     rax, QWORD PTR .L22[0+rax*8]        jmp     rax.L22:        .quad   .L20        .quad   .L27        .quad   .L26        .quad   .L25        .quad   .L24        .quad   .L23        .quad   .L21.L27:        mov     esi, OFFSET FLAT:.LC0        mov     edi, OFFSET FLAT:std::cout        call    std::basic_ostream&lt;char, std::char_traits&lt;char&gt; &gt;&amp; std::operator&lt;&lt; &lt;std::char_traits&lt;char&gt; &gt;(std::basic_ostream&lt;char, std::char_traits&lt;char&gt; &gt;&amp;, char const*)        mov     esi, OFFSET FLAT:std::basic_ostream&lt;char, std::char_traits&lt;char&gt; &gt;&amp; std::endl&lt;char, std::char_traits&lt;char&gt; &gt;(std::basic_ostream&lt;char, std::char_traits&lt;char&gt; &gt;&amp;)        mov     rdi, rax        call    std::basic_ostream&lt;char, std::char_traits&lt;char&gt; &gt;::operator&lt;&lt;(std::basic_ostream&lt;char, std::char_traits&lt;char&gt; &gt;&amp; (*)(std::basic_ostream&lt;char, std::char_traits&lt;char&gt; &gt;&amp;))        jmp     .L28.............L20:        mov     esi, OFFSET FLAT:.LC6        mov     edi, OFFSET FLAT:std::cout        call    std::basic_ostream&lt;char, std::char_traits&lt;char&gt; &gt;&amp; std::operator&lt;&lt; &lt;std::char_traits&lt;char&gt; &gt;(std::basic_ostream&lt;char, std::char_traits&lt;char&gt; &gt;&amp;, char const*)        mov     esi, OFFSET FLAT:std::basic_ostream&lt;char, std::char_traits&lt;char&gt; &gt;&amp; std::endl&lt;char, std::char_traits&lt;char&gt; &gt;(std::basic_ostream&lt;char, std::char_traits&lt;char&gt; &gt;&amp;)        mov     rdi, rax        call    std::basic_ostream&lt;char, std::char_traits&lt;char&gt; &gt;::operator&lt;&lt;(std::basic_ostream&lt;char, std::char_traits&lt;char&gt; &gt;&amp; (*)(std::basic_ostream&lt;char, std::char_traits&lt;char&gt; &gt;&amp;))        nop.L28:        nop        leave        ret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>省略号部分和<code>.L27</code>部分类似，只是将开始的<code>.LC0</code>做替换。</p><p>首先与switch-case语句的最大值比较，如果大于可以直接跳转到default语句；否则，加载局部变量的值到eax中，根据这个值作为索引，计算跳转的地址。</p><p>标记<code>.L22</code>处<code>.quad</code>表示当前位置分配了8个字节的存储空间，后面跟着的数值(或标签)会被放置在这 8 个字节的内存空间中，通常用于定义 64 位整数或指针类型的数据。此处7个<code>.quad</code>代表这段代码包含了7 个 64 位值的数据表，用于实现之前提到的 switch-case 结构中的跳转表。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如果if-else不进行二分、哈希等优化，switch-case结构的执行效率高，是以空间（跳转表）换时间的一种策略。</p><h2 id="巨人的肩膀"><a href="#巨人的肩膀" class="headerlink" title="巨人的肩膀"></a>巨人的肩膀</h2><p><a href="https://www.jeremyjone.com/546/">https://www.jeremyjone.com/546/</a></p><p><a href="https://www.eet-china.com/mp/a19622.html">https://www.eet-china.com/mp/a19622.html</a></p>]]></content>
      
      
      <categories>
          
          <category> c++进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++疑难点</title>
      <link href="/2024/03/08/c-yi-nan-dian/"/>
      <url>/2024/03/08/c-yi-nan-dian/</url>
      
        <content type="html"><![CDATA[<h1 id="C-疑难点"><a href="#C-疑难点" class="headerlink" title="C++疑难点"></a>C++疑难点</h1><p>什么人间绝味</p><p>无非情怀半碗</p><p>温柔几滴</p><p>往事一勺</p><p>乡愁少许</p><h2 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h2><p>调用成员函数时，成员函数通过一个名为 this 的隐式参数来访问调用它的那个对象，用请求该函数的对象地址初始化 this ，this 的指向总是自己这个对象，所以 this 是一个常量指针</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Box<span class="token operator">*</span> <span class="token function">get_address</span><span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token comment">//得到this的地址</span><span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>Box<span class="token operator">*</span> <span class="token function">get_address</span><span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token comment">//得到this的地址</span><span class="token punctuation">&#123;</span>Box box<span class="token punctuation">;</span><span class="token keyword">this</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>box<span class="token punctuation">;</span> <span class="token comment">// error: lvalue required as left operand of assignment</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="深拷贝问题"><a href="#深拷贝问题" class="headerlink" title="深拷贝问题"></a>深拷贝问题</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstring></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">String</span><span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span><span class="token function">String</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span>str<span class="token operator">=</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">String</span><span class="token punctuation">(</span><span class="token keyword">const</span> String<span class="token operator">&amp;</span> other<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">~</span><span class="token function">String</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>String<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> String<span class="token operator">&amp;</span>rhs<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">private</span><span class="token operator">:</span><span class="token keyword">char</span><span class="token operator">*</span> m_data<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token class-name">String</span><span class="token double-colon punctuation">::</span><span class="token function">String</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span>str<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span><span class="token punctuation">(</span>str<span class="token operator">==</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>m_data <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>m_data<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token char">'\0'</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>m_data <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token function">strlen</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token function">strcpy</span><span class="token punctuation">(</span>m_data<span class="token punctuation">,</span> str<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token class-name">String</span><span class="token double-colon punctuation">::</span><span class="token operator">~</span><span class="token function">String</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span><span class="token punctuation">(</span>m_data<span class="token operator">!=</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span> m_data<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>String<span class="token operator">&amp;</span> String<span class="token double-colon punctuation">::</span><span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> String<span class="token operator">&amp;</span> other<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">==</span> <span class="token operator">&amp;</span>other<span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span><span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span> m_data<span class="token punctuation">;</span>m_data <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token function">strlen</span><span class="token punctuation">(</span>other<span class="token punctuation">.</span>m_data<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token function">strcpy</span><span class="token punctuation">(</span>m_data<span class="token punctuation">,</span> other<span class="token punctuation">.</span>m_data<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="友元函数和运算符重载"><a href="#友元函数和运算符重载" class="headerlink" title="友元函数和运算符重载"></a>友元函数和运算符重载</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cmath></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">MyInteger</span><span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span><span class="token function">MyInteger</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">this</span><span class="token operator">-></span>num_ <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token function">MyInteger</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">num_</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>MyInteger <span class="token keyword">operator</span><span class="token operator">+</span><span class="token punctuation">(</span><span class="token keyword">const</span> MyInteger <span class="token operator">&amp;</span>other<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>MyInteger temp<span class="token punctuation">;</span>temp<span class="token punctuation">.</span>num_ <span class="token operator">=</span> <span class="token keyword">this</span><span class="token operator">-></span>num_ <span class="token operator">+</span> other<span class="token punctuation">.</span>num_<span class="token punctuation">;</span><span class="token comment">// this->num_ += m.num_; // 这违反了加法运算符的语义，加法运算通常是创建一个新的对象来保存结果，而不是改变原始对象。</span><span class="token keyword">return</span> temp<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>MyInteger <span class="token keyword">operator</span><span class="token operator">+</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>other<span class="token punctuation">)</span> <span class="token comment">// 运算符重载</span><span class="token punctuation">&#123;</span>MyInteger temp<span class="token punctuation">;</span>temp<span class="token punctuation">.</span>num_ <span class="token operator">=</span> <span class="token keyword">this</span><span class="token operator">-></span>num_ <span class="token operator">+</span> other<span class="token punctuation">;</span><span class="token keyword">return</span> temp<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>MyInteger <span class="token keyword">operator</span><span class="token operator">+=</span><span class="token punctuation">(</span><span class="token keyword">const</span> MyInteger <span class="token operator">&amp;</span>other<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>MyInteger temp<span class="token punctuation">;</span>temp<span class="token punctuation">.</span>num_ <span class="token operator">=</span> <span class="token keyword">this</span><span class="token operator">-></span>num_ <span class="token operator">+</span> other<span class="token punctuation">.</span>num_<span class="token punctuation">;</span><span class="token keyword">return</span> temp<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>MyInteger <span class="token keyword">operator</span><span class="token operator">+=</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>other<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>MyInteger temp<span class="token punctuation">;</span>temp<span class="token punctuation">.</span>num_ <span class="token operator">=</span> <span class="token keyword">this</span><span class="token operator">-></span>num_ <span class="token operator">+</span> other<span class="token punctuation">;</span><span class="token keyword">return</span> temp<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>MyInteger <span class="token operator">&amp;</span><span class="token keyword">operator</span><span class="token operator">++</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token operator">++</span>num_<span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>MyInteger <span class="token keyword">operator</span><span class="token operator">++</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>MyInteger <span class="token function">temp</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>num_<span class="token operator">++</span><span class="token punctuation">;</span><span class="token keyword">return</span> temp<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>MyInteger <span class="token operator">&amp;</span><span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> MyInteger <span class="token operator">&amp;</span>myInteger<span class="token punctuation">)</span> <span class="token comment">// 注意深浅拷贝问题</span><span class="token punctuation">&#123;</span>num_ <span class="token operator">=</span> myInteger<span class="token punctuation">.</span>num_<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">friend</span> ostream <span class="token operator">&amp;</span><span class="token keyword">operator</span><span class="token operator">&lt;&lt;</span><span class="token punctuation">(</span>ostream <span class="token operator">&amp;</span>out<span class="token punctuation">,</span> <span class="token keyword">const</span> MyInteger <span class="token operator">&amp;</span>myInteger<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 重载左移运算符 没加 const ，cout &lt;&lt; m++;报错</span><span class="token keyword">private</span><span class="token operator">:</span><span class="token keyword">int</span> num_<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>ostream <span class="token operator">&amp;</span><span class="token keyword">operator</span><span class="token operator">&lt;&lt;</span><span class="token punctuation">(</span>ostream <span class="token operator">&amp;</span>out<span class="token punctuation">,</span> <span class="token keyword">const</span> MyInteger <span class="token operator">&amp;</span>myInteger<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>out <span class="token operator">&lt;&lt;</span> myInteger<span class="token punctuation">.</span>num_<span class="token punctuation">;</span><span class="token keyword">return</span> out<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">test01</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>MyInteger m<span class="token punctuation">;</span>MyInteger <span class="token function">m1</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>m1 <span class="token operator">=</span> m <span class="token operator">+</span> m1<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> m <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> m1 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">test02</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>MyInteger <span class="token function">m</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>MyInteger <span class="token function">m1</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>m <span class="token operator">=</span> m1 <span class="token operator">+</span> m<span class="token punctuation">;</span>m1 <span class="token operator">+=</span> <span class="token number">10</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> m <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> m1 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">test03</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>MyInteger <span class="token function">m</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>MyInteger <span class="token function">m1</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// cout &lt;&lt; ++(++m) &lt;&lt; " " &lt;&lt; ++m1 &lt;&lt; endl;</span><span class="token comment">// cout &lt;&lt; m &lt;&lt; " ";</span>cout <span class="token operator">&lt;&lt;</span> m<span class="token operator">++</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> m<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">// test01();</span><span class="token comment">// test02();</span><span class="token function">test03</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// int a=1;</span><span class="token comment">// int b=2;</span><span class="token comment">// a=a+b;</span><span class="token comment">// cout&lt;&lt;a&lt;&lt;" "&lt;&lt;b&lt;&lt;endl;</span><span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> c<span class="token operator">++</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> c <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中后置++运算符返回值是局部变量，不能返回&amp;，即对象的引用，局部变量在函数运行结束后就销毁了。</p><h2 id="类型转换运算符重载"><a href="#类型转换运算符重载" class="headerlink" title="类型转换运算符重载"></a>类型转换运算符重载</h2><p>可以实现两个类之间使用=赋值</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">A</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">B</span><span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span><span class="token keyword">operator</span> <span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>A a<span class="token punctuation">;</span>B b<span class="token punctuation">;</span>a<span class="token operator">=</span>b<span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="不能重载的运算符"><a href="#不能重载的运算符" class="headerlink" title="不能重载的运算符"></a>不能重载的运算符</h2><p>.，:: ，?:，sizeof，typeid，.* 这几个运算符不能被重载</p><h2 id="C-编译器至少给一个类提供四个函数"><a href="#C-编译器至少给一个类提供四个函数" class="headerlink" title="C++编译器至少给一个类提供四个函数"></a>C++编译器至少给一个类提供四个函数</h2><p>1、构造函数</p><p>2、析构函数</p><p>3、拷贝构造函数</p><p>4、operator= 函数</p><h2 id="多态的实现"><a href="#多态的实现" class="headerlink" title="多态的实现"></a>多态的实现</h2><p>多态实现的前提三个条件</p><p>1、必须是共有继承</p><p>2、通过基类指针指向派生类，并且访问派生类重写的方法。</p><p>3、基类中的被重写的方法是<strong>虚函数</strong></p><p>这种技术让父类指针有<strong>多种形态</strong>，是一种泛型技术，直到运行时才决定执行哪个版本的函数。所谓<strong>泛型技术</strong>，就是使用不变的代码来实现可变的算法。多态中没有重写的函数是没有意义的。</p><p>水能载舟，亦能覆舟。多态也涉及了<strong>安全性</strong>的问题，</p><p>首先是无法访问子类中自己的虚函数，如<code>Base * base=new Derived(); base-&gt;f1();</code>编译时不会通过的（其中f1()是子类自己的虚函数，父类没有）；</p><p>然后是如果父类中虚函数是private或者protected，这些函数依旧会存在于虚函数表中，可以通过多态的方式来访问。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Father</span><span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        cout<span class="token operator">&lt;&lt;</span><span class="token string">"hello Father!"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Son</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Father</span></span><span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"hello Son!"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    Son s<span class="token punctuation">;</span>    Father <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>s<span class="token punctuation">;</span>    p<span class="token operator">-></span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Father f<span class="token punctuation">;</span>    p<span class="token operator">=</span><span class="token operator">&amp;</span>f<span class="token punctuation">;</span>    p<span class="token operator">-></span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="菱形继承的问题"><a href="#菱形继承的问题" class="headerlink" title="菱形继承的问题"></a>菱形继承的问题</h2><p>继承关系画成图像一个菱形，所以就叫做菱形继承，采用<strong>虚继承</strong>来解决二义性问题。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">A</span><span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span><span class="token keyword">int</span> n<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">virtual</span> <span class="token keyword">public</span> <span class="token class-name">A</span></span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">C</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">virtual</span> <span class="token keyword">public</span> <span class="token class-name">A</span></span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">D</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">A</span></span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">E</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">B</span><span class="token punctuation">,</span> <span class="token keyword">public</span> <span class="token class-name">C</span><span class="token punctuation">,</span> <span class="token keyword">public</span> <span class="token class-name">D</span></span><span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span><span class="token keyword">int</span> <span class="token function">getn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> B<span class="token double-colon punctuation">::</span>n<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>E d<span class="token punctuation">;</span>d<span class="token punctuation">.</span>B<span class="token double-colon punctuation">::</span>n <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>d<span class="token punctuation">.</span>C<span class="token double-colon punctuation">::</span>n <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>d<span class="token punctuation">.</span>D<span class="token double-colon punctuation">::</span>n <span class="token operator">=</span> <span class="token number">30</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> d<span class="token punctuation">.</span>B<span class="token double-colon punctuation">::</span>n <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> d<span class="token punctuation">.</span>C<span class="token double-colon punctuation">::</span>n <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> d<span class="token punctuation">.</span>D<span class="token double-colon punctuation">::</span>n <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> d<span class="token punctuation">.</span><span class="token function">getn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以先在脑子里想一下结果，然后可以运行一下看看是否与其一致，有助于理解哦。</p><h2 id="虚析构"><a href="#虚析构" class="headerlink" title="虚析构"></a>虚析构</h2><p>总的来说是为了避免内存泄漏，利用基类指针释放派生类对象的内存。也就是说，虚析构函数使得删除指向子类的父类指针时，不仅可以调用父类的的析构函数，也会调用子类的析构函数，这样就可以释放子类指针成员变量在堆中的内存，达到防止内存泄漏的目的。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;bits/stdc++.h></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">CA</span><span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">CA</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"CA"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"CA::f1( )"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>        <span class="token comment">// f2();</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">void</span> <span class="token function">f2</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"CA::f2( )"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">virtual</span> <span class="token operator">~</span><span class="token function">CA</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"~CA"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">CB</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">CA</span></span><span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">CB</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"CB"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"CB::f1( )"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">void</span> <span class="token function">f2</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"CB::f2( )"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">virtual</span> <span class="token operator">~</span><span class="token function">CB</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"~CB"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">CC</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">CB</span></span><span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">CC</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"CC"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>    <span class="token keyword">void</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        cout<span class="token operator">&lt;&lt;</span><span class="token string">"CC:f1()"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">void</span> <span class="token function">f2</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"CC:f2()"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">virtual</span> <span class="token operator">~</span><span class="token function">CC</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"~CC"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    CA <span class="token operator">*</span>pA <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">CC</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    pA<span class="token operator">-></span><span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">delete</span> pA<span class="token punctuation">;</span>    CA <span class="token operator">*</span>pA1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">CB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    pA1<span class="token operator">-></span><span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">delete</span> pA<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//注意看构造和析构的顺序，正好是相反的</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="运用运算符delete删除一个动态对象时，是先调用析构函数还是先释放对象内存"><a href="#运用运算符delete删除一个动态对象时，是先调用析构函数还是先释放对象内存" class="headerlink" title="运用运算符delete删除一个动态对象时，是先调用析构函数还是先释放对象内存"></a>运用运算符delete删除一个动态对象时，是先调用析构函数还是先释放对象内存</h2><p>当使用 <code>delete</code> 运算符删除动态分配的对象时，会<strong>先调用对象的析构函数来执行清理操作，然后再释放对象所占用的内存。</strong></p><p>如果先释放内存而不调用析构函数，就无法确保对象所占用的资源被正确释放，可能导致内存泄漏的问题，即程序无法再访问这些内存区域，但却无法再对其进行释放，造成系统资源浪费。</p><h2 id="g-和gcc的区别"><a href="#g-和gcc的区别" class="headerlink" title="g++和gcc的区别"></a>g++和gcc的区别</h2><p>面试的时候，问到了gcc和g++的区别，没答上来： </p><p>   首先说明：gcc 和 GCC 是两个不同的东西   </p><p>   GCC:GNU Compiler Collection(GNU 编译器集合)，它可以编译C、C++、JAV、Fortran、Pascal、Object-C、Ada等语言。   </p><p>   gcc是GCC中的GNU C Compiler（C 编译器）   </p><p>   g++是GCC中的GNU C++ Compiler（C++编译器）   </p><p>​    一个有趣的事实就是，就本质而言，gcc和g++并不是编译器，也不是编译器的集合，它们只是一种驱动器，根据参数中要编译的文件的类型，调用对应的GUN编译器而已，比如，用gcc编译一个c文件的话，会有以下几个步骤：    </p><p>​    Step1：Call a preprocessor, like cpp.    </p><p>​    Step2：Call an actual compiler, like cc or cc1.    </p><p>​    Step3：Call an assembler, like as.    </p><p>​    Step4：Call a linker, like ld    </p><p>​    由于编译器是可以更换的，所以gcc不仅仅可以编译C文件    </p><p>​    所以，更准确的说法是：gcc调用了C compiler，而g++调用了C++ compiler    </p><p>​    gcc和g++的<strong>主要区别</strong>：    </p><ol><li><p>对于 <em>.c和</em>.cpp文件，gcc分别当做c和cpp文件编译（c和cpp的语法强度是不一样的）    </p></li><li><p>对于 <em>.c和</em>.cpp文件，g++则统一当做cpp文件编译    </p></li><li><p>使用g++编译文件时，<strong>g++会自动链接标准库STL，而gcc不会自动链接STL</strong>    </p></li><li><p>gcc在编译C文件时，可使用的预定义宏是比较少的    </p></li><li><p>gcc在编译cpp文件时/g++在编译c文件和cpp文件时（这时候gcc和g++调用的都是cpp文件的编译器）</p></li></ol><h2 id="关于内联函数"><a href="#关于内联函数" class="headerlink" title="关于内联函数"></a>关于内联函数</h2><p>一般是加快程序执行速度，可能减小可执行文件大小，可能增加可执行文件大小。</p><p>速度快：当函数体较短时，内敛函数会像宏一样展开，所以执行速度比一般函数要快。但是如果函数体过大，一般的编译器会放弃内联方式，意思就是你使用内联函数，只不过是向编译器提出了一个申请，编译器可以拒绝，这个函数又会像普通函数一样，执行效率也和普通函数一样。</p><p>减小可执行文件大小：内联函数适度</p><p>增加可执行文件大小：内联函数过多</p><h2 id="仿函数"><a href="#仿函数" class="headerlink" title="仿函数"></a>仿函数</h2><p>在c++中仿函数（Functor）是一个类或者结构体，重载了函数调用运算符<code>()</code>，它的主要作用是提供一种更加灵活的函数对象，它可以包含状态信息，并且可以被传递给算法或者函数，从而实现定制的行为。比如实现<strong>排序准则、查找准则、谓词（就是一个bool返回值的函数）</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;algorithm></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">Print</span><span class="token punctuation">(</span><span class="token keyword">int</span> val<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>cout<span class="token operator">&lt;&lt;</span>val<span class="token operator">&lt;&lt;</span><span class="token string">" "</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> <span class="token class-name">Print1</span><span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span> val<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>cout<span class="token operator">&lt;&lt;</span>val<span class="token operator">&lt;&lt;</span><span class="token string">" "</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">test01</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> v<span class="token punctuation">;</span>    v<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    v<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token number">66</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">for_each</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> v<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">Print1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cout<span class="token operator">&lt;&lt;</span>endl<span class="token operator">&lt;&lt;</span><span class="token string">"--------------"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    <span class="token function">for_each</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> v<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> Print<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">test01</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="pointer-like-class的作用"><a href="#pointer-like-class的作用" class="headerlink" title="pointer-like-class的作用"></a>pointer-like-class的作用</h2><p><code>pointer-like-class</code>是指类似指针的类，这种类一般用来模拟指针的行为，但是与裸指针相比具有更多的功能和安全性，如智能指针（Smart Pointers）、迭代器（Iterators）。Smart Pointers有<code>std::unique_ptr</code>和<code>std::shared_ptr</code>、<code>std::weak_ptr</code>。</p><h1 id="一：结构化程序设计方法"><a href="#一：结构化程序设计方法" class="headerlink" title="一：结构化程序设计方法"></a>一：结构化程序设计方法</h1><h2 id="位运算及其运用"><a href="#位运算及其运用" class="headerlink" title="位运算及其运用"></a>位运算及其运用</h2><p>判断奇数还是偶数</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> a<span class="token operator">=</span><span class="token number">11</span><span class="token punctuation">;</span><span class="token keyword">int</span> b<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>b<span class="token operator">&amp;</span>a<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"is odd"</span> <span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>cout<span class="token operator">&lt;&lt;</span> <span class="token string">"is even"</span> <span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>取出指定的位</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> a<span class="token operator">=</span><span class="token number">0b11101101</span><span class="token punctuation">;</span><span class="token keyword">int</span> b<span class="token operator">=</span><span class="token number">0b1111</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token generic-function"><span class="token function">bitset</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">8</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>a<span class="token operator">&amp;</span>b<span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>判断是否为2的整数幂（0b10 0000 &amp; 0b01 1111），结果是0，说明是2的整数幂。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">64</span><span class="token punctuation">;</span><span class="token keyword">int</span> y <span class="token operator">=</span> x <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>x <span class="token operator">&amp;</span> y<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token string">"no"</span> <span class="token operator">:</span> <span class="token string">"yes"</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="指针数组与指向数组的指针的概念与使用"><a href="#指针数组与指向数组的指针的概念与使用" class="headerlink" title="指针数组与指向数组的指针的概念与使用"></a>指针数组与指向数组的指针的概念与使用</h2><p>a是一个指向含有三个int型数据数组的指针（如有int p[3]; a指向p是可以的 ）</p><p>a1是一个函数三个int*型数据的数组（如a1可以初始化为{&amp;b, &amp;c, &amp;d}）;</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;typeinfo></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">sz</span><span class="token expression"><span class="token punctuation">(</span>type<span class="token punctuation">)</span> cout<span class="token operator">&lt;&lt;</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">int</span> b<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">,</span> c<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> d<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>a<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span><span class="token operator">*</span> a1<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span> cout<span class="token operator">&lt;&lt;</span><span class="token keyword">typeid</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span> <span class="token function">sz</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">sz</span><span class="token punctuation">(</span>a1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">sz</span><span class="token punctuation">(</span>a1<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">sz</span><span class="token punctuation">(</span><span class="token operator">*</span>a<span class="token punctuation">)</span> <span class="token function">sz</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="引用的分类与使用"><a href="#引用的分类与使用" class="headerlink" title="引用的分类与使用"></a>引用的分类与使用</h2><p>1、初始化，定义引用时需要加&amp;，</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> a<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token operator">&amp;</span>b<span class="token operator">=</span>a<span class="token punctuation">;</span><span class="token comment">//相当于给a取了一个别名</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>2、作为函数参数传递，c++在函数参数中传递数组时，直接变成了指针，因为如果将数组传递过去需要将值一个一个拷贝过去，增加了函数调用的开销，所以在 C++ 中，我们有了一种比指针更加便捷的传递聚合类型数据的方式，那就是<strong>引用（Reference）</strong>，通过这种方式传过去减少了生成副本的消耗。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">&amp;</span>a<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>b<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">int</span> temp<span class="token operator">=</span>a<span class="token punctuation">;</span>a<span class="token operator">=</span>b<span class="token punctuation">;</span>b<span class="token operator">=</span>temp<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>3、作为函数返回值来传递，例如重载左移运算符，需要输出多个内容就需要返回引用。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;typeinfo></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">sz</span><span class="token expression"><span class="token punctuation">(</span>type<span class="token punctuation">)</span> cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></span></span><span class="token keyword">int</span> <span class="token function">function1</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">&amp;</span>aa<span class="token punctuation">)</span> <span class="token comment">// 以返回值的方法返回函数值</span><span class="token punctuation">&#123;</span><span class="token keyword">return</span> aa<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token operator">&amp;</span><span class="token function">function2</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">&amp;</span>aa<span class="token punctuation">)</span> <span class="token comment">// 以引用方式返回函数值</span><span class="token punctuation">&#123;</span><span class="token keyword">return</span> aa<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token comment">// 第一种情况，系统生成要返回值的副本（即临时变量）</span><span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token function">function1</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// function1()的返回值先储存在一个a的副本中，</span>  <span class="token comment">// 然后再把副本赋值给b</span><span class="token comment">// 第二种情况，报错</span><span class="token comment">//  function1(a) = 20;// function1()的返回值为临时变量，不能赋值（即不能为左值）</span><span class="token comment">// 第三种情况，系统不会生成返回值的副本</span><span class="token function">function2</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span> <span class="token comment">// OK  此时a的值变成了20</span>cout<span class="token operator">&lt;&lt;</span>a<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>重载左移运算符，返回引用才会连续输出两个值；</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Point</span><span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> x_<span class="token punctuation">,</span> y_<span class="token punctuation">;</span>    <span class="token function">Point</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">x_</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">y_</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    <span class="token keyword">friend</span> ostream <span class="token operator">&amp;</span><span class="token keyword">operator</span><span class="token operator">&lt;&lt;</span><span class="token punctuation">(</span>ostream <span class="token operator">&amp;</span>os<span class="token punctuation">,</span> <span class="token keyword">const</span> Point <span class="token operator">&amp;</span>p<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        os <span class="token operator">&lt;&lt;</span> p<span class="token punctuation">.</span>x_ <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> p<span class="token punctuation">.</span>y_ <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>        <span class="token keyword">return</span> os<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    Point <span class="token function">p</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cout<span class="token operator">&lt;&lt;</span>p<span class="token operator">&lt;&lt;</span>p<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="变量的作用域和生命周期"><a href="#变量的作用域和生命周期" class="headerlink" title="变量的作用域和生命周期"></a>变量的作用域和生命周期</h2><p>c++的内存主要分为一下几个部分：栈区、堆区、全局区（静态区）、文字常量区、程序代码区。</p><p>全局变量</p><blockquote><p>存储在静态内存分配区，整个程序的生命周期都可以使用，其他文件使用关键字extern也可以使用</p></blockquote><p>局部变量</p><blockquote><p>存储在栈区，与函数共存亡</p></blockquote><p>全局静态变量</p><blockquote><p>与全局变量类似，也是存储在静态内存分配区，生命周期与整个程序同在，不过不能再其他文件使用。</p></blockquote><p>局部静态变量</p><blockquote><p>也是存储在静态内存分配区，调用函数后便一直存在，只不过只能在函数内可见。</p></blockquote><h2 id="类型别名与类型推断"><a href="#类型别名与类型推断" class="headerlink" title="类型别名与类型推断"></a>类型别名与类型推断</h2><p>1、别名：typedef、using</p><p>2、推断：auto、decltype</p><h2 id="STL顺序容器"><a href="#STL顺序容器" class="headerlink" title="STL顺序容器"></a>STL顺序容器</h2><p>vector：视作可变大小的数组，可随机访问，在非尾部的位置插入比较慢</p><p>deque：双端队列，支持随机访问，在头尾位置插入和删除比较快</p><p>list：双向链表，支持双向顺序访问（rbegin()、rend()），在 list 任意位置插入和删除都比较快</p><p>forward_list：单向链表，只能单向顺序访问，在 forward_list 的任意位置插入和删除都比较快</p><p>array：固定大小的数组，支持随机访问，不能添加或者删除元素</p><p>string：与 vector 类似，专门保存字符串，随机访问快，在尾部插入和删除快</p><h2 id="STL关联容器"><a href="#STL关联容器" class="headerlink" title="STL关联容器"></a>STL关联容器</h2><p>map：键值对，一对一，基于红黑树，对关键字进行排序</p><p>set：只保存关键字，不重复</p><p>multimap：关键字可以重复的 map ，即一对多，如统计数学课的学生成绩</p><p>multiset：保存可以重复的关键字</p><p>unordered_map：键值对，一对一，基于哈希值，不对键值对进行排序</p><p>unordered_set：只保存关键字，不排序</p><p>unordered_multimap：键值对，一对多，基于哈希值</p><p>unordered_multiset：保存可以重复的关键字，不排序</p><h2 id="STL容器适配器"><a href="#STL容器适配器" class="headerlink" title="STL容器适配器"></a>STL容器适配器</h2><p>包括：stack、queue、priority_queue</p><p> stack 和 queue 基于deque实现， priority_queue 基于 vector 实现</p><h2 id="流对象"><a href="#流对象" class="headerlink" title="流对象"></a>流对象</h2><p>包括输入流对象（ostream，如std::cin，从键盘读取数据），输出流对象（istream，如std::cout，向屏幕写入数据）</p><p>还有文件输入流对象（ifstream，使用 std::ifstream 来创建对象，将数据从文件中读取出来），文件输出流对象（ofstream，使用 std::ofstream 来创建对象，将数据写入文件）</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;fstream></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">test01</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    ofstream file<span class="token punctuation">;</span>    file<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">"text.txt"</span><span class="token punctuation">,</span> ios<span class="token double-colon punctuation">::</span>out<span class="token punctuation">)</span><span class="token punctuation">;</span>    file <span class="token operator">&lt;&lt;</span> <span class="token string">"xinm"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    file <span class="token operator">&lt;&lt;</span> <span class="token string">"namji"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    file<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">test02</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    ifstream ifile<span class="token punctuation">;</span>    ifile<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">"text.txt"</span><span class="token punctuation">,</span> ios<span class="token double-colon punctuation">::</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>ifile<span class="token punctuation">.</span><span class="token function">is_open</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>ifile <span class="token operator">>></span> buf<span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            cout<span class="token operator">&lt;&lt;</span> buf<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    ifile<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">test02</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用二进制流读写文件</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;fstream></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Person</span><span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token comment">// Person(char name[], int age):name_(name), age_(age)&#123;&#125;</span>    <span class="token keyword">char</span> name_<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> age_<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">test01</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    ofstream file<span class="token punctuation">;</span>    file<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">"text.txt"</span><span class="token punctuation">,</span> ios<span class="token double-colon punctuation">::</span>out <span class="token operator">|</span> ios<span class="token double-colon punctuation">::</span>binary<span class="token punctuation">)</span><span class="token punctuation">;</span>    Person p <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token string">"hhhhh"</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    file<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>p<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       file<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">test02</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    ifstream ifile<span class="token punctuation">;</span>    ifile<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">"text.txt"</span><span class="token punctuation">,</span> ios<span class="token double-colon punctuation">::</span>in <span class="token operator">|</span> ios<span class="token double-colon punctuation">::</span>binary<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ifile<span class="token punctuation">.</span><span class="token function">is_open</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token comment">// 1</span>        <span class="token comment">// char buf[1024];</span>        <span class="token comment">// while(ifile >> buf)</span>        <span class="token comment">// &#123;</span>        <span class="token comment">//     cout&lt;&lt; buf&lt;&lt;endl;</span>        <span class="token comment">// &#125;</span>        <span class="token comment">// 2</span>        <span class="token comment">// char buf[1024];</span>        <span class="token comment">// while (ifile.getline(buf, sizeof(buf)))</span>        <span class="token comment">// &#123;</span>        <span class="token comment">//     cout &lt;&lt; buf &lt;&lt; endl;</span>        <span class="token comment">// &#125;</span>        <span class="token comment">// 3</span>        <span class="token comment">// string buf;</span>        <span class="token comment">// while(getline(ifile, buf))&#123;</span>        <span class="token comment">//     cout &lt;&lt; buf &lt;&lt;endl;</span>        <span class="token comment">// &#125;</span>        Person p<span class="token punctuation">;</span>        ifile<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>p<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        cout <span class="token operator">&lt;&lt;</span> p<span class="token punctuation">.</span>name_ <span class="token operator">&lt;&lt;</span> p<span class="token punctuation">.</span>age_ <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    ifile<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">test02</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从txt文件中读出的以空格为间隔的数字，并排序</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstdlib></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;ctime></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cmath></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;fstream></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">readFromTxt</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span> path<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token operator">&amp;</span>v<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>ifstream iFile<span class="token punctuation">;</span>iFile<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span>path<span class="token punctuation">,</span> ios<span class="token double-colon punctuation">::</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>iFile<span class="token punctuation">.</span><span class="token function">is_open</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>string s<span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>iFile<span class="token operator">>></span>s<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//v.push_back(s[0]-'0');</span>cout <span class="token operator">&lt;&lt;</span> s <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token keyword">int</span> num<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>num<span class="token operator">=</span>num<span class="token operator">*</span><span class="token number">10</span><span class="token operator">+</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span><span class="token char">'0'</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>v<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"v"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> i<span class="token operator">:</span>v<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>cout <span class="token operator">&lt;&lt;</span> i<span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">selectSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token operator">&amp;</span>v<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">int</span> n<span class="token operator">=</span>v<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">int</span> min<span class="token operator">=</span>i<span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span> j<span class="token operator">&lt;</span>n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span><span class="token punctuation">(</span>v<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">&lt;</span>v<span class="token punctuation">[</span>min<span class="token punctuation">]</span><span class="token punctuation">)</span> min<span class="token operator">=</span>j<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">swap</span><span class="token punctuation">(</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> v<span class="token punctuation">[</span>min<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">testReadFromTxt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">char</span><span class="token operator">*</span> path<span class="token operator">=</span><span class="token string">"a.txt"</span><span class="token punctuation">;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> v<span class="token punctuation">;</span><span class="token function">readFromTxt</span><span class="token punctuation">(</span>path<span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">selectSort</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"v"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> i<span class="token operator">:</span> v<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>cout <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">testReadFromTxt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="异常处理的构造和析构函数"><a href="#异常处理的构造和析构函数" class="headerlink" title="异常处理的构造和析构函数"></a>异常处理的构造和析构函数</h2><p>若在 try 中抛出异常，在转到 catch 前，会对有关对象进行析构</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token comment">//异常处理的构造和析构函数 </span><span class="token keyword">class</span> <span class="token class-name">Student</span><span class="token punctuation">&#123;</span><span class="token keyword">private</span><span class="token operator">:</span>string name<span class="token punctuation">;</span><span class="token keyword">int</span> sno<span class="token punctuation">;</span><span class="token keyword">public</span><span class="token operator">:</span><span class="token function">Student</span><span class="token punctuation">(</span>string name1<span class="token punctuation">,</span><span class="token keyword">int</span> sno1<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>name<span class="token operator">=</span>name1<span class="token punctuation">;</span>sno<span class="token operator">=</span>sno1<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token operator">~</span><span class="token function">Student</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>cout<span class="token operator">&lt;&lt;</span><span class="token string">"Destruct Student:"</span><span class="token operator">&lt;&lt;</span>sno<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">checkSno</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span><span class="token punctuation">(</span>sno<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">throw</span> sno<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>cout<span class="token operator">&lt;&lt;</span>name<span class="token operator">&lt;&lt;</span><span class="token string">":"</span><span class="token operator">&lt;&lt;</span>sno<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">try</span><span class="token punctuation">&#123;</span>Student <span class="token function">a</span><span class="token punctuation">(</span><span class="token string">"pink"</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>a<span class="token punctuation">.</span><span class="token function">checkSno</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Student <span class="token function">b</span><span class="token punctuation">(</span><span class="token string">"floyd"</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//构造对象</span>b<span class="token punctuation">.</span><span class="token function">checkSno</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//抛出异常跳到catch语句块中</span><span class="token punctuation">&#125;</span><span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>cout<span class="token operator">&lt;&lt;</span><span class="token string">"error:sno=0!"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到上面这段代码的输出结果是先对a、b析构然后再转到catch输出内容。</p><h2 id="类模板与继承"><a href="#类模板与继承" class="headerlink" title="类模板与继承"></a>类模板与继承</h2><p>要注意继承的时候要加上基类的类型</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">Base</span><span class="token punctuation">&#123;</span>    <span class="token keyword">public</span><span class="token operator">:</span>    T c<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">Deri</span><span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Base</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">></span></span><span class="token punctuation">&#123;</span>    <span class="token keyword">public</span><span class="token operator">:</span>    T a<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    Deri<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> d<span class="token punctuation">;</span>    d<span class="token punctuation">.</span>a<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">;</span>    d<span class="token punctuation">.</span>c<span class="token operator">=</span><span class="token number">6</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span>d<span class="token punctuation">.</span>Base<span class="token double-colon punctuation">::</span>c<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    <span class="token comment">// cout &lt;&lt; sizeof(Deri&lt;int>)&lt;&lt;endl;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="继承时不能被继承的函数"><a href="#继承时不能被继承的函数" class="headerlink" title="继承时不能被继承的函数"></a>继承时不能被继承的函数</h2><p>包括：构造函数、拷贝构造函数、析构函数，注意：operator=函数是可以被继承的</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstring></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">A</span><span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span><span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token function">A</span><span class="token punctuation">(</span><span class="token keyword">int</span> price<span class="token punctuation">,</span> <span class="token keyword">int</span> weight<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">price_</span><span class="token punctuation">(</span>price<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">weight_</span><span class="token punctuation">(</span>weight<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>A<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> A<span class="token operator">&amp;</span> a<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"operator=1"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">private</span><span class="token operator">:</span><span class="token keyword">int</span> price_<span class="token punctuation">;</span><span class="token keyword">int</span> weight_<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">B</span><span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">A</span></span><span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span><span class="token function">B</span><span class="token punctuation">(</span><span class="token keyword">int</span> price<span class="token punctuation">,</span> <span class="token keyword">int</span> weight<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">price_</span><span class="token punctuation">(</span>price<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">weight_</span><span class="token punctuation">(</span>weight<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token keyword">private</span><span class="token operator">:</span><span class="token keyword">int</span> price_<span class="token punctuation">;</span><span class="token keyword">int</span> weight_<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//A a1(1,0);</span><span class="token comment">//A a2;</span><span class="token comment">//a2=a1;</span>B <span class="token function">b1</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">b2</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>b2<span class="token operator">=</span>b1<span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面说明operator=函数被继承下去了。</p><h2 id="静态数据成员的只能在类外初始化"><a href="#静态数据成员的只能在类外初始化" class="headerlink" title="静态数据成员的只能在类外初始化"></a>静态数据成员的只能在类外初始化</h2><p>类内定义，类外初始化一次，然后在整个程序运行期间都可以存在</p><p>原因</p><p>1、静态成员变量存储在静态存储区域内，在编译阶段就为他们分配内存空间，</p><p>2、静态成员变量是类级别的，他在所有类实例中是公有的，如果允许在类内部初始化，就可能导致每个实例都有一个独立的副本</p><p>3、这样可以避免多次初始化</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstdlib></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;ctime></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;math.h></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Point</span><span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span><span class="token function">Point</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">x_</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">y_</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">setX</span><span class="token punctuation">(</span><span class="token keyword">int</span> val<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>x_ <span class="token operator">=</span> val<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">setY</span><span class="token punctuation">(</span><span class="token keyword">int</span> val<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>y_ <span class="token operator">=</span> val<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">getX</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">&#123;</span><span class="token keyword">return</span> x_<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">getY</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">&#123;</span><span class="token keyword">return</span> y_<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">private</span><span class="token operator">:</span><span class="token keyword">int</span> x_<span class="token punctuation">;</span><span class="token keyword">int</span> y_<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Circle</span><span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span><span class="token function">Circle</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">center_</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">r_</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>num_<span class="token operator">++</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Circle number: "</span> <span class="token operator">&lt;&lt;</span> <span class="token function">getNum</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">getNum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">return</span> num_<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">friend</span> <span class="token keyword">double</span> <span class="token function">getDistance</span><span class="token punctuation">(</span><span class="token keyword">const</span> Circle <span class="token operator">&amp;</span>c1<span class="token punctuation">,</span> <span class="token keyword">const</span> Circle <span class="token operator">&amp;</span>c2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">private</span><span class="token operator">:</span><span class="token keyword">static</span> <span class="token keyword">int</span> num_<span class="token punctuation">;</span>Point center_<span class="token punctuation">;</span><span class="token keyword">int</span> r_<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">int</span> Circle<span class="token double-colon punctuation">::</span>num_ <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">double</span> <span class="token function">getDistance</span><span class="token punctuation">(</span><span class="token keyword">const</span> Circle <span class="token operator">&amp;</span>c1<span class="token punctuation">,</span> <span class="token keyword">const</span> Circle <span class="token operator">&amp;</span>c2<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">double</span> x<span class="token operator">=</span><span class="token keyword">double</span><span class="token punctuation">(</span>c2<span class="token punctuation">.</span>center_<span class="token punctuation">.</span><span class="token function">getX</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span>c1<span class="token punctuation">.</span>center_<span class="token punctuation">.</span><span class="token function">getX</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">double</span> y<span class="token operator">=</span><span class="token keyword">double</span><span class="token punctuation">(</span>c2<span class="token punctuation">.</span>center_<span class="token punctuation">.</span><span class="token function">getY</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span>c1<span class="token punctuation">.</span>center_<span class="token punctuation">.</span><span class="token function">getY</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token function">sqrt</span><span class="token punctuation">(</span>x<span class="token operator">*</span>x <span class="token operator">+</span> y<span class="token operator">*</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">testCircle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>Circle <span class="token function">c1</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Circle <span class="token function">c2</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token function">getDistance</span><span class="token punctuation">(</span>c1<span class="token punctuation">,</span> c2<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">testCircle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="处理字符和字符串的输入输出操作"><a href="#处理字符和字符串的输入输出操作" class="headerlink" title="处理字符和字符串的输入输出操作"></a>处理字符和字符串的输入输出操作</h2><p>输出函数：</p><ol><li>putc()：将一个字符写入到指定的文件流中。</li><li>puts()：将一个字符串写入到标准输出流（屏幕）中，并自动添加换行符。</li><li>printf()：格式化输出函数，用于以指定格式将数据打印到标准输出流（屏幕）中。</li><li>fputc()：将一个字符写入到指定的文件流中。</li><li>fputs()：将一个字符串写入到指定的文件流中。</li><li>fprintf()：格式化输出函数，用于以指定格式将数据打印到指定的文件流中。</li></ol><p>输入函数：</p><ol><li>getc()：从指定的文件流中读取一个字符。</li><li>gets()：从标准输入流（键盘）中读取一行字符串，并存储到指定的字符数组中。</li><li>scanf()：格式化输入函数，用于从标准输入流（键盘）中读取指定格式的数据。</li><li>fgetc()：从指定的文件流中读取一个字符。</li><li>fgets()：从指定的文件流中读取一行字符串，并存储到指定的字符数组中。</li><li>fscanf()：格式化输入函数，用于从指定的文件流中读取指定格式的数据。</li></ol><h2 id="运算符的短路效果"><a href="#运算符的短路效果" class="headerlink" title="运算符的短路效果"></a>运算符的短路效果</h2><p>在C语言中，逻辑与运算符 <code>&amp;&amp;</code> 和逻辑或运算符 <code>||</code> 属于短路逻辑运算符。这意味着当使用这两个运算符进行条件判断时，如果第一个操作数的值已经能够确定整个表达式的值，那么就不会再对第二个操作数进行求值，从而实现了“短路”效果。</p><p>具体来说：</p><ul><li>对于逻辑与运算符 <code>&amp;&amp;</code>，当第一个操作数为假（0）时，整个表达式的值已经确定为假，此时不会再对第二个操作数进行求值，直接返回假。</li><li>对于逻辑或运算符 <code>||</code>，当第一个操作数为真（非0）时，整个表达式的值已经确定为真，此时不会再对第二个操作数进行求值，直接返回真。</li></ul>]]></content>
      
      
      <categories>
          
          <category> c++进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++类和对象的属性</title>
      <link href="/2024/02/01/c-lei-he-dui-xiang-de-shu-xing/"/>
      <url>/2024/02/01/c-lei-he-dui-xiang-de-shu-xing/</url>
      
        <content type="html"><![CDATA[<h1 id="C-类和对象的属性"><a href="#C-类和对象的属性" class="headerlink" title="C++类和对象的属性"></a>C++类和对象的属性</h1><p>千钧一发，让一根头发去承受三万斤的重量，但是它没有断。——-余华</p><h2 id="const修饰结构体指针"><a href="#const修饰结构体指针" class="headerlink" title="const修饰结构体指针"></a>const修饰结构体指针</h2><p>内部值不能修改，即：只能读，不能写。防止误操作</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">Point</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> x<span class="token punctuation">;</span>    <span class="token keyword">int</span> y<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">// const 修饰指针，指向的对象不能通过该指针被修改</span>    <span class="token keyword">const</span> Point<span class="token operator">*</span> p1 <span class="token operator">=</span> <span class="token keyword">new</span> Point<span class="token punctuation">&#123;</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token comment">// p1->x = 5;  // 编译错误：指针指向的对象是 const 的，不能被修改</span>    <span class="token comment">// 指针本身是 const，不能指向其他对象</span>    Point<span class="token operator">*</span> <span class="token keyword">const</span> p2 <span class="token operator">=</span> <span class="token keyword">new</span> Point<span class="token punctuation">&#123;</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token comment">// p2 = new Point&#123;7, 8&#125;;  // 编译错误：p2 是 const 指针，不能指向其他对象</span>    p2<span class="token operator">-></span>y <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span>  <span class="token comment">// 合法：指针指向的对象可以通过此指针被修改</span>    <span class="token comment">// 同时 const 修饰指针和指向的对象</span>    <span class="token keyword">const</span> Point<span class="token operator">*</span> <span class="token keyword">const</span> p3 <span class="token operator">=</span> <span class="token keyword">new</span> Point<span class="token punctuation">&#123;</span><span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token comment">// p3->x = 9;  // 编译错误：指针指向的对象是 const 的，不能被修改</span>    <span class="token comment">// p3 = new Point&#123;10, 11&#125;;  // 编译错误：p3 是 const 指针，不能指向其他对象</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="左移运算符重载"><a href="#左移运算符重载" class="headerlink" title="左移运算符重载"></a>左移运算符重载</h2><p>无法用成员函数写这个函数，因为不能把左移cout写在左边</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Point</span><span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> x_<span class="token punctuation">,</span> y_<span class="token punctuation">;</span>    <span class="token function">Point</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">x_</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">y_</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    <span class="token keyword">friend</span> ostream <span class="token operator">&amp;</span><span class="token keyword">operator</span><span class="token operator">&lt;&lt;</span><span class="token punctuation">(</span>ostream <span class="token operator">&amp;</span>os<span class="token punctuation">,</span> <span class="token keyword">const</span> Point <span class="token operator">&amp;</span>p<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        os <span class="token operator">&lt;&lt;</span> p<span class="token punctuation">.</span>x_ <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> p<span class="token punctuation">.</span>y_ <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>        <span class="token keyword">return</span> os<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    Point <span class="token function">p</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cout<span class="token operator">&lt;&lt;</span>p<span class="token operator">&lt;&lt;</span>p<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="运算符加号重载"><a href="#运算符加号重载" class="headerlink" title="运算符加号重载"></a>运算符加号重载</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//1、成员函数重载+号</span>Person <span class="token keyword">operator</span><span class="token operator">+</span><span class="token punctuation">(</span>Person <span class="token operator">&amp;</span>p<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    Person temp<span class="token punctuation">;</span>    temp<span class="token punctuation">.</span>m_A <span class="token operator">=</span> <span class="token keyword">this</span><span class="token operator">-></span>m_A <span class="token operator">+</span> p<span class="token punctuation">.</span>m_A<span class="token punctuation">;</span>    temp<span class="token punctuation">.</span>m_B <span class="token operator">=</span> <span class="token keyword">this</span><span class="token operator">-></span>m_B <span class="token operator">+</span> p<span class="token punctuation">.</span>m_B<span class="token punctuation">;</span>    <span class="token keyword">return</span> temp<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//2、全局函数重载+号</span>Person <span class="token keyword">operator</span><span class="token operator">+</span><span class="token punctuation">(</span>Person <span class="token operator">&amp;</span>p1<span class="token punctuation">,</span> Person <span class="token operator">&amp;</span>p2<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    Person temp<span class="token punctuation">;</span>    temp<span class="token punctuation">.</span>m_A <span class="token operator">=</span> p1<span class="token punctuation">.</span>m_A <span class="token operator">+</span> p2<span class="token punctuation">.</span>m_A<span class="token punctuation">;</span>    temp<span class="token punctuation">.</span>m_B <span class="token operator">=</span> p1<span class="token punctuation">.</span>m_B <span class="token operator">+</span> p2<span class="token punctuation">.</span>m_B<span class="token punctuation">;</span>    <span class="token keyword">return</span> temp<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 成员函数调用本质</span>Person p3 <span class="token operator">=</span> p1<span class="token punctuation">.</span><span class="token keyword">operator</span><span class="token operator">+</span><span class="token punctuation">(</span>p2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 全局函数调用本质</span>Person p3 <span class="token operator">=</span> <span class="token keyword">operator</span><span class="token operator">+</span><span class="token punctuation">(</span>p1<span class="token punctuation">,</span> p2<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="为什么有的操作符重载函数只能是成员函数"><a href="#为什么有的操作符重载函数只能是成员函数" class="headerlink" title="为什么有的操作符重载函数只能是成员函数"></a>为什么有的操作符重载函数只能是成员函数</h2><p>出自于 c++ primer 的一句话：</p><blockquote><p>赋值（=）、下标（[]）、调用（()）和成员访问箭头（-&gt;）运算符必须是成员（函数）。</p></blockquote><p>操作符重载函数规定是类的成员函数，有一个至关重要的特点：<strong>类的this指针会被绑定到运算符的左侧运算对象，成员运算符函数的显示参数比运算符对象总数少一个</strong>。</p><p><a href="https://blog.csdn.net/qq_29344757/article/details/78820189">为什么有的操作符重载函数只能是成员函数</a></p><h2 id="友元技术"><a href="#友元技术" class="headerlink" title="友元技术"></a>友元技术</h2><p>利用友元类技术，可以访问私有类型</p><p>当一个非成员函数需要直接访问类的私有成员时，可以将其声明为友元函数。而如果非成员函数不需要直接访问类的私有成员，那么就不必将其声明为友元函数，这种情况下，非成员函数可以通过类的公有接口进行访问，而无需成为友元函数。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">MyClass</span><span class="token punctuation">&#123;</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">int</span> a_<span class="token punctuation">;</span>    <span class="token keyword">friend</span> <span class="token keyword">class</span> <span class="token class-name">FriendClass</span><span class="token punctuation">;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">MyClass</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token function">a_</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    <span class="token keyword">int</span> <span class="token function">getA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">const</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> a_<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>MyClass <span class="token keyword">operator</span><span class="token operator">+</span><span class="token punctuation">(</span><span class="token keyword">const</span> MyClass<span class="token operator">&amp;</span> m1<span class="token punctuation">,</span> <span class="token keyword">const</span> MyClass<span class="token operator">&amp;</span> m2<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token function">MyClass</span><span class="token punctuation">(</span>m1<span class="token punctuation">.</span><span class="token function">getA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span>m2<span class="token punctuation">.</span><span class="token function">getA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> <span class="token class-name">FriendClass</span><span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">accessPrivateMember</span><span class="token punctuation">(</span>MyClass<span class="token operator">&amp;</span> my<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        cout<span class="token operator">&lt;&lt;</span><span class="token string">"Myclass private menber: "</span><span class="token operator">&lt;&lt;</span> my<span class="token punctuation">.</span>a_<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    MyClass <span class="token function">my</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    FriendClass friendClass<span class="token punctuation">;</span>    friendClass<span class="token punctuation">.</span><span class="token function">accessPrivateMember</span><span class="token punctuation">(</span>my<span class="token punctuation">)</span><span class="token punctuation">;</span>MyClass <span class="token function">my1</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>MyClass my2 <span class="token operator">=</span> my<span class="token operator">+</span>my1<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> my2<span class="token punctuation">.</span><span class="token function">getA</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>构造函数也可以重载</p><p>创建任何对象都要调用构造函数</p><h2 id="析构顺序"><a href="#析构顺序" class="headerlink" title="析构顺序"></a>析构顺序</h2><p>当类内存在其他类成员时，构造函数顺序是先成员变量的构造函数，后本类的构造函数，析构顺序则相反</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Phone</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Person</span><span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"moren"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">Person</span><span class="token punctuation">(</span>string name<span class="token punctuation">,</span> <span class="token keyword">int</span> age<span class="token punctuation">,</span> Phone<span class="token operator">*</span> phone<span class="token punctuation">,</span> <span class="token keyword">int</span> rea<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        m_name <span class="token operator">=</span> name<span class="token punctuation">;</span>        m_age <span class="token operator">=</span> age<span class="token punctuation">;</span>        m_phone <span class="token operator">=</span> phone<span class="token punctuation">;</span>        m_rea <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span>rea<span class="token punctuation">)</span><span class="token punctuation">;</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"gouzao---------------"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token operator">~</span><span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>m_rea <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token keyword">delete</span> m_rea<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"xigou----------------=="</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">Person</span><span class="token punctuation">(</span><span class="token keyword">const</span> Person <span class="token operator">&amp;</span>p<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"kaobei---------------==="</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token keyword">private</span><span class="token operator">:</span>    string m_name<span class="token punctuation">;</span>    <span class="token keyword">int</span> m_age<span class="token punctuation">;</span>    Phone<span class="token operator">*</span> m_phone<span class="token punctuation">;</span><span class="token comment">//为什么使用指针，有学问在里边</span>    <span class="token keyword">int</span> <span class="token operator">*</span>m_rea<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Phone</span><span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Phone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        m_Number <span class="token operator">=</span> <span class="token number">1232</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">Phone</span><span class="token punctuation">(</span><span class="token keyword">int</span> number<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">m_Number</span><span class="token punctuation">(</span>number<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Phone 构造"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token operator">~</span><span class="token function">Phone</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Phone 析构"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">int</span> m_Number<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">test01</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    Person p1<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">test02</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> t <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment">// Person p("123", 123, t);</span>    <span class="token comment">// Person p1(p);</span>    <span class="token comment">// cout &lt;&lt; "02" &lt;&lt; endl;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">test03</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    Phone <span class="token function">phone</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Person <span class="token function">p</span><span class="token punctuation">(</span><span class="token string">"123"</span><span class="token punctuation">,</span> <span class="token number">123</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>phone<span class="token punctuation">,</span> <span class="token number">123</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cout<span class="token operator">&lt;&lt;</span><span class="token string">"12333333333333333333333"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">// test02();</span>    <span class="token comment">// cout &lt;&lt; "03" &lt;&lt; endl;</span>    <span class="token function">test03</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面<code>Person</code>的<code>Phone</code>成员变量使用指针是因为<code>Person</code>类中的<code>Phone</code>对象是一个不完全类型，因此编译器无法确定其<strong>大小和布局</strong>。这导致在<code>Person</code>类中使用<code>Phone</code>对象时出现错误。</p><h2 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h2><p>执行拷贝构造函数的三个时机</p><p>（1）、用一个已经存在的对象来创建一个新的对象时（<strong>这是最本质的原因</strong>）</p><p>Spot spot2=spot1；</p><p>（2）、对象作为函数的参数（值传递，不是引用传递）时，实际上就是在调用拷贝构造函数。</p><p>Spot spot3(spot2);</p><p>（3）、函数的返回值是一个对象，执行return语句时，系统会自动调用拷贝构造函数创建返回值。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">MyClass</span> <span class="token punctuation">&#123;</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">int</span><span class="token operator">*</span> data<span class="token punctuation">;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token comment">// 默认构造函数</span>    <span class="token function">MyClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        data <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Default constructor called."</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 拷贝构造函数</span>    <span class="token function">MyClass</span><span class="token punctuation">(</span><span class="token keyword">const</span> MyClass<span class="token operator">&amp;</span> obj<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        data <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token operator">*</span>obj<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 深拷贝</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Copy constructor called."</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 析构函数</span>    <span class="token operator">~</span><span class="token function">MyClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">delete</span> data<span class="token punctuation">;</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Destructor called."</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 打印数据成员</span>    <span class="token keyword">void</span> <span class="token function">printData</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Data: "</span> <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>data <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">// 函数参数为对象</span><span class="token keyword">void</span> <span class="token function">myFunction</span><span class="token punctuation">(</span>MyClass obj<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    obj<span class="token punctuation">.</span><span class="token function">printData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>MyClass <span class="token function">myFunction1</span><span class="token punctuation">(</span><span class="token keyword">const</span> MyClass<span class="token operator">&amp;</span> obj<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> obj<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 用对象初始化另一个对象</span>    MyClass obj1<span class="token punctuation">;</span>    <span class="token comment">// MyClass obj2 = obj1;</span>    <span class="token comment">// 传递对象给函数参数</span>    <span class="token comment">// myFunction(obj1);</span>    <span class="token comment">// 通过值返回对象</span>    MyClass obj3 <span class="token operator">=</span> <span class="token function">myFunction1</span><span class="token punctuation">(</span>obj1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面三个都是一次默认构造，一次拷贝构造，两次析构。<code>myFunction</code>和<code>myFunction1</code>的区别：按值传递会触发拷贝构造函数，按引用传递不会触发，但是传递返回值时会触发拷贝构造函数，所以输出结果相同</p><h2 id="隐式转换"><a href="#隐式转换" class="headerlink" title="隐式转换"></a>隐式转换</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">A</span><span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>     <span class="token comment">// explicit</span>     <span class="token function">A</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Cons"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>     <span class="token function">A</span><span class="token punctuation">(</span><span class="token keyword">const</span> A<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Copy"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>    A<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> A<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Operator="</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">// A a=3;</span>    A a1<span class="token punctuation">;</span>    a1<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>a1=3这行代码会调用构造函数，将3隐式转换为A类型（可以通过在A前面+explicit来验证），然后调用operator=函数，就是上面的第一个时机。</p><h2 id="C-C-数组名与指针区别"><a href="#C-C-数组名与指针区别" class="headerlink" title="C/C++数组名与指针区别"></a>C/C++数组名与指针区别</h2><p><a href="https://blog.csdn.net/ykm0722/article/details/7031387">https://blog.csdn.net/ykm0722/article/details/7031387</a></p><h2 id="静态数据成员"><a href="#静态数据成员" class="headerlink" title="静态数据成员"></a>静态数据成员</h2><p>普通成员变量在类中只能声明可是不能定义，类在定义后并不分配存储空间，而是在定义类的对象的时候才分配存储空间，相反静态的数据成员和静态的成员函数是已经在内存中开辟了内存空间了，所以静态数据成员可以独立的访问在任何类对象没有建立起来都可以访问。</p><p>你们班里面有10个人（10个比如高一一班的对象），体育老师分给你们一个篮球（静态成员函数），你们每个人都带了一个篮球（非静态成员数），你们都很小气，自己的球只能自己拍，要是5对5打比赛，那就只能用那个静态的篮球了（每个人都可以拿来用，但是带来的影响是对全体的）。因此，我可以说那个篮球是高一一班的成员。所以也就是说：静态成员函数是类的成员函数（因为高一二班就不能拿来玩），但是这个篮球最后还是要还给老师的，任何私人不得占有。希望这样你能明白，其实在内存空间里面说白了静态的成员的内存是唯一的一份，就是当你在类内声明他时开辟的，但是非静态函数的空间分配是在你实例化对象时创建的。</p><p>静态成员变量是所有的类共有的，它有两种访问方式：</p><p>1、通过对象访问</p><p>2、通过类名访问（因为静态成员函数和静态变量是所有对象共有的一个性质）</p><p>静态成员函数调用方式：通过对象或者通过:类名::静态成员函数</p><p>静态成员函数不可以访问非静态成员变量，因为静态成员函数是所有对象共有的，当一个对象调用这个函数时，如果修改非静态成员变量，他不知道是哪个对象的变量。无法区分是哪个对象的。</p><p>静态成员函数也有访问权限</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Person</span><span class="token punctuation">&#123;</span>    string name<span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token keyword">int</span> Num<span class="token punctuation">;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Person</span><span class="token punctuation">(</span>string N<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">name</span><span class="token punctuation">(</span>N<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> Num<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>    <span class="token function">Person</span><span class="token punctuation">(</span><span class="token keyword">const</span> Person<span class="token operator">&amp;</span> p<span class="token punctuation">)</span><span class="token punctuation">&#123;</span> Num<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>    <span class="token keyword">void</span> <span class="token function">Print</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"共有"</span> <span class="token operator">&lt;&lt;</span> Num <span class="token operator">&lt;&lt;</span> <span class="token string">"个人"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>    <span class="token operator">~</span><span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> Num<span class="token operator">--</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">int</span> Person<span class="token double-colon punctuation">::</span>Num <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    Person <span class="token function">p1</span><span class="token punctuation">(</span><span class="token string">"hehe"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Person p2 <span class="token operator">=</span> p1<span class="token punctuation">;</span>    Person <span class="token function">p3</span><span class="token punctuation">(</span>p2<span class="token punctuation">)</span><span class="token punctuation">;</span>    Person <span class="token function">p4</span><span class="token punctuation">(</span><span class="token string">"hh"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    p1<span class="token punctuation">.</span><span class="token function">Print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="研究静态函数成员是否有this指针"><a href="#研究静态函数成员是否有this指针" class="headerlink" title="研究静态函数成员是否有this指针"></a>研究静态函数成员是否有this指针</h3><p>结论：没有，因为静态成员函数<strong>不属于某个对象</strong>，被类的所有对象共享。</p><h2 id="类的组合与继承"><a href="#类的组合与继承" class="headerlink" title="类的组合与继承"></a>类的组合与继承</h2><p><strong>当一个类将要被继承时，为了方便对他的继承，往往将他的private数据成员改为protected访问权限，因为基类的private成员不方便在派生类中访问</strong></p><p><strong>注意</strong>:<strong>只有构造函数初始化的时候能使用初始化列表</strong>。成员函数不行，要不然会报错</p><h2 id="友元类函数"><a href="#友元类函数" class="headerlink" title="友元类函数"></a>友元类函数</h2><p><del>定义友元类函数，再类外部定义时不能访问private成员，而在类内定义可以，</del></p><p>上面说法是错误的，原因是类外那个函数的定义的形参并没有+const，与类内的声明不相同，导致变成了一个普通函数。</p><p>程序如下</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cmath></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Point</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> x<span class="token punctuation">;</span>    <span class="token keyword">int</span> y<span class="token punctuation">;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">friend</span> <span class="token keyword">float</span> <span class="token function">Distance</span><span class="token punctuation">(</span><span class="token keyword">const</span> Point <span class="token operator">&amp;</span>p1<span class="token punctuation">,</span> <span class="token keyword">const</span> Point <span class="token operator">&amp;</span>p2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// &#123;</span>    <span class="token comment">//     return sqrt(pow(p2.x - p1.x, 2) + pow(p2.y - p1.y, 2));</span>    <span class="token comment">// &#125;</span>    <span class="token function">Point</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>X<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>Y<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        x <span class="token operator">=</span> X<span class="token punctuation">;</span>        y <span class="token operator">=</span> Y<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// void setX(int X) : x(X) &#123;&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">// float Distance(Point&amp; p1, Point&amp; p2)</span><span class="token comment">//&#123;</span><span class="token comment">//return sqrt(pow(p2.x - p1.x, 2) + pow(p2.y - p1.y, 2));</span><span class="token comment">//&#125;</span><span class="token keyword">float</span> <span class="token function">Distance</span><span class="token punctuation">(</span><span class="token keyword">const</span> Point<span class="token operator">&amp;</span> p1<span class="token punctuation">,</span> <span class="token keyword">const</span> Point<span class="token operator">&amp;</span> p2<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token function">sqrt</span><span class="token punctuation">(</span><span class="token function">pow</span><span class="token punctuation">(</span>p2<span class="token punctuation">.</span>x <span class="token operator">-</span> p1<span class="token punctuation">.</span>x<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">pow</span><span class="token punctuation">(</span>p2<span class="token punctuation">.</span>y <span class="token operator">-</span> p1<span class="token punctuation">.</span>y<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    Point <span class="token function">p1</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">p2</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token function">Distance</span><span class="token punctuation">(</span>p1<span class="token punctuation">,</span> p2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>如果子类中有与父类中同名的成员函数，直接调用是调用子类中的，子类中的同名的成员函数会覆盖父类中所有同名成员函数，如果想要访问的话，需要加上父类的作用域</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Parent</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Parent class display() function"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Child</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Parent</span></span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Child class display() function"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>                <span class="token comment">// 调用父类中的 display() 函数</span>        <span class="token comment">// Parent::display();</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    Child obj<span class="token punctuation">;</span>    obj<span class="token punctuation">.</span><span class="token class-name">Parent</span><span class="token double-colon punctuation">::</span><span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="继承的时候构造析构的顺序"><a href="#继承的时候构造析构的顺序" class="headerlink" title="继承的时候构造析构的顺序"></a>继承的时候构造析构的顺序</h2><p>如果没有出现组合，构造顺序是：先按照继承的顺序构造，然后是自己的构造函数</p><p>若出现组合，构造顺序：先按照继承顺序构造，然后是成员对象的构造，最后是自己的构造函数</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">B1</span><span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">B1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>cout<span class="token operator">&lt;&lt;</span><span class="token string">"B1"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>    <span class="token function">B1</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>cout<span class="token operator">&lt;&lt;</span><span class="token string">"B1:"</span><span class="token operator">&lt;&lt;</span>i<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token operator">~</span><span class="token function">B1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Des B1"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">B2</span><span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">B2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>cout<span class="token operator">&lt;&lt;</span><span class="token string">"B2"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>    <span class="token function">B2</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>cout<span class="token operator">&lt;&lt;</span><span class="token string">"B2:"</span><span class="token operator">&lt;&lt;</span>i<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token operator">~</span><span class="token function">B2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Des B2"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">C</span><span class="token operator">:</span><span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">B2</span><span class="token punctuation">,</span><span class="token keyword">public</span> <span class="token class-name">B1</span></span><span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">C</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">B1</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">B2</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>cout<span class="token operator">&lt;&lt;</span><span class="token string">"C"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token function">C</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">B1</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">B2</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>cout<span class="token operator">&lt;&lt;</span><span class="token string">"C2"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token operator">~</span><span class="token function">C</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Des C"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    C obj<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h2><p>优缺点：</p><p><a href="https://blog.csdn.net/jandunlab/article/details/14110117">(11条消息) 多继承的概念和优缺点_HappyJandun’s 学习笔录-CSDN博客_多继承的优缺点</a></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Person</span><span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"sleep"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>    <span class="token keyword">void</span> <span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"eat"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Author</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Person</span> <span class="token comment">// Author继承自Person</span></span><span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">writeBook</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"write Book"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Programmer</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Person</span> <span class="token comment">// Programmer继承自Person</span></span><span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">writeCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"write Code"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Programmer_Author</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Programmer</span><span class="token punctuation">,</span> <span class="token keyword">public</span> <span class="token class-name">Author</span> <span class="token comment">// 多重继承</span></span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    Programmer_Author pa<span class="token punctuation">;</span>    pa<span class="token punctuation">.</span><span class="token function">writeBook</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 调用基类Author的方法</span>    pa<span class="token punctuation">.</span><span class="token function">writeCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 调用基类Programmer的方法</span>    <span class="token comment">// pa.eat();       // 编译错误，eat()定义不明确</span>    <span class="token comment">// pa.sleep();     // 编译错误，sleep()定义不明确</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>多重继承的优点很明显，就是<strong>对象可以调用多个基类中的接口</strong></p><p>缺点是如果派生类所继承的多个基类有相同的基类，而派生类对象需要调用这个祖先类的接口方法，就会容易出现二义性。 </p><p>通常有两个解决方案：</p><p>（1）加上全局符确定调用哪一份拷贝。比如pa.Author::eat()调用属于Author的拷贝。</p><p>（2）使用虚拟继承，使得多重继承类Programmer_Author只拥有Person类的一份拷贝。比如在类 Author 和 Programmer 的继承前加入virtual就可以了。</p><h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Animal</span><span class="token punctuation">&#123;</span><span class="token keyword">private</span><span class="token operator">:</span>    string m_sound<span class="token punctuation">;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Animal</span><span class="token punctuation">(</span>string sound<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">m_sound</span><span class="token punctuation">(</span>sound<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">makeSomeSound</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Ainmal"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Cat</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Animal</span></span><span class="token punctuation">&#123;</span><span class="token keyword">private</span><span class="token operator">:</span>    string m_sound<span class="token punctuation">;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Cat</span><span class="token punctuation">(</span>string sound<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">m_sound</span><span class="token punctuation">(</span>sound<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">Animal</span><span class="token punctuation">(</span><span class="token string">"animal"</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token comment">// 必须显式调用父类的有参构造函数</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">makeSomeSound</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">override</span> <span class="token punctuation">&#123;</span> cout <span class="token operator">&lt;&lt;</span> m_sound <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Dog</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Animal</span></span><span class="token punctuation">&#123;</span><span class="token keyword">private</span><span class="token operator">:</span>    string m_sound<span class="token punctuation">;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Dog</span><span class="token punctuation">(</span>string sound<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">m_sound</span><span class="token punctuation">(</span>sound<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">Animal</span><span class="token punctuation">(</span><span class="token string">"animal"</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">makeSomeSound</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">override</span> <span class="token punctuation">&#123;</span> cout <span class="token operator">&lt;&lt;</span> m_sound <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">// 视他人之疑目如盏盏鬼火，大胆地去走你的夜路吧。</span>    Animal <span class="token operator">*</span>animal<span class="token punctuation">;</span>    Dog <span class="token function">dog</span><span class="token punctuation">(</span><span class="token string">"Wang Wang"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Cat <span class="token function">cat</span><span class="token punctuation">(</span><span class="token string">"Miao Miao"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    animal <span class="token operator">=</span> <span class="token operator">&amp;</span>dog<span class="token punctuation">;</span>    animal<span class="token operator">-></span><span class="token function">makeSomeSound</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    animal <span class="token operator">=</span> <span class="token operator">&amp;</span>cat<span class="token punctuation">;</span>    animal<span class="token operator">-></span><span class="token function">makeSomeSound</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>编译器为了实现虚函数，通常会生成虚函数表，在程序运行时通过虚函数动态的查找，然后据此调用正确的函数，这就是动态编译。vbtable是虚基表，虚基指针(vbptr)指向虚基表。</p><p><strong>C++为什么要用虚函数</strong></p><p><a href="https://blog.csdn.net/noricky/article/details/80051219?ops_request_misc=%7B%22request%5Fid%22%3A%22163806102216780255288237%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fall.%22%7D&amp;request_id=163806102216780255288237&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-2-80051219.first_rank_v2_pc_rank_v29&amp;utm_term=什么时候要用虚函数&amp;spm=1018.2226.3001.4187">(3条消息) C++为什么要用虚函数_Like a lunatic-CSDN博客</a></p><p><strong>总结起来：</strong>这样做是为了当用一个基类的指针删除一个派生类的对象时，派生类的析构函数会被调用</p><p>要实现多态，需要满足以下几个条件：</p><ol><li>子类重写（覆盖）父类的虚函数：在继承关系中，子类必须重写（覆盖）父类中的虚函数，即在子类中重新定义与父类中虚函数同名、同参数列表和同返回类型的函数，并使用关键字 “override” 明确说明这是对父类虚函数的重写。</li><li>父类指针或引用指向子类对象：通过将父类的指针或引用指向子类的对象，可以实现多态。这样，在运行时，根据指针或引用指向的对象的实际类型来确定调用的是子类中的实现。</li><li>虚函数机制：父类中被子类重写的函数必须声明为虚函数。通过虚函数表和动态绑定机制，确保在运行时根据对象的实际类型来调用正确的函数实现。</li></ol><p>定义了虚函数，如果有三辈的继承：爷爷，父亲，儿子，在主函数中，定义一个基类指针，指针指向谁，就调用谁的函数————实现的就是动态多态</p><h2 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h2><p><strong>一般语法</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//纯虚函数，可以有函数体，可实例化的派生类必须重写它</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>定义：</strong></p><p>像这样用virtual关键字修饰，并且末尾加上 =0 的格式声明的函数就是纯虚函数，还有一个重要特征，就是在当前类里这个方法不能有具体的实现，也就是不能有方法体。同时拥有纯虚函数的类会被默认定义为抽象类。</p><blockquote><p>什么是抽象类：至少拥有一个或者一个以上的纯虚函数的类，这种类不能创建对象，但是可以被继承，通常通过继承抽象类，然后通过重写纯虚函数后，方可以通过抽象父类的子类的对象来访问函数和数据成员。</p></blockquote><h2 id="模板函数的重载"><a href="#模板函数的重载" class="headerlink" title="模板函数的重载"></a>模板函数的重载</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">void</span> <span class="token function">Test1</span><span class="token punctuation">(</span>T a<span class="token punctuation">,</span> T b<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  cout<span class="token operator">&lt;&lt;</span><span class="token string">"Test1()"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">Test1</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token comment">//这里是重载</span><span class="token punctuation">&#123;</span>  cout<span class="token operator">&lt;&lt;</span><span class="token string">"2"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">Test</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  cout<span class="token operator">&lt;&lt;</span><span class="token string">"3"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token keyword">char</span> c <span class="token operator">=</span> <span class="token char">'c'</span><span class="token punctuation">,</span> d<span class="token operator">=</span> <span class="token char">'d'</span><span class="token punctuation">;</span>  <span class="token function">Test</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">Test1</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h2><p>定义一个简单的Array的类模板：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">Array</span><span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Array</span><span class="token punctuation">(</span><span class="token keyword">int</span> size<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">size_</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        data_ <span class="token operator">=</span> <span class="token keyword">new</span> T<span class="token punctuation">[</span>size<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token operator">~</span><span class="token function">Array</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span> data_<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    T <span class="token operator">&amp;</span><span class="token keyword">operator</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> data_<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">friend</span> ostream <span class="token operator">&amp;</span><span class="token keyword">operator</span><span class="token operator">&lt;&lt;</span><span class="token punctuation">(</span>ostream <span class="token operator">&amp;</span>os<span class="token punctuation">,</span> <span class="token keyword">const</span> Array<span class="token operator">&lt;</span>T<span class="token operator">></span> arr<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>           <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>arr<span class="token punctuation">.</span>size_<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>            cout<span class="token operator">&lt;&lt;</span>arr<span class="token punctuation">.</span>data_<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span><span class="token string">" "</span><span class="token punctuation">;</span>         <span class="token keyword">return</span> os<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token keyword">private</span><span class="token operator">:</span>    T <span class="token operator">*</span>data_<span class="token punctuation">;</span>    <span class="token keyword">int</span> size_<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    Array<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// for (int i = 0; i &lt; 10; i++)</span>        cout <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>类模板的定义：类模板是一种通用的类的定义，通过模板可以存储不同数据类型的对象</p><p><strong>为什么需要类模板：</strong>有时，有两个或多个类，其功能是相同的，仅仅是数据类型不同，如<code>vector</code>、<code>deque</code>、<code>map</code>等的实现。</p><p><strong>继承中的类模板：</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">Base</span><span class="token punctuation">&#123;</span><span class="token keyword">private</span><span class="token operator">:</span>    T value_<span class="token punctuation">;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Base</span><span class="token punctuation">(</span>T value<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">value_</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        cout<span class="token operator">&lt;&lt;</span><span class="token string">"Base constructed"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">Derived</span><span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Base</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">></span></span><span class="token punctuation">&#123;</span><span class="token keyword">private</span><span class="token operator">:</span>    T value_<span class="token punctuation">;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Derived</span><span class="token punctuation">(</span>T value1<span class="token punctuation">,</span> T value2<span class="token punctuation">)</span><span class="token operator">:</span><span class="token generic-function"><span class="token function">Base</span><span class="token generic class-name"><span class="token operator">&lt;</span>T<span class="token operator">></span></span></span><span class="token punctuation">(</span>value1<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">value_</span><span class="token punctuation">(</span>value2<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        cout<span class="token operator">&lt;&lt;</span><span class="token string">"Derived constructed"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    Base<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">base</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Derived<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">derived</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结论: 子类从模板类继承的时候,需要让编译器知道 父类的数据类型具体是什么(数据类型的本质:固定大小内存块的别名)A </p><p>从模板类派生时，需要具体化模板类，C++编译器需要知道父类的数据类型是什么样子的 要知道父类所占的内存多少</p><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>单例模式有许多种实现方法，</p><p>a. 懒汉式：使用的时候才创建，多线程访问的时候线程不安全(双检锁)</p><p>b. 饿汉式：类文件加载的时候已经创建好了对象，如果对象一直没有使用，则类对象浪费空间</p><p>特点与选择：</p><p>如果要进行线程同步，访问量比较大，或者可能访问的线程比较多时，采用饿汉实现，可以实现更好的性能。这是以空间换时间。</p><p>在访问量较小时，采用懒汉实现。这是以时间换空间。</p><p>CSDN博客：</p><p><a href="https://blog.csdn.net/yuexiaxiaoxi27172319/article/details/81410081?ops_request_misc=%7B%22request%5Fid%22%3A%22163910357816780357234401%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=163910357816780357234401&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-81410081.first_rank_v2_pc_rank_v29&amp;utm_term=c%2B%2B单例模式&amp;spm=1018.2226.3001.4187">C++设计模式(一)单例模式</a></p><p>设计原则之一：开放封闭原则：对扩展开放，对修改关闭</p><h2 id="组合和继承的优缺点"><a href="#组合和继承的优缺点" class="headerlink" title="组合和继承的优缺点"></a>组合和继承的优缺点</h2><p>（1）继承</p><p>继承是Is a 的关系，比如说Student继承Person,则说明Student is a Person。继承的优点是子类可以重写父类的方法来方便地实现对父类的扩展。</p><p>　　继承的缺点有以下几点：</p><p>　　①：父类的内部细节对子类是可见的。</p><p>　　②：子类从父类继承的方法在编译时就确定下来了，所以无法在运行期间改变从父类继承的方法的行为。</p><p>　　③：如果对父类的方法做了修改的话（比如增加了一个参数），则子类的方法必须做出相应的修改。所以说子类与父类是一种高耦合，违背了面向对象思想。</p><p>（2）组合</p><p>　　组合也就是设计类的时候把要组合的类的对象加入到该类中作为自己的<strong>成员变量</strong>。</p><p>　　组合的优点：</p><p>　　①：当前对象只能通过所包含的那个对象去调用其方法，所以所包含的对象的内部细节对当前对象时不可见的。</p><p>　　②：当前对象与包含的对象是一个低耦合关系，如果修改包含对象的类中代码不需要修改当前对象类的代码。</p><p>　　③：当前对象可以在运行时动态的绑定所包含的对象。可以通过set方法给所包含对象赋值。</p><p>　　组合的缺点：①：容易产生过多的对象。②：为了能组合多个对象，必须仔细对接口进行定义。</p><p><a href="">const是定义为const函数的组成部分，那么就可以通过添加const实现函数重载</a></p><h2 id="关于C-的常量的一点说明"><a href="#关于C-的常量的一点说明" class="headerlink" title="关于C++的常量的一点说明"></a>关于C++的常量的一点说明</h2><p>我们说过，C++“真常量”只针对内置数据类型，自己定义的类，编译器没法帮你“内传折叠”，所以仍是“假常量”，是能通过指针“篡次的<br>另外常量是“建没性”的预防措施，并不能防蓄意破坏。</p><p>C++中的真常量只针对其内置数据类型，对于自己定义的类的，是假常量，可以通过指针修改</p><h2 id="菱形的继承体系"><a href="#菱形的继承体系" class="headerlink" title="菱形的继承体系"></a>菱形的继承体系</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">A</span><span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>  <span class="token keyword">int</span> a<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">virtual</span> <span class="token keyword">public</span> <span class="token class-name">A</span></span><span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>  <span class="token keyword">int</span> b<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">C</span> <span class="token operator">:</span><span class="token base-clause"><span class="token keyword">virtual</span> <span class="token keyword">public</span> <span class="token class-name">A</span></span><span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>  <span class="token keyword">int</span> c<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">D</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">B</span><span class="token punctuation">,</span> <span class="token keyword">public</span> <span class="token class-name">C</span></span><span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>  <span class="token keyword">int</span> d<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>内存布局</p><p>上面这种菱形的继承体系中，如果没有virtual继承，那么D中就有两个A的成员int a；继承下来，使用的时候，就会有很多二义性。而加了virtual继承，在D中就只有A的成员int a；的一份拷贝，该拷贝不是来自B，也不是来自C，而是一份单独的拷贝，那么，编译器是怎么实现的呢？？</p><p>在回答这个问题之前，先想一下，sizeof(A),sizeof(B),sizeof(C),sizeof(D)是多少？（在32位x86的linux2.6下面，或者在vc2005下面）在linux2.6下面，结果如下：sizeof(A) = 4; sizeof(B) = 12; sizeof(C) = 12; sizeof(D) = 24;sizeof（B）为什么是12呢，那是因为多了一个指针（这一点和虚函数的实现一样），那个指针是干嘛的呢？</p><p>那么sizeof(D)为什么是24呢？那是因为除了继承B中的b，C中的c，A中的a,和D自己的成员d之外，还继承了B，C多出来的2个指针（B和C分别有一个）。再强调一遍，D中的int a不是来自B也不是来自C，而是另外的一份从A直接靠过来的成员。</p><p>如果声明了D的对象d： D d；</p><p>那么d的内存布局如下：</p><p>vb_ptr: 继承自B的指针</p><p>int b： 继承自B公有成员</p><p>vc_ptr：继承自C的指针</p><p>int c： 继承自C的共有成员</p><p>int d： D自己的公有成员</p><p>int a： 继承自A的公有成员</p><h2 id="关于多态"><a href="#关于多态" class="headerlink" title="关于多态"></a>关于多态</h2><p>多态分为静态多态和动态多态：</p><ul><li><p>静态多态是编译时发生了多态，多指函数重载和模板实现；</p></li><li><p>动态多态是运行时多态，一般通过虚函数实现。</p></li></ul><p>实现动态多态三个条件</p><p>1：要有public继承；</p><p>2：要有虚函数重写；</p><p>3：用父类指针（父类引用）指向子类对象</p><p><strong>菱形继承虚基类</strong></p><p>虚继承的出现就是为了解决重复继承中多个间接父类的问题的，二义性。钻石型的结构是其最经典的结构。</p><p>C++中的虚函数的作用主要是实现了多态的机制。关于多态，简而言之就是用父类型别的指针指向其子类的实例，然后通过父类的指针调用实际子类的成员函数。这种技术可以让父类的指针有“多种形态”，这是一种泛型技术。所谓泛型技术，说白了就是试图使用不变的代码来实现可变的算法。比如：模板技术，RTTI技术，虚函数技术，要么是试图做到在<strong>编译时决议</strong>，要么试图做到<strong>运行时决议</strong>。</p><p><strong>类的缺省参数：（不能在两个地方同时声明）</strong></p><p><strong>既可以在类的声明中，也可以在函数定义中声明缺省参数，但不能既在类声明中又在函数定义中同时声明缺省参数。</strong></p><h1 id="杂谈"><a href="#杂谈" class="headerlink" title="杂谈"></a>杂谈</h1><h2 id="Union"><a href="#Union" class="headerlink" title="Union"></a>Union</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">union</span> myun<span class="token punctuation">&#123;</span>    <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span> <span class="token keyword">int</span> x<span class="token punctuation">;</span> <span class="token keyword">int</span> y<span class="token punctuation">;</span> <span class="token keyword">int</span> z<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>u<span class="token punctuation">;</span>    <span class="token keyword">short</span> k<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>a<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    a<span class="token punctuation">.</span>u<span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span><span class="token number">17</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment">// 2的17次方是： 131072, 低16位是0x00 02</span>    a<span class="token punctuation">.</span>u<span class="token punctuation">.</span>y <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>    a<span class="token punctuation">.</span>u<span class="token punctuation">.</span>z <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span>    a<span class="token punctuation">.</span>k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d %d %d %d\n"</span><span class="token punctuation">,</span> a<span class="token punctuation">.</span>u<span class="token punctuation">.</span>x<span class="token punctuation">,</span> a<span class="token punctuation">.</span>u<span class="token punctuation">.</span>y<span class="token punctuation">,</span> a<span class="token punctuation">.</span>u<span class="token punctuation">.</span>z<span class="token punctuation">,</span> a<span class="token punctuation">.</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// a.k的16位覆盖了x的低16位</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"sizeof(a):%d\n"</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 联合体的 size 是最大的数据长度：三个 int 是12</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">17</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 这里short的16位覆盖了a.u.x的前16位</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​             </p><p>我们都知道联合(也叫共用体)中的不同类型的变量都是放在同一个地址开始的内存单元里面，当然这个内存单元足够大，可以容下<strong>所占空间最大的那个数据类型</strong>。</p><h2 id="explicit关键字"><a href="#explicit关键字" class="headerlink" title="explicit关键字"></a>explicit关键字</h2><p>在构造函数前面加上，为了防止其他类型的变量隐式转化为这个类的类型变量必须使用显式的转化</p><p>vector vs = {“hello”, “world”};比如这里就将const char转为string，但是加上<code>explicit</code>之后就不可以了</p><h2 id="auto关键字的缺点"><a href="#auto关键字的缺点" class="headerlink" title="auto关键字的缺点"></a>auto关键字的缺点</h2><p>auto 不利：降低代码可读性、可能得不到你预想的类型、配合decltype有意想不到的结果</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token number">2022</span><span class="token operator">-</span><span class="token number">4</span><span class="token operator">-</span><span class="token number">18</span><span class="token comment">// (4)</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> <span class="token operator">&amp;</span>elem<span class="token operator">:</span>vec<span class="token punctuation">)</span> <span class="token comment">// pass by reference</span>    elem <span class="token operator">*=</span> <span class="token number">3</span><span class="token punctuation">;</span><span class="token comment">// (5) 编译器会把(4)转换为(5)</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> _pos <span class="token operator">=</span> l<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> _end <span class="token operator">=</span> l<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> _pos <span class="token operator">!=</span> _end<span class="token punctuation">;</span> <span class="token operator">++</span>_pos<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">auto</span> <span class="token operator">&amp;</span>elem <span class="token operator">=</span> <span class="token operator">*</span>_pos<span class="token punctuation">;</span>    elem <span class="token operator">*=</span> <span class="token number">3</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">auto</span> ll1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token keyword">int</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> x <span class="token operator">+</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">// lambda 匿名函数 的简单使用</span>function<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token operator">></span> ll <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token keyword">int</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> x <span class="token operator">+</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>cout<span class="token operator">&lt;&lt;</span><span class="token function">ll1</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>cout<span class="token operator">&lt;&lt;</span><span class="token function">ll</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h2><p>Lambda 表达式是 C++11 引入的一个重要特性，它允许我们定义匿名函数，从而使代码更加简洁和易于阅读。</p><p>Lambda 表达式的一般形式如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Copy Code<span class="token punctuation">[</span>capture list<span class="token punctuation">]</span><span class="token punctuation">(</span>parameter list<span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token keyword">return</span> type <span class="token punctuation">&#123;</span>function body<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其中：</p><ul><li><code>capture list</code>：捕获列表，用于指定在函数体中使用的变量。</li><li><code>parameter list</code>：参数列表，指定函数的输入参数。</li><li><code>return type</code>：返回类型，指定函数的返回类型（可以自动推导）。</li><li><code>function body</code>：函数体，包含函数需要执行的代码。</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">auto</span> func <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token keyword">int</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>  <span class="token comment">// 输出 3</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>与 <code>auto</code> 关键字</p><h2 id="单例模式-1"><a href="#单例模式-1" class="headerlink" title="单例模式"></a>单例模式</h2><h3 id="简单单例模式"><a href="#简单单例模式" class="headerlink" title="简单单例模式"></a>简单单例模式</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//懒汉模式：只有在第一次用到的时候才会实例化</span><span class="token keyword">class</span> <span class="token class-name">singleton</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span><span class="token operator">:</span>        <span class="token function">singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>        <span class="token keyword">static</span> singleton <span class="token operator">*</span>p<span class="token punctuation">;</span>    <span class="token keyword">public</span><span class="token operator">:</span>        <span class="token keyword">static</span> singleton <span class="token operator">*</span><span class="token function">instance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>singleton <span class="token operator">*</span>singleton<span class="token double-colon punctuation">::</span>p <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>singleton<span class="token operator">*</span> singleton<span class="token double-colon punctuation">::</span><span class="token function">instance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span>        p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> p<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//将构造函数写在private或者protected里面，</span><span class="token comment">//同时有一个static指针维护这个单例</span><span class="token comment">//实例的实现由一个public方法来实现，该方法返回该类的唯一实例。</span><span class="token comment">//当然这个单例模式在单线程下面是安全的，</span><span class="token comment">//如果是多线程下同时检测到p是nullptr，会创建两个实例</span><span class="token comment">//饿汉模式</span><span class="token keyword">class</span> <span class="token class-name">singleton</span> <span class="token punctuation">&#123;</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token function">singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    <span class="token keyword">static</span> singleton <span class="token operator">*</span>p<span class="token punctuation">;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">static</span> singleton <span class="token operator">*</span><span class="token function">instance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>singleton <span class="token operator">*</span>singleton<span class="token double-colon punctuation">::</span>p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//实例化了</span>singleton<span class="token operator">*</span> singleton<span class="token double-colon punctuation">::</span><span class="token function">instance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> p<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 当然这个是线程安全的，对于我们通常阐述的线程不安全，为懒汉模式</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>decltype</code> 的意思是获得表达式的 <code>type</code> ，有点像 <code>typeof</code>。</p><p><code>final</code> 用在类后面 <code>class Base final &#123;&#125;</code> 表示这个类是继承的最后一个类，不能有其他类继承它</p><h3 id="加了锁的单例模式"><a href="#加了锁的单例模式" class="headerlink" title="加了锁的单例模式"></a>加了锁的单例模式</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;thread></span>         <span class="token comment">// std::thread </span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;mutex></span>          <span class="token comment">// std::mutex</span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token comment">/*用互斥量构建一个枷锁类*/</span><span class="token keyword">class</span> <span class="token class-name">Lock</span> <span class="token punctuation">&#123;</span><span class="token keyword">private</span><span class="token operator">:</span>    mutex mtx<span class="token punctuation">;</span><span class="token comment">//互斥量</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> mtx<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token comment">//加锁</span>    <span class="token keyword">void</span> <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> mtx<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token comment">//解锁</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">/*静态单例*/</span><span class="token keyword">class</span> <span class="token class-name">singleton</span> <span class="token punctuation">&#123;</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">int</span> _value<span class="token punctuation">;</span><span class="token comment">//测试用值，静态单例在哪个线程中被第一次获取，_value的值就是哪个线程的id</span>    <span class="token function">singleton</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//构造函数</span>    <span class="token function">singleton</span><span class="token punctuation">(</span><span class="token keyword">const</span> singleton<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//复制构造函数</span>    singleton<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> singleton<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//赋值构造函数</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">static</span> Lock<span class="token operator">*</span> Locker<span class="token punctuation">;</span><span class="token comment">//声明一个枷锁指针</span>    <span class="token keyword">static</span> singleton<span class="token operator">*</span> Instance<span class="token punctuation">;</span><span class="token comment">//声明一个对象</span>    <span class="token keyword">static</span> singleton<span class="token operator">*</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token keyword">int</span> thread_id<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//声明获取单例的函数</span>    <span class="token keyword">int</span> <span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//获取测试值</span>    <span class="token operator">~</span><span class="token function">singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//析构函数</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>singleton<span class="token double-colon punctuation">::</span><span class="token function">singleton</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">_value</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token comment">//构造函数</span>singleton<span class="token double-colon punctuation">::</span><span class="token function">singleton</span><span class="token punctuation">(</span><span class="token keyword">const</span> singleton<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token comment">//复制构造函数</span>singleton<span class="token operator">&amp;</span> singleton<span class="token double-colon punctuation">::</span><span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> singleton<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token comment">//赋值构造函数</span><span class="token class-name">singleton</span><span class="token double-colon punctuation">::</span><span class="token operator">~</span><span class="token function">singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token comment">//析构函数</span>Lock<span class="token operator">*</span> singleton<span class="token double-colon punctuation">::</span>Locker <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//初始化静态单例中的枷锁</span>singleton<span class="token operator">*</span> singleton<span class="token double-colon punctuation">::</span>Instance <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token comment">//初始化静态单例</span>singleton<span class="token operator">*</span> singleton<span class="token double-colon punctuation">::</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token keyword">int</span> thread_id<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">//定义获取单例的函数</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>Instance <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">//由于加锁比较费事，所以先判断一次</span>        Locker<span class="token operator">-></span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>Instance <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            Instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">singleton</span><span class="token punctuation">(</span>thread_id<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//初始化静态单例，参数为 线程的id</span>        <span class="token punctuation">&#125;</span>        Locker<span class="token operator">-></span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> Instance<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> singleton<span class="token double-colon punctuation">::</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">//获取测试值</span>    <span class="token keyword">return</span> _value<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>mutex myMtx<span class="token punctuation">;</span><span class="token comment">//为了防止多个线程争夺 标准输出资源而设置的互斥量</span><span class="token keyword">void</span> <span class="token function">print_thread_id</span><span class="token punctuation">(</span><span class="token keyword">int</span> thread_id<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">//线程函数</span>    singleton<span class="token operator">*</span> Instance <span class="token operator">=</span> singleton<span class="token double-colon punctuation">::</span><span class="token function">getInstance</span><span class="token punctuation">(</span>thread_id<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//获取静态单例</span>    myMtx<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"thread_id: "</span> <span class="token operator">&lt;&lt;</span> thread_id <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Instance is Created in thread: "</span> <span class="token operator">&lt;&lt;</span> Instance<span class="token operator">-></span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    myMtx<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    thread threads<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//两个线程</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>        threads<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">thread</span><span class="token punctuation">(</span>print_thread_id<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//启动线程</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;</span> th <span class="token operator">:</span> threads<span class="token punctuation">)</span> th<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//等线程结束</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;thread></span>         <span class="token comment">// std::thread </span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;mutex></span>          <span class="token comment">// std::mutex</span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">lock12</span> <span class="token punctuation">&#123;</span><span class="token keyword">private</span><span class="token operator">:</span>mutex mtx<span class="token punctuation">;</span><span class="token keyword">public</span><span class="token operator">:</span><span class="token keyword">void</span> <span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> mtx<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">unLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> mtx<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">&#123;</span><span class="token keyword">private</span><span class="token operator">:</span><span class="token keyword">int</span> value<span class="token punctuation">;</span><span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token keyword">int</span> _value<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">value</span><span class="token punctuation">(</span>_value<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token keyword">const</span> Singleton<span class="token operator">&amp;</span> single<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>Singleton<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> Singleton<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token keyword">public</span><span class="token operator">:</span><span class="token keyword">static</span> lock12<span class="token operator">*</span> lock1<span class="token punctuation">;</span><span class="token keyword">static</span> Singleton<span class="token operator">*</span> instance<span class="token punctuation">;</span><span class="token keyword">static</span> Singleton<span class="token operator">*</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token keyword">int</span> thread_id<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">get_value</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> value<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token operator">~</span><span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>lock12<span class="token operator">*</span> Singleton<span class="token double-colon punctuation">::</span>lock1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">lock12</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Singleton<span class="token operator">*</span> Singleton<span class="token double-colon punctuation">::</span>instance <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>Singleton<span class="token operator">*</span> <span class="token class-name">Singleton</span><span class="token double-colon punctuation">::</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token keyword">int</span> thread_id<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">//双检锁 1</span>lock1<span class="token operator">-></span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">//2</span>instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Singleton</span><span class="token punctuation">(</span>thread_id<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>lock1<span class="token operator">-></span><span class="token function">unLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> instance<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>mutex mtLock<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">print_thread_id</span><span class="token punctuation">(</span><span class="token keyword">int</span> thread_id<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>Singleton<span class="token operator">*</span> instance <span class="token operator">=</span> <span class="token class-name">Singleton</span><span class="token double-colon punctuation">::</span><span class="token function">getInstance</span><span class="token punctuation">(</span>thread_id<span class="token punctuation">)</span><span class="token punctuation">;</span>mtLock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> thread_id<span class="token operator">&lt;&lt;</span><span class="token string">" "</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> instance<span class="token operator">-></span><span class="token function">get_value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>mtLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>thread thread1<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>thread1<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">thread</span><span class="token punctuation">(</span>print_thread_id<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;</span> th <span class="token operator">:</span> thread1<span class="token punctuation">)</span> th<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//等线程结束</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Scott-Meyer-简洁的singleton写法"><a href="#Scott-Meyer-简洁的singleton写法" class="headerlink" title="Scott Meyer/简洁的singleton写法"></a>Scott Meyer/简洁的singleton写法</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Singleton <span class="token operator">*</span><span class="token class-name">Singleton</span><span class="token double-colon punctuation">::</span><span class="token function">getinstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">static</span> Singleton p<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token operator">&amp;</span>p<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>               <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="解耦"><a href="#解耦" class="headerlink" title="解耦"></a>解耦</h2><p><strong>程序设计经常提到的解耦，到底是要解除什么之间的耦合</strong></p><p>解耦，就是将程序积木化</p><p>就像我们玩的积木一样，各个积木可以<strong>组合</strong>在一起而形成一个形状，又可以<strong>拆分</strong>，又可以<strong>替换</strong>，因为基本上各个积木块都是<strong>独立</strong>的，只要他们之间的接口（形状）匹配，就可以灵活地组合在一起。</p><p>当然，这是理想状态。<strong>解耦是在逐达到这个理想状态。</strong></p><p>在实际开发中有几种方式实现解耦：</p><p>1、使用接口隔离</p><p>2、采用事件驱动架构</p><p>3、使用设计模式，提高灵活度</p>]]></content>
      
      
      <categories>
          
          <category> c++基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Makefile 学习</title>
      <link href="/2024/01/21/makefile-xue-xi/"/>
      <url>/2024/01/21/makefile-xue-xi/</url>
      
        <content type="html"><![CDATA[<h1 id="Makefile-学习"><a href="#Makefile-学习" class="headerlink" title="Makefile 学习"></a>Makefile 学习</h1><h1 id="C语言的编译过程"><a href="#C语言的编译过程" class="headerlink" title="C语言的编译过程"></a>C语言的编译过程</h1><h2 id="预处理（Preprocessing）"><a href="#预处理（Preprocessing）" class="headerlink" title="预处理（Preprocessing）"></a>预处理（Preprocessing）</h2><p>-E是让编译器在<strong>预处理之后</strong>就退出，不进行后续编译过程；-o是指定输出文件名。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">gcc <span class="token parameter variable">-E</span> hello.c <span class="token parameter variable">-o</span> hello.i<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="编译（Compilation）"><a href="#编译（Compilation）" class="headerlink" title="编译（Compilation）"></a>编译（Compilation）</h2><p><img src="https://s2.loli.net/2024/01/13/qWfwmgaBdeONbnZ.png" alt=""></p><p>这里的编译不是指程序从源文件到二进制程序的全部过程，而是指将经过预处理文件（test.i）之后的程序转换成特定汇编（test.s）代码的过程。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">gcc <span class="token parameter variable">-S</span> hello.i <span class="token parameter variable">-o</span> hello.s<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h2><p>汇编过程将上一步的汇编代码转换成机器码，这一步产生的文件叫做目标文件，是二进制格式。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">gcc <span class="token parameter variable">-c</span> hello.s <span class="token parameter variable">-o</span> hello.o<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p>链接过程使用链接器将该目标文件与其他目标文件、库文件、启动文件等链接起来生成可执行文件。附加的目标文件包括静态连接库和动态连接库。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">gcc hello.o <span class="token parameter variable">-o</span> hello<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>生成可执行程序过程为成四个步骤：</p><p>1、由.c文件到.i文件，这个过程叫预处理。<br>2、由.i文件到.s文件，这个过程叫编译。<br>3、由.s文件到.o文件，这个过程叫汇编。<br>4、由.o文件到可执行文件，这个过程叫链接。</p><h2 id="静态库"><a href="#静态库" class="headerlink" title="静态库"></a>静态库</h2><p>在编译的过程中，会被直接载入到可执行文件中，将多个文件组成一个库，实现复用，以lib开头，以.a结尾，使用ar命令</p><h2 id="动态库"><a href="#动态库" class="headerlink" title="动态库"></a>动态库</h2><p>在程序编译时并不会被连接到目标代码中，而是在程序运行是才被载入。这就带来了一个明显的好处：不同的应用程序如果调用相同的库，那么在内存里<strong>只需要有一份该共享库的实例</strong>，减小了各个模块之间的耦合程度，也减小了可执行文件的体积。</p><h1 id="MakeFile"><a href="#MakeFile" class="headerlink" title="MakeFile"></a>MakeFile</h1><h2 id="基本格式"><a href="#基本格式" class="headerlink" title="基本格式"></a>基本格式</h2><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token target symbol">target ...</span> <span class="token punctuation">:</span> prerequisites ...    command    ...    ...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>make debug执行下面的命令</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token target symbol">debug</span><span class="token punctuation">:</span>echo hello<span class="token builtin-target builtin">.PHONY</span><span class="token punctuation">:</span> clean <span class="token comment"># 伪目标</span><span class="token target symbol">clean</span><span class="token punctuation">:</span>rm *.o<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">cpp <span class="token operator">:=</span> src/main.cppobj <span class="token operator">:=</span> obj/main.o<span class="token target symbol"><span class="token variable">$</span>&#123;obj&#125;</span><span class="token punctuation">:</span> <span class="token variable">$</span><span class="token punctuation">&#123;</span>cpp<span class="token punctuation">&#125;</span>g++ -c <span class="token variable">$</span><span class="token punctuation">&#123;</span>cpp<span class="token punctuation">&#125;</span> -o <span class="token variable">$</span><span class="token punctuation">&#123;</span>obj<span class="token punctuation">&#125;</span><span class="token comment"># $@ target的名称</span><span class="token comment"># $&lt; 第一个依赖文件</span><span class="token comment"># $^ 所有的依赖文件</span><span class="token target symbol">compile</span><span class="token punctuation">:</span> <span class="token variable">$</span><span class="token punctuation">&#123;</span>obj<span class="token punctuation">&#125;</span><span class="token target symbol">clean</span><span class="token punctuation">:</span>rm -rf obj<span class="token comment"># Windows下使用del obj</span><span class="token builtin-target builtin">.PHONY</span><span class="token punctuation">:</span> clean debug<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="运算符号"><a href="#运算符号" class="headerlink" title="运算符号"></a>运算符号</h2><p>:=：赋值后不可改变</p><p>= ：可以改变</p><p>?=：在变量尚未设置时才将其设置为值</p><p>+=：添加</p><p>\：续行符</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>shell：把执行操作系统命令后的输出作为函数返回，本质上就是执行shell命令。</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">cpp_srcs <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">&#123;</span>shell find src -name *.cpp<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>subst、patsubst</p><p>格式：源字符串都是<code>&lt;text&gt;</code>的内容</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">subst</span> &lt;from>,&lt;to>,&lt;text><span class="token punctuation">)</span><span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">patsubst</span> &lt;pattern>,&lt;replacement>,&lt;text><span class="token punctuation">)</span> <span class="token comment"># pattern中的%和replacement中的%相同</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>foreach</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">foreach</span> &lt;var>,&lt;list>,&lt;text><span class="token punctuation">)</span><span class="token comment"># eg</span>names <span class="token operator">:=</span> a b c dfiles <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">foreach</span> n,<span class="token variable">$</span><span class="token punctuation">(</span>names<span class="token punctuation">)</span>,<span class="token variable">$</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span>.o<span class="token punctuation">)</span><span class="token comment"># $(file) := a.o b.o c.o d.o </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>dir</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">dir</span> &lt;names...><span class="token punctuation">)</span> <span class="token comment">#取目录函数</span><span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">dir</span> src/foo.c hacks<span class="token punctuation">)</span> <span class="token comment"># 返回值是 src/ ./</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>notdir、filter</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">notdir</span> &lt;names...><span class="token punctuation">)</span> <span class="token comment"># 取文件函数</span><span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">notdir</span> src/foo.c hacks<span class="token punctuation">)</span> <span class="token comment"># 返回值是 foo.c hacks</span><span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">filter</span> &lt;pattern...>,&lt;text><span class="token punctuation">)</span> <span class="token comment"># 过滤出text中符合pattern的字符串</span>sources <span class="token operator">:=</span> foo.c bar.c baz.s ugh.h<span class="token target symbol">foo</span><span class="token punctuation">:</span> <span class="token variable">$</span><span class="token punctuation">(</span>sources<span class="token punctuation">)</span>cc <span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">filter</span> %.c %.s,<span class="token variable">$</span><span class="token punctuation">(</span>sources<span class="token punctuation">)</span><span class="token punctuation">)</span> -o foo <span class="token comment"># $(filter %.c %.s,$(sources)) 返回的值是 foo.c bar.c baz.s</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="编译带有头文件的项目"><a href="#编译带有头文件的项目" class="headerlink" title="编译带有头文件的项目"></a>编译带有头文件的项目</h2><p>Makefile示例（1）：</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">cpp_srcs <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">shell</span> find src -name *.cpp<span class="token punctuation">)</span>cpp_objs <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">patsubst</span> src/%.cpp,objs/%.o,<span class="token variable">$</span><span class="token punctuation">(</span>cpp_srcs<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment"># 你的头文件所在文件夹路径（建议绝对路径）</span>include_paths <span class="token operator">:=</span> I_flag        <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span>include_paths<span class="token punctuation">:</span>%<span class="token operator">=</span>-I%<span class="token punctuation">)</span><span class="token target symbol">objs/%.o</span> <span class="token punctuation">:</span> src/%.cpp<span class="token operator">@</span>mkdir -p <span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">dir</span> <span class="token variable">$@</span><span class="token punctuation">)</span><span class="token operator">@</span>g++ -c <span class="token variable">$^</span> -o <span class="token variable">$@</span> <span class="token variable">$</span><span class="token punctuation">(</span>I_flag<span class="token punctuation">)</span><span class="token target symbol">workspace/exec</span> <span class="token punctuation">:</span> <span class="token variable">$</span><span class="token punctuation">(</span>cpp_objs<span class="token punctuation">)</span><span class="token operator">@</span>mkdir -p <span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">dir</span> <span class="token variable">$@</span><span class="token punctuation">)</span><span class="token operator">@</span>g++ <span class="token variable">$^</span> -o <span class="token variable">$@</span> <span class="token target symbol">run</span> <span class="token punctuation">:</span> workspace/exec<span class="token operator">@</span>./<span class="token variable">$&lt;</span><span class="token target symbol">debug</span> <span class="token punctuation">:</span><span class="token operator">@</span>echo <span class="token variable">$</span><span class="token punctuation">(</span>I_flag<span class="token punctuation">)</span><span class="token target symbol">clean</span> <span class="token punctuation">:</span><span class="token operator">@</span>rm -rf objs<span class="token builtin-target builtin">.PHONY</span> <span class="token punctuation">:</span> debug run<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Makefile示例（2）：</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token comment"># Compiler</span>CXX <span class="token operator">:=</span> g++<span class="token comment"># cpp sources</span>cpp_srcs <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">&#123;</span>shell find src -name *.cpp<span class="token punctuation">&#125;</span><span class="token comment"># $(warning cpp_srcs is $&#123;cpp_srcs&#125;)</span><span class="token comment"># cpp objects</span>cpp_objs <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">&#123;</span>patsubst src/%.cpp,objs/%.o,<span class="token variable">$</span><span class="token punctuation">&#123;</span>cpp_srcs<span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment"># $(warning cpp_objs is $&#123;cpp_objs&#125;)</span><span class="token comment"># cpp include path</span>include_path <span class="token operator">:=</span> /home/mirac/Desktop/Retest/<span class="token keyword">include</span>I_flags <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">&#123;</span>include_path<span class="token punctuation">:</span>%<span class="token operator">=</span>-I%<span class="token punctuation">&#125;</span><span class="token comment"># $&#123;warning I_flags is $&#123;I_flags&#125;&#125;</span><span class="token comment"># compile option</span>Compile_option <span class="token operator">:=</span> -g -O3 -wCompile_option <span class="token operator">+=</span> <span class="token variable">$</span><span class="token punctuation">&#123;</span>I_flags<span class="token punctuation">&#125;</span><span class="token comment"># $(warning Compile_option is $&#123;Compile_option&#125;)</span><span class="token target symbol">objs/%.o</span> <span class="token punctuation">:</span> src/%.cpp<span class="token operator">@</span>mkdir -p <span class="token variable">$</span><span class="token punctuation">&#123;</span>dir <span class="token variable">$@</span><span class="token punctuation">&#125;</span><span class="token operator">@</span><span class="token variable">$</span><span class="token punctuation">&#123;</span>CXX<span class="token punctuation">&#125;</span> -o <span class="token variable">$@</span> -c <span class="token variable">$^</span>  <span class="token variable">$</span><span class="token punctuation">&#123;</span>Compile_option<span class="token punctuation">&#125;</span><span class="token target symbol">workspace/testJson</span><span class="token punctuation">:</span> <span class="token variable">$</span><span class="token punctuation">&#123;</span>cpp_objs<span class="token punctuation">&#125;</span><span class="token operator">@</span><span class="token variable">$</span><span class="token punctuation">&#123;</span>CXX<span class="token punctuation">&#125;</span> -o <span class="token variable">$@</span>  <span class="token variable">$^</span> <span class="token target symbol">run</span> <span class="token punctuation">:</span> workspace/testJson<span class="token operator">@</span>./<span class="token variable">$&lt;</span><span class="token target symbol">debug</span><span class="token punctuation">:</span>echo <span class="token variable">$</span><span class="token punctuation">&#123;</span>cpp_srcs<span class="token punctuation">&#125;</span>echo <span class="token variable">$</span><span class="token punctuation">&#123;</span>cpp_objs<span class="token punctuation">&#125;</span>echo <span class="token variable">$</span><span class="token punctuation">&#123;</span>I_flags<span class="token punctuation">&#125;</span><span class="token comment"># @echo $&#123;CC&#125; -o $@ -c $^  $&#123;Compile_option&#125;</span><span class="token target symbol">clean</span> <span class="token punctuation">:</span> <span class="token operator">@</span>rm -r objs<span class="token operator">@</span>rm -r workspace/*<span class="token builtin-target builtin">.PHONY</span><span class="token punctuation">:</span> clean debug<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> c++基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++指针复习</title>
      <link href="/2024/01/19/c-de-zhi-zhen-fu-xi/"/>
      <url>/2024/01/19/c-de-zhi-zhen-fu-xi/</url>
      
        <content type="html"><![CDATA[<h1 id="CPP指针深析"><a href="#CPP指针深析" class="headerlink" title="CPP指针深析"></a>CPP指针深析</h1><p>指针对于初学者往往是很难以琢磨的东西，因为它并不如变量那么抽象，而是更贴近底层的真实结构。指针操作往往会出现各种各样的岔子，最常见的便是”segmentation fault”。所以这里辨析了各种指针类型，实践出真知，下面的例子如果自己敲下来就更好了😁😁😁</p><p>指针是C++中强大的工具，灵活但容易出错，同时也是一把“双刃剑”。</p><hr><h2 id="1-指针的基本概念"><a href="#1-指针的基本概念" class="headerlink" title="1. 指针的基本概念"></a><strong>1. 指针的基本概念</strong></h2><p>指针是一种保存地址的变量。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token keyword">int</span><span class="token operator">*</span> p <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">;</span> <span class="token comment">// p保存a的地址</span>std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Value of a: "</span> <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>p <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span> <span class="token comment">// 解引用获取a的值</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li><code>&amp;</code>：取地址符，获取变量地址。</li><li><code>*</code>：解引用符，通过地址访问变量值。</li></ul><p><strong>注意</strong>：未初始化的指针称为野指针，会导致未定义行为。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span><span class="token operator">*</span> p<span class="token punctuation">;</span> <span class="token comment">// 未初始化</span>std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>p <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span> <span class="token comment">// 未定义行为</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><hr><h2 id="2-指针的分类与使用"><a href="#2-指针的分类与使用" class="headerlink" title="2. 指针的分类与使用"></a><strong>2. 指针的分类与使用</strong></h2><h3 id="2-1-空指针"><a href="#2-1-空指针" class="headerlink" title="2.1 空指针"></a><strong>2.1 空指针</strong></h3><p>空指针（<code>nullptr</code>）指向“无效”地址，避免野指针问题。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span><span class="token operator">*</span> p <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Pointer is null"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注意</strong>：解引用空指针会引发运行时错误。</p><hr><h3 id="2-2-常量指针和指针常量"><a href="#2-2-常量指针和指针常量" class="headerlink" title="2.2 常量指针和指针常量"></a><strong>2.2 常量指针和指针常量</strong></h3><ul><li><strong>常量指针</strong>：指向的值不能修改。</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">const</span> <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">*</span> p <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">;</span> <span class="token comment">//*p = 20; // 错误，值不可修改</span>p <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span> <span class="token comment">// 指针本身可以指向其他地址</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>指针常量</strong>：指针的地址不能修改。</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">,</span> c <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span><span class="token keyword">int</span><span class="token operator">*</span> <span class="token keyword">const</span> p <span class="token operator">=</span> <span class="token operator">&amp;</span>b<span class="token punctuation">;</span><span class="token comment">//p = &amp;c; // 错误，指针地址不可修改</span><span class="token operator">*</span>p <span class="token operator">=</span> <span class="token number">30</span><span class="token punctuation">;</span> <span class="token comment">// 正确，值可以修改</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>指向常量的指针常量</strong>：</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">const</span> <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">*</span> <span class="token keyword">const</span> p <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">;</span><span class="token comment">//*p = 20; // 错误</span><span class="token comment">//p = &amp;b; // 错误</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="2-3-指针与数组"><a href="#2-3-指针与数组" class="headerlink" title="2.3 指针与数组"></a><strong>2.3 指针与数组</strong></h3><p>指针与数组关系密切，数组名即为首元素地址：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">int</span><span class="token operator">*</span> p <span class="token operator">=</span> arr<span class="token punctuation">;</span>std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> p<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span> <span class="token comment">// 输出 2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>使用指针操作数组：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span><span class="token punctuation">(</span>p <span class="token operator">+</span> i<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span> <span class="token comment">// 依次输出数组元素</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><hr><h3 id="2-4-指针与函数"><a href="#2-4-指针与函数" class="headerlink" title="2.4 指针与函数"></a><strong>2.4 指针与函数</strong></h3><p>指针可用于传递函数参数，实现高效操作：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">*</span> y<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> temp <span class="token operator">=</span> <span class="token operator">*</span>x<span class="token punctuation">;</span>    <span class="token operator">*</span>x <span class="token operator">=</span> <span class="token operator">*</span>y<span class="token punctuation">;</span>    <span class="token operator">*</span>y <span class="token operator">=</span> temp<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span><span class="token function">swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">,</span> <span class="token operator">&amp;</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span> std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> b <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span> <span class="token comment">// 输出 20 10</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="2-5-动态内存分配与指针"><a href="#2-5-动态内存分配与指针" class="headerlink" title="2.5 动态内存分配与指针"></a><strong>2.5 动态内存分配与指针</strong></h3><p>通过<code>new</code>和<code>delete</code>动态分配内存：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span><span class="token operator">*</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span> std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>p <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span> <span class="token comment">// 输出 42</span><span class="token keyword">delete</span> p<span class="token punctuation">;</span> <span class="token comment">// 释放内存</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>动态数组：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span><span class="token operator">*</span> arr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">;</span> <span class="token comment">// 释放动态数组</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>注意</strong>：</p><ul><li>忘记释放内存会导致内存泄漏。</li><li>使用<code>delete</code>释放后，不要再解引用。</li></ul><hr><h3 id="2-6-指针与多级指针"><a href="#2-6-指针与多级指针" class="headerlink" title="2.6 指针与多级指针"></a><strong>2.6 指针与多级指针</strong></h3><p>多级指针是指向指针的指针：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token keyword">int</span><span class="token operator">*</span> p1 <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">;</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token operator">*</span> p2 <span class="token operator">=</span> <span class="token operator">&amp;</span>p1<span class="token punctuation">;</span> <span class="token comment">// p2指向p1</span>std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span><span class="token operator">*</span>p2 <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span> <span class="token comment">// 输出10</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="3-常见问题与调试技巧"><a href="#3-常见问题与调试技巧" class="headerlink" title="3. 常见问题与调试技巧"></a><strong>3. 常见问题与调试技巧</strong></h3><ol><li><p><strong>空指针解引用</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span><span class="token operator">*</span> p <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>p <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span> <span class="token comment">// segmentation fault</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p><strong>指针越界</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">int</span><span class="token operator">*</span> p <span class="token operator">=</span> arr <span class="token operator">+</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token comment">// 超出数组范围</span>std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>p <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span> <span class="token comment">// 未定义行为</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p><strong>野指针</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span><span class="token operator">*</span> p<span class="token punctuation">;</span><span class="token keyword">delete</span> p<span class="token punctuation">;</span> <span class="token comment">// p未指向有效地址</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ol><p><strong>调试方法</strong>：</p><ul><li>检查<code>nullptr</code>。</li><li>使用工具（如Valgrind）检测内存泄漏。</li><li>避免无意义的解引用操作。</li></ul><hr><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a><strong>4. 总结</strong></h2><p>指针的强大功能伴随着复杂性和风险。通过反复实践和注重细节，可以掌握指针的精髓，写出高效可靠的C++代码。初学者特别要注意避免未定义行为，同时养成良好的编码习惯。</p><h2 id="const修饰指针"><a href="#const修饰指针" class="headerlink" title="const修饰指针"></a>const修饰指针</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Rectangle</span><span class="token punctuation">&#123;</span>  <span class="token keyword">public</span><span class="token operator">:</span>  <span class="token function">Rectangle</span><span class="token punctuation">(</span><span class="token keyword">int</span> length<span class="token punctuation">,</span> <span class="token keyword">int</span> width<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>chang<span class="token operator">=</span>length<span class="token punctuation">;</span> kuan<span class="token operator">=</span>width<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>    <span class="token keyword">void</span> <span class="token function">SetLength</span><span class="token punctuation">(</span><span class="token keyword">int</span> length<span class="token punctuation">)</span><span class="token punctuation">&#123;</span> chang<span class="token operator">=</span>length<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>    <span class="token keyword">int</span> <span class="token function">GetLength</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">&#123;</span> <span class="token keyword">return</span> chang<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>  <span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">int</span> chang<span class="token punctuation">;</span>    <span class="token keyword">int</span> kuan<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token comment">// int a=123;</span>  <span class="token comment">// const int *p=&amp;a;//const 修饰*，p可以改</span>  <span class="token comment">// cout&lt;&lt;*p&lt;&lt;endl;</span>  <span class="token comment">// int b=567;</span>  <span class="token comment">// p=&amp;b;</span>  <span class="token comment">// cout&lt;&lt;*p&lt;&lt;endl;</span>  <span class="token comment">// int const *p1=&amp;a;</span>  <span class="token comment">// int * const p2=&amp;b;const 修饰p2，*p2可以改</span>  <span class="token comment">// *p2=789;</span>  <span class="token comment">// // p2=&amp;a;</span>  <span class="token comment">// cout&lt;&lt;*p2&lt;&lt;endl;</span>  Rectangle <span class="token operator">*</span>rec<span class="token operator">=</span><span class="token keyword">new</span> <span class="token function">Rectangle</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">,</span> <span class="token number">456</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  Rectangle <span class="token operator">*</span>rec1<span class="token operator">=</span><span class="token keyword">new</span> <span class="token function">Rectangle</span><span class="token punctuation">(</span><span class="token number">789</span><span class="token punctuation">,</span> <span class="token number">456</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  cout<span class="token operator">&lt;&lt;</span>rec<span class="token operator">-></span><span class="token function">GetLength</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>  <span class="token keyword">const</span> Rectangle <span class="token operator">*</span> pRec<span class="token operator">=</span>rec<span class="token punctuation">;</span>  cout<span class="token operator">&lt;&lt;</span>pRec<span class="token operator">-></span><span class="token function">GetLength</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>  pRec<span class="token operator">=</span>rec1<span class="token punctuation">;</span><span class="token comment">//同p</span>  cout<span class="token operator">&lt;&lt;</span>pRec<span class="token operator">-></span><span class="token function">GetLength</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token comment">//只能调用const方法</span>  Rectangle <span class="token operator">*</span> <span class="token keyword">const</span> pRec1<span class="token operator">=</span>rec<span class="token punctuation">;</span><span class="token comment">//同p2</span>  cout<span class="token operator">&lt;&lt;</span>pRec1<span class="token operator">-></span><span class="token function">GetLength</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>  Rectangle <span class="token operator">*</span>pPrec0<span class="token operator">=</span>rec<span class="token punctuation">;</span>  pPrec0<span class="token operator">-></span><span class="token function">SetLength</span><span class="token punctuation">(</span><span class="token number">789</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//非const方法也可以调用</span>  cout<span class="token operator">&lt;&lt;</span>pRec<span class="token operator">-></span><span class="token function">GetLength</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这段代码通过一些实例讲解了<code>const</code>修饰指针的不同用法，并结合类的<code>const</code>方法，展示了指针常量和指向常量的指针的区别。以下是代码运行的核心分析：</p><hr><h3 id="核心概念解析"><a href="#核心概念解析" class="headerlink" title="核心概念解析"></a><strong>核心概念解析</strong></h3><h4 id="1-const修饰指针的两种情况"><a href="#1-const修饰指针的两种情况" class="headerlink" title="1. const修饰指针的两种情况"></a>1. <code>const</code>修饰指针的两种情况</h4><ol><li><p><strong>指向常量的指针（<code>const</code>修饰指向内容）</strong></p><ul><li>指针可以指向不同地址，但指向的内容不可修改。</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">;</span> <span class="token comment">// 或 int const *p = &amp;a;</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>b<span class="token punctuation">;</span>           <span class="token comment">// OK: 修改指针地址</span><span class="token operator">*</span>p <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>          <span class="token comment">// 错误: 修改指向内容</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p><strong>指针常量（<code>const</code>修饰指针本身）</strong></p><ul><li>指针地址不可修改，但指向的内容可以改。</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token operator">*</span><span class="token keyword">const</span> p <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">;</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>b<span class="token punctuation">;</span>           <span class="token comment">// 错误: 修改指针地址</span><span class="token operator">*</span>p <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>          <span class="token comment">// OK: 修改指向内容</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ol><hr><h4 id="2-类中的const方法"><a href="#2-类中的const方法" class="headerlink" title="2. 类中的const方法"></a>2. 类中的<code>const</code>方法</h4><ul><li><p><code>const</code>方法：</p><p> 方法后加<code>const</code>，表示该方法不会修改类的成员变量。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">GetLength</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span> <span class="token comment">// 只读方法</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果通过<code>const</code>对象（或<code>const</code>指针）调用方法，只能调用<code>const</code>方法。</p></li></ul><hr><h3 id="代码行为解析"><a href="#代码行为解析" class="headerlink" title="代码行为解析"></a>代码行为解析</h3><h4 id="（1）创建普通对象和指针"><a href="#（1）创建普通对象和指针" class="headerlink" title="（1）创建普通对象和指针"></a>（1）创建普通对象和指针</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Rectangle <span class="token operator">*</span>rec <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Rectangle</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">,</span> <span class="token number">456</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Rectangle <span class="token operator">*</span>rec1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Rectangle</span><span class="token punctuation">(</span><span class="token number">789</span><span class="token punctuation">,</span> <span class="token number">456</span><span class="token punctuation">)</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> rec<span class="token operator">-></span><span class="token function">GetLength</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// 输出 123</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li><code>rec</code>是普通指针，能自由调用非<code>const</code>方法。</li></ul><h4 id="（2）指向常量的指针"><a href="#（2）指向常量的指针" class="headerlink" title="（2）指向常量的指针"></a>（2）指向常量的指针</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">const</span> Rectangle <span class="token operator">*</span>pRec <span class="token operator">=</span> rec<span class="token punctuation">;</span> <span class="token comment">// pRec指向一个常量对象</span>cout <span class="token operator">&lt;&lt;</span> pRec<span class="token operator">-></span><span class="token function">GetLength</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// 输出 123</span>pRec <span class="token operator">=</span> rec1<span class="token punctuation">;</span> <span class="token comment">// OK: 修改指针地址</span>cout <span class="token operator">&lt;&lt;</span> pRec<span class="token operator">-></span><span class="token function">GetLength</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// 输出 789</span><span class="token comment">// pRec->SetLength(456); // 错误: 无法调用非const方法</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>pRec</code>只能调用<code>const</code>方法（<code>GetLength</code>），但可以指向其他<code>Rectangle</code>对象。</li></ul><h4 id="（3）指针常量"><a href="#（3）指针常量" class="headerlink" title="（3）指针常量"></a><strong>（3）指针常量</strong></h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Rectangle <span class="token operator">*</span><span class="token keyword">const</span> pRec1 <span class="token operator">=</span> rec<span class="token punctuation">;</span> <span class="token comment">// pRec1为指针常量</span>cout <span class="token operator">&lt;&lt;</span> pRec1<span class="token operator">-></span><span class="token function">GetLength</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// 输出 123</span>pRec1<span class="token operator">-></span><span class="token function">SetLength</span><span class="token punctuation">(</span><span class="token number">789</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// OK: 可调用非const方法修改内容</span>cout <span class="token operator">&lt;&lt;</span> pRec1<span class="token operator">-></span><span class="token function">GetLength</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// 输出 789</span><span class="token comment">// pRec1 = rec1; // 错误: 无法修改指针地址</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>pRec1</code>的指向地址不可修改，但其内容可以更改。</li></ul><h4 id="（4）普通指针调用非const方法"><a href="#（4）普通指针调用非const方法" class="headerlink" title="（4）普通指针调用非const方法"></a><strong>（4）普通指针调用非<code>const</code>方法</strong></h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Rectangle <span class="token operator">*</span>pPrec0 <span class="token operator">=</span> rec<span class="token punctuation">;</span>pPrec0<span class="token operator">-></span><span class="token function">SetLength</span><span class="token punctuation">(</span><span class="token number">789</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 调用非const方法</span>cout <span class="token operator">&lt;&lt;</span> pRec<span class="token operator">-></span><span class="token function">GetLength</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// 输出 789</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li><code>pPrec0</code>是普通指针，可以自由调用非<code>const</code>方法。</li></ul><hr><h3 id="输出结果"><a href="#输出结果" class="headerlink" title="输出结果"></a>输出结果</h3><p>最终输出如下：</p><pre class="line-numbers language-none"><code class="language-none">123123789123789<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><ul><li><strong><code>const</code>修饰指针的用法：</strong> 分清指向内容和指针本身谁是常量。</li><li><strong>类的<code>const</code>方法：</strong> 适用于保护类状态，在需要只读访问时尤为重要。</li><li><strong>实践建议：</strong> 在需要只读访问的场景下，优先使用<code>const</code>指针和<code>const</code>方法，提高代码的安全性和可维护性。</li></ul><h2 id="一维数组指针的区别"><a href="#一维数组指针的区别" class="headerlink" title="一维数组指针的区别"></a>一维数组指针的区别</h2><p>a代表首地址，在sizeof和&amp;a时当成了数组整体</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">sz</span><span class="token expression"><span class="token punctuation">(</span>type<span class="token punctuation">)</span> cout<span class="token operator">&lt;&lt;</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token number">12</span><span class="token punctuation">,</span><span class="token number">13</span><span class="token punctuation">,</span><span class="token number">14</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  <span class="token function">sz</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>  cout<span class="token operator">&lt;&lt;</span>a<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>  cout<span class="token operator">&lt;&lt;</span><span class="token operator">&amp;</span>a<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>  cout<span class="token operator">&lt;&lt;</span><span class="token operator">&amp;</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>  <span class="token comment">/*  12  0x9ffdb4  0x9ffdb4  0x9ffdb4  */</span>  cout<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>  cout<span class="token operator">&lt;&lt;</span>a<span class="token operator">&lt;&lt;</span><span class="token string">" "</span><span class="token operator">&lt;&lt;</span>a<span class="token operator">+</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span><span class="token string">" "</span><span class="token operator">&lt;&lt;</span>a<span class="token operator">+</span><span class="token number">2</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>            <span class="token comment">//a = &amp;a[0] != &amp;a</span>  cout<span class="token operator">&lt;&lt;</span><span class="token operator">&amp;</span>a<span class="token operator">&lt;&lt;</span><span class="token string">" "</span><span class="token operator">&lt;&lt;</span><span class="token operator">&amp;</span>a<span class="token operator">+</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span><span class="token string">" "</span><span class="token operator">&lt;&lt;</span><span class="token operator">&amp;</span>a<span class="token operator">+</span><span class="token number">2</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>  cout<span class="token operator">&lt;&lt;</span><span class="token operator">&amp;</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span><span class="token string">" "</span><span class="token operator">&lt;&lt;</span><span class="token operator">&amp;</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span><span class="token string">" "</span><span class="token operator">&lt;&lt;</span><span class="token operator">&amp;</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">2</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>  <span class="token comment">/*  0x9ffdb4 0x9ffdb8 0x9ffdbc  //步长是4，一个int  0x9ffdb4 0x9ffdc0 0x9ffdcc  //步长是12，三个int，也就是数组长度  0x9ffdb4 0x9ffdb8 0x9ffdbc  //步长是4，一个int  */</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个代码的核心在于区分一维数组的 <strong>数组名</strong> 和 <strong>数组地址</strong> 的概念，并通过<code>sizeof</code>和地址输出展示了它们的差异。下面详细解析这段代码及其输出。</p><hr><h3 id="核心概念解析-1"><a href="#核心概念解析-1" class="headerlink" title="核心概念解析"></a><strong>核心概念解析</strong></h3><h4 id="1-数组名-a"><a href="#1-数组名-a" class="headerlink" title="1. 数组名 a"></a><strong>1. 数组名 <code>a</code></strong></h4><ul><li>数组名（如 <code>a</code>）是一个特殊的指针，<strong>默认指向数组的首元素</strong>，即 <code>&amp;a[0]</code>。</li><li>但在某些特定场景中，<code>a</code>表现为整个数组的标志，比如 <code>sizeof(a)</code> 和 <code>&amp;a</code>。</li></ul><hr><h4 id="2-sizeof-的作用"><a href="#2-sizeof-的作用" class="headerlink" title="2. sizeof 的作用"></a><strong>2. <code>sizeof</code> 的作用</strong></h4><ul><li><code>sizeof(a)</code>：计算数组整体的字节大小（数组长度 × 元素大小）。</li><li><code>sizeof(&amp;a)</code>：计算指向数组的指针的大小，与平台有关（通常是4字节或8字节）。</li></ul><h4 id="3-amp-a-和-a-的区别"><a href="#3-amp-a-和-a-的区别" class="headerlink" title="3. &amp;a 和 a 的区别"></a><strong>3. <code>&amp;a</code> 和 <code>a</code> 的区别</strong></h4><ul><li><code>a</code> 是指向首元素的指针，等同于 <code>&amp;a[0]</code>。</li><li><code>&amp;a</code> 是整个数组的地址，表示一个数组整体。</li></ul><p>两者类型不同：</p><ul><li><code>a</code> 的类型是 <code>int*</code>，步长是单个元素的大小（<code>sizeof(int)</code>）。</li><li><code>&amp;a</code> 的类型是 <code>int(*)[3]</code>，步长是整个数组的大小（<code>sizeof(a)</code>）。</li></ul><hr><h4 id="4-地址运算"><a href="#4-地址运算" class="headerlink" title="4. 地址运算"></a><strong>4. 地址运算</strong></h4><ol><li><strong><code>a + i</code></strong>：表示第 <code>i</code> 个元素的地址。</li><li><strong><code>&amp;a + i</code></strong>：表示第 <code>i</code> 个数组的地址，步长是数组大小（即 3 × <code>sizeof(int)</code>）。</li><li><strong><code>&amp;a[0] + i</code></strong>：等价于 <code>a + i</code>，表示第 <code>i</code> 个元素的地址。</li></ol><hr><h3 id="代码解析及输出"><a href="#代码解析及输出" class="headerlink" title="代码解析及输出"></a><strong>代码解析及输出</strong></h3><h4 id="sizeof-示例"><a href="#sizeof-示例" class="headerlink" title="sizeof 示例"></a><strong><code>sizeof</code> 示例</strong></h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">sz</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 数组整体大小：3 × sizeof(int) = 12（假设int为4字节）</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>输出：</p><pre class="line-numbers language-none"><code class="language-none">12<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr><h4 id="地址比较"><a href="#地址比较" class="headerlink" title="地址比较"></a><strong>地址比较</strong></h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">cout <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>       <span class="token comment">// 数组首元素地址：&amp;a[0]</span>cout <span class="token operator">&lt;&lt;</span> <span class="token operator">&amp;</span>a <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>      <span class="token comment">// 数组整体地址</span>cout <span class="token operator">&lt;&lt;</span> <span class="token operator">&amp;</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>   <span class="token comment">// 数组首元素地址：&amp;a[0]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>输出：</p><pre class="line-numbers language-none"><code class="language-none">0x9ffdb4  &#x2F;&#x2F; 假设是数组的首地址，a 等价于 &amp;a[0]0x9ffdb4  &#x2F;&#x2F; &amp;a 表示数组整体的地址，与首地址相同，但意义不同0x9ffdb4  &#x2F;&#x2F; &amp;a[0] 是首元素地址<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><hr><h4 id="地址偏移"><a href="#地址偏移" class="headerlink" title="地址偏移"></a><strong>地址偏移</strong></h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">cout <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> a<span class="token operator">+</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> a<span class="token operator">+</span><span class="token number">2</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>  <span class="token comment">// 步长是单个元素的大小</span>cout <span class="token operator">&lt;&lt;</span> <span class="token operator">&amp;</span>a <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> <span class="token operator">&amp;</span>a<span class="token operator">+</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> <span class="token operator">&amp;</span>a<span class="token operator">+</span><span class="token number">2</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// 步长是整个数组的大小</span>cout <span class="token operator">&lt;&lt;</span> <span class="token operator">&amp;</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> <span class="token operator">&amp;</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> <span class="token operator">&amp;</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">2</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// 步长是单个元素的大小</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>输出：</p><pre class="line-numbers language-none"><code class="language-none">0x9ffdb4 0x9ffdb8 0x9ffdbc  &#x2F;&#x2F; a，步长是4字节（1个int大小）0x9ffdb4 0x9ffdc0 0x9ffdcc  &#x2F;&#x2F; &amp;a，步长是12字节（整个数组大小）0x9ffdb4 0x9ffdb8 0x9ffdbc  &#x2F;&#x2F; &amp;a[0]，步长是4字节（1个int大小）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><hr><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a><strong>总结</strong></h3><ol><li><strong><code>a</code> 与 <code>&amp;a</code> 的区别</strong>：<ul><li><code>a</code> 是指向首元素的指针，类型是 <code>int*</code>，步长是单个元素的大小。</li><li><code>&amp;a</code> 是指向整个数组的指针，类型是 <code>int(*)[3]</code>，步长是整个数组的大小。</li></ul></li><li><strong><code>sizeof</code> 的结果</strong>：<ul><li><code>sizeof(a)</code> 是数组整体大小，等于 <code>数组长度 × 单元素大小</code>。</li><li><code>sizeof(&amp;a)</code> 是指针大小，通常是 4 或 8 字节。</li></ul></li><li><strong>地址运算步长</strong>：<ul><li><code>a + 1</code> 或 <code>&amp;a[0] + 1</code>，步长是单个元素的大小（<code>sizeof(int)</code>）。</li><li><code>&amp;a + 1</code>，步长是整个数组的大小（<code>sizeof(a)</code>）。</li></ul></li></ol><p>通过这些例子可以清楚地理解一维数组在指针操作中的差异，更好地避免误用。</p><h2 id="二维数组指针的区别"><a href="#二维数组指针的区别" class="headerlink" title="二维数组指针的区别"></a>二维数组指针的区别</h2><p>注意与一维指针类比区别开来。</p><p>指针有减法和比较运算，没有加法运算。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">sz</span><span class="token expression"><span class="token punctuation">(</span>type<span class="token punctuation">)</span> cout<span class="token operator">&lt;&lt;</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">&#123;</span>    <span class="token punctuation">&#123;</span><span class="token number">12</span><span class="token punctuation">,</span><span class="token number">13</span><span class="token punctuation">,</span><span class="token number">14</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token punctuation">&#123;</span><span class="token number">112</span><span class="token punctuation">,</span><span class="token number">113</span><span class="token punctuation">,</span><span class="token number">114</span><span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  <span class="token function">sz</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">sz</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">sz</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  cout<span class="token operator">&lt;&lt;</span>a<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>  cout<span class="token operator">&lt;&lt;</span><span class="token operator">&amp;</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>  cout<span class="token operator">&lt;&lt;</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>  cout<span class="token operator">&lt;&lt;</span><span class="token operator">&amp;</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    cout<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token comment">//步长是三个元素的数组的长度</span>  cout<span class="token operator">&lt;&lt;</span><span class="token string">"a: "</span><span class="token operator">&lt;&lt;</span>a<span class="token operator">&lt;&lt;</span><span class="token string">" "</span><span class="token operator">&lt;&lt;</span>a<span class="token operator">+</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>           <span class="token comment">//a = &amp;a[0]</span>  cout<span class="token operator">&lt;&lt;</span><span class="token string">"&amp;a[0]:"</span><span class="token operator">&lt;&lt;</span><span class="token operator">&amp;</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span><span class="token string">" "</span><span class="token operator">&lt;&lt;</span><span class="token operator">&amp;</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>  cout<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token comment">//步长是一个int</span>  cout<span class="token operator">&lt;&lt;</span><span class="token string">"a[0]: "</span><span class="token operator">&lt;&lt;</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span><span class="token string">" "</span><span class="token operator">&lt;&lt;</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>  <span class="token comment">//a[0] = &amp;a[0][0]</span>  cout<span class="token operator">&lt;&lt;</span><span class="token string">"&amp;a[0][0]: "</span><span class="token operator">&lt;&lt;</span><span class="token operator">&amp;</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span><span class="token string">" "</span><span class="token operator">&lt;&lt;</span><span class="token operator">&amp;</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>  cout<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>  cout<span class="token operator">&lt;&lt;</span><span class="token string">"&amp;a: "</span><span class="token operator">&lt;&lt;</span><span class="token operator">&amp;</span>a<span class="token operator">&lt;&lt;</span><span class="token string">" "</span><span class="token operator">&lt;&lt;</span><span class="token operator">&amp;</span>a<span class="token operator">+</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token comment">//步长是二维数组的长度</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这段代码分析了二维数组中的指针及其不同地址步长的含义。以下从<strong>二维数组的本质</strong>入手，结合代码详细解析指针在二维数组中的行为及其与一维数组的区别。</p><hr><h3 id="二维数组指针核心概念"><a href="#二维数组指针核心概念" class="headerlink" title="二维数组指针核心概念"></a><strong>二维数组指针核心概念</strong></h3><h4 id="1-二维数组的内存布局"><a href="#1-二维数组的内存布局" class="headerlink" title="1. 二维数组的内存布局"></a><strong>1. 二维数组的内存布局</strong></h4><p>二维数组本质上是连续的内存块，可以看成是<strong>若干行一维数组的集合</strong>。<br> 例如，<code>int a[2][3]</code> 表示有两行，每行三个整型元素。</p><pre class="line-numbers language-none"><code class="language-none">a[2][3] &#x3D; &#123; &#123;12, 13, 14&#125;, &#123;112, 113, 114&#125; &#125;内存布局: [12, 13, 14, 112, 113, 114]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li><code>a[i]</code> 是指向第 <code>i</code> 行（即一维数组）的指针。</li><li><code>a[i][j]</code> 是指向第 <code>i</code> 行第 <code>j</code> 列的具体元素。</li></ul><hr><h4 id="2-各指针的含义"><a href="#2-各指针的含义" class="headerlink" title="2. 各指针的含义"></a><strong>2. 各指针的含义</strong></h4><div class="table-container"><table><thead><tr><th>表达式</th><th>含义</th><th>类型</th></tr></thead><tbody><tr><td><code>a</code></td><td>二维数组首地址，等价于 <code>&amp;a[0]</code></td><td><code>int (*)[3]</code></td></tr><tr><td><code>a[0]</code></td><td>第一行首地址，等价于 <code>&amp;a[0][0]</code></td><td><code>int*</code></td></tr><tr><td><code>&amp;a[0]</code></td><td>第一行的地址（整体的地址）</td><td><code>int (*)[3]</code></td></tr><tr><td><code>&amp;a[0][0]</code></td><td>第一行第一个元素的地址</td><td><code>int*</code></td></tr><tr><td><code>&amp;a</code></td><td>整个二维数组的地址</td><td><code>int (*)[2][3]</code></td></tr></tbody></table></div><hr><h4 id="3-步长的区别"><a href="#3-步长的区别" class="headerlink" title="3. 步长的区别"></a><strong>3. 步长的区别</strong></h4><ul><li><strong><code>a</code> 或 <code>&amp;a[0]</code> 的步长：</strong> <code>sizeof(a[0])</code>，即一行的大小，等于 <code>3 × sizeof(int)</code>。</li><li><strong><code>a[0]</code> 或 <code>&amp;a[0][0]</code> 的步长：</strong> <code>sizeof(int)</code>，即单个元素的大小。</li><li><strong><code>&amp;a</code> 的步长：</strong> <code>sizeof(a)</code>，即整个二维数组的大小，等于 <code>2 × 3 × sizeof(int)</code>。</li></ul><hr><h3 id="代码解析与输出"><a href="#代码解析与输出" class="headerlink" title="代码解析与输出"></a><strong>代码解析与输出</strong></h3><h4 id="1-使用-sizeof-查看大小"><a href="#1-使用-sizeof-查看大小" class="headerlink" title="1. 使用 sizeof 查看大小"></a><strong>1. 使用 <code>sizeof</code> 查看大小</strong></h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">sz</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// 整个二维数组的大小: 2 × 3 × sizeof(int) = 24（假设 int 是 4 字节）</span><span class="token function">sz</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 一行的大小: 3 × sizeof(int) = 12</span><span class="token function">sz</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 单个元素的大小: sizeof(int) = 4</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>输出：</p><pre class="line-numbers language-none"><code class="language-none">24124<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><hr><h4 id="2-各指针的地址输出"><a href="#2-各指针的地址输出" class="headerlink" title="2. 各指针的地址输出"></a><strong>2. 各指针的地址输出</strong></h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">cout <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>          <span class="token comment">// 等价于 &amp;a[0]，指向第一行</span>cout <span class="token operator">&lt;&lt;</span> <span class="token operator">&amp;</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>      <span class="token comment">// 等价于 a</span>cout <span class="token operator">&lt;&lt;</span> a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>       <span class="token comment">// 等价于 &amp;a[0][0]，指向第一行首元素</span>cout <span class="token operator">&lt;&lt;</span> <span class="token operator">&amp;</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>   <span class="token comment">// 第一行首元素地址</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>输出：</p><pre class="line-numbers language-none"><code class="language-none">0x9ffdb4  &#x2F;&#x2F; 数组首地址0x9ffdb4  &#x2F;&#x2F; 等价于 &amp;a[0]0x9ffdb4  &#x2F;&#x2F; 第一行首元素地址0x9ffdb4  &#x2F;&#x2F; 第一行首元素地址<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><hr><h4 id="3-步长分析"><a href="#3-步长分析" class="headerlink" title="3. 步长分析"></a><strong>3. 步长分析</strong></h4><h5 id="1-a-和-amp-a-0-的步长"><a href="#1-a-和-amp-a-0-的步长" class="headerlink" title="(1) a 和 &amp;a[0] 的步长"></a><strong>(1) <code>a</code> 和 <code>&amp;a[0]</code> 的步长</strong></h5><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">cout <span class="token operator">&lt;&lt;</span> <span class="token string">"a: "</span> <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> a <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"&amp;a[0]:"</span> <span class="token operator">&lt;&lt;</span> <span class="token operator">&amp;</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> <span class="token operator">&amp;</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li><code>a + 1</code> 或 <code>&amp;a[0] + 1</code>：跳过一行，步长是 <code>3 × sizeof(int)</code>。</li></ul><p>输出：</p><pre class="line-numbers language-none"><code class="language-none">a: 0x9ffdb4 0x9ffdc0  &#x2F;&#x2F; 步长是12字节（一行大小）&amp;a[0]: 0x9ffdb4 0x9ffdc0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h5 id="2-a-0-和-amp-a-0-0-的步长"><a href="#2-a-0-和-amp-a-0-0-的步长" class="headerlink" title="(2) a[0] 和 &amp;a[0][0] 的步长"></a><strong>(2) <code>a[0]</code> 和 <code>&amp;a[0][0]</code> 的步长</strong></h5><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">cout <span class="token operator">&lt;&lt;</span> <span class="token string">"a[0]: "</span> <span class="token operator">&lt;&lt;</span> a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"&amp;a[0][0]: "</span> <span class="token operator">&lt;&lt;</span> <span class="token operator">&amp;</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> <span class="token operator">&amp;</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li><code>a[0] + 1</code> 或 <code>&amp;a[0][0] + 1</code>：跳过一个元素，步长是 <code>sizeof(int)</code>。</li></ul><p>输出：</p><pre class="line-numbers language-none"><code class="language-none">a[0]: 0x9ffdb4 0x9ffdb8  &#x2F;&#x2F; 步长是4字节（一个int大小）&amp;a[0][0]: 0x9ffdb4 0x9ffdb8<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h5 id="3-amp-a-的步长"><a href="#3-amp-a-的步长" class="headerlink" title="(3) &amp;a 的步长"></a><strong>(3) <code>&amp;a</code> 的步长</strong></h5><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">cout <span class="token operator">&lt;&lt;</span> <span class="token string">"&amp;a: "</span> <span class="token operator">&lt;&lt;</span> <span class="token operator">&amp;</span>a <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> <span class="token operator">&amp;</span>a <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><code>&amp;a + 1</code>：跳过整个二维数组，步长是 <code>sizeof(a)</code>。</li></ul><p>输出：</p><pre class="line-numbers language-none"><code class="language-none">&amp;a: 0x9ffdb4 0x9ffdd8  &#x2F;&#x2F; 步长是24字节（整个数组大小）<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr><h3 id="与一维数组的区别"><a href="#与一维数组的区别" class="headerlink" title="与一维数组的区别"></a><strong>与一维数组的区别</strong></h3><div class="table-container"><table><thead><tr><th>属性</th><th>一维数组</th><th>二维数组</th></tr></thead><tbody><tr><td>数组名类型</td><td><code>int*</code></td><td><code>int (*)[列数]</code></td></tr><tr><td><code>a + 1</code> 步长</td><td>一个元素大小</td><td>一行的大小</td></tr><tr><td><code>&amp;a + 1</code> 步长</td><td>整个数组大小</td><td>整个二维数组的大小</td></tr><tr><td>行地址</td><td>不适用</td><td><code>&amp;a[行号]</code> 表示行的整体地址</td></tr><tr><td>元素地址</td><td><code>&amp;a[索引]</code></td><td><code>&amp;a[行号][列号]</code> 表示元素地址</td></tr></tbody></table></div><hr><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a><strong>总结</strong></h3><ol><li><strong>二维数组的数组名</strong>：<code>a</code> 是指向第0行的指针，类型为 <code>int (*)[列数]</code>，步长是单行大小。</li><li>行与元素的指针：<ul><li><code>a[i]</code> 是指向第 <code>i</code> 行首元素的指针，类型为 <code>int*</code>。</li><li><code>&amp;a[i]</code> 是第 <code>i</code> 行整体的地址，类型为 <code>int (*)[列数]</code>。</li></ul></li><li>地址运算步长：<ul><li><code>a + 1</code> 或 <code>&amp;a[0] + 1</code> 跳过一行，步长是 <code>列数 × 元素大小</code>。</li><li><code>&amp;a + 1</code> 跳过整个二维数组，步长是 <code>行数 × 列数 × 元素大小</code>。</li></ul></li></ol><h2 id="指针作为函数的参数"><a href="#指针作为函数的参数" class="headerlink" title="指针作为函数的参数"></a>指针作为函数的参数</h2><p><a href="https://blog.csdn.net/ykm0722/article/details/7031387">https://blog.csdn.net/ykm0722/article/details/7031387</a></p><p>使用swap（交换两个变量的值）作为演示，实现Swap的四种方法。当数组名作为<strong>函数的参数</strong>来传递的时候，他的高贵的数组结构特性已经失去了，成了一个地地道道的只拥有4个字节的平民。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">SWAP</span><span class="token expression"><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> temp<span class="token punctuation">)</span> <span class="token punctuation">(</span>temp<span class="token operator">=</span>a<span class="token punctuation">,</span> a<span class="token operator">=</span>b<span class="token punctuation">,</span> b<span class="token operator">=</span>temp<span class="token punctuation">)</span><span class="token punctuation">;</span></span></span><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>x<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>y<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">int</span> z<span class="token operator">=</span><span class="token operator">*</span>x<span class="token punctuation">;</span>  <span class="token operator">*</span>x<span class="token operator">=</span><span class="token operator">*</span>y<span class="token punctuation">;</span>  <span class="token operator">*</span>y<span class="token operator">=</span>z<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">func1</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">&amp;</span>x<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>y<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  cout<span class="token operator">&lt;&lt;</span>x<span class="token operator">&lt;&lt;</span><span class="token string">" "</span><span class="token operator">&lt;&lt;</span>y<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>   <span class="token keyword">int</span> z<span class="token operator">=</span>x<span class="token punctuation">;</span>  x<span class="token operator">=</span>y<span class="token punctuation">;</span>  y<span class="token operator">=</span>z<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">void</span> <span class="token function">Swap</span><span class="token punctuation">(</span>T <span class="token operator">&amp;</span>a<span class="token punctuation">,</span> T<span class="token operator">&amp;</span>b<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  T temp<span class="token operator">=</span>a<span class="token punctuation">;</span>  a<span class="token operator">=</span>b<span class="token punctuation">;</span>  b<span class="token operator">=</span>temp<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">float</span> a<span class="token operator">=</span><span class="token number">12.1</span><span class="token punctuation">,</span> b<span class="token operator">=</span><span class="token number">13.2</span><span class="token punctuation">;</span>  cout<span class="token operator">&lt;&lt;</span>a<span class="token operator">&lt;&lt;</span><span class="token string">" "</span><span class="token operator">&lt;&lt;</span>b<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>  <span class="token comment">// int c=a;</span>  <span class="token comment">// a=b;</span>  <span class="token comment">// b=c;</span>  <span class="token keyword">float</span> c<span class="token punctuation">;</span>  <span class="token function">Swap</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>  cout<span class="token operator">&lt;&lt;</span>a<span class="token operator">&lt;&lt;</span><span class="token string">" "</span><span class="token operator">&lt;&lt;</span>b<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这段代码展示了<strong>使用指针作为函数参数</strong>以及多种方式实现 <code>swap</code> 函数的机制和细节。以下是对代码和相关概念的详细解析。</p><hr><h3 id="1-多种实现-swap-的方式"><a href="#1-多种实现-swap-的方式" class="headerlink" title="1. 多种实现 swap 的方式"></a><strong>1. 多种实现 <code>swap</code> 的方式</strong></h3><h4 id="1-宏定义实现"><a href="#1-宏定义实现" class="headerlink" title="(1) 宏定义实现"></a><strong>(1) 宏定义实现</strong></h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">SWAP</span><span class="token expression"><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> temp<span class="token punctuation">)</span> <span class="token punctuation">(</span>temp<span class="token operator">=</span>a<span class="token punctuation">,</span> a<span class="token operator">=</span>b<span class="token punctuation">,</span> b<span class="token operator">=</span>temp<span class="token punctuation">)</span><span class="token punctuation">;</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>使用 <strong>宏定义</strong> 的方式实现变量交换。</li><li>优点：代码简单直观。</li><li>缺点：<ul><li><strong>缺乏类型安全性</strong>：没有检查参数类型，一旦传递复杂类型可能出错。</li><li><strong>调试困难</strong>：宏替换发生在预处理阶段，容易导致调试不便。</li></ul></li></ul><p>示例：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">float</span> a <span class="token operator">=</span> <span class="token number">12.1</span><span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token number">13.2</span><span class="token punctuation">,</span> temp<span class="token punctuation">;</span><span class="token function">SWAP</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> temp<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><hr><h4 id="2-使用指针参数"><a href="#2-使用指针参数" class="headerlink" title="(2) 使用指针参数"></a><strong>(2) 使用指针参数</strong></h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>x<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>y<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">int</span> z <span class="token operator">=</span> <span class="token operator">*</span>x<span class="token punctuation">;</span>  <span class="token operator">*</span>x <span class="token operator">=</span> <span class="token operator">*</span>y<span class="token punctuation">;</span>  <span class="token operator">*</span>y <span class="token operator">=</span> z<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>通过指针传递变量地址，实现值交换。</li><li>优点：函数可以直接操作实参的值，而非副本。</li><li>缺点：调用时需要传递地址，使用稍显繁琐。</li></ul><p>调用示例：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token function">func</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">,</span> <span class="token operator">&amp;</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><hr><h4 id="3-使用引用参数"><a href="#3-使用引用参数" class="headerlink" title="(3) 使用引用参数"></a><strong>(3) 使用引用参数</strong></h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">func1</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">&amp;</span>x<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>y<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">int</span> z <span class="token operator">=</span> x<span class="token punctuation">;</span>  x <span class="token operator">=</span> y<span class="token punctuation">;</span>  y <span class="token operator">=</span> z<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>通过 <strong>引用传递</strong>，实现值交换。</li><li>优点：<ul><li>代码更简洁，调用方式与值传递类似（不需要显式取地址）。</li><li>不需要额外的解引用操作，性能略优。</li></ul></li><li>缺点：不支持引用常量或数组。</li></ul><p>调用示例：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token function">func1</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><hr><h4 id="4-使用模板"><a href="#4-使用模板" class="headerlink" title="(4) 使用模板"></a><strong>(4) 使用模板</strong></h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">void</span> <span class="token function">Swap</span><span class="token punctuation">(</span>T <span class="token operator">&amp;</span>a<span class="token punctuation">,</span> T <span class="token operator">&amp;</span>b<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  T temp <span class="token operator">=</span> a<span class="token punctuation">;</span>  a <span class="token operator">=</span> b<span class="token punctuation">;</span>  b <span class="token operator">=</span> temp<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>使用 <strong>C++模板</strong> 泛化 <code>swap</code> 函数，支持多种数据类型。</li><li>优点：<ul><li>代码复用性强，适用于任何支持赋值操作的类型（如整型、浮点型、类对象等）。</li><li>类型安全。</li></ul></li><li>缺点：略增加编译时间。</li></ul><p>调用示例：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">float</span> a <span class="token operator">=</span> <span class="token number">12.1</span><span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token number">13.2</span><span class="token punctuation">;</span><span class="token function">Swap</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><hr><h3 id="2-特殊点：数组名作为函数参数"><a href="#2-特殊点：数组名作为函数参数" class="headerlink" title="2. 特殊点：数组名作为函数参数"></a><strong>2. 特殊点：数组名作为函数参数</strong></h3><p>在 C++ 中，<strong>数组名作为函数参数传递时，会退化为指针</strong>。以下是具体表现：</p><h4 id="数组名的特性"><a href="#数组名的特性" class="headerlink" title="数组名的特性"></a><strong>数组名的特性</strong></h4><ol><li><strong>数组名本质</strong>：数组名是数组首元素的地址，但它保留了数组的整体大小信息。</li><li><strong>传递到函数中</strong>：当数组名作为参数时，它退化为普通指针，数组大小信息丢失。</li></ol><h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a><strong>示例代码</strong></h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">processArray</span><span class="token punctuation">(</span><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// 输出指针大小</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// 输出数组大小 (40)</span>  <span class="token function">processArray</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment">// 数组退化为指针 (4或8)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a><strong>输出</strong></h4><pre class="line-numbers language-none"><code class="language-none">40    &#x2F;&#x2F; 数组实际大小：10 × sizeof(int)4     &#x2F;&#x2F; 指针大小（32位系统）或 8（64位系统）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a><strong>结论</strong></h4><ul><li>在函数内无法通过 <code>sizeof</code> 获取数组的长度。</li><li>如果需要数组长度，通常需要显式传递数组大小作为参数。</li></ul><hr><h3 id="3-代码解析与输出"><a href="#3-代码解析与输出" class="headerlink" title="3. 代码解析与输出"></a><strong>3. 代码解析与输出</strong></h3><h4 id="1-宏交换-SWAP"><a href="#1-宏交换-SWAP" class="headerlink" title="(1) 宏交换 SWAP"></a><strong>(1) 宏交换 <code>SWAP</code></strong></h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">float</span> a <span class="token operator">=</span> <span class="token number">12.1</span><span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token number">13.2</span><span class="token punctuation">,</span> temp<span class="token punctuation">;</span><span class="token function">SWAP</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> temp<span class="token punctuation">)</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> b <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>输出：</p><pre class="line-numbers language-none"><code class="language-none">13.2 12.1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr><h4 id="2-指针传递"><a href="#2-指针传递" class="headerlink" title="(2) 指针传递"></a><strong>(2) 指针传递</strong></h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token function">func</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">,</span> <span class="token operator">&amp;</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> b <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>输出：</p><pre class="line-numbers language-none"><code class="language-none">10 5<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr><h4 id="3-引用传递"><a href="#3-引用传递" class="headerlink" title="(3) 引用传递"></a><strong>(3) 引用传递</strong></h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token function">func1</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> b <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>输出：</p><pre class="line-numbers language-none"><code class="language-none">10 5<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr><h4 id="4-模板函数"><a href="#4-模板函数" class="headerlink" title="(4) 模板函数"></a><strong>(4) 模板函数</strong></h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">float</span> a <span class="token operator">=</span> <span class="token number">12.1</span><span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token number">13.2</span><span class="token punctuation">;</span><span class="token function">Swap</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> b <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>输出：</p><pre class="line-numbers language-none"><code class="language-none">13.2 12.1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr><h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a><strong>总结</strong></h3><ol><li><strong>宏定义</strong>：代码简单，但缺乏类型安全，不推荐。</li><li><strong>指针传递</strong>：显式操作地址，适合 C 风格代码。</li><li><strong>引用传递</strong>：代码更现代化，推荐使用。</li><li><strong>模板</strong>：支持泛型交换，适用于复杂类型，是最通用的方式。</li></ol><p>通过这些实现方式，可以灵活选择适合需求的方案，同时理解数组在函数参数中退化为指针的行为，有助于写出更清晰、可靠的代码。</p><h2 id="指针作为返回值"><a href="#指针作为返回值" class="headerlink" title="指针作为返回值"></a>指针作为返回值</h2><p>要作为返回值，必须保证调用后返回的指针不会销毁，否则就是野指针。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 全局数组，自动初始化为0</span><span class="token keyword">int</span><span class="token operator">*</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> a<span class="token punctuation">;</span> <span class="token comment">// 返回全局变量的地址</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 局部变量</span>  cout <span class="token operator">&lt;&lt;</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这段代码主要展示了<strong>指针作为函数返回值</strong>的机制，并且提到了一个非常关键的问题——<strong>返回指针的生命周期</strong>。以下是详细解析。</p><hr><h3 id="1-指针作为返回值的关键点"><a href="#1-指针作为返回值的关键点" class="headerlink" title="1. 指针作为返回值的关键点"></a><strong>1. 指针作为返回值的关键点</strong></h3><ul><li><strong>指针返回值</strong>是函数返回一个地址，调用者可以通过这个地址访问存储在该位置的值。</li><li><strong>安全性问题</strong>：如果返回的指针指向了函数的局部变量，则在函数返回后，该局部变量会被销毁，导致指针成为<strong>野指针</strong>，可能引发不可预期的错误。</li></ul><hr><h3 id="2-示例代码解析"><a href="#2-示例代码解析" class="headerlink" title="2. 示例代码解析"></a><strong>2. 示例代码解析</strong></h3><h4 id="2-1-全局数组的特点"><a href="#2-1-全局数组的特点" class="headerlink" title="2.1 全局数组的特点"></a>2.1 全局数组的特点</h4><ol><li><strong>全局变量的生命周期</strong><ul><li>全局变量的生命周期贯穿整个程序运行周期，直到程序结束才会被销毁。</li><li>因此返回全局变量的地址是安全的，不会出现野指针。</li></ul></li><li><strong>全局数组的初始化</strong><ul><li>如果没有显式赋值，全局数组中的元素会被初始化为 <code>0</code>（默认值）。</li><li>这里 <code>int a[3] = &#123;0, 0, 0&#125;</code>。</li></ul></li></ol><hr><h4 id="2-2-函数-func-的返回值"><a href="#2-2-函数-func-的返回值" class="headerlink" title="2.2 函数 func() 的返回值"></a><strong>2.2 函数 <code>func()</code> 的返回值</strong></h4><ul><li><code>func()</code> 返回全局数组 <code>a</code> 的首地址。</li><li>在主函数 <code>main()</code> 中，通过 <code>func()</code> 可以访问全局数组的内容。</li><li><strong>优点</strong>：返回全局数组的地址是安全的。</li><li><strong>缺点</strong>：如果多个地方修改了同一全局变量，会导致数据不可预测。</li></ul><hr><h4 id="2-3-局部变量作为返回值的风险"><a href="#2-3-局部变量作为返回值的风险" class="headerlink" title="2.3 局部变量作为返回值的风险"></a><strong>2.3 局部变量作为返回值的风险</strong></h4><p>以下是一个反面例子：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span><span class="token operator">*</span> <span class="token function">unsafeFunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">int</span> localVar <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span> <span class="token comment">// 局部变量</span>  <span class="token keyword">return</span> <span class="token operator">&amp;</span>localVar<span class="token punctuation">;</span>  <span class="token comment">// 返回局部变量地址</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>调用时：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span><span class="token operator">*</span> ptr <span class="token operator">=</span> <span class="token function">unsafeFunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>ptr <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// 未定义行为</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>问题：<ul><li><code>localVar</code> 是函数的局部变量，在函数返回时，它会被销毁。</li><li>返回的地址指向一个已经被释放的内存区域，结果是未定义行为。</li></ul></li></ul><hr><h4 id="2-4-全局变量的安全返回"><a href="#2-4-全局变量的安全返回" class="headerlink" title="2.4 全局变量的安全返回"></a><strong>2.4 全局变量的安全返回</strong></h4><p>代码：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span><span class="token operator">*</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> a<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>安全性：返回的是全局数组的地址，不会有生命周期问题。</li><li>数据访问：<ul><li><code>func()[0]</code> 等价于访问全局数组 <code>a[0]</code>。</li><li>默认值 <code>0</code> 会被输出。</li></ul></li></ul><hr><h3 id="3-输出结果"><a href="#3-输出结果" class="headerlink" title="3. 输出结果"></a><strong>3. 输出结果</strong></h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 全局数组，初始化为 &#123;0, 0, 0&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  cout <span class="token operator">&lt;&lt;</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出结果：</p><pre class="line-numbers language-none"><code class="language-none">0 0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr><h3 id="4-常见场景及建议"><a href="#4-常见场景及建议" class="headerlink" title="4. 常见场景及建议"></a><strong>4. 常见场景及建议</strong></h3><h4 id="4-1-返回全局变量指针"><a href="#4-1-返回全局变量指针" class="headerlink" title="4.1 返回全局变量指针"></a><strong>4.1 返回全局变量指针</strong></h4><p>适用场景：</p><ul><li>需要函数返回一个共享的全局数据结构。</li><li>确保所有访问点都使用相同的全局数据。</li></ul><p>注意：</p><ul><li>全局变量的使用需要小心，容易导致代码耦合高、可维护性低。</li></ul><hr><h4 id="4-2-返回动态分配的内存"><a href="#4-2-返回动态分配的内存" class="headerlink" title="4.2 返回动态分配的内存"></a><strong>4.2 返回动态分配的内存</strong></h4><p>如果需要函数动态生成数据，可以使用动态分配：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span><span class="token operator">*</span> <span class="token function">createArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">int</span><span class="token operator">*</span> arr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token comment">// 动态分配数组</span>  <span class="token keyword">return</span> arr<span class="token punctuation">;</span>                     <span class="token comment">// 返回数组首地址</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">int</span><span class="token operator">*</span> arr <span class="token operator">=</span> <span class="token function">createArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  cout <span class="token operator">&lt;&lt;</span> arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> arr<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> arr<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>  <span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">;</span> <span class="token comment">// 使用完毕释放内存</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>优点</strong>：</p><ul><li>数据独立于函数栈帧，生命周期可控。</li><li>灵活性高，可在堆上存储大数据。</li></ul><p><strong>注意</strong>：</p><ul><li>调用者负责释放动态分配的内存，否则可能导致内存泄漏。</li></ul><hr><h4 id="4-3-返回局部静态变量的指针"><a href="#4-3-返回局部静态变量的指针" class="headerlink" title="4.3 返回局部静态变量的指针"></a><strong>4.3 返回局部静态变量的指针</strong></h4><p>静态变量具有全局生命周期，但作用域受限于定义所在的函数。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span><span class="token operator">*</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">static</span> <span class="token keyword">int</span> localStaticVar <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token operator">&amp;</span>localStaticVar<span class="token punctuation">;</span> <span class="token comment">// 返回局部静态变量地址</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">int</span><span class="token operator">*</span> ptr <span class="token operator">=</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>ptr <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// 安全访问</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>优点</strong>：</p><ul><li>静态变量不会被销毁，返回地址是安全的。</li><li>避免了全局变量的污染。</li></ul><hr><h3 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a><strong>5. 总结</strong></h3><ol><li><strong>返回值类型分析</strong>：<ul><li><strong>全局变量</strong>：安全，但可能引入全局状态问题。</li><li><strong>局部变量</strong>：危险，容易导致野指针。</li><li><strong>动态分配内存</strong>：安全，但需手动管理内存。</li><li><strong>静态变量</strong>：安全，但需注意多线程安全问题。</li></ul></li><li><strong>建议</strong>：<ul><li>尽量避免使用全局变量。</li><li>优先考虑返回动态分配的内存或局部静态变量。</li><li>在多线程环境下，需注意同步访问问题。</li></ul></li></ol><p>通过理解指针生命周期和作用域，能更好地写出健壮和高效的代码。</p><h2 id="字符数组指针"><a href="#字符数组指针" class="headerlink" title="字符数组指针"></a>字符数组指针</h2><p>1、str和p是不相同的！！</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstring></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">char</span> str<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">"ab"</span><span class="token punctuation">;</span>  <span class="token keyword">char</span> <span class="token operator">*</span>p<span class="token operator">=</span>str<span class="token punctuation">;</span><span class="token comment">//此处可以修改str，因为str只是字符数组（使用了字符串字面量来初始化str），但是并不是常量</span>  size_t length <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">strlen</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//遇到'\0'才会停止计数</span>  <span class="token comment">// 例如 char a[3]=&#123;'a', 'b', 'c'&#125;, 使用strlen后的长度不是3!!!</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c-%s-%ld-%ld\n"</span><span class="token punctuation">,</span> <span class="token operator">*</span>str<span class="token punctuation">,</span> str<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">strlen</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// sizeof(str) 返回的是数组占用的内存大小，而 strlen(str) 返回的是字符串的长度。</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c-%s-%ld-%ld\n"</span><span class="token punctuation">,</span> <span class="token operator">*</span>p<span class="token punctuation">,</span> p<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">strlen</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// sizeof(p) 返回的是int型指针占用的内存大小，而 strlen(p) 返回的是字符串的长度。</span>  <span class="token operator">*</span>p<span class="token operator">=</span><span class="token char">'A'</span><span class="token punctuation">;</span>  <span class="token operator">*</span><span class="token punctuation">(</span>p<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token char">'B'</span><span class="token punctuation">;</span>  std<span class="token double-colon punctuation">::</span>cout<span class="token operator">&lt;&lt;</span><span class="token operator">*</span>str<span class="token operator">&lt;&lt;</span><span class="token operator">*</span><span class="token punctuation">(</span>str<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2、此处会有一个warning，因为“ab”是存储在常量区域的，不能修改，在使用时需要使用const来申明</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstring></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">char</span> <span class="token operator">*</span>p<span class="token operator">=</span><span class="token string">"ab"</span><span class="token punctuation">;</span><span class="token comment">// 先在常量区保存好"ab"，然后在栈区建立一个char *</span>  <span class="token comment">//   const char *p="ab";</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c-%s-%ld-%ld\n"</span><span class="token punctuation">,</span> <span class="token operator">*</span>p<span class="token punctuation">,</span> p<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">strlen</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// sizeof(p) 返回的是int型指针占用的内存大小，而 strlen(p) 返回的是字符串的长度。</span>  <span class="token operator">*</span>p<span class="token operator">=</span><span class="token char">'A'</span><span class="token punctuation">;</span>  <span class="token operator">*</span><span class="token punctuation">(</span>p<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token char">'B'</span><span class="token punctuation">;</span>  std<span class="token double-colon punctuation">::</span>cout<span class="token operator">&lt;&lt;</span><span class="token operator">*</span>p<span class="token operator">&lt;&lt;</span><span class="token operator">*</span><span class="token punctuation">(</span>p<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>3、此处会显示error: assignment of read-only location ‘* p’</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstring></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>p<span class="token operator">=</span><span class="token string">"ab"</span><span class="token punctuation">;</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c-%s-%ld-%ld\n"</span><span class="token punctuation">,</span> <span class="token operator">*</span>p<span class="token punctuation">,</span> p<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">strlen</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// sizeof(p) 返回的是int型指针占用的内存大小，而 strlen(p) 返回的是字符串的长度。</span>  <span class="token operator">*</span>p<span class="token operator">=</span><span class="token char">'A'</span><span class="token punctuation">;</span>  <span class="token operator">*</span><span class="token punctuation">(</span>p<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token char">'B'</span><span class="token punctuation">;</span>  std<span class="token double-colon punctuation">::</span>cout<span class="token operator">&lt;&lt;</span><span class="token operator">*</span>p<span class="token operator">&lt;&lt;</span><span class="token operator">*</span><span class="token punctuation">(</span>p<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>4、字符数组指针的初始化</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstring></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">char</span> a<span class="token operator">=</span><span class="token char">'a'</span><span class="token punctuation">;</span>  <span class="token keyword">char</span> b<span class="token operator">=</span><span class="token char">'b'</span><span class="token punctuation">;</span>  <span class="token keyword">char</span> <span class="token operator">*</span>p<span class="token operator">=</span><span class="token operator">&amp;</span>a<span class="token punctuation">;</span>  <span class="token keyword">char</span> c<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">&#123;</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> <span class="token char">'c'</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%p--%p--%c--%c\n"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">,</span> <span class="token operator">&amp;</span>b<span class="token punctuation">,</span> a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%p--%p--%c--%c\n"</span><span class="token punctuation">,</span> c<span class="token punctuation">,</span> c<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">*</span>c<span class="token punctuation">,</span> <span class="token operator">*</span><span class="token punctuation">(</span>c<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">char</span> <span class="token operator">*</span>p2<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token operator">&amp;</span>a<span class="token punctuation">,</span> p<span class="token punctuation">,</span> c<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span><span class="token number">3</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%p--%p--%c\n"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>p2<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> p2<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">*</span>p2<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><p>主要要把指针括起来</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  cout<span class="token operator">&lt;&lt;</span><span class="token string">"func"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> a<span class="token operator">+</span>b<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">int</span> a<span class="token operator">=</span><span class="token number">123</span><span class="token punctuation">;</span>  <span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token operator">=</span><span class="token operator">&amp;</span>a<span class="token punctuation">;</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%p--%p\n"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//无参</span>  <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>pFunc<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">&amp;</span>func<span class="token punctuation">;</span><span class="token comment">//要不要&amp;，都可</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%p--%p\n"</span><span class="token punctuation">,</span> func<span class="token punctuation">,</span> pFunc<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//带参</span>  <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>pFunc1<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">&amp;</span>add<span class="token punctuation">;</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%p--%p\n"</span><span class="token punctuation">,</span> add<span class="token punctuation">,</span> pFunc1<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="函数指针数组"><a href="#函数指针数组" class="headerlink" title="函数指针数组"></a>函数指针数组</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  cout<span class="token operator">&lt;&lt;</span><span class="token string">"func"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> a<span class="token operator">+</span>b<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">sub</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> a <span class="token operator">-</span> b<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token keyword">int</span> <span class="token function">mul</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> a<span class="token operator">*</span>b<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">div11</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> a<span class="token operator">/</span>b<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">int</span> a<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token keyword">int</span> b<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>  <span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token operator">=</span><span class="token operator">&amp;</span>a<span class="token punctuation">;</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%p--%p\n"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>pFunc<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token punctuation">&#123;</span>add<span class="token punctuation">,</span> sub<span class="token punctuation">,</span> mul<span class="token punctuation">,</span> div11<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span><span class="token number">4</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    cout<span class="token operator">&lt;&lt;</span><span class="token punctuation">(</span><span class="token operator">*</span>pFunc<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="函数指针深度辨析"><a href="#函数指针深度辨析" class="headerlink" title="函数指针深度辨析"></a>函数指针深度辨析</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  cout<span class="token operator">&lt;&lt;</span><span class="token string">"func"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> a<span class="token operator">+</span>b<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>pFunc<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">&amp;</span>func<span class="token punctuation">;</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%p\n"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>pFunc<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%p\n"</span><span class="token punctuation">,</span> pFunc<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%p\n"</span><span class="token punctuation">,</span> <span class="token operator">*</span>pFunc<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%p\n"</span><span class="token punctuation">,</span> <span class="token operator">*</span><span class="token operator">*</span>pFunc<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%p\n"</span><span class="token punctuation">,</span> <span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span>pFunc<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"----------\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%p\n"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>func<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%p\n"</span><span class="token punctuation">,</span> func<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%p\n"</span><span class="token punctuation">,</span> <span class="token operator">*</span>func<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%p\n"</span><span class="token punctuation">,</span> <span class="token operator">*</span><span class="token operator">*</span>func<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%p\n"</span><span class="token punctuation">,</span> <span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span>func<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这段代码试图对函数指针的使用进行深度探索，并分析各种形式下的打印结果。然而，这里涉及到一些误用和未定义行为，下面是详细的解析。</p><hr><h3 id="1-函数指针的基本概念"><a href="#1-函数指针的基本概念" class="headerlink" title="1. 函数指针的基本概念"></a><strong>1. 函数指针的基本概念</strong></h3><ul><li><p><strong>函数指针</strong>是一种特殊的指针，用于存储函数的入口地址。</p></li><li><p>定义函数指针的语法：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">返回值类型 <span class="token punctuation">(</span><span class="token operator">*</span>指针名<span class="token punctuation">)</span><span class="token punctuation">(</span>参数列表<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>示例：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>pFunc<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 定义一个返回值为void，参数为空的函数指针</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><hr><h3 id="2-示例代码解析-1"><a href="#2-示例代码解析-1" class="headerlink" title="2. 示例代码解析"></a><strong>2. 示例代码解析</strong></h3><p>代码片段：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  cout <span class="token operator">&lt;&lt;</span> <span class="token string">"func"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>pFunc<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>func<span class="token punctuation">;</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%p\n"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>pFunc<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 打印函数指针变量的地址</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%p\n"</span><span class="token punctuation">,</span> pFunc<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 打印函数的入口地址</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%p\n"</span><span class="token punctuation">,</span> <span class="token operator">*</span>pFunc<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 正确调用：实际上是调用了函数</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%p\n"</span><span class="token punctuation">,</span> <span class="token operator">*</span><span class="token operator">*</span>pFunc<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 错误：未定义行为</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%p\n"</span><span class="token punctuation">,</span> <span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span>pFunc<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 错误：未定义行为</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"----------\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%p\n"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>func<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 打印函数的入口地址（与 pFunc 相同）</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%p\n"</span><span class="token punctuation">,</span> func<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 打印函数的入口地址（与 &amp;func 相同）</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%p\n"</span><span class="token punctuation">,</span> <span class="token operator">*</span>func<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 错误：未定义行为</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%p\n"</span><span class="token punctuation">,</span> <span class="token operator">*</span><span class="token operator">*</span>func<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 错误：未定义行为</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%p\n"</span><span class="token punctuation">,</span> <span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span>func<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 错误：未定义行为</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="3-逐行解析与结果"><a href="#3-逐行解析与结果" class="headerlink" title="3. 逐行解析与结果"></a><strong>3. 逐行解析与结果</strong></h3><h4 id="3-1-第一部分：pFunc-的打印"><a href="#3-1-第一部分：pFunc-的打印" class="headerlink" title="3.1 第一部分：pFunc 的打印"></a><strong>3.1 第一部分：<code>pFunc</code> 的打印</strong></h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>pFunc<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>func<span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%p\n"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>pFunc<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 打印函数指针变量 pFunc 的地址</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%p\n"</span><span class="token punctuation">,</span> pFunc<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 打印函数的入口地址</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%p\n"</span><span class="token punctuation">,</span> <span class="token operator">*</span>pFunc<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 函数调用，实际输出 "func"</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%p\n"</span><span class="token punctuation">,</span> <span class="token operator">*</span><span class="token operator">*</span>pFunc<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 错误：未定义行为</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%p\n"</span><span class="token punctuation">,</span> <span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span>pFunc<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 错误：未定义行为</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p><strong><code>&amp;pFunc</code></strong>：打印的是指针变量 <code>pFunc</code> 的地址（不是函数的地址）。</p></li><li><p><strong><code>pFunc</code></strong>：打印的是函数 <code>func</code> 的入口地址，和 <code>&amp;func</code> 相同。</p></li><li><p><code>*pFunc</code></p><p>：</p><ul><li>函数指针解引用后实际是调用该函数，即会输出 <code>&quot;func&quot;</code>，<strong>但不能使用 <code>%p</code> 打印返回值</strong>。</li><li><code>%p</code> 是打印指针地址，而函数返回值类型是 <code>void</code>，这会导致未定义行为。</li></ul></li><li><p><code>**pFunc</code> 和 <code>***pFunc</code></p><p>：</p><ul><li>解引用次数超出函数指针的定义范围，属于未定义行为。</li></ul></li></ul><hr><h4 id="3-2-第二部分：func-的打印"><a href="#3-2-第二部分：func-的打印" class="headerlink" title="3.2 第二部分：func 的打印"></a><strong>3.2 第二部分：<code>func</code> 的打印</strong></h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%p\n"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>func<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 打印函数的入口地址</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%p\n"</span><span class="token punctuation">,</span> func<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 打印函数的入口地址</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%p\n"</span><span class="token punctuation">,</span> <span class="token operator">*</span>func<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 错误：未定义行为</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%p\n"</span><span class="token punctuation">,</span> <span class="token operator">*</span><span class="token operator">*</span>func<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 错误：未定义行为</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%p\n"</span><span class="token punctuation">,</span> <span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span>func<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 错误：未定义行为</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p><strong><code>&amp;func</code> 和 <code>func</code></strong>：对于函数名 <code>func</code>，它既表示函数入口地址，也是函数指针常量。</p></li><li><p><code>*func</code>、<code>**func</code> 和 <code>***func</code></p><p>：</p><ul><li>函数名不能被多次解引用，尝试这样操作会导致编译错误或未定义行为。</li></ul></li></ul><hr><h3 id="4-函数指针的正确使用方式"><a href="#4-函数指针的正确使用方式" class="headerlink" title="4. 函数指针的正确使用方式"></a><strong>4. 函数指针的正确使用方式</strong></h3><h4 id="4-1-使用函数指针调用函数"><a href="#4-1-使用函数指针调用函数" class="headerlink" title="4.1 使用函数指针调用函数"></a><strong>4.1 使用函数指针调用函数</strong></h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  cout <span class="token operator">&lt;&lt;</span> <span class="token string">"This is func"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>pFunc<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> func<span class="token punctuation">;</span>  <span class="token comment">// 函数指针指向函数</span>  <span class="token function">pFunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment">// 使用函数指针调用函数</span>  <span class="token punctuation">(</span><span class="token operator">*</span>pFunc<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment">// 解引用后调用（等价于 pFunc()）</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-2-函数指针作为参数"><a href="#4-2-函数指针作为参数" class="headerlink" title="4.2 函数指针作为参数"></a><strong>4.2 函数指针作为参数</strong></h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">subtract</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> a <span class="token operator">-</span> b<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 函数指针作为参数</span><span class="token keyword">int</span> <span class="token function">calculate</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>operation<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> <span class="token function">operation</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  cout <span class="token operator">&lt;&lt;</span> <span class="token function">calculate</span><span class="token punctuation">(</span>add<span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>      <span class="token comment">// 输出 8</span>  cout <span class="token operator">&lt;&lt;</span> <span class="token function">calculate</span><span class="token punctuation">(</span>subtract<span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// 输出 2</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-3-函数指针作为返回值"><a href="#4-3-函数指针作为返回值" class="headerlink" title="4.3 函数指针作为返回值"></a><strong>4.3 函数指针作为返回值</strong></h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">subtract</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> a <span class="token operator">-</span> b<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token function">getOperation</span><span class="token punctuation">(</span><span class="token keyword">bool</span> isAdd<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> isAdd <span class="token operator">?</span> add <span class="token operator">:</span> subtract<span class="token punctuation">;</span> <span class="token comment">// 返回函数指针</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>operation<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">getOperation</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 返回 add</span>  cout <span class="token operator">&lt;&lt;</span> <span class="token function">operation</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>                 <span class="token comment">// 输出 8</span>  operation <span class="token operator">=</span> <span class="token function">getOperation</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 返回 subtract</span>  cout <span class="token operator">&lt;&lt;</span> <span class="token function">operation</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// 输出 2</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="5-总结-1"><a href="#5-总结-1" class="headerlink" title="5. 总结"></a><strong>5. 总结</strong></h3><h4 id="5-1-函数指针的特性"><a href="#5-1-函数指针的特性" class="headerlink" title="5.1 函数指针的特性"></a><strong>5.1 函数指针的特性</strong></h4><ol><li>函数指针存储函数入口地址，可用于动态调用。</li><li>解引用函数指针后可以调用函数，但额外多次解引用是未定义行为。</li><li>函数名本身可以隐式转换为函数指针。</li></ol><h4 id="5-2-打印函数指针"><a href="#5-2-打印函数指针" class="headerlink" title="5.2 打印函数指针"></a><strong>5.2 打印函数指针</strong></h4><ul><li><code>%p</code> 适用于打印函数指针地址或函数入口地址。</li><li>解引用函数指针后不能直接打印，解引用后应调用函数。</li></ul><h4 id="5-3-函数指针的用法"><a href="#5-3-函数指针的用法" class="headerlink" title="5.3 函数指针的用法"></a><strong>5.3 函数指针的用法</strong></h4><ul><li>函数指针常用于回调机制、动态选择操作、简化代码结构。</li><li>小心未定义行为（如多次解引用、返回局部指针等）。</li></ul><p>通过合理使用函数指针，可以提高代码的灵活性和可扩展性。</p><h2 id="结构体内存对齐"><a href="#结构体内存对齐" class="headerlink" title="结构体内存对齐"></a>结构体内存对齐</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">sz</span><span class="token expression"><span class="token punctuation">(</span>type<span class="token punctuation">)</span> cout<span class="token operator">&lt;&lt;</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span></span></span><span class="token keyword">struct</span> <span class="token class-name">stu</span><span class="token punctuation">&#123;</span>  <span class="token keyword">char</span> c<span class="token punctuation">;</span>  <span class="token keyword">short</span> a<span class="token punctuation">;</span>  <span class="token keyword">int</span> <span class="token operator">*</span>b<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">//8</span><span class="token keyword">struct</span> <span class="token class-name">stu1</span><span class="token punctuation">&#123;</span>  <span class="token keyword">char</span> c<span class="token punctuation">;</span>  <span class="token keyword">int</span> <span class="token operator">*</span>b<span class="token punctuation">;</span>  <span class="token keyword">short</span> a<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">//12</span><span class="token keyword">struct</span> <span class="token class-name">stu2</span><span class="token punctuation">&#123;</span>  <span class="token keyword">double</span> a<span class="token punctuation">;</span>  <span class="token keyword">char</span> b<span class="token punctuation">;</span>  <span class="token keyword">int</span> <span class="token operator">*</span>c<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">//16</span><span class="token keyword">struct</span> <span class="token class-name">stu3</span><span class="token punctuation">&#123;</span>  <span class="token keyword">char</span> b<span class="token punctuation">;</span>  <span class="token keyword">double</span> a<span class="token punctuation">;</span>  <span class="token keyword">int</span> <span class="token operator">*</span>c<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">//24</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token function">sz</span><span class="token punctuation">(</span>stu<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">sz</span><span class="token punctuation">(</span>stu1<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">sz</span><span class="token punctuation">(</span>stu2<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">sz</span><span class="token punctuation">(</span>stu3<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="结构体指针"><a href="#结构体指针" class="headerlink" title="结构体指针"></a>结构体指针</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstring></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">Stu</span><span class="token punctuation">&#123;</span>  <span class="token keyword">int</span> a<span class="token punctuation">;</span>  <span class="token keyword">char</span> c<span class="token punctuation">[</span><span class="token number">13</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  Stu s<span class="token punctuation">;</span>  s<span class="token punctuation">.</span>a<span class="token operator">=</span><span class="token number">12</span><span class="token punctuation">;</span>  <span class="token function">strcpy</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>c<span class="token punctuation">,</span> <span class="token string">"121"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  cout<span class="token operator">&lt;&lt;</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>  cout<span class="token operator">&lt;&lt;</span>s<span class="token punctuation">.</span>a<span class="token operator">&lt;&lt;</span><span class="token string">"--"</span><span class="token operator">&lt;&lt;</span>s<span class="token punctuation">.</span>c<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>  Stu <span class="token operator">*</span>pStu<span class="token operator">=</span><span class="token punctuation">(</span>Stu <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Stu<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  pStu<span class="token operator">-></span>a<span class="token operator">=</span><span class="token number">11</span><span class="token punctuation">;</span>  <span class="token function">strcpy</span><span class="token punctuation">(</span>pStu<span class="token operator">-></span>c<span class="token punctuation">,</span><span class="token string">"qwe"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  cout<span class="token operator">&lt;&lt;</span>pStu<span class="token operator">-></span>a<span class="token operator">&lt;&lt;</span><span class="token string">"---"</span><span class="token operator">&lt;&lt;</span>pStu<span class="token operator">-></span>c<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这段代码演示了 <strong>结构体指针的基本用法</strong>，以及通过 <code>malloc</code> 动态分配内存来操作结构体的一个实例。以下是代码的分步解析：</p><hr><h3 id="1-代码运行及输出"><a href="#1-代码运行及输出" class="headerlink" title="1. 代码运行及输出"></a><strong>1. 代码运行及输出</strong></h3><h4 id="1-1-静态分配的结构体"><a href="#1-1-静态分配的结构体" class="headerlink" title="1.1 静态分配的结构体"></a><strong>1.1 静态分配的结构体</strong></h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Stu s<span class="token punctuation">;</span>s<span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token number">12</span><span class="token punctuation">;</span><span class="token function">strcpy</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>c<span class="token punctuation">,</span> <span class="token string">"121"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> s<span class="token punctuation">.</span>a <span class="token operator">&lt;&lt;</span> <span class="token string">"--"</span> <span class="token operator">&lt;&lt;</span> s<span class="token punctuation">.</span>c <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p><strong><code>Stu</code> 结构体内存布局</strong>（假设 64 位系统）：</p><pre class="line-numbers language-none"><code class="language-none">int a       -&gt; 4 字节char c[13]  -&gt; 13 字节填充        -&gt; 3 字节（以满足 4 字节对齐）总大小      -&gt; 20 字节<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong><code>sizeof(s)</code> 输出</strong>：<code>20</code>（总大小包含对齐后的填充字节）。</p></li><li><p><strong><code>s.a</code> 和 <code>s.c</code> 的值</strong>：分别为 <code>12</code> 和字符串 <code>&quot;121&quot;</code>。</p></li></ul><h4 id="1-2-动态分配的结构体"><a href="#1-2-动态分配的结构体" class="headerlink" title="1.2 动态分配的结构体"></a><strong>1.2 动态分配的结构体</strong></h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Stu <span class="token operator">*</span>pStu <span class="token operator">=</span> <span class="token punctuation">(</span>Stu <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Stu<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>pStu<span class="token operator">-></span>a <span class="token operator">=</span> <span class="token number">11</span><span class="token punctuation">;</span><span class="token function">strcpy</span><span class="token punctuation">(</span>pStu<span class="token operator">-></span>c<span class="token punctuation">,</span> <span class="token string">"qwe"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> pStu<span class="token operator">-></span>a <span class="token operator">&lt;&lt;</span> <span class="token string">"---"</span> <span class="token operator">&lt;&lt;</span> pStu<span class="token operator">-></span>c <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>动态分配了大小为 <code>sizeof(Stu)</code> 的内存块。</li><li>使用箭头操作符 (<code>-&gt;</code>) 对结构体的成员进行赋值和访问。</li><li>输出：<code>11---qwe</code>。</li></ul><hr><h3 id="2-关键知识点"><a href="#2-关键知识点" class="headerlink" title="2. 关键知识点"></a><strong>2. 关键知识点</strong></h3><h4 id="2-1-结构体的静态分配"><a href="#2-1-结构体的静态分配" class="headerlink" title="2.1 结构体的静态分配"></a><strong>2.1 结构体的静态分配</strong></h4><ul><li>定义 <code>Stu s;</code> 会在栈上分配内存，其生命周期由当前作用域决定。</li><li>通过点操作符 (<code>.</code>) 访问和操作结构体的成员。</li><li>对齐填充：<ul><li>为了提高 CPU 访问效率，系统通常要求结构体成员对齐到其最大类型大小的倍数（此处为 4 字节）。</li><li><code>char c[13]</code> 后需要填充 3 字节，确保结构体总大小为 4 的倍数。</li></ul></li></ul><hr><h4 id="2-2-结构体的动态分配"><a href="#2-2-结构体的动态分配" class="headerlink" title="2.2 结构体的动态分配"></a><strong>2.2 结构体的动态分配</strong></h4><ul><li>使用 <code>malloc</code> 分配内存时，内存是从堆上分配的，<strong>生命周期由程序员手动控制</strong>（需注意释放内存以防止内存泄漏）。</li><li>动态分配的结构体需要通过 <strong>指针访问</strong>，使用箭头操作符 (<code>-&gt;</code>) 访问成员。</li></ul><h4 id="2-3-内存管理注意事项"><a href="#2-3-内存管理注意事项" class="headerlink" title="2.3 内存管理注意事项"></a><strong>2.3 内存管理注意事项</strong></h4><ol><li><p><strong>动态分配的内存需要释放</strong>：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">free</span><span class="token punctuation">(</span>pStu<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>否则会造成内存泄漏。</p></li><li><p><strong>避免使用未初始化的内存</strong>： 动态分配后，内存中的值是未定义的，需显式赋值或初始化。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Stu <span class="token operator">*</span>pStu <span class="token operator">=</span> <span class="token punctuation">(</span>Stu <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Stu<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">memset</span><span class="token punctuation">(</span>pStu<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>Stu<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 初始化为 0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p><strong>使用 <code>malloc</code> 时注意类型转换</strong>： 在 C++ 中，最好使用 <code>new</code> 而不是 <code>malloc</code>：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Stu <span class="token operator">*</span>pStu <span class="token operator">=</span> <span class="token keyword">new</span> Stu<span class="token punctuation">;</span><span class="token keyword">delete</span> pStu<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>或者可以使用现代的智能指针来管理动态内存，避免手动释放的麻烦。</p></li></ol><hr><h3 id="3-输出结果（假设-64-位系统）"><a href="#3-输出结果（假设-64-位系统）" class="headerlink" title="3. 输出结果（假设 64 位系统）"></a><strong>3. 输出结果（假设 64 位系统）</strong></h3><p>运行程序时会得到如下输出：</p><pre class="line-numbers language-none"><code class="language-none">2012--12111---qwe<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><hr><h3 id="4-推荐改进"><a href="#4-推荐改进" class="headerlink" title="4. 推荐改进"></a><strong>4. 推荐改进</strong></h3><h4 id="4-1-替换-malloc"><a href="#4-1-替换-malloc" class="headerlink" title="4.1 替换 malloc"></a><strong>4.1 替换 <code>malloc</code></strong></h4><p>C++ 提供了更安全的内存分配方法，可以用 <code>new</code> 替换 <code>malloc</code>：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Stu <span class="token operator">*</span>pStu <span class="token operator">=</span> <span class="token keyword">new</span> Stu<span class="token punctuation">;</span>pStu<span class="token operator">-></span>a <span class="token operator">=</span> <span class="token number">11</span><span class="token punctuation">;</span><span class="token function">strcpy</span><span class="token punctuation">(</span>pStu<span class="token operator">-></span>c<span class="token punctuation">,</span> <span class="token string">"qwe"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> pStu<span class="token operator">-></span>a <span class="token operator">&lt;&lt;</span> <span class="token string">"---"</span> <span class="token operator">&lt;&lt;</span> pStu<span class="token operator">-></span>c <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token keyword">delete</span> pStu<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-2-使用智能指针"><a href="#4-2-使用智能指针" class="headerlink" title="4.2 使用智能指针"></a><strong>4.2 使用智能指针</strong></h4><p>使用 <code>std::unique_ptr</code> 或 <code>std::shared_ptr</code> 来管理动态分配的结构体：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;memory></span></span>std<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span>Stu<span class="token operator">></span> pStu <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">make_unique</span><span class="token generic class-name"><span class="token operator">&lt;</span>Stu<span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>pStu<span class="token operator">-></span>a <span class="token operator">=</span> <span class="token number">11</span><span class="token punctuation">;</span><span class="token function">strcpy</span><span class="token punctuation">(</span>pStu<span class="token operator">-></span>c<span class="token punctuation">,</span> <span class="token string">"qwe"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> pStu<span class="token operator">-></span>a <span class="token operator">&lt;&lt;</span> <span class="token string">"---"</span> <span class="token operator">&lt;&lt;</span> pStu<span class="token operator">-></span>c <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样可以自动释放内存，无需手动调用 <code>delete</code> 或 <code>free</code>。</p><hr><h3 id="5-总结-2"><a href="#5-总结-2" class="headerlink" title="5. 总结"></a><strong>5. 总结</strong></h3><ol><li><strong>动态分配的内存需手动管理</strong>，推荐使用现代 C++ 的 <code>new/delete</code> 或智能指针代替 <code>malloc/free</code>。</li><li>结构体的大小受对齐规则影响，可以通过调整成员顺序减少填充字节。</li><li>对动态分配的结构体指针，尽量初始化，避免出现未定义行为。</li></ol>]]></content>
      
      
      <categories>
          
          <category> c++进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>统计项目代码行数</title>
      <link href="/2023/06/22/tong-ji-xiang-mu-dai-ma-xing-shu/"/>
      <url>/2023/06/22/tong-ji-xiang-mu-dai-ma-xing-shu/</url>
      
        <content type="html"><![CDATA[<h1 id="Cloc工具介绍"><a href="#Cloc工具介绍" class="headerlink" title="Cloc工具介绍"></a>Cloc工具介绍</h1><p><code>cloc</code>是一款优秀的命令行工具，用于计算项目中的代码行数，注释行数，空白行数，全称是：Count Lines of Code。</p><p>该工具在统计的时候也可以指定代码输出的格式以及各种参数的配置，比如输出CSV格式，可以在命令行后面加上<code>--csv</code>，比如还可以指定统计的条件，<code>--include-ext</code>，填写需要统计的扩展名字：<code>c</code>、<code>cpp</code>、<code>py</code>。</p><h1 id="Ubuntu用户"><a href="#Ubuntu用户" class="headerlink" title="Ubuntu用户"></a>Ubuntu用户</h1><p>使用<code>cloc</code>在ubuntu内统计代码行数</p><ol><li><p>安装<code>cloc</code>工具</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> cloc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>进入需要统计的目录内，然后执行</p> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cloc <span class="token builtin class-name">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>然后就会显示文件目录中的文件数(files)、空白行数(blank)、注释行数(comment)和代码行数(code)。</p></li></ol><h1 id="Windows-用户"><a href="#Windows-用户" class="headerlink" title="Windows 用户"></a>Windows 用户</h1><p>也是使用<code>cloc</code>工具</p><ol><li><p>下载最新<code>cloc.exe</code>工具，官网地址：<a href="http://cloc.sourceforge.net/">http://cloc.sourceforge.net/</a></p><p> <img src="https://s2.loli.net/2023/06/22/Plp519xOn8NyDBS.png" alt=""></p><p> <img src="https://s2.loli.net/2023/06/22/f2RycgumFT16pIS.png" alt=""></p><p> <img src="https://s2.loli.net/2023/06/22/r32Wm6QleJzScDP.png" alt=""></p></li><li><p>下载完成后，将<code>cloc-1.64.exe</code>名称修改为<code>cloc.exe</code>，放在需要统计代码的文件夹所在目录</p><p><img src="https://s2.loli.net/2023/06/22/gdZl8Fko7QmuNHJ.png" alt=""></p><p>打开终端，输入命令<code>&gt;cloc.exe Project</code>(Project即要统计代码行数的文件名)</p></li><li><p>显示结果<img src="https://s2.loli.net/2023/06/22/BsDR8yoI9OaYrwT.png" alt=""></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程不安全版本的单例模式（详解）</title>
      <link href="/2023/06/22/xian-cheng-bu-an-quan-ban-ben-de-dan-li-mo-shi-xiang-jie/"/>
      <url>/2023/06/22/xian-cheng-bu-an-quan-ban-ben-de-dan-li-mo-shi-xiang-jie/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="出发点"><a href="#出发点" class="headerlink" title="出发点"></a>出发点</h1><p>保证一个类仅有一个实例，并提供一个该实例的全局访问点。 ——《设计模式》GoF</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h2 id="单例分为两种实现方法："><a href="#单例分为两种实现方法：" class="headerlink" title="单例分为两种实现方法："></a>单例分为两种实现方法：</h2><ul><li><h3 id="懒汉"><a href="#懒汉" class="headerlink" title="懒汉"></a>懒汉</h3></li></ul><ul><li>第一次用到类实例的时候才会去实例化，上述就是懒汉实现。</li><li><h3 id="饿汉"><a href="#饿汉" class="headerlink" title="饿汉"></a>饿汉</h3></li></ul><ul><li>单例类定义的时候就进行了实例化。</li></ul><p><strong>懒汉模式的实现：</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Singleton&#123;public:    static Singleton* getInstance()&#123;        &#x2F;&#x2F; 先检查对象是否存在        if (m_instance &#x3D;&#x3D; nullptr) &#123;            m_instance &#x3D; new Singleton();        &#125;        return m_instance;    &#125;private:    Singleton(); &#x2F;&#x2F;私有构造函数，不允许使用者自己生成对象    &#x2F;&#x2F;关键点就是将Singleton()设置为私有的    Singleton(const Singleton&amp; other);    static Singleton* m_instance; &#x2F;&#x2F;静态成员变量 &#125;;Singleton* Singleton::m_instance&#x3D;nullptr; &#x2F;&#x2F;静态成员需要先类外初始化<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>饿汉的实现：</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class singleton &#123;private:    singleton() &#123;&#125;    static singleton *p;public:    static singleton *instance();&#125;;singleton *singleton::p &#x3D; new singleton();singleton* singleton::instance() &#123;    return p;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h1><p>这是一个非常简单的实现，将构造函数声明为<strong>private</strong>或<strong>protect</strong>防止被<strong>外部函数实例化</strong>，内部有一个静态的类指针保存唯一的实例，<strong>实例的实现由一个public方法来实现</strong>，该方法返回该类的唯一实例。</p><p>当然这个代码只适合在单线程下，当多线程时，是不安全的。考虑两个线程同时首次调用instance方法且同时检测到p是nullptr，则<strong>两个线程会同时构造一个实例给p，这将违反了单例的准则。</strong></p><h2 id="多线程下的分析："><a href="#多线程下的分析：" class="headerlink" title="多线程下的分析："></a><strong>多线程下的分析：</strong></h2><p>正常情况下，如果线程A调用完了getInstance()之后，将m_instance初始化了，线程B再去调用getInstance()就不会在创建一个新的实例了，直接使用之前A创建好的实例；然而存在这一种情况，当线程A正在执行getInstance()，但是还没有创建好m_instance，此时B线程调用getInstance()，m_instance是nullptr，会new一个实例。A一个实例，B一个实例，这样就可能导致程序错误，同时，还会发生内存泄漏。</p><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>使用多线程加锁、双重检查锁模式、memory barrier指令、静态局部变量、Atomic、pthread_once等方法</p>]]></content>
      
      
      <categories>
          
          <category> c++进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>时间戳的简单含义</title>
      <link href="/2023/06/22/shi-jian-chuo-de-jian-dan-han-yi/"/>
      <url>/2023/06/22/shi-jian-chuo-de-jian-dan-han-yi/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>时间戳（timestamp），是计算机里存储和表示时间的基本方式。</p><p>以1970年1月1日0时0分0秒作为基准</p><p>计算当前时刻与这个基准时刻的秒数/毫秒/微妙之差</p><p>得到的这个数字就叫做时间差</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>什么是持久层框架</title>
      <link href="/2023/06/22/shi-me-shi-chi-jiu-ceng-kuang-jia/"/>
      <url>/2023/06/22/shi-me-shi-chi-jiu-ceng-kuang-jia/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="什么是持久层"><a href="#什么是持久层" class="headerlink" title="什么是持久层?"></a>什么是<a href="https://so.csdn.net/so/search?q=%E6%8C%81%E4%B9%85%E5%B1%82&amp;spm=1001.2101.3001.7020">持久层</a>?</h1><p>持久是相对于瞬时来说的，<strong><em> 持久层，可以理解成数据 保存在 数据库或者 硬盘一类可以保存很长时间的设备里面，不像放在内存中那样断电就消失了，也就是把数据存在持久化设备上</em></strong> ，你想一下 <a href="https://so.csdn.net/so/search?q=%E5%86%85%E5%AD%98&amp;spm=1001.2101.3001.7020">内存</a>中的数据 断电就没有了，硬盘的数据 是否会像内存中的数据一样断电消失么？</p><h1 id="为什么要使用持久化框架"><a href="#为什么要使用持久化框架" class="headerlink" title="为什么要使用持久化框架?"></a>为什么要使用持久化框架?</h1><p>企业应用中<strong>* 数据很重要(各种订单数据、客户数据、库存数据之类的)，他们的数据就是财富，比应用程序本身更重要，</strong> 所以需要把数据<strong>持久化</strong>。持久化可以通过很多方式，写文件和数据库都可以。只是现在企业一般都会选择把数据持久化到数据库中，因为可以很方便的查询统计分析，但数据库的数据最终还是会写到磁盘上的。Java 程序员为了操作数据库，<strong> 最开始是使用JDBC*</strong> 来进行的，但是这种方式<strong>* 开发效率低</strong> ，要写一堆重复代码，加上关系数据库和对象本身存在所谓的阻抗不匹配情况，所以<strong> 为了提高开发效率，有人发明了 ORM 即 对象关系映射框架*</strong> (Hibernate是其中的佼佼者)，对于 Java 程序员来说，就可以通过操纵对象来操纵数据库了。</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UTF-8编码</title>
      <link href="/2023/06/22/utf8-bian-ma/"/>
      <url>/2023/06/22/utf8-bian-ma/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>UTF-8就是在互联网上使用最Unicode的实现方式，其他实现方式还包括UTF-16和UTF-32。不过在互联网上基本不用。重复一遍，这里的关系是，UTF-8是Unicode的实现方式之一。</p><p>世界上存在着多种编码方式，同一个二进制数字可以被解释成不同的符号。因此，要想打开一个文本文件，就必须知道它的编码方式，否则用错误的编码方式解读，就会出现乱码。为什么电子邮件常常出现乱码？就是因为发信人和收信人使用的编码方式不一样。</p><p>可以想象，如果有一种编码，将世界上所有的符号都纳入其中。每一个符号都给予一个独一无二的编码，那么乱码问题就会消失。这就是Unicode，就像它的名字都表示的，这是一种所有符号的编码。</p><p>而Unicode里面UTF-8最大的一个特点，就是它是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。它同样包含全世界所有国家用到的字符，是国际编码了，通用性强，主要用以解决国际上字符的一种多字节编码，对英文使用八位（即一个字节），中文使用24位（即三个字节）。</p>]]></content>
      
      
      <categories>
          
          <category> c++基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL小小知识点：超键，候选键，主键，外键基本概念</title>
      <link href="/2023/06/22/sql-xiao-xiao-zhi-shi-dian-chao-jian-hou-xuan-jian-zhu-jian-wai-jian-ji-ben-gai-nian/"/>
      <url>/2023/06/22/sql-xiao-xiao-zhi-shi-dian-chao-jian-hou-xuan-jian-zhu-jian-wai-jian-ji-ben-gai-nian/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="超键"><a href="#超键" class="headerlink" title="超键"></a>超键</h1><p><strong>定义</strong>：在关系模式中，可以<strong>唯一标识</strong>一个元组的<strong>属性集</strong>称为<strong>超键（Super Key）</strong>。</p><p>举个栗子：student(Sno, Sname, Sage, Ssex)</p><p>在这个结构中，只有包含Sno的属性集合才能是超键，因为如果不包含Sno，可能会出现同名，同姓的人，也可能出现同岁的人，所以在上面的关系模式中只有通过学号才能找到某个特定的学生。</p><p>因此上述关系模式中只有包含学号的属性集才能称之为超键：</p><p>例如：(Sno), (Sno, Sname), (Sno, Sname, Sage)等</p><h1 id="候选键"><a href="#候选键" class="headerlink" title="候选键"></a>候选键</h1><p><strong>定义</strong>：在关系模式中，能<strong>唯一标识元组</strong>并且<strong>不含多余属性的属性集</strong>称为<strong>候选键（Candidate Key）</strong>。</p><p>例如在上面提到的例子中，student(Sno, Sname, Sage, Ssex)</p><p>如果没有重名的学生，Sname也可以当成是候选键，这里可以看出候<strong>选键是一种特殊的超键，即把超键中多余的属性删除就可以叫做候选键。</strong></p><p>所以上述关系中（Sno）（Sname）可以叫做候选键。</p><h1 id="主键"><a href="#主键" class="headerlink" title="主键"></a>主键</h1><p>定义：在关系模式中的<strong>若干个候选键</strong>中，随意指定一个作为关键字，此关键字即为<strong>主键（Primary Key）</strong>。</p><p>分析：student(Sno, Sname, Sage, Ssex)</p><p>　　主键很好理解，<strong>就在在候选键的基础上任意选择一个作为主键（理解这点就明白了什么可以当主键了）</strong>，同时衍生出<strong>复合主键</strong>和<strong>联合主键</strong> ，假设我们没有学号字段，如果可以通过姓名，年龄，性别一同找到某个特定的学生，那么就称(name, age, sex)为复合主键，全部由主键构成的称为联合主键。</p><p>　　因此上述关系模式中，姓名，和年龄也能唯一确定学生，那么主键有：</p><p>　　例：(Sno), (Sname)，复合主键（Sname，Sage）</p><h1 id="外键"><a href="#外键" class="headerlink" title="外键"></a>外键</h1><p>定义：可以把一张表的数据与另一张表关联起来，这种列称为<strong><code>外键</code>（Foreign Key）</strong>。</p><p>分析：student(Sno, Sname, Sage, Ssex,SCredit), score(Sno, Tno, Sco)</p><p>　　外键是建立在两个关系模式中的，从上述定义中可用知道，某关系模式中主键一定是其候选键，那对于另一关系，只要原关系的主键只表示普通属性，那它就是另一属性的外键，上表中Sno就是score的外键，他把两个表关联起来了。</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>QT连接Mysql后的简单操作（增删改查）</title>
      <link href="/2023/06/22/qt-lian-jie-mysql-hou-de-jian-dan-cao-zuo-zeng-shan-gai-cha/"/>
      <url>/2023/06/22/qt-lian-jie-mysql-hou-de-jian-dan-cao-zuo-zeng-shan-gai-cha/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h1><p>首先要连接自己在电脑上安装的MySql的数据库（这个是最难也是最重要的一步，万事起步难），连接上了之后的Sql语句就会就会非常简单了，连接数据库可以参考这篇博客（注意在连接时会有可能会有很多报错信息，但是只要按照这个操作来，一步一步操作应该没有问题。） </p><p><a href="https://blog.csdn.net/qq_38832450/article/details/110452117">Qt编译MySQL数据库驱动_焕小谢的博客-CSDN博客_qt编译mysql驱动</a></p><p>注意在操作完这些操作后不要直接点构建，</p><p><img src="https://img-blog.csdnimg.cn/ff8480a26a9d41a68a8cc1141003af75.png" alt=""></p><p><img src="https://img-blog.csdnimg.cn/eb55c56339f749a28cc2965a0b817e68.png" alt=""></p><p>要点重新构建所有项目（我因为这个问题弄了好久😭😭😭）。</p><h1 id="增删改查（MySql）"><a href="#增删改查（MySql）" class="headerlink" title="增删改查（MySql）"></a>增删改查（MySql）</h1><p>首先在xxx.pro文件中加入sql模块。</p><p><img src="https://img-blog.csdnimg.cn/1711a48b7b8c47c3805b9219e761cc0a.png" alt=""></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &quot;widget.h&quot;#include &quot;ui_widget.h&quot;#include &lt;QDebug&gt;#include &lt;QSqlDatabase&gt;#include &lt;QStringList&gt;#include &lt;QSqlError&gt;#include &lt;QSqlQuery&gt;#include &lt;QMessageBox&gt;Widget::Widget(QWidget *parent)    : QWidget(parent)    , ui(new Ui::Widget)&#123;    ui-&gt;setupUi(this);    &#x2F;&#x2F; 1. 添加一个数据库实例    QStringList ls &#x3D; QSqlDatabase::drivers();    qDebug() &lt;&lt; ls;    QSqlDatabase db &#x3D; QSqlDatabase::addDatabase(&quot;QMYSQL&quot;);    &#x2F;&#x2F; 2. 得到实例对象之后需要初始化连接信息    &#x2F;&#x2F;    -- 服务器的IP, 端口, 数据库名, 用户名, 密码    db.setHostName(&quot;localhost&quot;);    db.setPort(3306);   &#x2F;&#x2F; 如果使用的是默认端口, 可以不调用该函数    db.setDatabaseName(&quot;student&quot;);&#x2F;&#x2F;这是我自己建的表的名字，要看自己在DBMS上面建了什么表。    db.setUserName(&quot;root&quot;);&#x2F;&#x2F;root用户    db.setPassword(&quot;123456&quot;);&#x2F;&#x2F;密码    &#x2F;&#x2F; 3. 连接数据库    bool bl &#x3D; db.open();    if(!bl)    &#123;        qDebug() &lt;&lt; db.lastError().text();        return;    &#125;    else    &#123;&#x2F;&#x2F;        qDebug() &lt;&lt; &quot;数据库连接成功了...&quot;;        QMessageBox::information(this, &quot;succeed&quot;, &quot;hahah&quot;);    &#125;    QSqlQuery query;    &#x2F;&#x2F; 4. 插入数据&#x2F;&#x2F;    QString sql &#x3D; &quot;insert into dept values(23, &#39;火影忍者&#39;, &#39;东京&#39;)&quot;;&#x2F;&#x2F;    QString sql &#x3D; &quot;select * from student&quot;;    &#x2F;&#x2F; 开启事务&#x2F;&#x2F;    db.transaction();&#x2F;&#x2F;    bool flag &#x3D; query.exec(sql);&#x2F;&#x2F;    if(flag)&#x2F;&#x2F;    &#123;&#x2F;&#x2F;       db.commit();&#x2F;&#x2F;    &#125;&#x2F;&#x2F;    else&#x2F;&#x2F;    &#123;&#x2F;&#x2F;       db.rollback();&#x2F;&#x2F;    &#125;&#x2F;&#x2F;    &#x2F;&#x2F; 5. 查询数据表 - dept&#x2F;&#x2F;    query.exec(&quot;select * from score&quot;);    &#x2F;&#x2F; 遍历结果集    while(query.next())    &#123;        &#x2F;&#x2F; 从当前记录中取出各个字段的值&#x2F;&#x2F;        qDebug() &lt;&lt; query.value(0).toString()&#x2F;&#x2F;                &lt;&lt; query.value(1).toString()&#x2F;&#x2F;                &lt;&lt; query.value(&quot;dname&quot;).toString()&#x2F;&#x2F;                &lt;&lt; query.value(&quot;loc&quot;).toString();        QString sno &#x3D; query.value(0).toString();        QString cno &#x3D; query.value(1).toString();        QString tno &#x3D; query.value(2).toString();        double grade &#x3D; query.value(3).toDouble();        qDebug()&lt;&lt;sno&lt;&lt;&quot; &quot;&lt;&lt;cno&lt;&lt;&quot; &quot;&lt;&lt;tno&lt;&lt;&quot; &quot;&lt;&lt;grade;    &#125;    db.close();&#125;Widget::~Widget()&#123;    delete ui;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>增删改查其实就利用这个模板来操作了，这个时候就要看你的MqSql的功底了。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">query.exec(&quot;insert into student values(......)&quot;);&#x2F;&#x2F;增query.exec(&quot;DELETE FROM table_name [WHERE Clause]&quot;);&#x2F;&#x2F;删除query.exec(&quot;UPDATE table_name SET field1&#x3D;new-value1, field2&#x3D;new-value2[WHERE Clause]&quot;);&#x2F;&#x2F;更新query.exec(&quot;select * from score&quot;);&#x2F;&#x2F;查询<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> QT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> QT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Qt:_QWidget::paintEngine:_Should_no_longer_be_called</title>
      <link href="/2023/06/22/qtqwidgetpaintengineshouldnolongerbecalled/"/>
      <url>/2023/06/22/qtqwidgetpaintengineshouldnolongerbecalled/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="由来"><a href="#由来" class="headerlink" title="由来"></a>由来</h2><p>今天在QT Creater使用QPainter的时候出现了这个错误，在引用输出窗口还有这么一些错误</p><p><img src="https://img-blog.csdnimg.cn/d4c9c9eaba8d46789d0896411d73845e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5aSc54yr56iL5bqP54y_,size_18,color_FFFFFF,t_70,g_se,x_16" alt=""></p><p>之前在使用其他类的时候，直接在widget.h中的MainWindow中写都可以运行像这样</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &quot;mainwindow.h&quot;#include &quot;ui_mainwindow.h&quot;#include &lt;QDialog&gt;#include &lt;QStatusBar&gt;#include &lt;QMessageBox&gt;#include &lt;QColorDialog&gt;#include &lt;QDebug&gt;#include &lt;QFileDialog&gt;#include &lt;QString&gt;#include &lt;QFontDialog&gt;MainWindow::MainWindow(QWidget *parent) :    QMainWindow(parent),    ui(new Ui::MainWindow)&#123;    ui-&gt;setupUi(this);    QStatusBar *staBar &#x3D; statusBar();    setStatusBar(staBar);&#x2F;&#x2F;only one set, not only one add;    ui-&gt;actionNew-&gt;setIcon(QIcon(&quot;D:&#x2F;图片&#x2F;三体智子高清4k动漫壁纸_彼岸图网.jpg&quot;));    connect(ui-&gt;actionNew, &amp;QAction::triggered, [&#x3D;]()&#123;&#x2F;&#x2F;        mo tai duihuakuang&#x2F;&#x2F;        QDialog log(this);&#x2F;&#x2F;模态        QDialog *log &#x3D; new QDialog(this);&#x2F;&#x2F;new在堆区的        log-&gt;resize(200, 100);        log-&gt;show();&#x2F;&#x2F;非模态        log-&gt;setAttribute(Qt::WA_DeleteOnClose);&#x2F;&#x2F;非模态的时候才需要设置这个属性，因为非模态是new在堆区的&#x2F;&#x2F;        log.exec();&#x2F;&#x2F;模态，把窗口阻塞了&#x2F;&#x2F;        fei motai dui hua kuang    &#125;);&#x2F;&#x2F;    QMessageBox::critical(this, &quot;ha&quot;, &quot;错误&quot;);&#x2F;&#x2F;    QColorDialog color &#x3D; QColorDialog::getColor(QColor(255, 0, 0));&#x2F;&#x2F;    qDebug()&lt;&lt;&quot;r&#x3D;&quot;&lt;&lt;color.red()&lt;&lt;&quot; &quot;&lt;&lt;&quot;g&#x3D;&quot;&lt;&lt;color.green();&#x2F;&#x2F;    QString str &#x3D; QFileDialog::getOpenFileName(this, &quot;open&quot;,&#x2F;&#x2F;                                 &quot;D:\OneDrive文档\OneDrive - officeapp.org\Desktop&quot;, &quot;*.txt&quot;);&#x2F;&#x2F;    qDebug()&lt;&lt;str;&#x2F;&#x2F;    bool flag;&#x2F;&#x2F;    QFont font &#x3D; QFontDialog::getFont(&amp;flag, QFont(&quot;华文彩文&quot;, 36));&#125;MainWindow::~MainWindow()&#123;    delete ui;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="注意下面我的创建过程："><a href="#注意下面我的创建过程：" class="headerlink" title="注意下面我的创建过程："></a><strong>注意下面我的创建过程：</strong></h2><p><img src="https://img-blog.csdnimg.cn/df90169dccb34d2c98305119b73c16fd.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5aSc54yr56iL5bqP54y_,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""></p><p><img src="https://img-blog.csdnimg.cn/790e51f20a0747b7b0383ad851bf85e4.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5aSc54yr56iL5bqP54y_,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""></p><p><img src="https://img-blog.csdnimg.cn/3549f541aa1c4b829ec037504a448ea8.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5aSc54yr56iL5bqP54y_,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""></p><p><img src="https://img-blog.csdnimg.cn/c64d24b5f45a4ab9a435e4f4ca2caac0.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5aSc54yr56iL5bqP54y_,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""></p><p><strong> 注意这一步</strong>：</p><p><img src="https://img-blog.csdnimg.cn/57fac6cc320a41da80e11097ec5aad22.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5aSc54yr56iL5bqP54y_,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""></p><p> 然后我在QWidget.cpp中写了下面的代码</p><p><img src="https://img-blog.csdnimg.cn/0cf0563fb3424b9497d8a7eb9c94d29c.png" alt=""></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &quot;ui_widget.h&quot;#include &lt;ui_widget.h&gt;Widget::Widget(QWidget *parent) :    QWidget(parent),    ui(new Ui::Widget)&#123;    ui-&gt;setupUi(this);    QPainterPath path;    path.addRect(20, 20, 60, 60);&#x2F;&#x2F;    path.moveTo(0, 0);&#x2F;&#x2F;    path.cubicTo(99, 0,  50, 50,  99, 99);&#x2F;&#x2F;    path.cubicTo(0, 99,  50, 50,  0, 0);    QPainter painter(this);    painter.fillRect(0, 0, 100, 100, Qt::white);    painter.setPen(QPen(QColor(79, 106, 25), 1, Qt::SolidLine,                        Qt::FlatCap, Qt::MiterJoin));    painter.setBrush(QColor(122, 163, 39));    painter.drawPath(path);&#125;Widget::~Widget()&#123;    delete ui;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 然后就出现了上面的错误。</p><h2 id="下面是解决方法："><a href="#下面是解决方法：" class="headerlink" title="下面是解决方法："></a><strong>下面是解决方法：</strong></h2><p><strong>首先在QWidget.h中加入这个函数的申明</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void paintEvent(QPaintEvent *);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p> 然后再QWidget.cpp中定义这个函数，此时就可以使用QPainter类了</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &quot;widget.h&quot;#include &quot;ui_widget.h&quot;Widget::Widget(QWidget *parent) :    QWidget(parent),    ui(new Ui::Widget)&#123;    ui-&gt;setupUi(this);&#125;void Widget::paintEvent(QPaintEvent *)&#123;    QPainterPath path;    path.addRect(20, 20, 60, 60);    path.moveTo(0, 0);    path.cubicTo(99, 0,  50, 50,  99, 99);    path.cubicTo(0, 99,  50, 50,  0, 0);    QPainter painter(this);    painter.fillRect(0, 0, 100, 100, Qt::white);    painter.setPen(QPen(QColor(79, 106, 25), 1, Qt::SolidLine,                        Qt::FlatCap, Qt::MiterJoin));    painter.setBrush(QColor(122, 163, 39));    painter.drawPath(path);&#125;Widget::~Widget()&#123;    delete ui;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>运行结果如下： </strong></p><p><img src="https://img-blog.csdnimg.cn/0ef6cebd17a440108de64de391623118.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5aSc54yr56iL5bqP54y_,size_12,color_FFFFFF,t_70,g_se,x_16" alt=""></p><h2 id="产生这个错误的原因："><a href="#产生这个错误的原因：" class="headerlink" title="产生这个错误的原因："></a>产生这个错误的原因：</h2><p>在这里很好地解释了这一点：<br><a href="https://forum.qt.io/topic/64693/unable-to-paint-on-qt-widget-shows-error-paintengine-should-no-longer-be-called/3">https://forum.qt.io/topic/64693/unable-to-paint-on-qt-widget-shows-error-paintengine-should-no-longer-be-called/3</a></p><p>简而言之：不要尝试直接从输入事件处理程序进行绘制，而是在您的小部件中重载 paintEvent 方法并在那里创建 QPainter。仅使用输入事件来修改内部数据模型，并在paintEvent 中使用QPainter 将其显示在输出路径上。</p>]]></content>
      
      
      <categories>
          
          <category> QT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> QT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>QT_Creater工程文件介绍</title>
      <link href="/2023/06/22/qtcreater-gong-cheng-wen-jian-jie-shao/"/>
      <url>/2023/06/22/qtcreater-gong-cheng-wen-jian-jie-shao/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="Qt-Creator工程管理"><a href="#Qt-Creator工程管理" class="headerlink" title="Qt Creator工程管理"></a>Qt Creator工程管理</h1><p>Qt Creator以<strong>工程项目的方式</strong>对<a href="https://so.csdn.net/so/search?q=%E6%BA%90%E7%A0%81&amp;spm=1001.2101.3001.7020">源码</a>进行管理</p><p>一个Qt Craetor工程包含不同类型的文件</p><ul><li>.pro项目描述文件+ .pro.user用户配置描述文件+ .h头文件+ .cpp源文件+ .ui界面描述文件+ .qrc资源文件（图片，视频，等）</li></ul><h1 id="pro项目描述文件"><a href="#pro项目描述文件" class="headerlink" title=".pro项目描述文件"></a>.pro项目描述文件</h1><p>实质上是Makefile文件</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#-------------------------------------------------</span><span class="token comment">#</span><span class="token comment"># Project created by QtCreator 2022-04-08T19:06:19</span><span class="token comment">#</span><span class="token comment">#-------------------------------------------------</span>QT       <span class="token operator">+=</span> core gui              <span class="token comment"># 模块声明 core模块 gui模块</span>greaterThan<span class="token punctuation">(</span>QT_MAJOR_VERSION, <span class="token number">4</span><span class="token punctuation">)</span>: QT <span class="token operator">+=</span> widgets    <span class="token comment"># 如果使用QT版本大于4，那么需要告诉QT，还需要widgets模块</span>TARGET <span class="token operator">=</span> test1                    <span class="token comment"># 可执行文件名</span>TEMPLATE <span class="token operator">=</span> app                    <span class="token comment"># test1是一个app，可执行程序</span>SOURCES <span class="token operator">+=</span> main.cpp<span class="token punctuation">\</span>                <span class="token comment"># 源文件</span>        mainwindow.cppHEADERS  <span class="token operator">+=</span> mainwindow.h            <span class="token comment"># 头文件</span>FORMS    <span class="token operator">+=</span> mainwindow.ui            <span class="token comment">#界面描述文件.ui</span>RESOURCES <span class="token operator">+=</span> <span class="token punctuation">\</span>                        <span class="token comment"># 资源文件</span>    image.qrcCONFIG <span class="token operator">+=</span> <span class="token punctuation">\</span>                        <span class="token comment">#设定项目的配置信息和编译选项，这里是添加了c++11标准</span>    c++11<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h1><p>1、Qt Creator在打开项目文件的<strong>同时会生成.pro.user文件</strong></p><p>2、.pro.user文件包含一些与Qt相关的本地配置信息</p><p>3、<strong>当需要在不同计算机之间移动项目源码时，建议删除.pro.user文件</strong></p>]]></content>
      
      
      <categories>
          
          <category> QT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> QT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Qt5_的类_QPoint，QPointF（相关的方法，不会的都在）</title>
      <link href="/2023/06/22/qt5-de-lei-qpointqpointf-xiang-guan-de-fang-fa-bu-hui-de-du-zai/"/>
      <url>/2023/06/22/qt5-de-lei-qpointqpointf-xiang-guan-de-fang-fa-bu-hui-de-du-zai/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="QPoint"><a href="#QPoint" class="headerlink" title="QPoint"></a>QPoint</h1><p><a href="https://doc.qt.io/qt-5/qpoint.html">QPoint官网链接</a></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>QPoint 类使用整数精度来定义平面中的一个点</p><h2 id="包含的成员"><a href="#包含的成员" class="headerlink" title="包含的成员"></a>包含的成员</h2><p><img src="https://img-blog.csdnimg.cn/0043bcf801d74b6c952319df2648a945.png" alt=""></p><p>我觉得你可能<strong>看不懂</strong>的成员使用的方法：</p><p>1、dotProduct(const QPoint &amp;, const QPoint &amp;):int，参数是两个点的坐标，return 他们两点之间的点积，即进行向量的点乘运算，即x1<em>x2+y1</em>y2。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">QPoint p<span class="token punctuation">(</span> <span class="token number">3</span>, <span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">;</span>QPoint q<span class="token punctuation">(</span>-1, <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>int lengthSquared <span class="token operator">=</span> QPoint::dotProduct<span class="token punctuation">(</span>p, q<span class="token punctuation">)</span><span class="token punctuation">;</span>   // lengthSquared becomes <span class="token number">25</span>// -3+28<span class="token operator">=</span><span class="token number">25</span>，可以用来计算两条直线之间的角度<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>2、isNull()const : bool，如果 x 和 y 坐标都设置为 0，则返回 true，否则返回 false。</p><p>3、manhattanLength() const : int ，曼哈顿长度，返回的是他们的曼哈顿距离d(i,j)=|xi-xj|+|yi-yj|。</p><p>4、rx()，ry()，则是对一个点的x，y坐标单独拿出来进行更改</p><p>5、transPosed(): const QPoint，交换一个点的x，y坐标（exchanged）。</p><h1 id="QPointF"><a href="#QPointF" class="headerlink" title="QPointF"></a>QPointF</h1><h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><p>第一眼看上去以为是一个新的类，结果发现就是Float QPoint（哈哈😁），用法的话相信你认真看完前面的QPoint后，这一个类的使用也会恍然大悟。QPointF在浮点精度上表征平面上的点，绝大部分操作都是与QPoint相类似的，细微的差别在于运算符重载以及提供了QPoint与QPointF的相互转换。</p><h2 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h2><p><img src="https://img-blog.csdnimg.cn/292ce357d1b04be7843cc413ca582df2.png" alt=""></p><p>看完这张图你就会发现QPointF的用法和QPoint基本一样的，里面的很多方法和QPoint一样都是对运算符的重载。</p><p>几个要注意的函数：</p><p>1、toPoint() const由浮点精度转化为整数精度</p><p>2、构造函数那里QPointF(const QPoint&amp; point)由是为了从整数精度转化为浮点精度。</p>]]></content>
      
      
      <categories>
          
          <category> QT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> QT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python_字典中get（）的使用</title>
      <link href="/2023/06/22/python-zi-dian-zhong-get-de-shi-yong/"/>
      <url>/2023/06/22/python-zi-dian-zhong-get-de-shi-yong/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>当我们使用字典中不存在的键值时，会导致python显示Traceback，指出存在键值错误（KeyError），这时，可以使用方法get()在指定的键值不存在时，显示返回一个默认值，从而避免这样的错误。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">a<span class="token operator">=</span><span class="token punctuation">&#123;</span>    <span class="token string">"jason"</span><span class="token punctuation">:</span><span class="token string">"c"</span><span class="token punctuation">,</span>    <span class="token string">"sarah"</span><span class="token punctuation">:</span><span class="token string">"c++"</span><span class="token punctuation">,</span>    <span class="token string">"aaa"</span><span class="token punctuation">:</span><span class="token string">"python"</span><span class="token punctuation">,</span>    <span class="token string">"bbb"</span><span class="token punctuation">:</span><span class="token string">"javasripe"</span><span class="token punctuation">&#125;</span><span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token string">"jason"</span><span class="token punctuation">]</span><span class="token punctuation">)</span>b<span class="token operator">=</span>a<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">"ccc"</span><span class="token punctuation">,</span> <span class="token string">"Do not have this person."</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出结果：</p><p><img src="https://img-blog.csdnimg.cn/73148b5a36e948c68ad0f09512de3643.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5aSc54yr56iL5bqP54y_,size_17,color_FFFFFF,t_70,g_se,x_16" alt=""></p><p>这时我们就可以发现这种错误。</p><p>如果指定的键值可能不存在时，就应该考虑这种方法，不应该使用方括号表示法。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>里氏替换原则</title>
      <link href="/2023/06/22/liskovsubstitutionprinciple-ji-cheng-li-shi-ti-huan-yuan-ze/"/>
      <url>/2023/06/22/liskovsubstitutionprinciple-ji-cheng-li-shi-ti-huan-yuan-ze/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="Liskov-Substitution-principle"><a href="#Liskov-Substitution-principle" class="headerlink" title="Liskov Substitution principle"></a>Liskov Substitution principle</h1><p>在面向对象的程序设计中，<strong>里氏替换原则</strong>（Liskov Substitution principle）是对子类型的特别定义。它由芭芭拉·利斯科夫（Barbara Liskov）在1987年在一次会议上名为“数据的抽象与层次”的演说中首先提出。</p><p>里氏替换原则的内容可以描述为：“派生类（子类）对象可以在程序中代替其基类（超类）对象。”在实际开发中，我们经常会用子类对象去替换掉一个父类对象，这是面向对象编程中一个常见的行为。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token builtin">object</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""人"""</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> name<span class="token punctuation">,</span> age<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>_name <span class="token operator">=</span> name        self<span class="token punctuation">.</span>_age <span class="token operator">=</span> age    <span class="token decorator annotation punctuation">@property</span>    <span class="token keyword">def</span> <span class="token function">name</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>_name    <span class="token decorator annotation punctuation">@property</span>    <span class="token keyword">def</span> <span class="token function">age</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>_age    <span class="token decorator annotation punctuation">@age<span class="token punctuation">.</span>setter</span>    <span class="token keyword">def</span> <span class="token function">age</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> age<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>_age <span class="token operator">=</span> age    <span class="token keyword">def</span> <span class="token function">play</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'%s正在愉快的玩耍.'</span> <span class="token operator">%</span> self<span class="token punctuation">.</span>_name<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">watch_av</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>_age <span class="token operator">>=</span> <span class="token number">18</span><span class="token punctuation">:</span>            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'%s正在观看爱情动作片.'</span> <span class="token operator">%</span> self<span class="token punctuation">.</span>_name<span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'%s只能观看《熊出没》.'</span> <span class="token operator">%</span> self<span class="token punctuation">.</span>_name<span class="token punctuation">)</span><span class="token keyword">class</span> <span class="token class-name">Student</span><span class="token punctuation">(</span>Person<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""学生"""</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> name<span class="token punctuation">,</span> age<span class="token punctuation">,</span> grade<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token builtin">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span>name<span class="token punctuation">,</span> age<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>_grade <span class="token operator">=</span> grade    <span class="token decorator annotation punctuation">@property</span>    <span class="token keyword">def</span> <span class="token function">grade</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>_grade    <span class="token decorator annotation punctuation">@grade<span class="token punctuation">.</span>setter</span>    <span class="token keyword">def</span> <span class="token function">grade</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> grade<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>_grade <span class="token operator">=</span> grade    <span class="token keyword">def</span> <span class="token function">study</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> course<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'%s的%s正在学习%s.'</span> <span class="token operator">%</span> <span class="token punctuation">(</span>self<span class="token punctuation">.</span>_grade<span class="token punctuation">,</span> self<span class="token punctuation">.</span>_name<span class="token punctuation">,</span> course<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">class</span> <span class="token class-name">Teacher</span><span class="token punctuation">(</span>Person<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""老师"""</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> name<span class="token punctuation">,</span> age<span class="token punctuation">,</span> title<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token builtin">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span>name<span class="token punctuation">,</span> age<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>_title <span class="token operator">=</span> title    <span class="token decorator annotation punctuation">@property</span>    <span class="token keyword">def</span> <span class="token function">title</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>_title    <span class="token decorator annotation punctuation">@title<span class="token punctuation">.</span>setter</span>    <span class="token keyword">def</span> <span class="token function">title</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> title<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>_title <span class="token operator">=</span> title    <span class="token keyword">def</span> <span class="token function">teach</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> course<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'%s%s正在讲%s.'</span> <span class="token operator">%</span> <span class="token punctuation">(</span>self<span class="token punctuation">.</span>_name<span class="token punctuation">,</span> self<span class="token punctuation">.</span>_title<span class="token punctuation">,</span> course<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    stu <span class="token operator">=</span> Student<span class="token punctuation">(</span><span class="token string">'王大锤'</span><span class="token punctuation">,</span> <span class="token number">15</span><span class="token punctuation">,</span> <span class="token string">'初三'</span><span class="token punctuation">)</span>    stu<span class="token punctuation">.</span>study<span class="token punctuation">(</span><span class="token string">'数学'</span><span class="token punctuation">)</span>    stu<span class="token punctuation">.</span>watch_av<span class="token punctuation">(</span><span class="token punctuation">)</span>    t <span class="token operator">=</span> Teacher<span class="token punctuation">(</span><span class="token string">'骆昊'</span><span class="token punctuation">,</span> <span class="token number">38</span><span class="token punctuation">,</span> <span class="token string">'砖家'</span><span class="token punctuation">)</span>    t<span class="token punctuation">.</span>teach<span class="token punctuation">(</span><span class="token string">'Python程序设计'</span><span class="token punctuation">)</span>    t<span class="token punctuation">.</span>watch_av<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    main<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里就是一个继承关系，使用了@property包装器来包装getter和setter方法，可以让属性的访问既方便又安全，下面是@property的用法解释。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">Typical use <span class="token keyword">is</span> to define a managed attribute x<span class="token punctuation">:</span><span class="token keyword">class</span> <span class="token class-name">C</span><span class="token punctuation">(</span><span class="token builtin">object</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">getx</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">return</span> self<span class="token punctuation">.</span>_x    <span class="token keyword">def</span> <span class="token function">setx</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">:</span> self<span class="token punctuation">.</span>_x <span class="token operator">=</span> value    <span class="token keyword">def</span> <span class="token function">delx</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">del</span> self<span class="token punctuation">.</span>_x x <span class="token operator">=</span> <span class="token builtin">property</span><span class="token punctuation">(</span>getx<span class="token punctuation">,</span> setx<span class="token punctuation">,</span> delx<span class="token punctuation">,</span> <span class="token string">"I'm the 'x' property."</span><span class="token punctuation">)</span>Decorators make defining new properties <span class="token keyword">or</span> modifying existing ones easy<span class="token punctuation">:</span><span class="token keyword">class</span> <span class="token class-name">C</span><span class="token punctuation">(</span><span class="token builtin">object</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token decorator annotation punctuation">@property</span> <span class="token keyword">def</span> <span class="token function">x</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token string">"I am the 'x' property."</span> <span class="token keyword">return</span> self<span class="token punctuation">.</span>_x    <span class="token decorator annotation punctuation">@x<span class="token punctuation">.</span>setter</span> <span class="token keyword">def</span> <span class="token function">x</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>_x <span class="token operator">=</span> value    <span class="token decorator annotation punctuation">@x<span class="token punctuation">.</span>deleter</span> <span class="token keyword">def</span> <span class="token function">x</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">del</span> self<span class="token punctuation">.</span>_x<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>dbms_output.put_line的用法（Oracle）</title>
      <link href="/2023/06/22/dbmsoutputputline-de-yong-fa-oracle/"/>
      <url>/2023/06/22/dbmsoutputputline-de-yong-fa-oracle/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="dbms-output-put-line的用法"><a href="#dbms-output-put-line的用法" class="headerlink" title="dbms_output.put_line的用法"></a><strong>dbms_output.put_line的用法</strong></h1><h1 id="涉及到的知识点如下："><a href="#涉及到的知识点如下：" class="headerlink" title="涉及到的知识点如下："></a>涉及到的知识点如下：</h1><h2 id="1、enable："><a href="#1、enable：" class="headerlink" title="1、enable："></a>1、enable：</h2><p>在serveroutput on的情况下，用来使dbms_output生效(默认即打开)</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">set serveroutput on --将output 服务打开<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="2、disable："><a href="#2、disable：" class="headerlink" title="2、disable："></a>2、disable：</h2><p>在serveroutput on的情况下，用来使dbms_output失效</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">set serveroutput off --将output 服务关闭<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/5ccf8ce979664cd9ac2103cc09e0058e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5aSc54yr56iL5bqP54y_,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""></p><h2 id="3、put："><a href="#3、put：" class="headerlink" title="3、put："></a>3、put：</h2><p>将内容写到内存，等到put_line时一起输出，new_line的时候也可以输出。</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">begin  dbms_output.put_line(&#39;hello world1111111&#39;);  dbms_output.new_line();  dbms_output.put(&#39;Hello, Lao An &#39;);  dbms_output.put(&#39;Hello, Lao An &#39;);  dbms_output.new_line();  dbms_output.put_line(&#39;Hello, Lao An &#39;);end;&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出：</p><p><img src="https://img-blog.csdnimg.cn/76f3c865dc57456f8a525932af924bac.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5aSc54yr56iL5bqP54y_,size_15,color_FFFFFF,t_70,g_se,x_16" alt=""></p><h2 id="4、put-line："><a href="#4、put-line：" class="headerlink" title="4、put_line："></a>4、put_line：</h2><p>不用多说了，输出字符，并刷新buffer，前提是set severoutput on；</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">exec dbms_output.put_line(&#39;hello world1111111&#39;);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/6afc315404ed49bb9f4a3358ece7ff8a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5aSc54yr56iL5bqP54y_,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""></p><h2 id="5、new-line："><a href="#5、new-line：" class="headerlink" title="5、new_line："></a>5、new_line：</h2><p>作为一行的结束，可以理解为写入buffer时的换行符</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">set serveroutput onbegin  dbms_output.put_line(&#39;hello world1111111&#39;);  dbms_output.put(&#39;Hello, Lao An&#39;);  dbms_output.new_line();  dbms_output.put_line(&#39;Hello, Lao An&#39;);end;&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/184650230b38414d9a9c55c14a29b417.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5aSc54yr56iL5bqP54y_,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""></p><p><strong>这里运用了begin+/来执行PL/SQL过程，我解释一下oracle中斜杠(/)</strong>的含义 斜杠就是让<strong>服务器执行前面所写的sql脚本</strong>。如果是普通的select语句，一个分号，就可以执行了。但是如果是存储过程，那么遇到分号，就不能马上执行了。这个时候，就需要通过斜杠(/)来执行。</p><p><img src="https://img-blog.csdnimg.cn/33849042ca5845109d969979e1147cb5.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5aSc54yr56iL5bqP54y_,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""></p><h2 id="6、get-line-value-index-："><a href="#6、get-line-value-index-：" class="headerlink" title="6、get_line(value, index)："></a>6、get_line(value, index)：</h2><p>获取缓冲区的单行信息。</p><p>注：使用get_line时不能用put_line输出，因为put_line之后会将buffer清空。(当然在<strong>serveroutput off的情况下put_line是不影响buffer的</strong>)。</p><h2 id="7、get-lines-array-index-："><a href="#7、get-lines-array-index-：" class="headerlink" title="7、get_lines(array, index)："></a>7、get_lines(array, index)：</h2><p>以数组形式来获取缓冲区的多行信息</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">declare   v_data dbms_output.chararr;   --先声明局部变量                          v_numlines number;                                   begin                                                  --enable the buffer first.                             dbms_output.enable(1000000);   --设置缓冲区的大小                                                                               dbms_output.put_line(&#39;line one&#39;);                       dbms_output.put_line(&#39;line two&#39;);                       dbms_output.put_line(&#39;line three&#39;);                                                                          v_numlines :&#x3D; 3;                                       dbms_output.get_lines(v_data, v_numlines);  --array, index           for v_counter in 1..v_numlines loop                        dbms_output.put_line(v_data(v_counter));               end loop;                                           end;                                                &#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 输出：</p><p><img src="https://img-blog.csdnimg.cn/91e4417305374c8199922a56fd95e2d6.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5aSc54yr56iL5bqP54y_,size_10,color_FFFFFF,t_70,g_se,x_16" alt=""></p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++_中数据类型大小（所占用字节数）</title>
      <link href="/2023/06/22/c-zhong-shu-ju-lei-xing-da-xiao-suo-zhan-yong-zi-jie-shu/"/>
      <url>/2023/06/22/c-zhong-shu-ju-lei-xing-da-xiao-suo-zhan-yong-zi-jie-shu/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#include&lt;iostream></span>using namespace std<span class="token punctuation">;</span><span class="token comment">#define str(type) #type</span><span class="token comment">#define sz(type) cout&lt;&lt; str(type) &lt;&lt; ":" &lt;&lt; sizeof(type) &lt;&lt; "B"&lt;&lt; endl; </span>int <span class="token function-name function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>sz<span class="token punctuation">(</span>char<span class="token punctuation">)</span><span class="token punctuation">;</span>sz<span class="token punctuation">(</span>unsigned char<span class="token punctuation">)</span><span class="token punctuation">;</span>sz<span class="token punctuation">(</span>short<span class="token punctuation">)</span><span class="token punctuation">;</span>sz<span class="token punctuation">(</span>unsigned short<span class="token punctuation">)</span><span class="token punctuation">;</span>sz<span class="token punctuation">(</span>int<span class="token punctuation">)</span><span class="token punctuation">;</span>sz<span class="token punctuation">(</span>unsigned int<span class="token punctuation">)</span><span class="token punctuation">;</span>sz<span class="token punctuation">(</span>long<span class="token punctuation">)</span><span class="token punctuation">;</span>sz<span class="token punctuation">(</span>unsigned long<span class="token punctuation">)</span><span class="token punctuation">;</span>sz<span class="token punctuation">(</span>int long<span class="token punctuation">)</span><span class="token punctuation">;</span>sz<span class="token punctuation">(</span>unsigned int long<span class="token punctuation">)</span><span class="token punctuation">;</span>sz<span class="token punctuation">(</span>long long<span class="token punctuation">)</span><span class="token punctuation">;</span>sz<span class="token punctuation">(</span>unsigned long long<span class="token punctuation">)</span><span class="token punctuation">;</span>sz<span class="token punctuation">(</span>float<span class="token punctuation">)</span><span class="token punctuation">;</span>sz<span class="token punctuation">(</span>double<span class="token punctuation">)</span><span class="token punctuation">;</span>sz<span class="token punctuation">(</span>long double<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token builtin class-name">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="define字符串化运算符"><a href="#define字符串化运算符" class="headerlink" title="define字符串化运算符"></a>define字符串化运算符</h1><p>在这里第四行，用到了define 的一元运算符 #，它常称为字符串化运算符（stringify operator 或 stringizing operator），<strong>它会把宏调用时的实参转换为字符串</strong>。# 的操作数必须是宏替换文本中的形参。当形参名称出现在替换文本中，并且具有前缀 # 字符时，预处理器会把与该形参对应的实参放到一对双引号中，形成一个字符串字面量。</p><p><strong>比如在这里，sz(char)，#会把char转化成”char”，赋值给str(type)，然后输出。</strong></p><h1 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h1><p><img src="https://img-blog.csdnimg.cn/6c36ca9663924a3e9d801828e632ee64.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5aSc54yr56iL5bqP54y_,size_8,color_FFFFFF,t_70,g_se,x_16" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> c++基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++_中explicit的作用及用法（虽然简单，但是还是有用的）</title>
      <link href="/2023/06/22/c-zhong-explicit-de-zuo-yong-ji-yong-fa-sui-ran-jian-dan-dan-shi-huan-shi-you-yong-de/"/>
      <url>/2023/06/22/c-zhong-explicit-de-zuo-yong-ji-yong-fa-sui-ran-jian-dan-dan-shi-huan-shi-you-yong-de/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p><strong>目录</strong></p><p><a href="#%C2%A0C%2B%2Bexplicit%EF%BC%88%E5%AE%98%E7%BD%91%E7%9A%84%E8%AF%B4%E6%B3%95%EF%BC%89"> C++explicit（官网的说法）</a></p><p><a href="#firstHeading">explicit specifier</a></p><p><a href="#C%2B%2Bexplicit%20%E6%B8%85%E6%A5%9A%E7%9A%84%E8%AF%B4%E6%B3%95%EF%BC%88%E5%BB%BA%E8%AE%AE%E8%8B%B1%E6%96%87%E4%B8%8D%E5%A5%BD%E7%9A%84%E4%BB%8E%E8%BF%99%E9%87%8C%E5%BC%80%E5%A7%8B%E9%A3%9F%E7%94%A8%E5%93%A6%EF%BC%89">C++explicit 清楚的说法（建议英文不好的从这里开始食用哦）</a></p><p><a href="#explicit%E4%BD%9C%E7%94%A8%3A">explicit作用:</a></p><p><a href="#explicit%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%3A">explicit使用注意事项:</a></p><p><a href="#C%2B%2Bexplicit%E4%BD%BF%E7%94%A8%E7%9A%84%E4%BE%8B%E5%AD%90%EF%BC%88%E5%BB%BA%E8%AE%AE%E5%96%9C%E6%AC%A2%E8%87%AA%E5%B7%B1%E6%95%B2%E4%BB%A3%E7%A0%81%E5%AE%9E%E9%AA%8C%E7%9A%84%E4%BB%8E%E8%BF%99%E9%87%8C%E5%BC%80%E5%A7%8B%E9%A3%9F%E7%94%A8%E5%93%A6%EF%BC%89">C++explicit使用的例子（建议喜欢自己敲代码实验的从这里开始食用哦）</a></p><p><a href="#%E4%BE%8B%E5%AD%90">例子</a></p><p><a href="#%C2%A0%E4%B8%8A%E9%9D%A2%E4%B8%89%E8%A1%8C%E7%9A%84%E6%8A%A5%E9%94%99%E4%BF%A1%E6%81%AF%EF%BC%9A"> 上面三行的报错信息：</a></p><p><a href="#%E6%80%BB%E7%BB%93">总结</a></p><h1 id="C-explicit（官网的说法）"><a href="#C-explicit（官网的说法）" class="headerlink" title="C++explicit（官网的说法）"></a>C++explicit（官网的说法）</h1><h1 id="explicit-specifier"><a href="#explicit-specifier" class="headerlink" title="explicit specifier"></a><code>explicit</code> specifier</h1><p><code>**explicit**</code>(1)<code>**explicit (**</code> expression <code>**)**</code>(2)(since C++20)<br>expression-<a href="https://en.cppreference.com/w/cpp/language/constant_expression#Converted_constant_expression">contextually converted constant expression of type bool</a></p><p>1) Specifies that a constructor or conversion function (since C++11) or <a href="https://en.cppreference.com/w/cpp/language/ctad">deduction guide</a> (since C++17) is explicit, that is, it cannot be used for <a href="https://en.cppreference.com/w/cpp/language/implicit_cast">implicit conversions</a> and <a href="https://en.cppreference.com/w/cpp/language/copy_initialization">copy-initialization</a>.</p><p>翻译：指定构造函数或转换函数 (C++11 起) 或推导指南 (C++17 起) 是显式的，也就是说，它不能用于隐式转换和复制初始化。</p><p>2) The explicit specifier may be used with a constant expression. The function is explicit if and only if that constant expression evaluates to true. (since C++20)</p><p>翻译：显式说明符可以与常量表达式一起使用。当且仅当该常量表达式的计算结果为真时，该函数才是显式的。 </p><p>The explicit specifier may only appear within the decl-specifier-seq of the declaration of a constructor or conversion function (since C++11) within its class definition.</p><p>翻译：显式说明符只能出现在其类定义中的构造函数或转换函数（C++11 起）声明的 decl-specifier-seq 中。</p><h1 id="C-explicit-清楚的说法（建议英文不好的从这里开始食用哦）"><a href="#C-explicit-清楚的说法（建议英文不好的从这里开始食用哦）" class="headerlink" title="C++explicit 清楚的说法（建议英文不好的从这里开始食用哦）"></a>C++explicit 清楚的说法（建议英文不好的从这里开始食用哦）</h1><h2 id="explicit作用"><a href="#explicit作用" class="headerlink" title="explicit作用:"></a><strong>explicit作用:</strong></h2><p>在C++中，explicit关键字用来<strong>修饰类的构造函数</strong>，被修饰的构造函数的类，不能发生相应的隐式类型转换，只能以显式的方式进行类型转换。</p><h2 id="explicit使用注意事项"><a href="#explicit使用注意事项" class="headerlink" title="explicit使用注意事项:"></a>explicit使用注意事项:</h2><pre><code>  （1）explicit 关键字只能用于类内部的构造函数声明上。  （2） explicit 关键字作用于单个参数的构造函数。* 在C++中，explicit关键字用来修饰类的构造函数，被修饰的构造函数的类，不能发生相应的隐式类型转换</code></pre><h1 id="C-explicit使用的例子（建议喜欢自己敲代码实验的从这里开始食用哦）"><a href="#C-explicit使用的例子（建议喜欢自己敲代码实验的从这里开始食用哦）" class="headerlink" title="C++explicit使用的例子（建议喜欢自己敲代码实验的从这里开始食用哦）"></a>C++explicit使用的例子（建议喜欢自己敲代码实验的从这里开始食用哦）</h1><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;class Circle&#123;    public:        Circle()&#123;&#125;        Circle(double _a):a(_a)&#123;&#125;        Circle(int _b, int _c):b(_b), c(_c)&#123;&#125;        Circle(const Circle&amp; A)        &#123;            a&#x3D;A.a; b&#x3D;A.b; c&#x3D;A.c;        &#125;        void Print()        &#123;            cout&lt;&lt;a&lt;&lt;&quot; &quot;&lt;&lt;b&lt;&lt;&quot; &quot;&lt;&lt;c&lt;&lt;endl;        &#125;    private:        double a;        int b;        int c;&#125;;class Circle1&#123;    public:        Circle1()&#123;&#125;        explicit Circle1(double _a):a(_a)&#123;&#125;        explicit Circle1(int _b, int _c):b(_b), c(_c)&#123;&#125;        explicit Circle1(const Circle1&amp; A)        &#123;            a&#x3D;A.a; b&#x3D;A.b; c&#x3D;A.c;        &#125;        void Print()        &#123;            cout&lt;&lt;a&lt;&lt;&quot; &quot;&lt;&lt;b&lt;&lt;&quot; &quot;&lt;&lt;c&lt;&lt;endl;        &#125;    private:        double a;        int b;        int c;&#125;;int main()&#123;    Circle q1(1);    Circle w1(2, 3);    q1.Print();    w1.Print();    &#x2F;&#x2F;隐式调用, 不会报错    Circle q2 &#x3D; 1;&#x2F;&#x2F; just like Circle q(1); 调用的是Circle(double _a)    Circle w2 &#x3D; 1.0;&#x2F;&#x2F; just like Circle q(1.0); 调用的是Circle(double _a)    Circle e &#x3D; q2;&#x2F;&#x2F; 调用的是Circle(const Circle&amp; A)            &#x2F;&#x2F;隐式调用，会报错，注意Circle1()的构造函数，都有explicit    &#x2F;&#x2F; Circle1 q3 &#x3D; 1;    &#x2F;&#x2F; Circle1 w3 &#x3D; 1.0;    &#x2F;&#x2F; Circle1 e1 &#x3D; q3;    &#x2F;&#x2F; 以上三行都会报错。    &#x2F;&#x2F;显式调用，都不会有问题    Circle1 q3(1);    Circle1 w3(1.0);    Circle1 e1(q3);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="上面三行的报错信息："><a href="#上面三行的报错信息：" class="headerlink" title="上面三行的报错信息："></a>上面三行的报错信息：</h2><p><img src="https://img-blog.csdnimg.cn/597541d462a9453d918bbb4657e54c68.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5aSc54yr56iL5bqP54y_,size_16,color_FFFFFF,t_70,g_se,x_16" alt=""></p><p><img src="https://img-blog.csdnimg.cn/ea541e17239346b9abf52c487615d072.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5aSc54yr56iL5bqP54y_,size_17,color_FFFFFF,t_70,g_se,x_16" alt=""></p><p><img src="https://img-blog.csdnimg.cn/583c79b46bd24c49953bb1a84ba525b1.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5aSc54yr56iL5bqP54y_,size_14,color_FFFFFF,t_70,g_se,x_16" alt=""></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>explicit可以<strong>抑制</strong>内置类型隐式转换，所以在类的构造函数中，<strong>最好尽可能多用explicit关键字，</strong>防止不必要的隐式转换。</p>]]></content>
      
      
      <categories>
          
          <category> c++基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++_std::array用法</title>
      <link href="/2023/06/22/c-stdarray-yong-fa/"/>
      <url>/2023/06/22/c-stdarray-yong-fa/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="Array简介"><a href="#Array简介" class="headerlink" title="Array简介"></a>Array简介</h1><p><code>std::array</code> is a container that encapsulates fixed size arrays.</p><p>Defined in header <code>[&lt;array&gt;](https://en.cppreference.com/w/cpp/header/array)</code> template&lt;<br>    class T,     <a href="http://en.cppreference.com/w/cpp/types/size_t">std::size_t</a> N &gt; struct array;(since C++11)</p><p>它是c++里面的一个容器，在使用上与普通数组相似，但是它的大小是固定的，无法像vector一样动态扩展，安全性上面也比普通数组更加安全 。</p><h1 id="初始化方式"><a href="#初始化方式" class="headerlink" title="初始化方式"></a>初始化方式</h1><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">array&lt;int, 10&gt; arr&#x3D;&#123;1, 2, 3, 4, 5&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在这里，只初始化了数组的前五个值，后面的五个值都是0。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;array&gt;using namespace std;int main() &#123;    array&lt;int, 10&gt; a &#x3D; &#123; 1, 2 ,3, 4, 5 &#125;;    for (int i &#x3D; 0; i &lt; 10; i++)    &#123;        cout &lt;&lt; a.at(i) &lt;&lt; &quot; &quot;;    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出： </p><p><img src="https://img-blog.csdnimg.cn/b69f3e004722493e84bcb6d0812ce8bf.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5aSc54yr56iL5bqP54y_,size_13,color_FFFFFF,t_70,g_se,x_16" alt=""></p><h1 id="array容器成员函数汇总"><a href="#array容器成员函数汇总" class="headerlink" title="array容器成员函数汇总"></a>array容器成员函数汇总</h1><p><strong>成员函数功能</strong></p><ol><li>begin()返回指向容器中第一个元素的随机访问迭代器。</li><li>end()返回指向容器最后一个元素之后一个位置的随机访问迭代器，通常和 begin() 结合使用。</li><li>rbegin()返回指向最后一个元素的随机访问迭代器。</li><li>rend()返回指向第一个元素之前一个位置的随机访问迭代器。</li><li>cbegin()和 begin() 功能相同，只不过在其基础上增加了 const 属性，不能用于修改元素。</li><li>cend()和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。crbegin()和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</li><li>crend()和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</li><li>size()返回容器中当前元素的数量，其值始终等于初始化 array 类的第二个模板参数 N。</li><li>max_size()返回容器可容纳元素的最大数量，其值始终等于初始化 array 类的第二个模板参数 N。</li><li>empty()判断容器是否为空，和通过 size()==0 的判断条件功能相同，但其效率可能更快。</li><li>at(n)返回容器中 n 位置处元素的引用，该函数自动检查 n 是否在有效的范围内，如果不是则抛出 out_of_range 异常。</li><li>front()返回容器中第一个元素的直接引用，该函数不适用于空的 array 容器。</li><li>back()返回容器中最后一个元素的直接应用，该函数同样不适用于空的 array 容器。</li><li>data()返回一个指向容器首个元素的指针。利用该指针，可实现复制容器中所有元素等类似功能。</li><li>fill(val)将 val 这个值赋值给容器中的每个元素。</li><li>array1.swap(array2)交换 array1 和 array2 容器中的所有元素，但前提是它们具有相同的长度和类型。</li></ol>]]></content>
      
      
      <categories>
          
          <category> c++基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++_allocator类</title>
      <link href="/2023/06/22/c-callocator-lei/"/>
      <url>/2023/06/22/c-callocator-lei/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p><strong>目录</strong></p><p><a href="#firstHeading">std::allocator::allocate</a></p><p><a href="#c%2B%2B%E4%B8%AD%E7%9A%84allocator%E7%B1%BB">c++中的allocator类</a></p><p><a href="#%E6%A6%82%E8%BF%B0">概述</a></p><p><a href="#allocator%E7%94%A8%E6%B3%95">allocator用法</a></p><p><a href="#%E8%AF%A6%E8%A7%A3">详解</a></p><p><a href="#allocate%E7%94%A8%E4%BA%8E%E5%88%86%E9%85%8D%E5%8E%9F%E5%A7%8B%E5%86%85%E5%AD%98">allocate用于分配原始内存</a></p><p><a href="#Return%20value">Return value</a></p><p><a href="#%E5%9C%A8STL%E4%B8%AD%E4%B9%9F%E4%BC%9A%E7%94%A8allocate%E7%B1%BB">在STL中也会用allocate类</a></p><h1 id="std-allocator-allocate"><a href="#std-allocator-allocate" class="headerlink" title="std::allocator::allocate"></a>std::allocator<T>::allocate</h1><p>(1)<br>pointer allocate( size_type n, const void <em> hint = 0 ); (until C++17)<br>T</em> allocate( <a href="http://en.cppreference.com/w/cpp/types/size_t">std::size_t</a> n, const void <em> hint); (since C++17) (deprecated) (removed in C++20)(2)<br>T</em> allocate( <a href="http://en.cppreference.com/w/cpp/types/size_t">std::size_t</a> n ); (since C++17) (until C++20)<br>[[nodiscard]] constexpr T* allocate( <a href="http://en.cppreference.com/w/cpp/types/size_t">std::size_t</a> n ); (since C++20)</p><h1 id="c-中的allocator类"><a href="#c-中的allocator类" class="headerlink" title="c++中的allocator类"></a>c++中的allocator类</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li>它用于将内存的分配和对象的构造分离开来. 它分配的<strong>内存是原始的、未构造的.</strong>+ Throws <a href="https://en.cppreference.com/w/cpp/memory/new/bad_alloc">std::bad_alloc</a> if allocation fails.+ 标准库中allocator类定义在头文件memory中</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">allocator&lt;string&gt; alloc;  &#x2F;&#x2F; 定义了一个可以分配string的allocator对象auto const p &#x3D; alloc.allocate(n);  &#x2F;&#x2F; 分配n个未初始化的string内存，即为n个空string分配了内存，分配的内存是原始的、未构造的<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h1 id="allocator用法"><a href="#allocator用法" class="headerlink" title="allocator用法"></a>allocator用法</h1><ul><li>allocator a // 定义了一个名为a的allocator对象，它可以为类型T的对象分配内存+ a.allocate(n) // 分配能保存<strong>n个类型为T的对象的内存</strong>+ a.deallocate(p, n) // <strong>释放T*指针p地址开始的内存</strong>，这块内存保存了n个类型为T的对象，p必须是一个先前由allocate返回的指针，且n必须是p创建时所要求的大小，且<strong>在调用该函数之前必须销毁在这片内存上创建的对象</strong>，这是因为在创建的过程中我们分配的是最原始的内存，所以在释放内存的时候也只能严格释放<strong>这片最原始的内存</strong>+ a.construct(p, args) // p必须是一个类型为T<em>的指针，指向一片原始内存，arg将被传递给类型为T的构造函数，用来在p指向的原始内存上构建对象+ a.destory(p) // p为T</em>类型的指针，用于对p指向的对象执行析构函数</li></ul><h1 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h1><ul><li><h2 id="allocate用于分配原始内存"><a href="#allocate用于分配原始内存" class="headerlink" title="allocate用于分配原始内存"></a>allocate用于<strong>分配原始内存</strong></h2></li></ul><ul><li>正如前面说到，allocate出来的内存是最原始的，未构造的内存. 它的construct成员函数接受一个指针和零个或多个额外的参数，在<strong>给定位置构造对象</strong>， 额外的参数是用于初始化构造对象的</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">auto q &#x3D; p;  &#x2F;&#x2F; q指向最后构造的元素之后的位置alloc.construct(q++);  &#x2F;&#x2F; *q为空字符串alloc.construct(q++, 10, &#39;c&#39;);  &#x2F;&#x2F; *q为ccccccccccalloc.construct(q++, &quot;hi&quot;);  &#x2F;&#x2F; *q为hi<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>用完对象后，<strong>必须对这种构造的对象调用destory销毁</strong>，它接受一个指针，对指向的对象执行析构函数</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">while(q !&#x3D; p)alloc.destory(--q);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p> 循环开始处，q是指向最后构造的元素之后的一个位置，调用destory之前我们先对q进行递减操作，所以第一次调用destory销毁的是最后一个元素，依次执行销毁操作直到q和p相等. 我们只能对真正构造了的元素进行destory操作，一旦元素被销毁，就可以重新使用这部分内存来保存其他string或归还给系统，释放内存通过调用deallocate完成<br><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">alloc.deallocate(p, n)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br> 其中p不能为空，必须指向allocate分配的内存，而且大小参数n也必须与调用allocate分配内存时提供的大小参数相等。 +  ### Return value<br> Pointer to the first element of an array of <code>n</code> objects of type <code>T</code> whose elements have not been constructed yet.  就是返回未构造的第一个元素 </p><h1 id="在STL中也会用allocate类"><a href="#在STL中也会用allocate类" class="headerlink" title="在STL中也会用allocate类"></a>在STL中也会用allocate类</h1><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;memory></span></span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span> <span class="token keyword">class</span> <span class="token class-name">Vector</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Vector</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">elements</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">first_free</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    <span class="token keyword">void</span> <span class="token function">push_back</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">static</span> std<span class="token double-colon punctuation">::</span>allocator<span class="token operator">&lt;</span>T<span class="token operator">></span> alloc<span class="token punctuation">;</span> <span class="token comment">// object to get raw memory</span>    <span class="token keyword">void</span> <span class="token function">reallocate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// get more space and copy existing elements</span>    T<span class="token operator">*</span> elements<span class="token punctuation">;</span>        <span class="token comment">// pointer to first elment in the array</span>    T<span class="token operator">*</span> first_free<span class="token punctuation">;</span>      <span class="token comment">// pointer to first free element in the array</span>    T<span class="token operator">*</span> end<span class="token punctuation">;</span>             <span class="token comment">// pointer to one past the end of the array</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span> std<span class="token double-colon punctuation">::</span>allocator<span class="token operator">&lt;</span>T<span class="token operator">></span> Vector<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token double-colon punctuation">::</span>alloc<span class="token punctuation">;</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">void</span> <span class="token class-name">Vector</span><span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token double-colon punctuation">::</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> t<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>first_free <span class="token operator">==</span> end<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">reallocate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    alloc<span class="token punctuation">.</span><span class="token function">construct</span><span class="token punctuation">(</span>first_free<span class="token punctuation">,</span> t<span class="token punctuation">)</span><span class="token punctuation">;</span>    first_free<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">void</span> <span class="token class-name">Vector</span><span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token double-colon punctuation">::</span><span class="token function">reallocate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// compute size of current array and allocate space for twice as many elements</span>    std<span class="token double-colon punctuation">::</span>ptrdiff_t size <span class="token operator">=</span> first_free <span class="token operator">-</span> elements<span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>ptrdiff_t newcapacity <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> <span class="token punctuation">(</span>size <span class="token operator">></span> <span class="token number">1</span> <span class="token operator">?</span> size <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//容量翻倍</span>    T<span class="token operator">*</span> newelements <span class="token operator">=</span> alloc<span class="token punctuation">.</span><span class="token function">allocate</span><span class="token punctuation">(</span>newcapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span><span class="token function">uninitialized_copy</span><span class="token punctuation">(</span>elements<span class="token punctuation">,</span> first_free<span class="token punctuation">,</span> newelements<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//元素拷贝</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>T<span class="token operator">*</span> p <span class="token operator">=</span> first_free<span class="token punctuation">;</span> p <span class="token operator">!=</span> elements<span class="token punctuation">;</span> alloc<span class="token punctuation">.</span><span class="token function">destroy</span><span class="token punctuation">(</span><span class="token operator">--</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//原来的空间的释放</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>elements<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        alloc<span class="token punctuation">.</span><span class="token function">deallocate</span><span class="token punctuation">(</span>elements<span class="token punctuation">,</span> end <span class="token operator">-</span> elements<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    elements <span class="token operator">=</span> newelements<span class="token punctuation">;</span>    first_free <span class="token operator">=</span> elements <span class="token operator">+</span> size<span class="token punctuation">;</span>    end <span class="token operator">=</span> elements <span class="token operator">+</span> newcapacity<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> c++基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络</title>
      <link href="/2023/06/20/ji-suan-ji-wang-luo/"/>
      <url>/2023/06/20/ji-suan-ji-wang-luo/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="第一章：计算机网络体系结构"><a href="#第一章：计算机网络体系结构" class="headerlink" title="第一章：计算机网络体系结构"></a>第一章：计算机网络体系结构</h1><h2 id="常用的协议："><a href="#常用的协议：" class="headerlink" title="常用的协议："></a>常用的协议：</h2><p><img src="https://img-blog.csdnimg.cn/fb9c783cc0c442e2a3d497680c8f4795.png" alt=""></p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><img src="https://img-blog.csdnimg.cn/253fedbd8c504b41933283d8ff6e3119.png" alt=""></p><p>计算机网络是一个互联、自治的计算机集合</p><p>计算机网络的功能：数据共享</p><p><img src="https://img-blog.csdnimg.cn/e5be72d0e6a44376ab3ec718f5b1b478.png" alt=""></p><p><img src="https://img-blog.csdnimg.cn/ce799324e4064e62a435468654ec0d7e.png" alt=""></p><p><img src="https://img-blog.csdnimg.cn/0517ad2799a94e42b39006294adc9f82.png" alt=""></p><p>kb KB</p><p><img src="https://img-blog.csdnimg.cn/c57ccbd895fe4072b13f17b2ae7241be.png" alt=""></p><p>最高频率与最低频率之差</p><p>吞吐量：单位时间内通过某个网络（通道或接口）的数据量</p><p><img src="https://img-blog.csdnimg.cn/e443f06f7f0c4875aba56b6c59df1c46.png" alt=""></p><p>发送时延是：发生在主机上，发送到信道上所需要的时间。</p><p>传播时延：从一个主机传播到另外一个主机的时间，单位m/s</p><p>排队时延和处理时延：可以想象成机场安检的过程，发生在路由器上。</p><p><img src="https://img-blog.csdnimg.cn/4af9b8c56c3e4fb787fdbee25d11be34.png" alt=""></p><p><img src="https://img-blog.csdnimg.cn/90b7e18f73ac4d759c47e70bc682e1b1.png" alt=""></p><p>协议：对等实体之间数据交换的规则</p><p>接口：上层使用下层服务的入口（把酒装箱的服务）</p><p><img src="https://img-blog.csdnimg.cn/2a36454f6b6644ebbd6a6fce5061c316.png" alt=""></p><p>OSI 7层参考模型 </p><p><img src="https://img-blog.csdnimg.cn/f8415f92949c449d92ed1a9bb49c4a5c.png" alt=""></p><p><strong>物数网传会表应</strong></p><p><img src="https://img-blog.csdnimg.cn/78a0a734d960457abedfcd34697979e9.png" alt=""></p><p>TCP/IP参考模型：网网传应</p><p><img src="https://img-blog.csdnimg.cn/8c2b7f35e9474184b7cf08c6b42ac46b.png" alt=""></p><h2 id="常见面试题-1：-TCP-建立连接为什么要三次握手而不是两次？"><a href="#常见面试题-1：-TCP-建立连接为什么要三次握手而不是两次？" class="headerlink" title="常见面试题 1： TCP 建立连接为什么要三次握手而不是两次？"></a>常见面试题 1： TCP 建立连接为什么要三次握手而不是两次？</h2><p>答：网上大多数资料对这个问题的回答只有简单的一句：防止已过期的连接请求报文突然又传送到服务器，因而产生错误，这既不够全面也不够具体。下面给出比较详细而全面的回答：</p><ul><li>防止已过期的连接请求报文突然又传送到服务器，因而产生错误</li></ul><p>在双方两次握手即可建立连接的情况下，假设客户端发送 A 报文段请求建立连接，由于网络原因造成 A 暂时无法到达服务器，服务器接收不到请求报文段就不会返回确认报文段，客户端在长时间得不到应答的情况下重新发送请求报文段 B，这次 B 顺利到达服务器，服务器随即返回确认报文并进入 ESTABLISHED 状态，客户端在收到 确认报文后也进入 ESTABLISHED 状态，双方建立连接并传输数据，之后正常断开连接。此时姗姗来迟的 A 报文段才到达服务器，服务器随即返回确认报文并进入 ESTABLISHED 状态，但是已经进入 CLOSED 状态的客户端无法再接受确认报文段，更无法进入 ESTABLISHED 状态，这将导致服务器长时间单方面等待，造成资源浪费。</p><ul><li>三次握手才能让双方均确认自己和对方的发送和接收能力都正常</li></ul><p>第一次握手：客户端只是发送处请求报文段，什么都无法确认，而服务器可以确认自己的接收能力和对方的发送能力正常；</p><p>第二次握手：客户端可以确认自己发送能力和接收能力正常，对方发送能力和接收能力正常；</p><p>第三次握手：服务器可以确认自己发送能力和接收能力正常，对方发送能力和接收能力正常；</p><p>可见三次握手才能让双方都确认自己和对方的发送和接收能力全部正常，这样就可以愉快地进行通信了。</p><p><img src="https://img-blog.csdnimg.cn/9629dc61c1604c4093b56a9a17d982c1.png" alt=""></p><h2 id="五层参考模型"><a href="#五层参考模型" class="headerlink" title="五层参考模型"></a>五层参考模型</h2><p><img src="https://img-blog.csdnimg.cn/10a15ff26ebc4156a8de2c884ea9e85f.png" alt=""></p><h2 id="典型的数据通信模型"><a href="#典型的数据通信模型" class="headerlink" title="典型的数据通信模型"></a>典型的数据通信模型</h2><p>数据通信：从信源输入信息，转为数字信号，通过调制调解器将数字信号转为模拟信号，广域网，左右对称。</p><p><img src="https://img-blog.csdnimg.cn/94b8f8920b5b448ab9761eddf6de6811.png" alt=""></p><h2 id="数据通信相关术语"><a href="#数据通信相关术语" class="headerlink" title="数据通信相关术语"></a>数据通信相关术语</h2><p><img src="https://img-blog.csdnimg.cn/1085a3911e344b69bfba8ded8de4c670.png" alt=""></p><h2 id="三种通信方式"><a href="#三种通信方式" class="headerlink" title="三种通信方式"></a>三种通信方式</h2><p><img src="https://img-blog.csdnimg.cn/5ef2c94d86a1485991f9f5d3df1df365.png" alt=""></p><h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><p><strong>多个分组转发的时延的计算：</strong></p><p><img src="https://s2.loli.net/2023/07/20/oeRh5ZOwYqJLIUf.png" alt=""></p><h1 id="第二章：物理层"><a href="#第二章：物理层" class="headerlink" title="第二章：物理层"></a>第二章：物理层</h1><h2 id="奈氏准则与香奈定理"><a href="#奈氏准则与香奈定理" class="headerlink" title="奈氏准则与香奈定理"></a>奈氏准则与香奈定理</h2><p>码间串扰：信号频率过快，导致码元间界限不明显，无法区分信号，奈氏准则可以解决。</p><p><img src="https://img-blog.csdnimg.cn/3d38ada810694509851b026148777b76.png" alt=""></p><p><img src="https://img-blog.csdnimg.cn/2c657f88b5074394b682101c9828493e.png" alt=""></p><p><img src="https://img-blog.csdnimg.cn/2c2ff203e655476187b80311b39fdddd.png" alt=""></p><p>例题：</p><p><img src="https://img-blog.csdnimg.cn/dc0dba84ce1e41ec919db0a615fb276a.png" alt=""></p><p>如何选择“Nice”和“香浓”</p><p><img src="https://img-blog.csdnimg.cn/486e1151b2b8404e8d212220144f15dc.png" alt=""></p><h2 id="基带信号和宽带信号"><a href="#基带信号和宽带信号" class="headerlink" title="基带信号和宽带信号"></a>基带信号和宽带信号</h2><p><img src="https://img-blog.csdnimg.cn/88cdda2b18ae43d09e0e8465c34f0c38.png" alt=""></p><p>距离近使用基带信号（发出去了就直接表达出来，比如声波），距离远使用宽带信号（衰减到了很低的频率，通过调制到高的信号）</p><h2 id="编码与调制"><a href="#编码与调制" class="headerlink" title="编码与调制"></a>编码与调制</h2><p><img src="https://img-blog.csdnimg.cn/73360047c8ed4e7e8b99cd388e581edd.png" alt=""></p><h3 id="一-数字数据编码为数字信号"><a href="#一-数字数据编码为数字信号" class="headerlink" title="一.数字数据编码为数字信号"></a>一.数字数据编码为数字信号</h3><p>1.非归零编码【NRZ】</p><p>高1低0，最普通的编码方式</p><p>编码容易实现，但没有检错功能，且无法判断一个码元的开始和结束，以至于双方难以保持同步</p><p>2.曼彻斯特编码：</p><p>将一个码元分成两个相等的间隔，前一个间隔为低电平后一个间隔为高电平表示码元1；码元0则正好相反。也可以采用相反的规定。该编码的特点是在每一个码元的中间出现电平跳动，位中间的跳变即作时钟信号（可用于同步），又坐数据信号，但它所占的频带宽度是原始数据的基带宽度的两倍。</p><p>每一个码元都被调成两个电平，所以数据传输速率只有调制速率的1/2。</p><p>3.差分曼彻斯特编码</p><p>同1异0</p><p>常用于局域网传输，其规则是：若码元为1，则前半个码元的电平与上一个码元的后半个码元的电平相同，若为0，则相反。该编码的特点是，在每个码元的中间，都有一次电平的跳转，可以实现自同步，且抗干扰性强于曼彻斯特编码。</p><p>4.归零编码【RZ】</p><p>信号电平在一个码元之内都要恢复到零的这种编码成编码方式。</p><p>（不推荐使用）因为处于低电频比较多比较久。</p><p>5.反向不归零编码【NRZI】</p><p>信号电平翻转表示0，信号电平不变表示1. 与归零编码主要区别：一个码元内不会跳变。</p><p>综合以上的编码方式产生：</p><p>（6）4B/5B 编码</p><p>比特流中插入额外的比特以打破一连串的0或1，就是用5个比特来编码4个比特的数据，之后再传送给接收方，因此称为4B/5B。编码效率为80%。</p><p>只采用16种对应的64种不同的4为码，其他的16种作为控制码（帧的开始和结束，线路的状态信息等）或保留。</p><h3 id="二-数字数据调制为模拟信号"><a href="#二-数字数据调制为模拟信号" class="headerlink" title="二.数字数据调制为模拟信号"></a>二.数字数据调制为模拟信号</h3><p><img src="https://img-blog.csdnimg.cn/f38a4b777fc247939a1596288bd1736a.png" alt=""></p><p>数字数据调制技术在发送端将数字信号转换为模拟信号，而在接收端将模拟信号还原为数字信号，分别对应于调制解调器的调制和解调过程。</p><p>正交振幅调制QAM</p><p><img src="https://s2.loli.net/2023/07/21/8Bu6zCmfFexcts1.png" alt=""></p><h3 id="三-模拟数据编码为数字信号"><a href="#三-模拟数据编码为数字信号" class="headerlink" title="三.模拟数据编码为数字信号"></a>三.模拟数据编码为数字信号</h3><p><img src="https://img-blog.csdnimg.cn/a8461752f95549a58d9b9c0f53911614.png" alt=""></p><h3 id="四、编码与调制的综述："><a href="#四、编码与调制的综述：" class="headerlink" title="四、编码与调制的综述："></a>四、编码与调制的综述：</h3><p><img src="https://img-blog.csdnimg.cn/91020adbec94455197627c412481dda1.png" alt=""></p><h1 id="第三章：数据链路层"><a href="#第三章：数据链路层" class="headerlink" title="第三章：数据链路层"></a>第三章：数据链路层</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><img src="https://img-blog.csdnimg.cn/cd4e2f3397c448c0a7d85198b9e6a486.png" alt=""></p><p><img src="https://img-blog.csdnimg.cn/cc7b9077368f41978b60e0b14a7702a3.png" alt=""></p><p>数据链路层在传输数据的时候，添加首和尾，</p><p><img src="https://img-blog.csdnimg.cn/bd707318c33243c5a6db23483db7fe34.png" alt=""></p><p>称为数据链路层协议首部和尾部，简称帧头和帧尾。这个动作叫做封装成帧。</p><p><img src="https://img-blog.csdnimg.cn/ff2f7925bb6d442997320ef7ade2ec7e.png" alt=""></p><h2 id="帧定界："><a href="#帧定界：" class="headerlink" title="帧定界："></a>帧定界：</h2><p><img src="https://img-blog.csdnimg.cn/8f8d009b0ca444ac8fa20a94122a99c6.png" alt=""></p><p><img src="https://img-blog.csdnimg.cn/d5abeaea1d9d43888f1c5f0e61f17e7b.png" alt=""></p><p>如果传输数据里面正好包含了帧定界符，数据链路层会在不是帧定界符加上转义字符，防止出现误判，认为数据传输结束了。</p><h2 id="差错检测：奇偶校验（计组）"><a href="#差错检测：奇偶校验（计组）" class="headerlink" title="差错检测：奇偶校验（计组）"></a>差错检测：奇偶校验（计组）</h2><h3 id="奇偶校验"><a href="#奇偶校验" class="headerlink" title="奇偶校验"></a>奇偶校验</h3><p><img src="https://img-blog.csdnimg.cn/6ea616730ac444fb82dde9478fed1ee7.png" alt=""></p><h3 id="循环冗余校验CRC"><a href="#循环冗余校验CRC" class="headerlink" title="循环冗余校验CRC"></a>循环冗余校验CRC</h3><p><img src="https://img-blog.csdnimg.cn/35f5a4bd4a494d55ad4d251a102ce47b.png" alt=""></p><h2 id="可靠传输的基本概念"><a href="#可靠传输的基本概念" class="headerlink" title="可靠传输的基本概念"></a>可靠传输的基本概念</h2><p>首先直到有两种服务：不可靠服务（丢弃误码的帧）和可靠服务（不会丢弃）。</p><p><img src="https://img-blog.csdnimg.cn/38b202e85d6c497a91ded7ddeb8e83b1.png" alt=""></p><p>可靠传输的开销比较大，要根据需求选择。</p><h2 id="SW协议：Stop-and-Wait（停止等待协议）"><a href="#SW协议：Stop-and-Wait（停止等待协议）" class="headerlink" title="SW协议：Stop and Wait（停止等待协议）"></a>SW协议：Stop and Wait（停止等待协议）</h2><p>ACK是正确无误的收到发送方的全部数据之后接收方的回应，则NAK是出现误码的回应，丢弃该数据。</p><p>特殊情况：每次的数据传输，发送方都会启动一个超时计数器，如果DATA在传输过程中出现丢失，等待时间操过了重传时间，发送方就会重新发送，这就叫做超时重传。解决接收方收不到分组的情况：设置一个超时计数器，如果超过了最大的重传时间，发送方重传（超时重传），如下图所示：</p><p><img src="https://img-blog.csdnimg.cn/5ce2c9974adb400ab437215aa0c88dd8.png" alt=""></p><p>为了克服停止等待协议的信道利用率低的缺点，就产生了另外两种协议：后退N帧协议、选择重传协议</p><p><img src="https://img-blog.csdnimg.cn/7af198b8d611413fa2a3b20225bd03aa.png" alt=""></p><p>总结：各种可能出现的问题的描述与解决。</p><p><img src="https://img-blog.csdnimg.cn/9783f5fa0eb04a92ba3613b9acf195e0.png" alt=""></p><h2 id="回退N帧协议：GBN协议"><a href="#回退N帧协议：GBN协议" class="headerlink" title="回退N帧协议：GBN协议"></a>回退N帧协议：<a href="https://zhuanlan.zhihu.com/p/405573476">GBN协议</a></h2><p>如果发送方在收到ACK之前，可以连续发送多个DATA，则可以大大提高信道利用率，这是一种流水线式的传输。这个协议利用传输窗口，来限制发送方和连续发送分组个数。</p><p>采用的是累计确认的方式:接收方不一定要对收到的数据分组逐个发送确认，而是可以在收到几个数据分组后，对按序到达的最后一个数据分组发送确认，ACKn表示序号为n及以前的所有数据分组都已经正确接收。</p><p>在有差错的情况下：接收方利用检错码发现这个数据分组中有数据出错了，就丢弃这个数据，这样就会让接下来接受的数据序号与接受窗口的序号不匹配，这样就要把这一组的其他数据也丢弃（回退N帧的由来），全部重新发送。重新发送可以等超时计数器超时也可以根据回传的重复信号ACKn。</p><p><img src="https://img-blog.csdnimg.cn/b7ecdea1a6fb4756b412ad01e3973641.png" alt=""></p><p>总结：累计确认。接收方发送ACKN代表前面N（包括N）个帧都收到了，但是如果中间出现了丢失，重传了，就会把发送窗口内的都丢弃重传。</p><p><img src="https://img-blog.csdnimg.cn/065ca957ad294aeda36d771eafaa0c27.png" alt=""></p><h2 id="选择重传协议：SR协议"><a href="#选择重传协议：SR协议" class="headerlink" title="选择重传协议：SR协议"></a>选择重传协议：<a href="https://zhuanlan.zhihu.com/p/405575394">SR协议</a></h2><p>回退N帧协议的接受窗口尺寸只能等于1，因此接收方只能按序接受正确到达的DATA。</p><p>为了进一步提升性能，可设法只重传出现误码的数据分组，因此，接收窗口的尺寸不应该再等于1，而应该大于1，以便接收方收下失序到达但无误码并且序号落在接收窗口内的DATA，等到所缺分组收齐后再一起送交上层，这就是选择重传协议（Selective Request）。</p><p>注意：由于只重传出现误码的数据分组，接收方不能采用累计确认，要采用逐一确认。</p><p>发送窗口尺寸必须满足： <img src="https://img-blog.csdnimg.cn/02e7bc17425844518916d7a2d863bb00.png" alt=""></p><p>其中n是构成分组序号的比特数量<img src="https://img-blog.csdnimg.cn/b46103aef36648c7ba2fdc7a7f592ae8.png" alt=""></p><ul><li>如果  ：就是停止-等待协议</li><li>如果  ：造成接收方无法分辨新旧DATA的问题</li></ul><p>接收窗口的尺寸必须满足： <img src="https://img-blog.csdnimg.cn/244acbd55cee453e9e7b9c2f33be9843.png" alt=""></p><ul><li><p>如果<img src="https://img-blog.csdnimg.cn/76892842442a4a9eb4aa4100205b9611.png" alt="">：与回退N帧协议相同</p></li><li><p>如果<img src="https://img-blog.csdnimg.cn/c292ece4bb8a4ddd9c3201bab2252eab.png" alt=""> ：无意义</p></li></ul><h2 id="点对点协议（Point-to-Point-Protocol）"><a href="#点对点协议（Point-to-Point-Protocol）" class="headerlink" title="点对点协议（Point-to-Point Protocol）"></a><a href="https://www.cnblogs.com/fudashi/p/6814652.html">点对点协议（Point-to-Point Protocol）</a></h2><p>工作在数据链路层，</p><p>PPP协议的组成</p><p><img src="https://img-blog.csdnimg.cn/2046a88462854af69800f667788bc4d5.png" alt=""></p><ul><li>建立、配置数据链路连接的LCP（Link Control Protocol）+ 网络控制协议NCP（Network Control Protocol）+ 将IP数据报封装到串行链路的方法</li></ul><p>跟其他协议一样，也要解决数据链路层的三个基本问题：封装成帧，透明传输，差错检测。</p><h2 id="媒体接入控制"><a href="#媒体接入控制" class="headerlink" title="媒体接入控制"></a>媒体接入控制</h2><p><img src="https://img-blog.csdnimg.cn/d32143d24fb34a1f985be0df6410a948.png" alt=""></p><h2 id="介质访问控制"><a href="#介质访问控制" class="headerlink" title="介质访问控制"></a>介质访问控制</h2><p>　　介质访问控制就是采取一定的措施，使得两对节点之间的通信不会发生互相干扰的情况。</p><p>　　介质访问控制（就是媒体接入控制）可以分为静态划分信道和动态分配信道。</p><p>　　（1）静态划分信道：也叫信道划分介质访问控制，有四种控制的方法，1、频分多路复用FDM；2、时分多路复用TDM；3、波分多路复用WDM；4、码分多路复用CDM。</p><p>　　（2）动态分配信道，可以分为轮询访问控制  令牌传递协议；随机访问介质访问控制 ALOHA协议、CSMA协议、CSMA/CD协议、CSMA/CA协议。</p><h3 id="1、频分多路复用FDM"><a href="#1、频分多路复用FDM" class="headerlink" title="1、频分多路复用FDM"></a>1、频分多路复用FDM</h3><p>多路复用器接受来自多个源的模拟信号，每个信号有自己独立的带宽，信号在通信的过程中自始自终都占用这个频带，在同样的时间占用不同的带宽频率，信号被组合成一个具有更大带宽的信号</p><p><img src="https://img-blog.csdnimg.cn/0f6e460c8dae4d1196e922cb0c99d28f.png" alt=""></p><h3 id="2、时分多路复用TDM"><a href="#2、时分多路复用TDM" class="headerlink" title="2、时分多路复用TDM"></a>2、时分多路复用TDM</h3><p>时分多路复用TDM，信道分割的方法是信号占用的时间，将使用复用的各路信号在时间上互不重叠，在传输时把时间分成小的时隙，每一时隙由复用的一个信号占用。</p><p><img src="https://img-blog.csdnimg.cn/f1c59e5bb03f49a69733cc1cbc4cc807.png" alt=""></p><h3 id="3、波分多路复用WDM"><a href="#3、波分多路复用WDM" class="headerlink" title="3、波分多路复用WDM"></a>3、波分多路复用WDM</h3><p><img src="https://img-blog.csdnimg.cn/151a54463c37462caadb8472f9628a66.png" alt=""></p><h3 id="4、码分多路复用CDM"><a href="#4、码分多路复用CDM" class="headerlink" title="4、码分多路复用CDM"></a>4、码分多路复用CDM</h3><p>它既共享信道的频率，也共享时间，是一种真正的动态复用技术</p><h2 id="CSMA-CD-协议"><a href="#CSMA-CD-协议" class="headerlink" title="CSMA/CD 协议"></a>CSMA/CD 协议</h2><p>总线局域网使用的协议：CSMA/CD协议为带有冲突检测的载波监听多路访问技术，数据链路层，协议的实质是“载波监听”和“碰撞检测”。</p><p>载波监听就是利用电子技术检测总线上有没有其他计算机也在发送。载波监听实际上就是检测信道。在发送前，每个站不停地检测信道，是为了获得发送权；在发送中检测信道，是为了及时发现有没有其他站的发送和本站发送的碰撞，这就是碰撞检测。总之，载波监听是全程都在进行的。</p><p>碰撞检测就是边发送边监听。就是网卡边发送数据边检测新岛上的信号电压的变化情况，以便判断自己在发送数据的时候其他站是否也在发送数据。当几个站同时在总线上发送数据时，总线上的信号电压变化幅度将会增大（互相叠加），当网卡检测到的信号电压超过一定的门限值时，说明总线上至少有两个站同时在发送数据，表明产生了碰撞（冲突），所以也称为冲突检测。这时，由于接收的信号已经识别不出来，所以任何一个正在发送的站就会立即停止发送数据，然后等待一段随机事件以后再次发送。</p><p>CSMA/CD 算法如下</p><ul><li>当帧准备好时，发送站检查信道是空闲还是忙碌。+ 如果信道拥塞，该站将等待直到它变得可用。+ 如果信道是空的，则站开始传输并观察信道是否发生冲突+ 如果检测到冲突，该站启动冲突解决程序。</li></ul><p>站点重置重传计数器并完成帧传输。</p><p>尽管 CSMA/CS 检测到冲突，但它没有减少冲突数量的机制。因此，它不适用于大型网络，因为当添加更多站点时性能会呈指数级下降。</p><h2 id="CSMA-CA协议"><a href="#CSMA-CA协议" class="headerlink" title="CSMA/CA协议"></a>CSMA/CA协议</h2><p>载波监听多点接入 / 碰撞避免协议（Carrier Sense Multiple Access With Collision Avoidance）</p><p>CSMA/CA 的算法如下：</p><ul><li>当帧准备好时，发送站检查信道是空闲还是忙碌。+ 如果通道不畅通，则节点开始等待随机时间量，然后再检查是否畅通。</li></ul><p>这个等待时间被称为“退避因子”，它由退避计数器倒计时。</p><ul><li>如果信道空闲，则站等待帧间间隙 (IFG) 时间，然后发送帧。+ 它在发送帧后设置一个计时器。+ 然后该站等待接收器的确认。</li></ul><p>如果在定时器超时前收到确认，则表示发送成功。</p><ul><li>否则，它会等待一个回退时间段并重新启动算法。</li></ul><p>CMSA/CA 防止冲突。当它等待确认时，数据不会不必要地丢失，并且避免了浪费的传输。CSMA/CA 非常适合无线传输。</p><h2 id="Mac地址-IP地址-Arp协议"><a href="#Mac地址-IP地址-Arp协议" class="headerlink" title="Mac地址 IP地址 Arp协议"></a>Mac地址 IP地址 Arp协议</h2><p><img src="https://img-blog.csdnimg.cn/985b1e00a3c4487ca861693bc211682e.png" alt=""></p><p>Mac地址又称为物理地址，MAC 地址由六组两位字符组成，由冒号分隔。比如00:1B:44:11:3A:B7，就是一个 MAC 地址。固化在网卡的EEPROM中，所以叫做硬件地址。</p><p>IP地址：完整的 IP 寻址范围从 0.0.0.0 到 255.255.255.255。</p><p>数据包的转发：数据包在转发过程中，源IP地址和目的IP地址始终保持不变，而数据在数据链路层通过ARP协议找到一条去往目的地的路，即路上要经过的路由器的MAC地址，经过一个或多个路由器（一次只能够找到下一步的MAC地址，不能一次性的把路上所有的MAC都找到），最终交付给目的地。</p><p><img src="https://img-blog.csdnimg.cn/12af1a7f22e841989ec813e76d65d02f.png" alt=""></p><p><img src="https://img-blog.csdnimg.cn/7360393ad10f481c9b0cc9eec76394c6.png" alt=""></p><p><a href="https://cloud.tencent.com/developer/news/637065">一文读懂ARP协议，从IP获取对方MAC实操</a> </p><h2 id="集线器、交换机、路由器"><a href="#集线器、交换机、路由器" class="headerlink" title="集线器、交换机、路由器"></a>集线器、交换机、路由器</h2><p>集线器以广播方式发送，交换机单独发送</p><p><img src="https://img-blog.csdnimg.cn/0010f4b68f3b4557a48c692e73a1c254.png" alt=""></p><p>集线器对接收到的信号放大、转发，交换机根据MAC地址对帧进行转发。</p><p><img src="https://img-blog.csdnimg.cn/888ac41ce78d4aad86f0a111553c8722.png" alt=""></p><p><a href="https://www.eet-china.com/mp/a73949.html">一文让你搞懂：路由器，集线器，交换机，网桥，光猫有啥区别？</a></p><h2 id="以太网交换机的自学习和转发帧的流程"><a href="#以太网交换机的自学习和转发帧的流程" class="headerlink" title="以太网交换机的自学习和转发帧的流程"></a>以太网交换机的自学习和转发帧的流程</h2><p><img src="https://img-blog.csdnimg.cn/670ac883aca7420586fb8e53a850d854.png" alt=""></p><p><img src="https://img-blog.csdnimg.cn/56dccf0ac6cd4672aba092571f69f144.png" alt=""></p><h2 id="以太网交换机的生成树协议"><a href="#以太网交换机的生成树协议" class="headerlink" title="以太网交换机的生成树协议"></a>以太网交换机的生成树协议</h2><p><img src="https://img-blog.csdnimg.cn/04c2ca11663e4980982423008433654e.png" alt=""></p><h2 id="虚拟局域网VLAN的实现机制"><a href="#虚拟局域网VLAN的实现机制" class="headerlink" title="虚拟局域网VLAN的实现机制"></a>虚拟局域网VLAN的实现机制</h2><p>对以太网的MAC帧进行了扩展，插入了四个字节的VLAN标记。当交换机收到普通的以太网帧时，插入四字节的VLAN标记，转变为802.1Q帧，“打标签”。当交换机转发802.1Q帧时，会删除标签，“去标签”。</p><p><img src="https://img-blog.csdnimg.cn/b6e72333ee944c81a7d86634295ad3fd.png" alt=""></p><p>交换机的Access端口：PVID与VID相等时才会转发，用于连接用户计算机。</p><p><img src="https://img-blog.csdnimg.cn/066c241eaf2440d19b02c4536d5a2fc7.png" alt=""></p><p>Trunk端口：用于连接交换机之间或者交换机与路由器之间。</p><p><img src="https://img-blog.csdnimg.cn/2deb1f838eac45ddaf908bcbaae0155e.png" alt=""></p><p>Hybird端口：发送时查看该帧是否在端口的去标签列表中，存在则去标签转发，否则直接转发；接受时</p><p><img src="https://img-blog.csdnimg.cn/546a6319646a4c21a34a89b7a3e0a0d4.png" alt=""></p><p>虚拟局域网VLAN的实现机制</p><p>对以太网的MAC帧进行了扩展，插入了四个字节的VLAN标记。当交换机收到普通的以太网帧时，插入四字节的VLAN标记，转变为802.1Q帧，“打标签”。当交换机转发802.1Q帧时，会删除标签，“去标签”。</p><p><img src="https://img-blog.csdnimg.cn/f5fe83defdd34e9a82d510866262c1e4.png" alt=""></p><p>交换机的Access端口：PVID与VID相等时才会转发，用于连接用户计算机。</p><p><img src="https://img-blog.csdnimg.cn/a1508fea46c24a8b939d5851412a688a.png" alt=""></p><p>Trunk端口：用于连接交换机之间或者交换机与路由器之间。</p><p><img src="https://img-blog.csdnimg.cn/691a870ef6ca4d86ba6ea69e77211c55.png" alt=""></p><p>Hybird端口：发送时查看该帧是否在端口的去标签列表中，存在则去标签转发，否则直接转发；接受时</p><p><img src="https://img-blog.csdnimg.cn/38dd150fd262475fad714c65b9257f80.png" alt=""></p><h1 id="第四章：网络层"><a href="#第四章：网络层" class="headerlink" title="第四章：网络层"></a>第四章：网络层</h1><h2 id="IPv4地址的格式"><a href="#IPv4地址的格式" class="headerlink" title="IPv4地址的格式"></a>IPv4地址的格式</h2><p>点分十进制表示方法：</p><p><img src="https://img-blog.csdnimg.cn/4f5c8548fc3743da887a612825744600.png" alt=""></p><p>辨别ABC类地址</p><p><img src="https://img-blog.csdnimg.cn/f555fa48ed484a0a96e71dc7a1a9d533.png" alt=""></p><h2 id="分类编制的IPv4地址"><a href="#分类编制的IPv4地址" class="headerlink" title="分类编制的IPv4地址"></a>分类编制的IPv4地址</h2><p>小结：主机号全零是网络地址，全一是广播地址，注意ABC类地址的范围</p><p><img src="https://img-blog.csdnimg.cn/a9a8afe218404f1ea23b42cb4d95f850.png" alt=""></p><h2 id="划分子网的IPv4地址"><a href="#划分子网的IPv4地址" class="headerlink" title="划分子网的IPv4地址"></a>划分子网的IPv4地址</h2><p>子网掩码：使用连续的1来代表网络号和子网号，0对应主机号，与原来的网络地址相与就可以得到网络地址。</p><p><img src="https://img-blog.csdnimg.cn/2511e43a339d4f819a2ea037f1c32875.png" alt=""></p><p>划分细节：全零的和全一的要忽略掉</p><p><img src="https://img-blog.csdnimg.cn/28f70672318a497db8a46837a3962ec1.png" alt=""></p><p>小结：</p><p><img src="https://img-blog.csdnimg.cn/673e396d7304422ea0b042885d425ede.png" alt=""></p><h2 id="无分类编址的划分子网CIDR"><a href="#无分类编址的划分子网CIDR" class="headerlink" title="无分类编址的划分子网CIDR"></a>无分类编址的划分子网CIDR</h2><p>在IPv4地址后面加上斜线，表示网络前缀所占的比特数量。</p><p><img src="https://img-blog.csdnimg.cn/882a3453ea464552a79e8dce6df9785f.png" alt=""></p><p>最长前缀匹配：</p><p><img src="https://img-blog.csdnimg.cn/a9393a3c29fb4a2683702f55fa792aa8.png" alt=""></p><p>举例说明：</p><p><img src="https://img-blog.csdnimg.cn/894242eb41264e69aa18392d8d32e96a.png" alt=""></p><p>例题2：</p><p><img src="https://img-blog.csdnimg.cn/d390e4fe857d4c9fb70153f47d520bc7.png" alt=""></p><p>小结：</p><p><img src="https://img-blog.csdnimg.cn/bdc1a6541ed943c9854fa7fa1e5ae5ac.png" alt=""></p><h2 id="IP数据报的发送与转发过程"><a href="#IP数据报的发送与转发过程" class="headerlink" title="IP数据报的发送与转发过程"></a>IP数据报的发送与转发过程</h2><p>如果在同一个网络中，直接交付；不在，间接交付。</p><p><strong>如何判断目的主机与自己是否在同一个网络中？</strong></p><p>将本机IP地址与本机子网掩码相与得到网络地址，将目的主机IP地址与本机子网掩码相与得到另外一个网络地址，看看两个网络地址是否相同。同，在一个网络；不同在不同的网络。</p><p><img src="https://img-blog.csdnimg.cn/1b1eccc36c9543688b2bf826d946450f.png" alt=""></p><h2 id="静态路由配置以及可能产生的路由环路问题"><a href="#静态路由配置以及可能产生的路由环路问题" class="headerlink" title="静态路由配置以及可能产生的路由环路问题"></a>静态路由配置以及可能产生的路由环路问题</h2><p>网络管理员自己手动配置路由表。</p><p><img src="https://img-blog.csdnimg.cn/87cc07ac8af4429b9dc01f721c7e5d26.png" alt=""></p><h2 id="外部-BGP-与内部-BGP-有什么区别？"><a href="#外部-BGP-与内部-BGP-有什么区别？" class="headerlink" title="外部 BGP 与内部 BGP 有什么区别？"></a>外部 BGP 与内部 BGP 有什么区别？</h2><p>在互联网上，路由交换和流量传输是通过外部 BGP（eBGP）进行的。自治系统也可使用 BGP 的内部版本来路由内部网络上的数据，也就是 iBGP（internal）。应该指出的是，使用内部 BGP 并非使用外部 BGP 的前提条件。自治系统可从多种内部协议中选择，来连接内部网络上的路由器。</p><p>外部 BGP 就像国际运输。在国际上运送邮件时，需要遵循特定的标准和规则。邮件到达目的地国家后，必须通过目的地国家的本地邮政服务才能达到其最终目的地。每个国家都有自己的内部邮政服务，不必遵循其他国家的相同规则。同样，每个自治系统都可以有自己的内部路由协议，用于路由自身网络内部的数据。</p><h2 id="内部网关协议：路由信息协议RIP的基本工作原理"><a href="#内部网关协议：路由信息协议RIP的基本工作原理" class="headerlink" title="内部网关协议：路由信息协议RIP的基本工作原理"></a>内部网关协议：路由信息协议RIP的基本工作原理</h2><p>RIP的路由条目的更新规则，先加1，然后逐渐更新</p><p><img src="https://img-blog.csdnimg.cn/c124805b378f4c61a971f52a755a66ba.png" alt=""></p><p>使用跳数来衡量到达目的网络的距离，next hop，下一跳</p><p><img src="https://img-blog.csdnimg.cn/9961223a7ffd40939ab535a9495b31bd.png" alt=""></p><h2 id="广播域与冲突域"><a href="#广播域与冲突域" class="headerlink" title="广播域与冲突域"></a>广播域与冲突域</h2><p>一个集线器（中继器）连接的网络成为冲突域，因为每台主机都连接在了同一条线路上，所以传送信息时会冲突。<strong>冲突域是基于第一层(物理层)</strong></p><p>而交换机的本质是一个多借口网桥，就是说由交换机组成的网络中，任意两台主机通信都是通过一条专有线路，故不会冲突。所以交换机出来的每个接口都是一个冲突域。<strong>广播域是基于第二层(链路层)</strong></p><p>通常一个局域网VLAN算一个广播域，故路由器的每个端口产生一个广播域。</p><h2 id="开放最短路径OSPF的基本工作原理"><a href="#开放最短路径OSPF的基本工作原理" class="headerlink" title="开放最短路径OSPF的基本工作原理"></a>开放最短路径OSPF的基本工作原理</h2><p>在自治系统AS中可以通过OSPF将其划分成更小的区域。</p><p><img src="https://img-blog.csdnimg.cn/ce148a6ff01b4569b374611147313b1d.png" alt=""></p><h3 id="OSPF在多点接入网络中路由邻居关系的建立"><a href="#OSPF在多点接入网络中路由邻居关系的建立" class="headerlink" title="OSPF在多点接入网络中路由邻居关系的建立"></a>OSPF在多点接入网络中路由邻居关系的建立</h3><p>选举指定路由器DR和备用的指定路由器BDR，减少网络中邻居关系之间的问候分组（Hello分组）</p><p><img src="https://s2.loli.net/2023/07/24/KhRbkJlWF6VernL.png" alt="image-20230724165601768"></p><h3 id="OSPF小结"><a href="#OSPF小结" class="headerlink" title="OSPF小结"></a>OSPF小结</h3><p><img src="https://img-blog.csdnimg.cn/e772b21b41f04d1f9b6765cf985cfb36.png" alt=""></p><h2 id="边界网关协议BGP"><a href="#边界网关协议BGP" class="headerlink" title="边界网关协议BGP"></a>边界网关协议BGP</h2><p>BGP是找到有路径就可以，不用去找最佳的路由。</p><p><img src="https://img-blog.csdnimg.cn/852d8062d30a45969c981b765eaa9d47.png" alt=""></p><p>例题：</p><p><img src="https://img-blog.csdnimg.cn/029ca4afc3144ab9ba44a69539f70932.png" alt=""></p><p>小结：</p><p><img src="https://img-blog.csdnimg.cn/bd44fdb4680141fb8f2ed835a5713968.png" alt=""></p><h2 id="IPVv4数据报的格式"><a href="#IPVv4数据报的格式" class="headerlink" title="IPVv4数据报的格式"></a>IPVv4数据报的格式</h2><p>TTL字段的作用：防止IP数据报在网络中永久兜圈。</p><p>如下图将R2的静态路由表配置错了，导致要转发给R3的转发给了R1，造成路由环路。</p><p><img src="https://img-blog.csdnimg.cn/bc99ba4e538a411085020b799467e526.png" alt=""></p><p>当IP数据报经过一个路由器的时候：TTL字段减一，首部检验和需要更改，如果IP数据报过大，大于MTU（最大数据报单元），则要重新分片，标志字段、总长度字段、片位移字段都要修改。</p><p><img src="https://img-blog.csdnimg.cn/5c0ea351cc244fa895481c3c59f08e90.png" alt=""></p><h2 id="网际控制报文协议ICMP"><a href="#网际控制报文协议ICMP" class="headerlink" title="网际控制报文协议ICMP"></a>网际控制报文协议ICMP</h2><p>通过ICMP来发送差错报告报文和询问报文，ICMP报文被封装在IP数据报中发送出去，有五种差错报文。</p><p>ICMP的应用：PING、traceroute（TTL从1开始，到了一个中间的站点，发送一个时间超过报文）</p><p><img src="https://img-blog.csdnimg.cn/e686be839f394ae7bccfbc3c3e2404a7.png" alt=""></p><h2 id="网络地址转换NAT和虚拟专用网VPN"><a href="#网络地址转换NAT和虚拟专用网VPN" class="headerlink" title="网络地址转换NAT和虚拟专用网VPN"></a>网络地址转换NAT和虚拟专用网VPN</h2><p>利用端口号和IP地址一起放入转换表中，这样可以极大程度的利用一个分配IP地址路由器与多个主机的多个服务之间通信、转发，减缓IP地址的使用。</p><p><img src="https://img-blog.csdnimg.cn/7603516f32f641f28dd366cc80dcfbc0.png" alt=""></p><p>两个私有的网通过公有的因特网进行通信，这个时候会将原始的数据进行加密处理，然后将其封装，保证数据安全。</p><p>外地员工连内网，利用专有的软件，远程接入VPN</p><p><img src="https://img-blog.csdnimg.cn/5b0d54007dd2445797b0a044e4fb3548.png" alt=""></p><h2 id="移动IP技术"><a href="#移动IP技术" class="headerlink" title="移动IP技术"></a>移动IP技术</h2><p>通俗的解释：归属代理就相当于你老家的邮局，外地代理就相当于你公司的邮局，你可能换不同公司，但你的老同学给你寄东西可以先寄给你老家，然后转交给你的公司</p><p>应用场景：在移动的汽车内下载文件</p><p><img src="https://s2.loli.net/2023/07/24/eyLmW7UwtFj6Tvp.png" alt="image-20230724173809610"></p><h1 id="第五章：运输层"><a href="#第五章：运输层" class="headerlink" title="第五章：运输层"></a>第五章：运输层</h1><h2 id="运输层简介"><a href="#运输层简介" class="headerlink" title="运输层简介"></a>运输层简介</h2><p>通过这一层的封装，两个计算机之间的通信好像变成了它们之间两个进程之间的直接通信，端口号代表了进程的标识符（0-65535，0-2^16-1）。</p><p><img src="https://img-blog.csdnimg.cn/d23f41ef64c040ea994c53cca10cb04d.png" alt=""></p><h2 id="运输层端口号、分用、复用的概念"><a href="#运输层端口号、分用、复用的概念" class="headerlink" title="运输层端口号、分用、复用的概念"></a>运输层端口号、分用、复用的概念</h2><p>应用层协议的常用熟知端口号。</p><p><img src="https://img-blog.csdnimg.cn/43addfd97cee4ff3981f67aa4bb4bee5.png" alt=""></p><p>端口号只具有本地意义，不同计算机之间的相同端口号是没有联系的。</p><p><img src="https://img-blog.csdnimg.cn/61d88ad2e5324e12942048bdd045f7c9.png" alt=""></p><h2 id="UDP和TCP的对比"><a href="#UDP和TCP的对比" class="headerlink" title="UDP和TCP的对比"></a>UDP和TCP的对比</h2><p>UDP支持单播、多播以及广播，TCP仅支持1对1的服务。</p><p>UDP适用于视频通话</p><p><img src="https://img-blog.csdnimg.cn/fbaf0c5aa964406ca1f04340c2a40573.png" alt=""></p><p>UDP面向报文，TCP面向字节流。</p><p><img src="https://img-blog.csdnimg.cn/0ead83be92d94f65aa5131475282148f.png" alt=""></p><p>UDP首部只有8个字节，TCP首部最少20字节，最多60字节。</p><p><img src="https://img-blog.csdnimg.cn/b2c80ecffebe4abdb7e1708aeed0b729.png" alt=""></p><p>小结：</p><p><img src="https://img-blog.csdnimg.cn/f9c6c942c08744dea8b0366e1593741e.png" alt=""></p><h2 id="TCP的流量控制"><a href="#TCP的流量控制" class="headerlink" title="TCP的流量控制"></a>TCP的流量控制</h2><p>解决死锁情况的计时器：在接收方将窗口修改为0时启动，</p><p>零窗口探测报文在rwnd=0时也可以接收。</p><p>大写的ACK是确认信号，返回给client，小写的ack是累计确认，表示ack号字节以前的数据都收到了。</p><p><img src="https://img-blog.csdnimg.cn/c7f2754415d6437d9ca11ac1fdabaf3a.png" alt=""></p><p>例题：注意通高的接受窗口的大小是2000字节</p><p><img src="https://img-blog.csdnimg.cn/e51e63d89af14aa48df52851a904e2c8.png" alt=""></p><p>小结：流量控制是为了让发送方的发送速度不要过快，利用的是滑动窗口的机制。接收方发送零窗口通知后，发送方收到后会启动持续计时器。接收方是通过rwnd的值来设置窗口大小，从而实现流量控制。</p><p><img src="https://img-blog.csdnimg.cn/82dbdd4e7c8f455aa78026c42f5059d8.png" alt=""></p><h2 id="TCP的拥塞控制"><a href="#TCP的拥塞控制" class="headerlink" title="TCP的拥塞控制"></a>TCP的拥塞控制</h2><p>慢开始，拥塞避免：</p><p>维护三个变量：拥塞窗口cwnd、发送窗口swnd，慢开始门限ssthresh。</p><p><img src="https://img-blog.csdnimg.cn/4646d065760f4e4284b09047d7913e0c.png" alt=""></p><p>快重传算法：不等待超时重传计时器的超时，而是收到了三个连续的重复确认就将报文段立即重传。</p><p><img src="https://img-blog.csdnimg.cn/c688bcccb4b34422a94ddd5bcf0fe114.png" alt=""></p><p>快恢复算法：收到三个重复确认就知道了只是丢失了个别的报文段，这个时候不启动慢开始算法，而是执行快恢复算法。</p><p><img src="https://img-blog.csdnimg.cn/774dd5e4144e4c518f228718ace023d3.png" alt=""></p><p>慢开始，拥塞控制，快重传，快恢复</p><p><img src="https://img-blog.csdnimg.cn/39fcf6826f94478faf3cb0cd1f34547b.png" alt=""></p><p>TCP超时重传时间的计算</p><p>RTO=RTTs+4*RTT D；</p><p>出现超时重传，新RTO=2*旧的RTO。</p><p><img src="https://img-blog.csdnimg.cn/f80d68c1c0e44794b629796fd445b1b7.png" alt=""></p><h2 id="TCP可靠传输的实现"><a href="#TCP可靠传输的实现" class="headerlink" title="TCP可靠传输的实现"></a>TCP可靠传输的实现</h2><p>返送窗口的前沿和后沿的移动情况，</p><p><img src="https://img-blog.csdnimg.cn/52e84af5653c470fbda5718335c16500.png" alt=""></p><p>小结：以字节为单位的滑动窗口来实现可靠传输。而对于没有按序到达的数据的处理，没有明确规定，通常是将这些数据临时保存在接收窗口中。</p><p><img src="https://img-blog.csdnimg.cn/dcebef6fe5124728bd3f5b81314a1220.png" alt=""></p><h2 id="TCP的连接建立：三握手"><a href="#TCP的连接建立：三握手" class="headerlink" title="TCP的连接建立：三握手"></a>TCP的连接建立：三握手</h2><p>三报文握手来建立连接。</p><p><img src="https://img-blog.csdnimg.cn/a5423c39832b4c94b230e67a968cbff2.png" alt=""></p><p>两次握手不可行的示意图：失效的TCP连接请求在一段时间后到达服务端，服务端也会认为是一个请求，错误的进入ESTABLISHED状态，会浪费资源。</p><p><img src="https://img-blog.csdnimg.cn/e9af9490c0164a75a51f0517b827d6da.png" alt=""></p><p>所以第三次握手不是多余的；</p><p><img src="https://img-blog.csdnimg.cn/4e80798d88e84c9a89df449f55496209.png" alt=""></p><p>例题：SYN=1 ACK=1 seq=11221 ack=11221</p><p><img src="https://img-blog.csdnimg.cn/eeffe6784ef649fa97fb915ebac7f631.png" alt=""></p><p>小结：SYN=1的报文段不能携带数据。</p><p><img src="https://img-blog.csdnimg.cn/d0a78f9448c34e7bb6dba8da42a83ea2.png" alt=""></p><h2 id="TCP连接的释放：四挥手"><a href="#TCP连接的释放：四挥手" class="headerlink" title="TCP连接的释放：四挥手"></a>TCP连接的释放：四挥手</h2><p>4报文挥手，客户端最后还要经过2MSL的时间才会进入关闭状态，确保返回给服务器的ACK到达服务端，以及清理掉此次连接中的所有报文段。</p><p><img src="https://img-blog.csdnimg.cn/b7a540c088e744e2b5f5c00737fce93f.png" alt=""></p><p>使用2*MSL时间的原因：当出现最后的确认报文段丢失的情况时，还可以收到服务端的FIN信号，否则服务器就会一直重传FIN报文段，而此时客户端已经进入了CLOSED状态，不会发送ACK，服务端这时会一直收不到确认信号。</p><p><img src="https://img-blog.csdnimg.cn/f2fdfceb80e44182b7f9d8ab1ff3aeb6.png" alt=""></p><p>保活计时器</p><p><img src="https://img-blog.csdnimg.cn/b051b9fec6914671a305be27606b66a6.png" alt=""></p><h2 id="TCP报文段的首部格式"><a href="#TCP报文段的首部格式" class="headerlink" title="TCP报文段的首部格式"></a>TCP报文段的首部格式</h2><p>都有20字节的固定首部</p><p><img src="https://img-blog.csdnimg.cn/0eed4e40c69b40f3bb4d6c84cc5dec1c.png" alt=""></p><h1 id="第六章：应用层"><a href="#第六章：应用层" class="headerlink" title="第六章：应用层"></a>第六章：应用层</h1><h2 id="B-S和P2P方式"><a href="#B-S和P2P方式" class="headerlink" title="B/S和P2P方式"></a>B/S和P2P方式</h2><p>P2P方式是两边对等的，没有固定的服务端和客户端，</p><p><img src="https://img-blog.csdnimg.cn/7791c8324f8f4e6aa6cd1d07ac087dfe.png" alt=""></p><h2 id="动态主机配置协议DHCP"><a href="#动态主机配置协议DHCP" class="headerlink" title="动态主机配置协议DHCP"></a>动态主机配置协议DHCP</h2><p>DHCP的工作过程：主要有四步，DHCP DISCOVER、DHCP OFFER、DHCP REQUEST、DHCP ACK。</p><p><img src="https://img-blog.csdnimg.cn/d7332fef336047de984f5e003408675c.png" alt=""></p><p>DHCP中继代理：在主机发送广播的DHCP DISCOVER时，将路由器当成中继代理，让它给服务器发送单播DHCP DISCOVER，这样主机就可以获取到IP地址分配。如果不这样配置，路由器会直接丢弃广播的DHCP DISCOVER。</p><p><img src="https://img-blog.csdnimg.cn/d2c09e54836942e4a7aa6f732c4bd777.png" alt=""></p><p>小结：</p><p><img src="https://img-blog.csdnimg.cn/9ef3bdde05704fa482ae618afb99d432.png" alt=""></p><h2 id="域名系统DNS"><a href="#域名系统DNS" class="headerlink" title="域名系统DNS"></a>域名系统DNS</h2><p>域名的层次结构：树根没有域名，顶级、二级、三级、四级域名。</p><p><img src="https://img-blog.csdnimg.cn/ba5b4ee5d5aa4bb086a890e1c9edda80.png" alt=""></p><p>域名的解析有两种：递归查询和迭代查询。</p><p><img src="https://img-blog.csdnimg.cn/e48b660d791147b49924ba1b6f107ee0.png" alt=""></p><h2 id="文件传输协议FTP"><a href="#文件传输协议FTP" class="headerlink" title="文件传输协议FTP"></a>文件传输协议FTP</h2><p>三条命令，可以传输文件</p><p>fpt ip; //连接FTP服务器</p><p>get [name]//下载文件</p><p>put [name]//上传文件</p><p><img src="https://img-blog.csdnimg.cn/582ded89c75f4f049cb95e424c0c6c9d.png" alt=""></p><p><img src="https://img-blog.csdnimg.cn/73a0f218414247129ba2e59b99afa3bc.png" alt=""></p><p>小结</p><p><img src="https://s2.loli.net/2023/07/25/ksQzKMjp46nIyLJ.png" alt=""></p><h2 id="电子邮件"><a href="#电子邮件" class="headerlink" title="电子邮件"></a>电子邮件</h2><p>简单邮件传送协议SMTP：simple mail transfer protocol，基于TCP连接，使用熟知端口号25，只能发送ASCII文本。</p><p><img src="https://img-blog.csdnimg.cn/1ea41adb8ef0430086ed44888eaf7f66.png" alt=""></p><p>电子邮件的格式：信封和内容</p><p><img src="https://img-blog.csdnimg.cn/f7bd5712d610441ba05057b7824d35fd.png" alt=""></p><p>小结：常见的邮件读取协议有POP3、IMAP。邮件读取协议是指邮件服务器读取邮件内容的时候要遵循的协议。</p><p><img src="https://img-blog.csdnimg.cn/df53058638094f77b5cbbee24dabd68f.png" alt=""></p><h2 id="万维网WWW"><a href="#万维网WWW" class="headerlink" title="万维网WWW"></a>万维网WWW</h2><p>HTTP的报文格式：包含请求报文和响应报文</p><p><img src="https://img-blog.csdnimg.cn/8e9f7489cf1f4059a447c0a5da0b232e.png" alt=""></p><p>万维网缓存与代理服务器：提高万维网的效率，减轻原始服务器的压力。</p><p><img src="https://img-blog.csdnimg.cn/531aaa4985c5495abe4b5d2e7c7222c2.png" alt=""></p><p>小结：</p><p>万维网使用统一资源定位符URL来指定英特网上的资源的位置：</p><p>&lt;协议&gt;://&lt;主机&gt;:&lt;端口&gt;/&lt;路径&gt;，如：<a href="https://www.baidu.com/">https://www.baidu.com/</a></p><p>HTTP是超文本传输协议，1.0采用无连接的方式，1.1采用持续连接的方式</p><p>（keep-alive），</p><p><img src="https://img-blog.csdnimg.cn/5f8dfed559db45589de599feb0caa3b0.png" alt=""></p><h1 id="参考视频链接"><a href="#参考视频链接" class="headerlink" title="参考视频链接"></a>参考视频链接</h1><p><a href="https://www.bilibili.com/video/BV1c4411d7jb?p=1&amp;vd_source=b99c7e40ffa0f64b68b706f2af755c8e">计算机网络微课堂（有字幕无背景音乐版）</a> </p><p><a href="https://www.bilibili.com/video/BV1NT411g7n6">深入浅出计算机网络 微课视频</a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>广播域与冲突域</title>
      <link href="/2023/06/20/guang-bo-yu-yu-chong-tu-yu/"/>
      <url>/2023/06/20/guang-bo-yu-yu-chong-tu-yu/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="广播域与冲突域"><a href="#广播域与冲突域" class="headerlink" title="广播域与冲突域"></a>广播域与冲突域</h1><p> 一个集线器（中继器）连接的网络成为冲突域，因为每台主机都连接在了同一条线路上，所以传送信息时会冲突。 冲突域是基于第一层(物理层)</p><p>而交换机的本质是一个多借口网桥，就是说由交换机组成的网络中，任意两台主机通信都是通过一条专有线路，故不会冲突。所以交换机出来的每个接口都是一个冲突域。 广播域是基于第二层(链路层)</p><p>通常一个局域网VLAN算一个广播域，故路由器的每个端口产生一个广播域。</p><p>例题：</p><p>在下图的网络配置中，总共有（）个广播域，（）个冲突域。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/58c839a3804405ab3622e4e9ded13dc3.png" alt=""></p><p>答案是：2个广播域，7个冲突域。</p><p>解析：每个路由器的一个端口就是一个广播域和冲突域；集线器不隔离冲突域 ，也不隔离广播域；交换机隔离冲突域，不隔离广播域。所以路由器有两个端口，就有两个广播域；左边有一个冲突域，右边有6个冲突域，总共7个。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>跟腾讯架构大师学网络框架与后台架构</title>
      <link href="/2023/06/20/gen-teng-xun-jia-gou-da-shi-xue-wang-luo-kuang-jia-yu-hou-tai-jia-gou/"/>
      <url>/2023/06/20/gen-teng-xun-jia-gou-da-shi-xue-wang-luo-kuang-jia-yu-hou-tai-jia-gou/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="网络框架与后台架构"><a href="#网络框架与后台架构" class="headerlink" title="网络框架与后台架构"></a>网络框架与后台架构</h1><h1 id="单机服务"><a href="#单机服务" class="headerlink" title="单机服务"></a>单机服务</h1><h2 id="1、单机服务：基本概念"><a href="#1、单机服务：基本概念" class="headerlink" title="1、单机服务：基本概念"></a>1、单机服务：基本概念</h2><p><img src="https://img-blog.csdnimg.cn/55d5b77b35c94c63a074bf1fe72bc547.png" alt=""></p><h2 id="2、单机服务：同步阻塞"><a href="#2、单机服务：同步阻塞" class="headerlink" title="2、单机服务：同步阻塞"></a>2、单机服务：同步阻塞</h2><p><img src="https://img-blog.csdnimg.cn/c06c9be4fdb84121a914af18173b0411.png" alt=""></p><h2 id="3、单机服务：异步非阻塞框架"><a href="#3、单机服务：异步非阻塞框架" class="headerlink" title="3、单机服务：异步非阻塞框架"></a>3、单机服务：异步非阻塞框架</h2><p>使用非阻塞IO，检测到有事件</p><p>性能最高：不会阻塞IO，数据拷贝最少</p><p><img src="https://img-blog.csdnimg.cn/483f1de6bcde4b9281ff41ab37eaf348.png" alt=""></p><h2 id="4、单机服务：典型框架："><a href="#4、单机服务：典型框架：" class="headerlink" title="4、单机服务：典型框架："></a>4、单机服务：典型框架：</h2><p><img src="https://img-blog.csdnimg.cn/b1c58c550e9340d0bfbebb1f7b7d0c5a.png" alt=""></p><h2 id="5、单机服务：协程框架"><a href="#5、单机服务：协程框架" class="headerlink" title="5、单机服务：协程框架"></a>5、单机服务：协程框架</h2><p><img src="https://img-blog.csdnimg.cn/31fe20c831fe4b33b0b134a5128ff38d.png" alt=""></p><h2 id="6、单机服务：新玩法，NODEJS的闭包"><a href="#6、单机服务：新玩法，NODEJS的闭包" class="headerlink" title="6、单机服务：新玩法，NODEJS的闭包"></a>6、单机服务：新玩法，NODEJS的闭包</h2><p>利用上层来保存，可以直接使用上层的局部变量，回调的地狱。<br><img src="https://img-blog.csdnimg.cn/11117a7ab6fd407ba560e135ae68596f.png" alt=""></p><h2 id="7、单机服务：几种典型框架对比"><a href="#7、单机服务：几种典型框架对比" class="headerlink" title="7、单机服务：几种典型框架对比"></a>7、单机服务：几种典型框架对比</h2><p><code>nodejs</code>可能比多线程同步高<br><img src="https://img-blog.csdnimg.cn/ca91f235d577474f836476480ce1e930.png" alt=""></p><h2 id="8、单机服务：网络框架的监控"><a href="#8、单机服务：网络框架的监控" class="headerlink" title="8、单机服务：网络框架的监控"></a>8、单机服务：网络框架的监控</h2><p>监控点多一点，出现问题的时候就比较快的找到问题所在。<br><img src="https://img-blog.csdnimg.cn/139325a2cf4946a0b38c94151d912130.png" alt=""></p><h2 id="9、单机服务：从C10K问题到C10M问题"><a href="#9、单机服务：从C10K问题到C10M问题" class="headerlink" title="9、单机服务：从C10K问题到C10M问题"></a>9、单机服务：从C10K问题到C10M问题</h2><p><img src="https://img-blog.csdnimg.cn/b2a3871eb49b4fc1ade8c358631c58c7.png" alt=""></p><h2 id="10、单机服务：神器"><a href="#10、单机服务：神器" class="headerlink" title="10、单机服务：神器"></a>10、单机服务：神器</h2><p><img src="https://img-blog.csdnimg.cn/072d7bf470a24c48aa11b026356333d0.png" alt=""></p><h1 id="Cache-类服务"><a href="#Cache-类服务" class="headerlink" title="Cache 类服务"></a>Cache 类服务</h1><h2 id="1、Cache类服务：基本概念"><a href="#1、Cache类服务：基本概念" class="headerlink" title="1、Cache类服务：基本概念"></a>1、Cache类服务：基本概念</h2><p><img src="https://img-blog.csdnimg.cn/109c7607980b4f0b9cc76c3e342419ea.png" alt=""></p><h2 id="2、Cache类：Local-Cache"><a href="#2、Cache类：Local-Cache" class="headerlink" title="2、Cache类：Local Cache"></a>2、Cache类：Local Cache</h2><p><img src="https://img-blog.csdnimg.cn/700ccc63c546415cb75bdb8357c0edba.png" alt=""></p><h2 id="3、Cache类：分布式Cache"><a href="#3、Cache类：分布式Cache" class="headerlink" title="3、Cache类：分布式Cache"></a>3、Cache类：分布式Cache</h2><p><img src="https://img-blog.csdnimg.cn/2cc03bdf362d4b5498f36feba06a82c6.png" alt=""></p><h1 id="存储类"><a href="#存储类" class="headerlink" title="存储类"></a>存储类</h1><h2 id="1、存储类：基本概念"><a href="#1、存储类：基本概念" class="headerlink" title="1、存储类：基本概念"></a>1、存储类：基本概念</h2><p><img src="https://img-blog.csdnimg.cn/bb3e5b4c1cfd42da99ad8660782f4711.png" alt=""></p><h2 id="2、存储类：SQL"><a href="#2、存储类：SQL" class="headerlink" title="2、存储类：SQL"></a>2、存储类：SQL</h2><p><img src="https://img-blog.csdnimg.cn/e6bd6d57996b46edab4bac05c96059b7.png" alt=""></p><h2 id="3、存储类：NOSQL"><a href="#3、存储类：NOSQL" class="headerlink" title="3、存储类：NOSQL"></a>3、存储类：NOSQL</h2><p>有持久化与非持久化的选择，可能是一个状态，不需要落地</p><p>很容易扩展，平行扩展。</p><p>弱一致性</p><p>远程数据库redis，文档数据库mongoDB。<br><img src="https://img-blog.csdnimg.cn/c25102f873a24480a778b3a58da602f9.png" alt=""></p><p>while key-value ?<br><img src="https://img-blog.csdnimg.cn/fec8269f285e4e6da4a8a49bb15fc303.png" alt=""></p><p>CAP理论</p><p><img src="https://img-blog.csdnimg.cn/64cedc466e6b4d6882d99ec59c83add4.png" alt=""></p><h2 id="4、存储类：如何不丢数据"><a href="#4、存储类：如何不丢数据" class="headerlink" title="4、存储类：如何不丢数据"></a>4、存储类：如何不丢数据</h2><p>master-slave：master宕机之后，将slave转为master。</p><p>流水+快照：<br><img src="https://img-blog.csdnimg.cn/8ff2e265f1db4cb0a8c76eca039d4280.png" alt=""></p><h2 id="5、存储类：其他存储"><a href="#5、存储类：其他存储" class="headerlink" title="5、存储类：其他存储"></a>5、存储类：其他存储</h2><p><img src="https://img-blog.csdnimg.cn/528f7b7b26294fba8d2d7f141e4d5104.png" alt=""></p><h1 id="通讯类服务"><a href="#通讯类服务" class="headerlink" title="通讯类服务"></a>通讯类服务</h1><p><img src="https://img-blog.csdnimg.cn/93692cb56a4243d28efa848aa37650c6.png" alt=""></p><h1 id="计算类服务"><a href="#计算类服务" class="headerlink" title="计算类服务"></a>计算类服务</h1><p> <img src="https://img-blog.csdnimg.cn/70fe9f09378f46b8b1a4ffa8f09afffa.png" alt=""></p><h1 id="寻址类服务"><a href="#寻址类服务" class="headerlink" title="寻址类服务"></a>寻址类服务</h1><p><img src="https://img-blog.csdnimg.cn/03e85d73e2fd4f56b4e722c772c1afc2.png" alt=""></p><h1 id="事务类服务"><a href="#事务类服务" class="headerlink" title="事务类服务"></a>事务类服务</h1><p><img src="https://img-blog.csdnimg.cn/08d39e57acf44e27bf6d3882f0d297b4.png" alt=""></p><h1 id="展望"><a href="#展望" class="headerlink" title="展望"></a>展望</h1><p><img src="https://img-blog.csdnimg.cn/ab4c9fbdbfb343d2bf966f36f3016d72.png" alt=""></p><h1 id="视频链接"><a href="#视频链接" class="headerlink" title="视频链接"></a>视频链接</h1><p><a href="https://www.bilibili.com/video/BV1Jv41117Zu/?spm_id_from=333.1007.top_right_bar_window_custom_collection.content.click&amp;vd_source=b99c7e40ffa0f64b68b706f2af755c8e">跟腾讯架构大师学网络框架与后台架构_哔哩哔哩_bilibili</a></p>]]></content>
      
      
      <categories>
          
          <category> c++进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统基础教程</title>
      <link href="/2023/06/20/cao-zuo-xi-tong-ji-chu-jiao-cheng/"/>
      <url>/2023/06/20/cao-zuo-xi-tong-ji-chu-jiao-cheng/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="第二章：处理器管理"><a href="#第二章：处理器管理" class="headerlink" title="第二章：处理器管理"></a><strong>第二章：处理器管理</strong></h1><p><a href="https://houbb.github.io/2020/10/04/os-03-schedule">操作系统学习(3)处理机调度：调度的概念、时机、切换、过程以及调度方式和基本准则 | Echo Blog</a></p><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>1、指令系统和寄存器。</p><p>2、特权指令和非特权指令：特权指令只能在内核态使用，非特权指令在内核态和用户态（管态和目态）都可以使用。</p><p>3、内核态、用户态</p><p>4、处理器状态及其转换：有几种情况可以让处理器从用户态转为内核态，一、执行系统调用，程序请求操作系统服务；二、中断事件；三、产生异常。</p><p><strong>中断技术：</strong>分为内中断（出现就立即执行），外中断。</p><h2 id="进程调度的层次"><a href="#进程调度的层次" class="headerlink" title="进程调度的层次"></a>进程调度的层次</h2><p><strong>有三种层次：</strong></p><p>1、高级调度：作业调度，内存与辅存之间的调度</p><p>2、中级调度：一种缓冲机制，作用是将暂时挂起的进程重新调入内存运行。进程挂起当内存不足的时候该进程不进入内存，而是在外存等待，即挂起状态。</p><p>3、低级调度：进程/线程调度，是操作系统中最基本的一种调度。</p><h2 id="进程的调度方式："><a href="#进程的调度方式：" class="headerlink" title="进程的调度方式："></a>进程的调度方式：</h2><p>1、非剥夺式调度，一旦开始就必须等他运行结束，实现简单，系统开销小。</p><p>2、剥夺式调度：在有优先级的进程时，处理一个优先级更高的进程，这个进程就要是剥夺式进程，就是要处理更加紧急的进程任务。<strong>釆用剥夺式的调度，对提高系统吞吐率和响应效率都有明显的好处。</strong></p><h2 id="调度的评价标准："><a href="#调度的评价标准：" class="headerlink" title="调度的评价标准："></a>调度的评价标准：</h2><p>1、CPU 利用率</p><p>2、系统吞吐率</p><p>3、周转时间：作业完成时间-作业到来时间</p><p>平均作业周转时间（相加之和/数量）、平均带权作业周转时间=（完成时间/所需CPU时间+…）/size</p><p>4、等待时间</p><p>5、响应时间</p><h2 id="典型的调度算法："><a href="#典型的调度算法：" class="headerlink" title="典型的调度算法："></a>典型的调度算法：</h2><p><strong>1、先来先服务算法（First Come First Served，FCFS）：</strong>每次从就绪队列中选择最先进入该队列的进程，直到完成。</p><p><strong>2、短作业优先算法（Shortest Job First，SJF）：</strong>从后备队列中选择一个或若干个估计运行时间最短的作业，将它们调入内存运行。由于一直选则最短的作业运行，最早进入但是运行时间长的作业等待时间会很长，<strong>出现饥饿现象。</strong></p><p><strong>3、最短剩余时间优先算法（Shortest Remaining Time First，SRTF）：</strong>将SJF改为剥夺式算法就成为了该算法。</p><p><strong>3、优先级调度算法：</strong>优先级调度算法每次从后备作业队列中选择优先级最髙的一个或几个作业，将它们调入内存，分配必要的资源，创建进程并放入就绪队列。也分为静态优先级和动态优先级，静态优先级可能会造成饥饿现象，即低优先级的进程一直推迟运行。</p><p><strong>4、高响应比优先算法（Highest Response Radio First，HRRF）：</strong>该算法是对FCFS调度算法和SJF调度算法的一种综合平衡，同时考虑每个作业的等待时间和估计的运行时间。在每次进行作业调度时，先计算后备作业队列中每个作业的响应比，从中<strong>选出响应比最高</strong>的作业投入运行。其中响应比=(等待时间 + 作业处理时间) / 作业处理时间。</p><p><strong>5、时间片轮转调度算法（Round-Robin，RR）：</strong>在这种算法中，系统将所有就绪进程按到达时间的先后次序排成一个队列，进程调度程序总是选择就绪队列中第一个进程执行，即先来先服务的原则，但仅能运行一个时间片，如100ms，形成一个时间环。</p><p><strong>6、多级反馈队列调度算法：</strong>它是时间片轮转调度算法和优先级调度算法的综合和发展，多个就绪队列，每个队列赋予不同的优先级，而且赋予每个队列的时间片也不相同，如第一个队列的优先级最高，时间片最短。如果是一个短作业，它在级别较高的队列就可以处理完；如果是一个长作业，第一级队列没有完成，可以转到下一个时间片更长的队列<strong>末尾</strong>，以此类推。</p><h1 id="第三章：同步、通信和死锁"><a href="#第三章：同步、通信和死锁" class="headerlink" title="第三章：同步、通信和死锁"></a>第三章：同步、通信和死锁</h1><p><a href="https://blog.csdn.net/Shangxingya/article/details/113799732">操作系统~进程同步与进程互斥的概念和实现方式_Listen-Y的博客-CSDN博客</a></p><h2 id="什么是进程同步？"><a href="#什么是进程同步？" class="headerlink" title="什么是进程同步？"></a>什么是进程同步？</h2><p><img src="https://img-blog.csdnimg.cn/img_convert/6bf12302e0c526b5e63e31f3d67167c8.png" alt=""></p><p>请看这个管道通信的例子，显然必须先往里面写了数据之后，才可以读数据，但是读数据和写数据是异步发生的，我们不知道实际的读写数据操作谁先谁后，所以需要用进程同步来解决这种问题。</p><p>同步亦称<strong>直接制约关系</strong>，它是指为完成某种任务而建立的两个或多个进程，这些进程因为需要在某些位置上协调它们的工作次序而产生的制约关系。进程间的直接制约关系就是<strong>源于它们之间的相互合作</strong>。</p><h2 id="什么是进程互斥？"><a href="#什么是进程互斥？" class="headerlink" title="什么是进程互斥？"></a>什么是进程互斥？</h2><p>一句话来解释就是对共享资源（也叫临界资源）的互斥访问的控制。共享资源就是多个进程之间的需要共享的资源，在一个进程使用的时候，另外一个进程必须等待（C++中可以使用std::unique_lock<std::mutex> std::lock_guard<std::mutex>来实现资源的互斥锁）。</p><p>实现资源互斥，需要遵循以下原则:1.空闲让进。2.忙则等待。3.有限等待。4. 让权等待。</p><h2 id="进程同步的实现方式"><a href="#进程同步的实现方式" class="headerlink" title="进程同步的实现方式"></a>进程同步的实现方式</h2><p>1、临界区：Critical Section 通过对多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问。</p><p>2、互斥量（Mutex）：为协调共同对一个共享资源的单独访问而设计的。</p><p>3、信号量（Semaphore）</p><p>4、事件：用来通知线程有一些事件已发生，从而启动后继任务的开始。</p><h2 id="进程互斥的实现方式"><a href="#进程互斥的实现方式" class="headerlink" title="进程互斥的实现方式"></a>进程互斥的实现方式</h2><p>软件算法：Peterson算法，给每个进程设置标志，为true代表此进程要求进入临界区。</p><p>硬件算法：</p><p>1、中断屏蔽方法：利用“开/关中断指令”实现（与原语的实现思想相同，即在某进程开始访问临界区到结束访问为止都不允许被中断，也就不能发生进程切换，因此也不可能发生两个线程同时访问临界区的情况)</p><p>2、测试并设置指令：系统利用TS指令来实现临界区的上锁和开锁原语操作（不可以中断的操作）。</p><p>3、对换指令：void SWAP(bool key, bool lock){ bool temp=b; b=a; a=tmep;}</p><h2 id="信号量和PV操作"><a href="#信号量和PV操作" class="headerlink" title="信号量和PV操作"></a>信号量和PV操作</h2><p><strong>1、一般信号量</strong></p><p><code>**typedef struct&#123; int value; struct pcb* list;&#125;**</code><strong>，</strong><code>**void P(semaphore s)&#123; s.value--; if(s.value&lt;0) sleep(s.list);&#125;**</code><strong>，</strong></p><p><code>**void V(semaphore s)&#123; s.value++; if(s.value&lt;=0) wakeup(s.list);&#125;**</code></p><p>上面就是PV操作的相关结构和函数，注意PV操作都是原语（Atomic Language）。</p><p>推论：</p><p>1）若<code>s.value&gt;0</code>，s.value代表可以使用的资源数量。</p><p>2）若<code>s.value&lt;0</code>，s.value代表等待队列中的进程数量。</p><p>3）通常P操作代表申请一个资源，v操作代表归还一个资源</p><p><strong>信号量解决的问题：</strong></p><ul><li>信号量实现互斥+ 信号量解决五位哲学家进餐问题+ 信号量解决生产者-消费者问题+ 信号量解决读者-写者问题+ 信号量解决睡眠理发师问题。</li></ul><h2 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h2><p>在管程中有一个很重要的东西，叫做条件变量。</p><p><a href="https://www.zhihu.com/question/68017337">怎样理解C++11中的条件变量？ - 知乎</a></p><p><a href="https://en.cppreference.com/w/cpp/thread/condition_variable">std::condition_variable - cppreference.com</a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>八大排序算法</title>
      <link href="/2023/06/20/pai-xu-suan-fa/"/>
      <url>/2023/06/20/pai-xu-suan-fa/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><h2 id="1、冒泡排序"><a href="#1、冒泡排序" class="headerlink" title="1、冒泡排序"></a>1、冒泡排序</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">void</span> <span class="token function">BubbleSort</span><span class="token punctuation">(</span>T a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> len<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> j<span class="token operator">&lt;</span>len<span class="token operator">-</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">></span>a<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token punctuation">&#123;</span>                <span class="token function">swap</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2、选择排序"><a href="#2、选择排序" class="headerlink" title="2、选择排序"></a>2、选择排序</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">void</span> <span class="token function">SelectSort</span><span class="token punctuation">(</span>T arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> len<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> min<span class="token operator">=</span>i<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span> j<span class="token operator">&lt;</span>len<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">&lt;</span>arr<span class="token punctuation">[</span>min<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                min<span class="token operator">=</span>j<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>min<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3、插入排序"><a href="#3、插入排序" class="headerlink" title="3、插入排序"></a>3、插入排序</h2><pre class="line-numbers language-none"><code class="language-none">template&lt;typename T&gt;void InsertSort(T arr[], int len)&#123;    for(int i&#x3D;1; i&lt;len; i++)&#123;        int key&#x3D;arr[i];        int j&#x3D;i-1;        while(j&gt;&#x3D;0 &amp;&amp; key&lt;arr[j])&#123;            arr[j+1]&#x3D;arr[j];            j--;        &#125;        arr[j+1]&#x3D;key;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4、希尔排序"><a href="#4、希尔排序" class="headerlink" title="4、希尔排序"></a>4、希尔排序</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">void</span> <span class="token function">ShellSort</span><span class="token punctuation">(</span>T arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> len<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> gap<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>gap<span class="token operator">&lt;</span>len<span class="token operator">/</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        gap<span class="token operator">=</span>gap<span class="token operator">*</span><span class="token number">3</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>gap<span class="token operator">>=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>gap<span class="token punctuation">;</span> i<span class="token operator">&lt;</span>len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span>i<span class="token punctuation">;</span> j<span class="token operator">></span>gap <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">&lt;</span>arr<span class="token punctuation">[</span>j<span class="token operator">-</span>gap<span class="token punctuation">]</span><span class="token punctuation">;</span> j<span class="token operator">-=</span>gap<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>j<span class="token operator">-</span>gap<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        gap<span class="token operator">/=</span><span class="token number">3</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5、快速排序"><a href="#5、快速排序" class="headerlink" title="5、快速排序"></a>5、快速排序</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">quickSort</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;</span> r<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> i<span class="token punctuation">,</span>j<span class="token punctuation">,</span>x<span class="token punctuation">;</span>        i <span class="token operator">=</span> l<span class="token punctuation">;</span>        j <span class="token operator">=</span> r<span class="token punctuation">;</span>        x <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j <span class="token operator">&amp;&amp;</span> a<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> x<span class="token punctuation">)</span>                j<span class="token operator">--</span><span class="token punctuation">;</span> <span class="token comment">// 从右向左找第一个小于x的数</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j<span class="token punctuation">)</span>                a<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j <span class="token operator">&amp;&amp;</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> x<span class="token punctuation">)</span>                i<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment">// 从左向右找第一个大于x的数</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j<span class="token punctuation">)</span>                a<span class="token punctuation">[</span>j<span class="token operator">--</span><span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">;</span><span class="token comment">// 将分割点放到正确位置</span>        <span class="token function">quickSort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> l<span class="token punctuation">,</span> i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* 递归调用 */</span>        <span class="token function">quickSort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* 递归调用 */</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="6、堆排序"><a href="#6、堆排序" class="headerlink" title="6、堆排序"></a>6、堆排序</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">sift_down</span><span class="token punctuation">(</span><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> parent <span class="token operator">=</span> start<span class="token punctuation">;</span>    <span class="token keyword">int</span> child <span class="token operator">=</span> <span class="token number">2</span><span class="token operator">*</span>start<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>child<span class="token operator">&lt;=</span>end<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>child<span class="token operator">+</span><span class="token number">1</span><span class="token operator">&lt;=</span>end <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>child<span class="token punctuation">]</span><span class="token operator">&lt;</span>arr<span class="token punctuation">[</span>child<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>            child<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>parent<span class="token punctuation">]</span><span class="token operator">></span>arr<span class="token punctuation">[</span>child<span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token punctuation">;</span>        <span class="token keyword">else</span><span class="token punctuation">&#123;</span>            <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>parent<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>child<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">//往下调整</span>            parent<span class="token operator">=</span>child<span class="token punctuation">;</span>            child<span class="token operator">=</span><span class="token number">2</span><span class="token operator">*</span>parent<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">heap_sort</span><span class="token punctuation">(</span><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> len<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//调整为大根堆，从最后一个父元素开始(len-1-1)/2</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token punctuation">(</span>len<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span> i<span class="token operator">>=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token function">sift_down</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> i<span class="token punctuation">,</span> len<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//将堆的根（最大值）掉换到最后一个元素（从小到大排序），在重新调整为大根堆</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>len<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">>=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">sift_down</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="7、归并排序"><a href="#7、归并排序" class="headerlink" title="7、归并排序"></a>7、归并排序</h2><p>一半一半砍开来，砍成只有两个元素之后，归并。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">void</span> <span class="token function">merge_sort1</span><span class="token punctuation">(</span>T arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> len<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    T<span class="token operator">*</span> a <span class="token operator">=</span> arr<span class="token punctuation">;</span>    T<span class="token operator">*</span> b <span class="token operator">=</span> <span class="token keyword">new</span> T<span class="token punctuation">[</span>len<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> seg <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> seg <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> seg <span class="token operator">+=</span> seg<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">//区间长度</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> start <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> start <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> start <span class="token operator">+=</span> seg <span class="token operator">+</span> seg<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> low <span class="token operator">=</span> start<span class="token punctuation">,</span> mid <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>start <span class="token operator">+</span> seg<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">,</span> high <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>start <span class="token operator">+</span> seg <span class="token operator">+</span> seg<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> k <span class="token operator">=</span> low<span class="token punctuation">;</span>            <span class="token keyword">int</span> start1 <span class="token operator">=</span> low<span class="token punctuation">,</span> end1 <span class="token operator">=</span> mid<span class="token punctuation">;</span>            <span class="token keyword">int</span> start2 <span class="token operator">=</span> mid<span class="token punctuation">,</span> end2 <span class="token operator">=</span> high<span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>start1 <span class="token operator">&lt;</span> end1 <span class="token operator">&amp;&amp;</span> start2 <span class="token operator">&lt;</span> end2<span class="token punctuation">)</span>                b<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>start1<span class="token punctuation">]</span> <span class="token operator">&lt;</span> a<span class="token punctuation">[</span>start2<span class="token punctuation">]</span> <span class="token operator">?</span> a<span class="token punctuation">[</span>start1<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">:</span> a<span class="token punctuation">[</span>start2<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>start1 <span class="token operator">&lt;</span> end1<span class="token punctuation">)</span>                b<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>start1<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>start2 <span class="token operator">&lt;</span> end2<span class="token punctuation">)</span>                b<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>start2<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        T<span class="token operator">*</span> temp <span class="token operator">=</span> a<span class="token punctuation">;</span>        a <span class="token operator">=</span> b<span class="token punctuation">;</span>        b <span class="token operator">=</span> temp<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">!=</span> arr<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">//这里没有看懂</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>            b<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        b <span class="token operator">=</span> a<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span> b<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="8、桶排序"><a href="#8、桶排序" class="headerlink" title="8、桶排序"></a>8、桶排序</h2><p>将数据放到到各个桶中，在插入数据的时候每个桶的数据保持有序，所以每个桶相当于是一个有序链表。最后将各个桶合并起来，即将各个链表Merge，形成一个有序的整体。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iterator></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;vector></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span> BUCKET_NUM <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token comment">// 桶的个数</span><span class="token comment">/** *链表结构体 */</span><span class="token keyword">struct</span> <span class="token class-name">ListNode</span><span class="token punctuation">&#123;</span><span class="token keyword">explicit</span> <span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">mData</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">mNext</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>ListNode<span class="token operator">*</span> mNext<span class="token punctuation">;</span><span class="token keyword">int</span> mData<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">/** * 插入的时候是有序的，返回值是头节点 */</span>ListNode<span class="token operator">*</span> <span class="token function">insert</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> head<span class="token punctuation">,</span><span class="token keyword">int</span> val<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>ListNode dummyNode<span class="token punctuation">;</span>ListNode <span class="token operator">*</span>newNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">ListNode</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>ListNode <span class="token operator">*</span>pre<span class="token punctuation">,</span><span class="token operator">*</span>curr<span class="token punctuation">;</span>dummyNode<span class="token punctuation">.</span>mNext <span class="token operator">=</span> head<span class="token punctuation">;</span>pre <span class="token operator">=</span> <span class="token operator">&amp;</span>dummyNode<span class="token punctuation">;</span>curr <span class="token operator">=</span> head<span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token operator">!=</span>curr <span class="token operator">&amp;&amp;</span> curr<span class="token operator">-></span>mData<span class="token operator">&lt;=</span>val<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>pre <span class="token operator">=</span> curr<span class="token punctuation">;</span>curr <span class="token operator">=</span> curr<span class="token operator">-></span>mNext<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>newNode<span class="token operator">-></span>mNext <span class="token operator">=</span> curr<span class="token punctuation">;</span>pre<span class="token operator">-></span>mNext <span class="token operator">=</span> newNode<span class="token punctuation">;</span><span class="token keyword">return</span> dummyNode<span class="token punctuation">.</span>mNext<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/** * 将两个链表合并，合并后仍然保持有序  */</span>ListNode<span class="token operator">*</span> <span class="token function">Merge</span><span class="token punctuation">(</span>ListNode <span class="token operator">*</span>head1<span class="token punctuation">,</span>ListNode <span class="token operator">*</span>head2<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>ListNode dummyNode<span class="token punctuation">;</span>ListNode <span class="token operator">*</span>dummy <span class="token operator">=</span> <span class="token operator">&amp;</span>dummyNode<span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token operator">!=</span>head1 <span class="token operator">&amp;&amp;</span> <span class="token constant">NULL</span><span class="token operator">!=</span>head2<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span><span class="token punctuation">(</span>head1<span class="token operator">-></span>mData <span class="token operator">&lt;=</span> head2<span class="token operator">-></span>mData<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>dummy<span class="token operator">-></span>mNext <span class="token operator">=</span> head1<span class="token punctuation">;</span>head1 <span class="token operator">=</span> head1<span class="token operator">-></span>mNext<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>dummy<span class="token operator">-></span>mNext <span class="token operator">=</span> head2<span class="token punctuation">;</span>head2 <span class="token operator">=</span> head2<span class="token operator">-></span>mNext<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>dummy <span class="token operator">=</span> dummy<span class="token operator">-></span>mNext<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token operator">!=</span>head1<span class="token punctuation">)</span> dummy<span class="token operator">-></span>mNext <span class="token operator">=</span> head1<span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token operator">!=</span>head2<span class="token punctuation">)</span> dummy<span class="token operator">-></span>mNext <span class="token operator">=</span> head2<span class="token punctuation">;</span><span class="token keyword">return</span> dummyNode<span class="token punctuation">.</span>mNext<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/** * 桶排序主体部分 */</span><span class="token keyword">void</span> <span class="token function">BucketSort</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>vector<span class="token operator">&lt;</span>ListNode<span class="token operator">*</span><span class="token operator">></span> <span class="token function">buckets</span><span class="token punctuation">(</span>BUCKET_NUM<span class="token punctuation">,</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 存的是每个桶的头节点，一个桶相当于是一个有序链表</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">int</span> index <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">/</span>BUCKET_NUM<span class="token punctuation">;</span> <span class="token comment">// 看要将数据放在哪个桶里面</span>ListNode <span class="token operator">*</span>head <span class="token operator">=</span> buckets<span class="token punctuation">.</span><span class="token function">at</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 局部变量</span>buckets<span class="token punctuation">.</span><span class="token function">at</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">insert</span><span class="token punctuation">(</span>head<span class="token punctuation">,</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 插入桶中</span><span class="token punctuation">&#125;</span>ListNode <span class="token operator">*</span>head <span class="token operator">=</span> buckets<span class="token punctuation">.</span><span class="token function">at</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 初始值是第0个桶</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>BUCKET_NUM<span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>head <span class="token operator">=</span> <span class="token function">Merge</span><span class="token punctuation">(</span>head<span class="token punctuation">,</span>buckets<span class="token punctuation">.</span><span class="token function">at</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 将两个桶合并</span><span class="token punctuation">&#125;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> head<span class="token operator">-></span>mData<span class="token punctuation">;</span>head <span class="token operator">=</span> head<span class="token operator">-></span>mNext<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="9、折半插入排序"><a href="#9、折半插入排序" class="headerlink" title="9、折半插入排序"></a>9、折半插入排序</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">void</span> <span class="token function">insertSort1</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token operator">&amp;</span>v<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> n<span class="token operator">=</span>v<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> l<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> r<span class="token operator">=</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        T key<span class="token operator">=</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> mid<span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>l<span class="token operator">&lt;=</span>r<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            mid<span class="token operator">=</span><span class="token punctuation">(</span>l<span class="token operator">+</span>r<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>key <span class="token operator">&lt;</span> v<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">)</span> r<span class="token operator">=</span>mid<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> l<span class="token operator">=</span>mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>            <span class="token comment">//寻找第一个大于key的位置，所以直接使用else，&lt;=的元素都不需要管</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">int</span> k<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>k<span class="token operator">=</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> k<span class="token operator">></span>r<span class="token punctuation">;</span> k<span class="token operator">--</span><span class="token punctuation">)</span> v<span class="token punctuation">[</span>k<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span>v<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>        v<span class="token punctuation">[</span>k<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span>key<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> c++基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>string底层实现之SSO</title>
      <link href="/2023/06/20/string-di-ceng-shi-xian-zhi-sso/"/>
      <url>/2023/06/20/string-di-ceng-shi-xian-zhi-sso/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="string底层实现之SSO"><a href="#string底层实现之SSO" class="headerlink" title="string底层实现之SSO"></a>string底层实现之SSO</h1><p><a href="https://cplusplus.com/reference/string/string/string/">string的构造函数</a></p><p><a href="https://www.ccppcoding.com/archives/1199">参考资料</a></p><p>Simple String Optimization，最小字符串优化，基本原理是：<strong>当分配的字节数小于16字节的时候，直接从栈上进行进行内存分配，如果大于16字节，则在堆上进行内存分配。</strong></p><p>验证一下：</p><pre class="line-numbers language-none"><code class="language-none">#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;stdlib.h&gt;using namespace std;void *operator new(size_t n)&#123;    cout&lt;&lt;&quot;new size&#x3D;&quot;&lt;&lt;n;    return malloc(n);&#125;void operator delete(void* p)&#123;    free(p);&#125;int main()&#123;    for(int i&#x3D;0; i&lt;30; i++)&#123;        cout&lt;&lt;&quot;i&#x3D;&quot;&lt;&lt;i&lt;&lt;&quot;: &quot;&lt;&lt;string(i, &#39;&#x3D;&#39;)&lt;&lt;endl;    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里对new进行了重载，以便我们观察是否调用的new。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@***********************:~<span class="token comment"># g++ -o test test.cpp </span>root@***********************:~<span class="token comment"># ./test</span><span class="token assign-left variable">i</span><span class="token operator">=</span><span class="token number">0</span>: <span class="token assign-left variable">i</span><span class="token operator">=</span><span class="token number">1</span>: <span class="token operator">=</span><span class="token assign-left variable">i</span><span class="token operator">=</span><span class="token number">2</span>: <span class="token operator">==</span><span class="token assign-left variable">i</span><span class="token operator">=</span><span class="token number">3</span>: <span class="token operator">==</span><span class="token operator">=</span><span class="token assign-left variable">i</span><span class="token operator">=</span><span class="token number">4</span>: <span class="token operator">==</span><span class="token operator">==</span><span class="token assign-left variable">i</span><span class="token operator">=</span><span class="token number">5</span>: <span class="token operator">==</span><span class="token operator">==</span><span class="token operator">=</span><span class="token assign-left variable">i</span><span class="token operator">=</span><span class="token number">6</span>: <span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token assign-left variable">i</span><span class="token operator">=</span><span class="token number">7</span>: <span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">=</span><span class="token assign-left variable">i</span><span class="token operator">=</span><span class="token number">8</span>: <span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token assign-left variable">i</span><span class="token operator">=</span><span class="token number">9</span>: <span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">=</span><span class="token assign-left variable">i</span><span class="token operator">=</span><span class="token number">10</span>: <span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token assign-left variable">i</span><span class="token operator">=</span><span class="token number">11</span>: <span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">=</span><span class="token assign-left variable">i</span><span class="token operator">=</span><span class="token number">12</span>: <span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token assign-left variable">i</span><span class="token operator">=</span><span class="token number">13</span>: <span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">=</span><span class="token assign-left variable">i</span><span class="token operator">=</span><span class="token number">14</span>: <span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token assign-left variable">i</span><span class="token operator">=</span><span class="token number">15</span>: <span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">=</span><span class="token assign-left variable">i</span><span class="token operator">=</span><span class="token number">16</span>: new <span class="token assign-left variable">size</span><span class="token operator">=</span><span class="token number">17</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token assign-left variable">i</span><span class="token operator">=</span><span class="token number">17</span>: new <span class="token assign-left variable">size</span><span class="token operator">=</span><span class="token number">18</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">=</span><span class="token assign-left variable">i</span><span class="token operator">=</span><span class="token number">18</span>: new <span class="token assign-left variable">size</span><span class="token operator">=</span><span class="token number">19</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token assign-left variable">i</span><span class="token operator">=</span><span class="token number">19</span>: new <span class="token assign-left variable">size</span><span class="token operator">=</span><span class="token number">20</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">=</span><span class="token assign-left variable">i</span><span class="token operator">=</span><span class="token number">20</span>: new <span class="token assign-left variable">size</span><span class="token operator">=</span><span class="token number">21</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token assign-left variable">i</span><span class="token operator">=</span><span class="token number">21</span>: new <span class="token assign-left variable">size</span><span class="token operator">=</span><span class="token number">22</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">=</span><span class="token assign-left variable">i</span><span class="token operator">=</span><span class="token number">22</span>: new <span class="token assign-left variable">size</span><span class="token operator">=</span><span class="token number">23</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token assign-left variable">i</span><span class="token operator">=</span><span class="token number">23</span>: new <span class="token assign-left variable">size</span><span class="token operator">=</span><span class="token number">24</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">=</span><span class="token assign-left variable">i</span><span class="token operator">=</span><span class="token number">24</span>: new <span class="token assign-left variable">size</span><span class="token operator">=</span><span class="token number">25</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token assign-left variable">i</span><span class="token operator">=</span><span class="token number">25</span>: new <span class="token assign-left variable">size</span><span class="token operator">=</span><span class="token number">26</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">=</span><span class="token assign-left variable">i</span><span class="token operator">=</span><span class="token number">26</span>: new <span class="token assign-left variable">size</span><span class="token operator">=</span><span class="token number">27</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token assign-left variable">i</span><span class="token operator">=</span><span class="token number">27</span>: new <span class="token assign-left variable">size</span><span class="token operator">=</span><span class="token number">28</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">=</span><span class="token assign-left variable">i</span><span class="token operator">=</span><span class="token number">28</span>: new <span class="token assign-left variable">size</span><span class="token operator">=</span><span class="token number">29</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token assign-left variable">i</span><span class="token operator">=</span><span class="token number">29</span>: new <span class="token assign-left variable">size</span><span class="token operator">=</span><span class="token number">30</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">=</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这就说明当字符串长度小于16时，是在栈上面分配内存，大于16的时候，在堆上分配内存，也就是调用了new方法。</p>]]></content>
      
      
      <categories>
          
          <category> c++进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Static、#define、const、mutable、typedef</title>
      <link href="/2023/06/20/staticdefineconstmutabletypedef/"/>
      <url>/2023/06/20/staticdefineconstmutabletypedef/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="Static、-define、const、mutable、typedef"><a href="#Static、-define、const、mutable、typedef" class="headerlink" title="Static、#define、const、mutable、typedef"></a>Static、#define、const、mutable、typedef</h1><p>代码存储区域：常量区、代码区、静态区（全局区）、堆区、栈区</p><p>栈区向下增长，堆区向上增长。<strong>栈由系统管理，没有内存碎片，每个元素之间都是连续的，大小比较小，8k，可以修改系统参数</strong>，堆区存储动态开辟的变量。</p><p>还有一个内核空间，但是它不与用户直接交互（内核区）。</p><p><img src="https://img-blog.csdnimg.cn/03ce5015530048e18593741047e6988d.png#pic_center" alt=""></p><h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><p>修饰局部变量：局部变量的存储区域改变、变为静态区，生命周期改为程序结束才销毁。</p><p>修饰全局变量：全局变量只能在本文件中访问，不能在其它文件中访问， <strong>extern 外部声明</strong>也不可以。</p><p>修饰成员变量：静态成员变量不属于实体的类对象，要在类外初始化</p><p>修饰成员函数：静态函数<strong>属于类不属于类对象</strong> 需要通过类作用域调用 <strong>函数无this指针</strong>(静态成员函数仅能访问静态的数据成员，不能访问非静态的数据成员，也不能访问非静态的成员函数)</p><h2 id="define"><a href="#define" class="headerlink" title="#define"></a>#define</h2><p>带参数的宏定义可以减少函数调用的开销，在运行时只是简单的展开。</p><h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><p>申明一个常量，在运行期间可以进行类型检查。</p><h2 id="mutable"><a href="#mutable" class="headerlink" title="mutable"></a>mutable</h2><p>mutable为可变的，易变的跟C++中的const是反义词。被mutable修饰的变量(mutable智能用于修饰类的非静态数据成员)<strong>,将永远处于可变的状态</strong>, 即使在一个const函数中</p><h2 id="typedef"><a href="#typedef" class="headerlink" title="typedef"></a>typedef</h2><p>用途： 1、为名称复杂的变量创建别名； 2、创建与平台无关的变量，当跨平台时，只要改下 typedef 本身就行，不用对其他源码做任何修改。 另外，因为typedef是定义了一种类型的新别名，不是简单的字符串替换，所以它比宏来得稳健（虽然用宏有时也可以完成以上的用途）。 比如：<a href="https://en.cppreference.com/w/cpp/types/size_t">size_t的介绍</a></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 在vs中，short 2个字节，int 4个，long也是4个，long long 8个</span><span class="token keyword">typedef</span> <span class="token keyword">short</span> <span class="token keyword">int16_t</span><span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">int</span> <span class="token keyword">int32_t</span><span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">long</span> <span class="token keyword">long</span> <span class="token keyword">int64_t</span><span class="token punctuation">;</span><span class="token comment">// 在Linux下，short 2个，int 4 个，long 8个，long long 也是8个</span><span class="token keyword">typedef</span> <span class="token keyword">short</span> <span class="token keyword">int16_t</span><span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">int</span> <span class="token keyword">int32_t</span><span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">long</span> <span class="token keyword">int64_t</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>所以在程序源码中，只使用这些在头文件中声明的别名。 参考：<a href="https://www.cnblogs.com/Solomon-xm/articles/9140576.html">typedef用法详解</a></p>]]></content>
      
      
      <categories>
          
          <category> c++基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Reactor模式理论支持</title>
      <link href="/2023/06/20/reactor-mo-shi-li-lun-zhi-chi/"/>
      <url>/2023/06/20/reactor-mo-shi-li-lun-zhi-chi/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p><strong>目录</strong></p><p><a href="#1.%20%E5%89%8D%E8%A8%80">1. 前言</a></p><p><a href="#2%E3%80%81%E4%B8%BB%E8%A6%81%E6%80%9D%E6%83%B3">2、主要思想</a></p><p><a href="#3%E3%80%81%E4%B8%89%E7%A7%8D%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AE%9E%E7%8E%B0">3、三种不同的实现</a></p><p><a href="#%E5%8D%95%20Reactor%20%E5%8D%95%E7%BA%BF%E7%A8%8B">单 Reactor 单线程</a></p><p><a href="#%E5%8D%95%20Reactor%20%E5%A4%9A%E7%BA%BF%E7%A8%8B">单 Reactor 多线程</a></p><p><a href="#%E4%B8%BB%E4%BB%8E%20Reactor%20%E5%A4%9A%E7%BA%BF%E7%A8%8B">主从 Reactor 多线程</a></p><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>开始的服务端的设计是每一个连接都创建一个thread去处理，但是当请求开始变多了之后，比如有1w的request到达服务端，就会 <strong>pthread_create() </strong>创建1w个thread，结束之后销毁线程。这样的创建，处理完然后销毁无疑是非常消耗资源的。</p><p>之后就升级，采用线程池处理请求，提前在一个队列中创建多个线程，从线程池取出线程处理。还有要注意，这个线程队列是全局共享的，为了避免多个线程竞争，要提前给这个线程加锁。</p><p>采用线程池处理主要有两个原因：1、不用频繁的创建和销毁线程。2、线程池能处理的线程有上限，可以防止无限开辟线程而将服务器资源消耗殆尽，挂掉。</p><p>线程池：<a href="https://en.wikipedia.org/wiki/Thread_pool">https://en.wikipedia.org/wiki/Thread_pool</a></p><p>实现：<a href="https://github.com/progschj/ThreadPool/blob/master/ThreadPool.h">ThreadPool/ThreadPool.h at master · progschj/ThreadPool · GitHub</a></p><p>其实在上面的模型是个【<strong>多线程模型</strong>】，其实还有一种【<strong>多进程模型</strong>】。主要思想是利用<strong> fork()</strong> 函数，创建子进程。父进程要处理好自己的孩子，就是在进程退出的时候要回收好资源，否则可能变成【僵尸进程】（进程只保留了相关的信息，但是占用了进程号）。怎么回收资源呢？答案是调用【<strong>wait()</strong>】和【<strong>waitpid()</strong>】。在这个过程中，对父进程和子进程的处理是不相同的：</p><ul><li>父进程：只需要管理监听的 【Socket】描述符，而不关心已经连接的【Socket】+ 子进程：只关心已经连接的【Socket】，不用管监听的【Socket】</li></ul><p>上面两个模型，【<strong>多线程模型</strong>】缺点主要是服务端如果同时维护多个线程是不现实的，操作系统会扛不住；【<strong>多进程模型</strong>】缺点则是在多个连接同时存在的情况下进程的上下文切换所耗费的系统资源过大。这个时候更为设计一种高效的模式是当务之急，【<strong>Reactor模式</strong>】应运而生</p><h2 id="2、主要思想"><a href="#2、主要思想" class="headerlink" title="2、主要思想"></a>2、主要思想</h2><p>【<strong>Reactor模式</strong>】基于【<strong>select/poll/epoll</strong>】的【<strong>IO多路复用</strong>】进行了一层封装，使得我们在编写网络程序的时候，不需要考虑底层API的细节，符合当下面向对象的思想。</p><p> IO复用：<a href="https://mp.weixin.qq.com/s/Qpa0qXxuIM8jrBqDaXmVNA">这次答应我，一举拿下 I/O 多路复用！</a></p><p>【<strong>Reactor模式</strong>】的 Reactor 的翻译是反应堆，意思是只要来了一个事件，Reactor 就有反应。</p><p>Reactor主要包括两个部分：Reactor 和处理资源池。</p><ul><li>Reactor 负责监听事件和分发事件，事件可能是读写事件或连接事件。+ 处理资源池将Reactor 分发给他的事件，主要的流程：Read-&gt;处理业务-&gt;Send</li></ul><p>因此 【<strong>Reactor模式</strong>】也叫【<strong>Dispatcher 模式】</strong>，一个主线程负责监听和分发事件，其他的线程处理业务，所以这个名字应该更加的贴切。</p><p>目的是减少等待，当遇到需要等待的IO的时候，先释放资源，在IO完成之后，通过事件驱动的方式没继续接下来的处理。</p><p>根据 Reactor 的数量和处理资源池线程的数量不同，有 3 种典型的实现：</p><ul><li>单 Reactor 单线程 +  单 Reactor 多线程 +  主从 Reactor 多线程 </li></ul><h2 id="3、三种不同的实现"><a href="#3、三种不同的实现" class="headerlink" title="3、三种不同的实现"></a>3、三种不同的实现</h2><h3 id="单-Reactor-单线程"><a href="#单-Reactor-单线程" class="headerlink" title="单 Reactor 单线程"></a>单 Reactor 单线程</h3><p>话不多说，先看一个图片。</p><p><img src="https://img-blog.csdnimg.cn/8a592a409ca64f1eba4ef26fc02d9917.png" alt=""></p><p> 首先从图中可以看到：</p><ul><li>Reactor 处理监听以及事件的分发+ Accept 处理连接+ Handler 处理IO事件以及业务</li></ul><p>下面详细介绍下流程：</p><ul><li>【<strong>Reactor</strong>】通过 select（IO多路复用接口）监听多个 Socket ，如果 Socket 有事件发生，判断事件类别后看看分配给【<strong>Acceptor</strong>】，还是【<strong>Handler</strong>】。+ 如果是建立连接事件，交付给【<strong>Acceptor</strong>】处理，【<strong>Acceptor</strong>】会创建一个【<strong>Handler</strong>】来处理这个刚连接的 Socket 的后续事件。+ 如果是处理非连接事件，交付给【<strong>Handler</strong>】处理，一般处理过程：read-&gt;业务处理-&gt;send。</li></ul><p>缺点是无法利用CPU多核的能力</p><p>应用场景：Redis使用的就是这种模式，但是它是在内存中处理业务的，所以处理起来很快。</p><h3 id="单-Reactor-多线程"><a href="#单-Reactor-多线程" class="headerlink" title="单 Reactor 多线程"></a>单 Reactor 多线程</h3><p>看一下流程图</p><p><img src="https://img-blog.csdnimg.cn/93aaef58ff03418da459b6110980b9e4.png" alt=""></p><p>流程：</p><ul><li>【<strong>Reactor</strong>】通过 select（IO多路复用接口）监听多个 Socket ，如果 Socket 有事件发生，判断事件类别后看看分配给【<strong>Acceptor</strong>】，还是【<strong>Handler</strong>】。+ 如果是建立连接事件，交付给【<strong>Acceptor</strong>】处理，【<strong>Acceptor</strong>】会创建一个【<strong>Handler</strong>】来处理这个刚连接的 Socket 的后续事件。+ 如果是处理非连接事件，交付给【<strong>Handler</strong>】处理。</li></ul><p>上面的三个步骤和单 Reactor 单线程方案是一样的，接下来的步骤就开始不一样了：</p><ul><li>【<strong>Handler</strong>】 对象不再负责业务处理，只负责数据的接收和发送，【<strong>Handler</strong>】 对象通过 read 读取到数据后，会将数据发给子线程里的 【<strong>Processor</strong>】 对象进行业务处理；+ 子线程里的 【<strong>Processor</strong>】 对象就进行业务处理，处理完后，将结果发给主线程中的 【<strong>Handler</strong>】对象，接着由 【<strong>Handler</strong>】通过 send 方法将响应结果发送给 client；</li></ul><h3 id="主从-Reactor-多线程"><a href="#主从-Reactor-多线程" class="headerlink" title="主从 Reactor 多线程"></a>主从 Reactor 多线程</h3><p>流程：</p><ul><li>主线程中的 MainReactor 对象通过 select 监控连接建立事件，收到事件后通过 Acceptor 对象中的 accept 获取连接，将新的连接分配给某个子线程；+ 子线程中的 SubReactor 对象将 MainReactor 对象分配的连接加入 select 继续进行监听，并创建一个 Handler 用于处理连接的响应事件。+ 如果有新的事件发生时，SubReactor 对象会调用当前连接对应的 Handler 对象来进行响应。+ Handler 对象通过 read -&gt; 业务处理 -&gt; send 的流程来完成完整的业务流程。</li></ul><p><a href="https://www.zhihu.com/question/26943938/answer/1856426252">如何深刻理解Reactor和Proactor？ - 知乎</a></p><p><a href="https://www.modb.pro/db/189720">从Reactor模式俯瞰Nginx，你会发现你与高手的差距就在设计模式上，不在内卷上 - 墨天轮</a></p>]]></content>
      
      
      <categories>
          
          <category> c++进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>QT中国象棋初版</title>
      <link href="/2023/06/20/qt-zhong-guo-xiang-qi-chu-ban/"/>
      <url>/2023/06/20/qt-zhong-guo-xiang-qi-chu-ban/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="Chinese-Chess"><a href="#Chinese-Chess" class="headerlink" title="Chinese-Chess"></a>Chinese-Chess</h1><p>中国象棋初版</p><p>实现了单人双方对战、人对战电脑、开两个客户端联机对战</p><pre class="line-numbers language-none"><code class="language-none">佛曰: *          写字楼里写字间，写字间里程序员； *          程序人员写程序，又拿程序换酒钱。 *          酒醒只在网上坐，酒醉还来网下眠； *          酒醉酒醒日复日，网上网下年复年。 *          但愿老死电脑间，不愿鞠躬老板前； *          奔驰宝马贵者趣，公交自行程序员。 *          别人笑我忒疯癫，我笑自己命太贱； *          不见满街漂亮妹，哪个归得程序员？<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="界面展示"><a href="#界面展示" class="headerlink" title="界面展示"></a>界面展示</h2><h3 id="主菜单界面："><a href="#主菜单界面：" class="headerlink" title="主菜单界面："></a>主菜单界面：</h3><p><img src="https://img-blog.csdnimg.cn/0460f32b642f4d29862cfe1d8effac0e.png#pic_center" alt=""></p><p>主界面部分代码：</p><pre class="line-numbers language-none"><code class="language-none">#include &quot;choosemainwindow.h&quot;ChooseMainWindow::ChooseMainWindow(QWidget *parent) : QDialog(parent)&#123;    this-&gt;setWindowTitle(&quot;选择游戏方式&quot;);    this-&gt;setFixedSize(250,120);    this-&gt;setWindowIcon(QIcon(&quot;:&#x2F;images&#x2F;chess.svg&quot;));    QVBoxLayout* lay &#x3D; new QVBoxLayout(this);    lay-&gt;addWidget(m_buttons[0] &#x3D; new QPushButton(&quot;玩家自己对战&quot;));    lay-&gt;addWidget(m_buttons[1] &#x3D; new QPushButton(&quot;玩家和AI对战&quot;));    lay-&gt;addWidget(m_buttons[2] &#x3D; new QPushButton(&quot;双人网络对战&quot;));    &#x2F;*游戏方式一: 自己和自己下棋【同一台PC机器】*&#x2F;    connect(m_buttons[0], &amp;QPushButton::clicked,[&#x3D;]()&#123;        this-&gt;hide();        m_pAgainstYourself &#x3D; new ChessBoard();        m_pAgainstYourself-&gt;setWindowTitle(&quot;玩家自己对战&quot;);        m_pAgainstYourself-&gt;show();        &#x2F;&#x2F;返回主窗口        connect(m_pAgainstYourself,&amp;ChessBoard::toMenu,[&#x3D;]()&#123;            m_pAgainstYourself-&gt;close();            this-&gt;show();        &#125;);    &#125;);    &#x2F;*游戏方式二: 自己和电脑下棋【同一台PC机器】*&#x2F;    connect(m_buttons[1], &amp;QPushButton::clicked,[&#x3D;]()&#123;        this-&gt;hide();        m_pRobotGame &#x3D; new RobotGame();        m_pRobotGame-&gt;setWindowTitle(&quot;玩家和AI对战&quot;);        m_pRobotGame-&gt;show();        &#x2F;&#x2F;返回主窗口        connect(m_pRobotGame,&amp;ChessBoard::toMenu,[&#x3D;]()&#123;            m_pRobotGame-&gt;close();            this-&gt;show();        &#125;);    &#125;);    &#x2F;*游戏方式三: 双人局域网下棋【可在局域网下不同台PC机器】*&#x2F;    connect(m_buttons[2], &amp;QPushButton::clicked,[&#x3D;]()&#123;        this-&gt;hide();        QMessageBox::StandardButtons ret &#x3D; QMessageBox::question(NULL, &quot;提示&quot;, &quot;是否作为服务器启动[选择红方]?&quot;);        bool bServer &#x3D; false;        if(ret &#x3D;&#x3D; QMessageBox::Yes)            bServer &#x3D; true;        m_pNetworkGame &#x3D; new NetworkGame(bServer);        m_pNetworkGame-&gt;setWindowTitle(&quot;双人网络对战&quot;);        m_pNetworkGame-&gt;show();        &#x2F;&#x2F;返回主窗口        connect(m_pNetworkGame,&amp;ChessBoard::toMenu,[&#x3D;]()&#123;            m_pNetworkGame-&gt;close();            this-&gt;show();        &#125;);    &#125;);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="玩家和自己对战界面："><a href="#玩家和自己对战界面：" class="headerlink" title="玩家和自己对战界面："></a>玩家和自己对战界面：</h3><p><img src="https://img-blog.csdnimg.cn/ddce9e5977c9405488ea8601f44ce0d2.png#pic_center" alt=""></p><p>棋盘绘制部分代码：</p><pre class="line-numbers language-none"><code class="language-none">void ChessBoard::paintEvent(QPaintEvent *)&#123;    QPainter painter(this);    painter.setRenderHint(QPainter::Antialiasing, true);&#x2F;&#x2F;渲染提示    int side &#x3D; qMin(int(ui-&gt;centralwidget-&gt;width() - ui-&gt;rightWidget-&gt;width()), ui-&gt;label-&gt;height());    painter.scale(side &#x2F; 960.0, side &#x2F; 960.0);    m_offset &#x3D; 60;              &#x2F;&#x2F;距离界面的边距    m_distance &#x3D; 90;            &#x2F;&#x2F;间距为90px    m_radius &#x3D; m_distance&#x2F;2;    &#x2F;&#x2F;棋子半径为d&#x2F;2    for(int i &#x3D; 0; i &lt;10; i++)&#123;        painter.drawLine(QPoint(m_offset, m_offset+i*m_distance), QPoint(m_offset+8*m_distance, m_offset+i*m_distance));    &#125;    for(int i&#x3D;0; i&lt;9; i++)&#123;        if(i&#x3D;&#x3D;0 || i&#x3D;&#x3D;8)&#123;            painter.drawLine(QPoint(m_offset+i*m_distance, m_offset), QPoint(m_offset+i*m_distance, m_offset+9*m_distance));        &#125;else&#123;            painter.drawLine(QPoint(m_offset+i*m_distance, m_offset), QPoint(m_offset+i*m_distance, m_offset+4*m_distance));            painter.drawLine(QPoint(m_offset+i*m_distance, m_offset+5*m_distance), QPoint(m_offset+i*m_distance, m_offset+9*m_distance));        &#125;    &#125;    painter.drawLine(QPoint(m_offset+3*m_distance, m_offset), QPoint(m_offset+5*m_distance, m_offset+2*m_distance));    painter.drawLine(QPoint(m_offset+3*m_distance, m_offset+2*m_distance), QPoint(m_offset+5*m_distance, m_offset));    painter.drawLine(QPoint(m_offset+3*m_distance, m_offset+7*m_distance), QPoint(m_offset+5*m_distance, m_offset+9*m_distance));    painter.drawLine(QPoint(m_offset+3*m_distance, m_offset+9*m_distance), QPoint(m_offset+5*m_distance, m_offset+7*m_distance));    QRect rect1(m_offset+m_distance,   m_offset+4*m_distance, m_distance, m_distance);    QRect rect2(m_offset+2*m_distance, m_offset+4*m_distance, m_distance, m_distance);    QRect rect3(m_offset+5*m_distance, m_offset+4*m_distance, m_distance, m_distance);    QRect rect4(m_offset+6*m_distance, m_offset+4*m_distance, m_distance, m_distance);    painter.setFont(QFont(&quot;FangSong&quot;, m_radius * 5 &#x2F; 6, 800));    painter.drawText(rect1, &quot;楚&quot;, QTextOption(Qt::AlignCenter));    painter.drawText(rect2, &quot;河&quot;, QTextOption(Qt::AlignCenter));    painter.drawText(rect3, &quot;汉&quot;, QTextOption(Qt::AlignCenter));    painter.drawText(rect4, &quot;界&quot;, QTextOption(Qt::AlignCenter));    &#x2F;&#x2F;*******************绘画棋子*******************    &#x2F;&#x2F;绘制上次移动棋子的起止位置    if(m_isShowStep)        drawLastStep(painter,m_chessSteps);    for(int i &#x3D; 0; i &lt; 32; i++)        drawChessPieces(painter, i);    &#x2F;&#x2F;绘制文本棋谱    drawTextStep();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="玩家和AI对战界面："><a href="#玩家和AI对战界面：" class="headerlink" title="玩家和AI对战界面："></a>玩家和AI对战界面：</h3><p><img src="https://img-blog.csdnimg.cn/275f7732d6ca46488f458bb459f0dec3.png#pic_center" alt=""></p><p>其实并不算是真正的AI，算法实现的是只要有可以吃到的子，就会直接吃掉，有多个可以吃掉的子，会计算各个棋子的得分，没有就随便走一步。</p><p>部分实现代码：</p><pre class="line-numbers language-none"><code class="language-none">ChessStep *RobotGame::getBestMove()&#123;    int maxScore &#x3D; -10000;    ChessStep* retStep &#x3D; NULL;    &#x2F;&#x2F;有可击杀的红棋子就走击杀红棋子最优的一步    &#x2F;&#x2F; 1.看看有那些步骤可以走    QVector&lt;ChessStep*&gt; steps;    getAllPossibleMoveStep(steps);    &#x2F;&#x2F;没有可击杀的红棋子就走最后的一步    QVector&lt;ChessStep*&gt; stepsAndNoKill;    getAllPossibleMoveStepAndNoKill(stepsAndNoKill);    &#x2F;&#x2F;2.试着走一下    for(QVector&lt;ChessStep*&gt;::iterator it &#x3D; steps.begin(); it!&#x3D;steps.end(); it++)    &#123;        ChessStep* step &#x3D; *it;        fakeMove(step);        int score &#x3D; calcScore();   &#x2F;&#x2F;3.计算最好的局面分        unFakeMove(step);        if(score &gt; maxScore)        &#123;            maxScore &#x3D; score;            retStep &#x3D; step;        &#125;    &#125;    if(retStep !&#x3D; NULL)        return retStep;    &#x2F;&#x2F;2.试着走一下    &#x2F;&#x2F;从这种不击杀红棋子，只是单纯移动黑棋steps里面，随机抽选一种进行下棋    int nStepsCount &#x3D; stepsAndNoKill.count();    qsrand(QTime(0,0,0).secsTo(QTime::currentTime()));    int temp &#x3D;qrand()% nStepsCount;    QVector&lt;ChessStep*&gt;::iterator it &#x3D; stepsAndNoKill.begin();    retStep &#x3D; it[temp];    if(retStep &#x3D;&#x3D; NULL)        whoWin();    return retStep;&#125;int RobotGame::calcScore()&#123;    &#x2F;&#x2F;enum m_emTYPE&#123;JIANG, SHI, XIANG, MA, CHE, PAO, BING&#125;;    &#x2F;&#x2F;黑棋分数 - 红棋分数    int redGrossScore &#x3D; 0;    int blackGrossScore &#x3D; 0;    static int chessScore[]&#x3D;&#123;200, 20, 40, 60, 100, 80, 10&#125;;    for(int i&#x3D;0; i&lt;16; i++)    &#123;        if(m_chessPieces[i].m_isDead)            continue;        blackGrossScore +&#x3D; chessScore[m_chessPieces[i].m_emType];    &#125;    for(int i&#x3D;16; i&lt;32; i++)    &#123;        if(m_chessPieces[i].m_isDead)            continue;        redGrossScore +&#x3D; chessScore[m_chessPieces[i].m_emType];    &#125;    return (blackGrossScore - redGrossScore);&#125;void RobotGame::getAllPossibleMoveStep(QVector&lt;ChessStep *&gt; &amp;steps)&#123;    for(int id &#x3D; 0; id&lt;16; id++)&#123;        if(m_chessPieces[id].m_isDead)            continue;        for(int row&#x3D;0; row&lt;10; row++)&#123;            for(int col&#x3D;0; col&lt;9; col++)&#123;                int i &#x3D; 16;             &#x2F;&#x2F;机器人是黑方                for( ; i &lt;&#x3D; 31; i++)&#123;                    if(m_chessPieces[i].m_row &#x3D;&#x3D; row &amp;&amp; m_chessPieces[i].m_col &#x3D;&#x3D; col &amp;&amp; m_chessPieces[i].m_isDead &#x3D;&#x3D; false)                        break;                &#125;                if(i!&#x3D;32)&#123;                    if(canMove(id, i, row, col))                        saveStep(id, i, row, col, steps);                &#125;            &#125;        &#125;    &#125;&#125;&#x2F;&#x2F; 该函数实现了一个棋类游戏中所有未死亡的棋子在棋盘上所有能够不吃子移动的走法的获取void RobotGame::getAllPossibleMoveStepAndNoKill(QVector&lt;ChessStep *&gt; &amp;steps)&#123;    for(int id &#x3D; 0; id&lt;16; id++)&#123;        if(m_chessPieces[id].m_isDead)            continue;        for(int row&#x3D;0; row&lt;10; row++)&#123;            for(int col&#x3D;0; col&lt;9; col++)&#123;                int i &#x3D; 0;                for( ; i &lt;&#x3D; 31; i++)&#123;                    if(m_chessPieces[i].m_row &#x3D;&#x3D; row &amp;&amp; m_chessPieces[i].m_col &#x3D;&#x3D; col &amp;&amp; m_chessPieces[i].m_isDead &#x3D;&#x3D; false)                        break;                &#125;                if(id &lt; 16 &amp;&amp; i &#x3D;&#x3D;32)&#123;&#x2F;&#x2F;-1??????                    if(canMove(id, -1, row, col))                        saveStep(id, -1, row, col, steps);                &#125;            &#125;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="双人网络对战："><a href="#双人网络对战：" class="headerlink" title="双人网络对战："></a>双人网络对战：</h3><p><img src="https://img-blog.csdnimg.cn/48f372c15d034afe8999976ad3bf4b1a.png#pic_center" alt=""></p><p><img src="https://img-blog.csdnimg.cn/585ab690769343649521236e64f5f9a2.png#pic_center" alt=""></p><p>部分代码展示：</p><pre class="line-numbers language-none"><code class="language-none">#include &quot;networkgame.h&quot;NetworkGame::NetworkGame(bool isServer)&#123;    m_tcpServer &#x3D; nullptr;    m_tcpSocket &#x3D; nullptr;    if(isServer)&#123;        m_isTcpServer &#x3D; true;        m_tcpServer &#x3D; new QTcpServer(this);        m_tcpServer-&gt;listen(QHostAddress::Any, 5555);        connect(m_tcpServer, &amp;QTcpServer::newConnection, this, &amp;NetworkGame::slotNewConnection);    &#125; else &#123;        m_isTcpServer &#x3D; false;        m_tcpSocket &#x3D; new QTcpSocket(this);        m_tcpSocket-&gt;connectToHost(QHostAddress(&quot;127.0.0.1&quot;), 5555);        connect(m_tcpSocket, &amp;QTcpSocket::readyRead, this, &amp;NetworkGame::slotRecv);    &#125;&#125;NetworkGame::~NetworkGame()&#123;&#125;void NetworkGame::clickPieces(int id, int row, int col)&#123;    if(m_isTcpServer)&#123;        if(m_selectID &#x3D;&#x3D; -1 &amp;&amp; m_checkedID &#x3D;&#x3D; -1)&#123;            if(m_isTcpServer !&#x3D; m_chessPieces[id].m_isRed)                return ;        &#125;    &#125; else &#123;        if(m_selectID &#x3D;&#x3D; -1 &amp;&amp; m_checkedID &#x3D;&#x3D; -1)&#123;            if(m_isTcpServer !&#x3D; m_chessPieces[id].m_isRed)                return ;        &#125;    &#125;    whoWin();    ChessBoard::clickPieces(id, row, col);    char array[3];    array[0] &#x3D; id;    array[1] &#x3D; row;    array[2] &#x3D; col;    &#x2F;&#x2F; 如果先创建的客户端，就会报错，因为构造函数没有new QTcpSocket。    m_tcpSocket-&gt;write(array, 3);&#125;void NetworkGame::slotNewConnection()&#123;    if(m_isTcpServer)        return ;    m_tcpSocket &#x3D; m_tcpServer-&gt;nextPendingConnection();    connect(m_tcpSocket, &amp;QTcpSocket::readyRead, this, &amp;NetworkGame::slotRecv);&#125;void NetworkGame::slotRecv()&#123;    QByteArray array &#x3D; m_tcpSocket-&gt;readAll();    int checkedID &#x3D; array[0];    int row &#x3D; array[1];    int col &#x3D; array[2];    ChessBoard::clickPieces(checkedID, row, col);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Author"><a href="#Author" class="headerlink" title="Author"></a>Author</h2><p><a href="https://github.com/allenmirac/Chinese-Chess">AllenMirac-ChineseChess</a></p><h1 id="巨人的肩膀"><a href="#巨人的肩膀" class="headerlink" title="巨人的肩膀"></a>巨人的肩膀</h1><p><a href="https://blog.csdn.net/qq_33154343/article/details/80931400">项目实战：Qt5／C++：QT象棋【初版】</a></p><p><a href="https://github.com/XMuli/ChineseChess">XMuli-ChineseChess</a></p>]]></content>
      
      
      <categories>
          
          <category> QT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> QT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>QT_Review之元对象系统（Moc）</title>
      <link href="/2023/06/20/qtreview-zhi-yuan-dui-xiang-xi-tong-moc/"/>
      <url>/2023/06/20/qtreview-zhi-yuan-dui-xiang-xi-tong-moc/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p><strong>目录</strong></p><p><a href="#QT%20%E5%85%83%E5%AF%B9%E8%B1%A1%E7%B3%BB%E7%BB%9F">QT 元对象系统</a></p><p><a href="#%E5%AE%9E%E9%AA%8C%E6%A1%88%E4%BE%8B">实验案例</a></p><p><a href="#%E4%BB%8E%E5%9B%9B%E4%B8%AA%E6%96%B9%E9%9D%A2%E6%9D%A5%E4%BB%8B%E7%BB%8D%E5%85%83%E5%AF%B9%E8%B1%A1%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%A5%A5%E7%A7%98">从四个方面来介绍元对象系统的奥秘</a></p><p><a href="#%E6%98%AF%E4%BB%80%E4%B9%88">是什么</a></p><p><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88">为什么</a></p><p><a href="#%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0">怎么实现</a></p><p><a href="#%E6%80%8E%E4%B9%88%E7%94%A8">怎么用</a></p><p><a href="#moc%20%E4%BD%BF%E7%94%A8">moc 使用</a></p><p><a href="#%E5%BC%95%E7%94%A8">引用</a></p><p><a href="#%E6%AC%A2%E8%BF%8E%E5%A4%A7%E5%AE%B6star">欢迎大家star</a></p><h1 id="QT-元对象系统"><a href="#QT-元对象系统" class="headerlink" title="QT 元对象系统"></a>QT 元对象系统</h1><p>QT 的元对象系统（The Meta-Object System）由它的元对象编译器（Meta-Object Compiler，moc）帮忙实现，moc 通过读取头文件中的 Q_OBJCET 宏来判断是否需要生成元对象代码。如果需要，则生成以 moc_ 开头的源文件，在链接（Linking）时会和源文件一起生成可执行文件。</p><h2 id="实验案例"><a href="#实验案例" class="headerlink" title="实验案例"></a>实验案例</h2><p>欢迎大家star：</p><p><a href="https://github.com/allenmirac/QTStudy/tree/main/QTReviewMoc">QTStudy/QTReviewMoc at main · allenmirac/QTStudy · GitHub</a></p><h2 id="从四个方面来介绍元对象系统的奥秘"><a href="#从四个方面来介绍元对象系统的奥秘" class="headerlink" title="从四个方面来介绍元对象系统的奥秘"></a>从四个方面来介绍元对象系统的奥秘</h2><h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><ul><li>从 QT 新增的关键字（signals、slots、emit）可以看出 QT 并不是标准的 C++ 语言，而是对其进行了一定程度的扩展。 +  元对象系统是 QT 核心的一部分，用于支持 QT 的 C++ 扩展（QT’s C++ extensions），它提供了用于对象间通信的信号与槽、运行时类型信息以及动态属性系统。 </li></ul><h2 id="为什么"><a href="#为什么" class="headerlink" title="为什么"></a>为什么</h2><p>由于 QT 是标准 C++ 的一个扩展，所以编译源代码时就需要将这些扩展的语法去掉，然后交给标准 C++ 编译器，诸如 GCC、MinGW、Clang 等。</p><h2 id="怎么实现"><a href="#怎么实现" class="headerlink" title="怎么实现"></a>怎么实现</h2><p>元对象系统基于以下 3 件事：</p><ul><li><code>QObject</code>类为使用元对象系统的 QT 对象提供了一个基类。 +  <code>Q_OBJECT</code> 宏用来在类中启用元对象特性，例如动态属性、信号、槽。 +  <code>moc</code> 为每个 QObject 子类提供实现元对象特性所需要的代码。 </li></ul><p>moc 工具读取 C++ 源文件。如果发现源文件中有一个类或者多个类的声明中包含 Q_OBJECT 宏，它就生成一个包含了这些类所需要的元对象代码的源文件。这个新源文件的文件名为源文件名前加上 moc_。<strong>新生成的源文件必须被 #include 到源文件中，或者更常见的是编译和连接到类的实现中。</strong></p><h2 id="怎么用"><a href="#怎么用" class="headerlink" title="怎么用"></a>怎么用</h2><p>元对象系统有以下特性：</p><ul><li><code>signals and slots</code> 一个用于对象间通信的信号与槽机制（QT 引入元对象系统最主要的原因）。 +  <code>QObject::metaObject()</code> 用来返回类关联的元对象。 +  <code>QMetaObject::className()</code> 用来在运行时获取类名，<strong>这个方法不需要原生 C++ 编译器的运行时类型信息（Runtime type information，RTTI）支持</strong>。 +  <code>QObject::inherits()</code> 用来判别一个对象是否是 QObject 继承树中的特定类的对象。 +  <code>QObject::tr()</code> 和 <code>QObject::trUtf8()</code> 提供 QT 国际化中翻译字符串的支持。 +  <code>QObject::setProperty()</code> 和 <code>QObject::property()</code> 提供动态地设置和获取属性名。 +  <code>QMetaObject::newInstance()</code> 用于构造一个类的新实例。 +  <code>qobject_cast</code> 处理继承自 QObject 类的动态转换。它不需要 RTTI 支持，并且支持跨动态库转换。转换成功返回非零指针，失败返回 nullptr。 </li></ul><p>在 QObject 的派生类中，不使用 Q_OBJECT 宏以及没有元对象代码，上述元对象系统特性也能用。需要注意的是，QMetaObject::className() 只会返回离它最近且拥有元对象代码的祖先（即最近一个声明 Q_OBJECT 的祖先）的类名。所以建议 QObject 的派生类一律添加 Q_OBJECT 宏！</p><h2 id="moc-使用"><a href="#moc-使用" class="headerlink" title="moc 使用"></a>moc 使用</h2><p>在这个案例中的使用：</p><p><a href="https://github.com/allenmirac/QTStudy/blob/main/QTReviewMoc/expersion.h">QTStudy/expersion.h at main · allenmirac/QTStudy · GitHub</a></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">EXPERSION_H</span></span> <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">EXPERSION_H</span></span> ​ <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;QObject></span></span> ​ <span class="token keyword">class</span> <span class="token class-name">ExPersion</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">QObject</span></span> <span class="token punctuation">&#123;</span>     Q_OBJECT     <span class="token comment">//Connected to the property system is an additional macro, Q_CLASSINFO(), that can be used to attach additional name--value pairs to a class's meta-object</span>     <span class="token function">Q_CLASSINFO</span><span class="token punctuation">(</span><span class="token string">"author"</span><span class="token punctuation">,</span><span class="token string">"hzy"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token function">Q_CLASSINFO</span><span class="token punctuation">(</span><span class="token string">"version"</span><span class="token punctuation">,</span> <span class="token string">"1.1.1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token function">Q_CLASSINFO</span><span class="token punctuation">(</span><span class="token string">"info"</span><span class="token punctuation">,</span> <span class="token string">"QT5 Meta Object and Property Example"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">//A property behaves like a class data member, but it has additional features accessible through the Meta-Object System.</span>     <span class="token function">Q_PROPERTY</span><span class="token punctuation">(</span><span class="token keyword">int</span> age READ getAge WRITE setAge NOTIFY ageChanged<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token function">Q_PROPERTY</span><span class="token punctuation">(</span>QString name MEMBER m_name<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token function">Q_PROPERTY</span><span class="token punctuation">(</span><span class="token keyword">int</span> score MEMBER m_score<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">public</span><span class="token operator">:</span>     <span class="token keyword">explicit</span> <span class="token function">ExPersion</span><span class="token punctuation">(</span>QString name<span class="token punctuation">,</span> QObject <span class="token operator">*</span>parent <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span> ​ <span class="token keyword">public</span><span class="token operator">:</span>     <span class="token keyword">int</span> <span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">void</span> <span class="token function">setAge</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span> ​     <span class="token keyword">void</span> <span class="token function">incAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> ​ signals<span class="token operator">:</span>     <span class="token keyword">void</span> <span class="token function">ageChanged</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span> ​ <span class="token keyword">private</span><span class="token operator">:</span>     <span class="token keyword">int</span> m_age <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>     QString m_name<span class="token punctuation">;</span>     <span class="token keyword">int</span> m_score <span class="token operator">=</span> <span class="token number">50</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span> ​ <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span> <span class="token comment">// EXPERSION_H</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>官方文档的Example：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">MyClass</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">QObject</span></span> <span class="token punctuation">&#123;</span>     Q_OBJECT     <span class="token function">Q_PROPERTY</span><span class="token punctuation">(</span>Priority priority READ priority WRITE setPriority NOTIFY priorityChanged<span class="token punctuation">)</span> ​ <span class="token keyword">public</span><span class="token operator">:</span>     <span class="token function">MyClass</span><span class="token punctuation">(</span>QObject <span class="token operator">*</span>parent <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token operator">~</span><span class="token function">MyClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> ​     <span class="token keyword">enum</span> <span class="token class-name">Priority</span> <span class="token punctuation">&#123;</span> High<span class="token punctuation">,</span> Low<span class="token punctuation">,</span> VeryHigh<span class="token punctuation">,</span> VeryLow <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>     <span class="token function">Q_ENUM</span><span class="token punctuation">(</span>Priority<span class="token punctuation">)</span> ​     <span class="token keyword">void</span> <span class="token function">setPriority</span><span class="token punctuation">(</span>Priority priority<span class="token punctuation">)</span>     <span class="token punctuation">&#123;</span>         m_priority <span class="token operator">=</span> priority<span class="token punctuation">;</span>         emit <span class="token function">priorityChanged</span><span class="token punctuation">(</span>priority<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">&#125;</span>     Priority <span class="token function">priority</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>     <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> m_priority<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> ​ signals<span class="token operator">:</span>     <span class="token keyword">void</span> <span class="token function">priorityChanged</span><span class="token punctuation">(</span>Priority<span class="token punctuation">)</span><span class="token punctuation">;</span> ​ <span class="token keyword">private</span><span class="token operator">:</span>     Priority m_priority<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><a href="https://beyondyuanshu.github.io/2019/09/03/qt-core-the-meta-object-system.html">Qt 核心之元对象系统 - Shu’s Site</a></p><p><a href="https://doc.qt.io/qt-6/qobject.html#Q_PROPERTY">QObject Class | Qt Core 6.4.3</a></p><h2 id="欢迎大家star"><a href="#欢迎大家star" class="headerlink" title="欢迎大家star"></a>欢迎大家star</h2><p><a href="https://github.com/allenmirac/QTStudy">GitHub - allenmirac/QTStudy: This is a repository to learn QT.</a></p>]]></content>
      
      
      <categories>
          
          <category> QT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> QT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>QT_Review之_QSlider（滑块）</title>
      <link href="/2023/06/20/qtreview-zhi-qslider-hua-kuai/"/>
      <url>/2023/06/20/qtreview-zhi-qslider-hua-kuai/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p><strong>目录</strong></p><p><a href="#QT%20QSlider">QT QSlider</a></p><p><a href="#%E6%98%AF%E4%BB%80%E4%B9%88">是什么</a></p><p><a href="#%E5%AE%9E%E9%AA%8C%E6%A1%88%E4%BE%8B">实验案例</a></p><p><a href="#%E6%80%8E%E4%B9%88%E7%94%A8">怎么用</a></p><p><a href="#%E6%A1%88%E4%BE%8B">案例</a></p><p><a href="#%E6%AC%A2%E8%BF%8E%E5%A4%A7%E5%AE%B6star">欢迎大家star</a></p><h1 id="QT-QSlider"><a href="#QT-QSlider" class="headerlink" title="QT QSlider"></a>QT QSlider</h1><h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><p>滑块是控制有界值的经典小部件。它允许用户沿着水平或垂直槽移动滑块手柄，并将手柄的位置转换为合法范围内的整数值。</p><p><code>QSlider</code> 自己的功能很少，大部分功能都继承于 <code>QAbstractSlider</code>。最常用的函数是 <code>setValue ()</code> ，它可以将滑块直接设置为某个值; <code>triggerAction ()</code>可以模拟单击的效果(对快捷键有用) ;<code>setSingleStep ()</code>，<code>setPageStep ()</code>可以设置步骤; <code>setMinimum()</code>和 <code>setMaximum()</code>可以定义滚动条的范围。</p><h2 id="实验案例"><a href="#实验案例" class="headerlink" title="实验案例"></a>实验案例</h2><p>欢迎大家star：</p><p><a href="https://github.com/allenmirac/QTStudy/tree/main/QTReviewQSlider">QTStudy/QTReviewQSlider at main · allenmirac/QTStudy · GitHub</a></p><h2 id="怎么用"><a href="#怎么用" class="headerlink" title="怎么用"></a>怎么用</h2><p><strong>继承的属性：</strong></p><ul><li><code>minimum</code>、<code>maximum</code>：设置输入范围的最小值和最大值，例如，用红、绿、蓝配色时，每 种基色的大小范围是0~255，所以设置<strong>minimum</strong>为0，<strong>maximum</strong>为255。 +  <code>singlestep</code>:单步长，拖动标尺上的滑块，或按下左/右光标键时的最小变化数值。 +  <code>pageStep</code>:在<strong>Slider</strong>上输入焦点，按<strong>PgUp</strong>或<strong>PgDn</strong>键时变化的数值。 +  <code>value</code>：组件的当前值，拖动滑块时自动改变此值，并限定在<strong>minimum</strong>和<strong>maximum</strong>定义的 范围之内。 +  <code>sliderPosition</code>:滑块的位置，若<strong>tracking</strong>属性设置为true，<strong>sliderPosition</strong>就等于value。 +  <strong><code>tracking</code>：sliderPosition</strong>是否等同于<strong>value</strong>，如果<strong>tracking</strong>=true，改变value时也同时改变 sliderPosition。 +  <code>orientation</code>: <strong>Slider</strong>的方向，可以设置为水平或垂直。方向参数是Qt的枚举类型enum +  <code>Qt::Orientation</code>：取值包括以下两种。<br>枚举含义Qt::Horizontal水平方向Qt::Vertical垂直方向+  <code>invertedAppearance</code>:显示方式是否反向，<strong>invertedAppearance</strong>=false时，水平的Slider由左向右数值增大，否则反过来。 +  <code>invertedControls</code>：反向按键控制，若<strong>invertedControls</strong>=true，则按下<strong>PgUp</strong>或<strong>PgDn</strong>按键时调整数值的反向相反。 +  <strong>属于QSlider的专有属性有两个，如下：</strong> +  <code>tickPosition</code>:标尺刻度的显示位置，使用枚举类型<strong>QSlider:TickPosition</strong>，取值包括以下6种<br>枚举含义QSlider::NoTicks不显示刻度QSlider::TicksBothSides标尺两侧都显示刻度QSlider::TicksAbove标尺上方显示刻度QSlider::TicksBelow标尺下方显示刻度QSlider::TicksLeft标尺左侧显示刻度QSlider::TicksRight标尺右侧显示刻度+  <code>ticklnterval</code>：标尺刻度的间隔值，若设置为0，会在<strong>singleStep</strong>和<strong>pageStep</strong>之间自动选择。 </li></ul><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"exqslider.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"ui_exqslider.h"</span></span>​<span class="token class-name">ExQSlider</span><span class="token double-colon punctuation">::</span><span class="token function">ExQSlider</span><span class="token punctuation">(</span>QWidget <span class="token operator">*</span>parent<span class="token punctuation">)</span>    <span class="token operator">:</span> <span class="token function">QWidget</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span>    <span class="token punctuation">,</span> <span class="token function">ui</span><span class="token punctuation">(</span><span class="token keyword">new</span> Ui<span class="token double-colon punctuation">::</span>ExQSlider<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    ui<span class="token operator">-></span><span class="token function">setupUi</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">setWindowTitle</span><span class="token punctuation">(</span><span class="token function">QString</span><span class="token punctuation">(</span><span class="token string">"QSlider的用法"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>​    <span class="token comment">//QSlider控件，设置最大值为255,初始范围是0-100;</span>    ui<span class="token operator">-></span>sliderRed<span class="token operator">-></span><span class="token function">setMaximum</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    ui<span class="token operator">-></span>sliderGreen<span class="token operator">-></span><span class="token function">setMaximum</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    ui<span class="token operator">-></span>sliderBlue<span class="token operator">-></span><span class="token function">setMaximum</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    ui<span class="token operator">-></span>sliderAlpha<span class="token operator">-></span><span class="token function">setMaximum</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span><span class="token punctuation">;</span>​    <span class="token comment">//QSlider控件，设置初值</span>    ui<span class="token operator">-></span>sliderRed<span class="token operator">-></span><span class="token function">setValue</span><span class="token punctuation">(</span><span class="token number">145</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    ui<span class="token operator">-></span>sliderGreen<span class="token operator">-></span><span class="token function">setValue</span><span class="token punctuation">(</span><span class="token number">190</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    ui<span class="token operator">-></span>sliderBlue<span class="token operator">-></span><span class="token function">setValue</span><span class="token punctuation">(</span><span class="token number">251</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    ui<span class="token operator">-></span>sliderAlpha<span class="token operator">-></span><span class="token function">setValue</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span><span class="token punctuation">;</span>​    <span class="token comment">//QTextEdit控件，设置初试颜色</span>    QColor color<span class="token punctuation">;</span>    color<span class="token punctuation">.</span><span class="token function">setRgb</span><span class="token punctuation">(</span><span class="token number">145</span><span class="token punctuation">,</span> <span class="token number">190</span><span class="token punctuation">,</span> <span class="token number">251</span><span class="token punctuation">,</span> <span class="token number">255</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    QPalette palette <span class="token operator">=</span> ui<span class="token operator">-></span>textColor<span class="token operator">-></span><span class="token function">palette</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//拿到调色板</span>    palette<span class="token punctuation">.</span><span class="token function">setColor</span><span class="token punctuation">(</span>QPalette<span class="token double-colon punctuation">::</span>Base<span class="token punctuation">,</span> color<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//设置背景颜色</span>    ui<span class="token operator">-></span>textColor<span class="token operator">-></span><span class="token function">setPalette</span><span class="token punctuation">(</span>palette<span class="token punctuation">)</span><span class="token punctuation">;</span>​    <span class="token function">connect</span><span class="token punctuation">(</span>ui<span class="token operator">-></span>sliderRed<span class="token punctuation">,</span> <span class="token operator">&amp;</span>QSlider<span class="token double-colon punctuation">::</span>valueChanged<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>ExQSlider<span class="token double-colon punctuation">::</span>onSetColor<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">connect</span><span class="token punctuation">(</span>ui<span class="token operator">-></span>sliderGreen<span class="token punctuation">,</span> <span class="token operator">&amp;</span>QSlider<span class="token double-colon punctuation">::</span>valueChanged<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>ExQSlider<span class="token double-colon punctuation">::</span>onSetColor<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">connect</span><span class="token punctuation">(</span>ui<span class="token operator">-></span>sliderBlue<span class="token punctuation">,</span> <span class="token operator">&amp;</span>QSlider<span class="token double-colon punctuation">::</span>valueChanged<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>ExQSlider<span class="token double-colon punctuation">::</span>onSetColor<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">connect</span><span class="token punctuation">(</span>ui<span class="token operator">-></span>sliderAlpha<span class="token punctuation">,</span> <span class="token operator">&amp;</span>QSlider<span class="token double-colon punctuation">::</span>valueChanged<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>ExQSlider<span class="token double-colon punctuation">::</span>onSetColor<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>​<span class="token class-name">ExQSlider</span><span class="token double-colon punctuation">::</span><span class="token operator">~</span><span class="token function">ExQSlider</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">delete</span> ui<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>​<span class="token keyword">void</span> <span class="token class-name">ExQSlider</span><span class="token double-colon punctuation">::</span><span class="token function">onSetColor</span><span class="token punctuation">(</span><span class="token keyword">int</span> val<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">Q_UNUSED</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>​    <span class="token keyword">int</span> nRed <span class="token operator">=</span> ui<span class="token operator">-></span>sliderRed<span class="token operator">-></span><span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> nGreen <span class="token operator">=</span> ui<span class="token operator">-></span>sliderGreen<span class="token operator">-></span><span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> nBlue <span class="token operator">=</span> ui<span class="token operator">-></span>sliderBlue<span class="token operator">-></span><span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> nAlpha <span class="token operator">=</span> ui<span class="token operator">-></span>sliderAlpha<span class="token operator">-></span><span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>​    QColor color<span class="token punctuation">;</span>    color<span class="token punctuation">.</span><span class="token function">setRgb</span><span class="token punctuation">(</span>nRed<span class="token punctuation">,</span> nGreen<span class="token punctuation">,</span> nBlue<span class="token punctuation">,</span> nAlpha<span class="token punctuation">)</span><span class="token punctuation">;</span>    QPalette palette <span class="token operator">=</span> ui<span class="token operator">-></span>textColor<span class="token operator">-></span><span class="token function">palette</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    palette<span class="token punctuation">.</span><span class="token function">setColor</span><span class="token punctuation">(</span>QPalette<span class="token double-colon punctuation">::</span>Base<span class="token punctuation">,</span> color<span class="token punctuation">)</span><span class="token punctuation">;</span>    ui<span class="token operator">-></span>textColor<span class="token operator">-></span><span class="token function">setPalette</span><span class="token punctuation">(</span>palette<span class="token punctuation">)</span><span class="token punctuation">;</span>​    ui<span class="token operator">-></span>labRGBVal<span class="token operator">-></span><span class="token function">setText</span><span class="token punctuation">(</span><span class="token function">QString</span><span class="token punctuation">(</span><span class="token string">"RGB(%1, %2, %3, %4)"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">arg</span><span class="token punctuation">(</span>nRed<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">arg</span><span class="token punctuation">(</span>nGreen<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">arg</span><span class="token punctuation">(</span>nBlue<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">arg</span><span class="token punctuation">(</span>nAlpha<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>​<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="欢迎大家star"><a href="#欢迎大家star" class="headerlink" title="欢迎大家star"></a>欢迎大家star</h2><p><a href="https://github.com/allenmirac/QTStudy">GitHub - allenmirac/QTStudy: This is a repository to learn QT.</a></p>]]></content>
      
      
      <categories>
          
          <category> QT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> QT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>QComboBox_和_QPlainTextEdit</title>
      <link href="/2023/06/20/qcombobox-he-qplaintextedit/"/>
      <url>/2023/06/20/qcombobox-he-qplaintextedit/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="QComboBox"><a href="#QComboBox" class="headerlink" title="QComboBox"></a>QComboBox</h1><p>QComboBox 主要的功能是提供一个下拉列表供选择输入，也可以直接当作一个 QLineEdit 用作输入（<code>ui-&gt;comboBox-&gt;setEditable(true);</code>）。</p><h2 id="添加项"><a href="#添加项" class="headerlink" title="添加项"></a>添加项</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token class-name">ExQComboBox</span><span class="token double-colon punctuation">::</span><span class="token function">on_btnInitNameAge_clicked</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    QIcon ico<span class="token punctuation">;</span>    ico<span class="token punctuation">.</span><span class="token function">addFile</span><span class="token punctuation">(</span><span class="token string">":/girl.ico"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>​    QMap<span class="token operator">&lt;</span>QString<span class="token punctuation">,</span> QString<span class="token operator">></span> map<span class="token punctuation">;</span>    map<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token string">"张投"</span><span class="token punctuation">,</span> <span class="token string">"16岁"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    map<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token string">"张我"</span><span class="token punctuation">,</span> <span class="token string">"17岁"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    map<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token string">"张以"</span><span class="token punctuation">,</span> <span class="token string">"18岁"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    map<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token string">"张木"</span><span class="token punctuation">,</span> <span class="token string">"19岁"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    map<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token string">"张李"</span><span class="token punctuation">,</span> <span class="token string">"20岁"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    map<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token string">"张，"</span><span class="token punctuation">,</span> <span class="token string">"21岁"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    map<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token string">"张报"</span><span class="token punctuation">,</span> <span class="token string">"22岁"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>​    ui<span class="token operator">-></span>comboBoxRight<span class="token operator">-></span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">foreach</span><span class="token punctuation">(</span><span class="token keyword">const</span> QString <span class="token operator">&amp;</span>str<span class="token punctuation">,</span> map<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        ui<span class="token operator">-></span>comboBoxRight<span class="token operator">-></span><span class="token function">addItem</span><span class="token punctuation">(</span>ico<span class="token punctuation">,</span> str<span class="token punctuation">,</span> map<span class="token punctuation">.</span><span class="token function">value</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里用了foreach遍历map。</p><p>添加具有用户数据的项 QComboBox::addltem() 函数的两种参数的原型定义如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">addItem</span> <span class="token punctuation">(</span><span class="token keyword">const</span> QString <span class="token operator">&amp;</span>text<span class="token punctuation">,</span> <span class="token keyword">const</span> QVariant <span class="token operator">&amp;</span>userData <span class="token operator">=</span> <span class="token function">QVariant</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">void</span> <span class="token function">addItem</span> <span class="token punctuation">(</span><span class="token keyword">const</span> QIcon <span class="token operator">&amp;</span>icon<span class="token punctuation">,</span> <span class="token keyword">const</span> QString <span class="token operator">&amp;</span>text<span class="token punctuation">,</span> <span class="token keyword">const</span> QVariant <span class="token operator">&amp;</span>userData <span class="token operator">=</span> <span class="token function">QVariant</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h2><p>QComboBox 存储的项是一个列表，但是 QComboBox 不提供整个列表用于访问，可以通过索引访问某个项。访问项的一些函数主要有以下几种：</p><ul><li>int currentlndex()：返回当前项的序号，第一个项的序号为0。 +  QString currentText()：返回当前项的文字。 +  QVariant currentData(int role = Qt::UserRole)：返回当前项的关联数据，数据的缺省角色为 role = Qt::UserRole，角色的意义在后续章节会详细介绍。 +  QString itemText(int index)：返回指定索引号的项的文字。 +  QVariant itemData(int index, int role = Qt%:UserRole)：返回指定索引号的项的关联数据。 +  int count()：返回项的个数。 </li></ul><p>在一个 QComboBox 组件上选择项发生变化时，会发射如下两个信号：<br>void currentlndexChanged(int index)<br>void currentlndexChanged(const QString &amp;text)</p><h1 id="QPlainTextEdit"><a href="#QPlainTextEdit" class="headerlink" title="QPlainTextEdit"></a>QPlainTextEdit</h1><p>QPlainTextEdit 是一个多行文本编辑器，用于显示和编辑多行简单文本。</p><p>QPlainTextEdit 提供<strong>cut( )、copy( )、paste( )、undo( )、redo( )、clear( )、selectAll( )</strong>等标准编辑功 能的槽函数，QPlainTextEdit还提供一个标准的右键快捷菜单。</p><p>QPlainTextEdit的文字内容以QTextDocument类型存储，函数document()返回这个文档对象的指针。</p><p>QTextDocument是内存中的文本对象，以文本块的方式存储，一个文本块就是一个段落，每个段落以回车符结束。QTextDocument提供一些函数实现对文本内容的存取。</p><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>常用函数含义()appendPlainText()向QPlain TextEdit添加一行话int blockCount()获得文本块个数QTextBlock findBlockByNumber(int blockNumber)读取某一个文本块，序号从0开始，至blockCount()-1结束。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token class-name">ExQComboBox</span><span class="token double-colon punctuation">::</span><span class="token function">onSelectDisplay</span><span class="token punctuation">(</span>QString str<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    QString strData <span class="token operator">=</span> ui<span class="token operator">-></span>comboBoxRight<span class="token operator">-></span><span class="token function">currentData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    ui<span class="token operator">-></span>plainTextEdit<span class="token operator">-></span><span class="token function">appendPlainText</span><span class="token punctuation">(</span>str <span class="token operator">+</span> <span class="token string">" "</span> <span class="token operator">+</span> strData<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h1 id="欢迎大家star"><a href="#欢迎大家star" class="headerlink" title="欢迎大家star"></a>欢迎大家star</h1><p>这里是项目的源码，是一个很好的练习的例子，可以自己敲着玩一玩，练习练习手感</p><p><a href="https://github.com/allenmirac/QTStudy/tree/main/QTReviewQCombobox">QTStudy/QTReviewQCombobox at main · allenmirac/QTStudy · GitHub</a></p>]]></content>
      
      
      <categories>
          
          <category> QT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> QT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python细碎知识点（getattr......）</title>
      <link href="/2023/06/20/python-xi-sui-zhi-shi-dian-getattr/"/>
      <url>/2023/06/20/python-xi-sui-zhi-shi-dian-getattr/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="类外给类增加属性、设置属性"><a href="#类外给类增加属性、设置属性" class="headerlink" title="类外给类增加属性、设置属性"></a>类外给类增加属性、设置属性</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">change</span><span class="token punctuation">:</span>     <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> z<span class="token punctuation">)</span><span class="token punctuation">:</span>         self<span class="token punctuation">.</span>a <span class="token operator">=</span> x <span class="token operator">+</span> y <span class="token operator">+</span> z x <span class="token operator">=</span> change<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span> y <span class="token operator">=</span> <span class="token builtin">getattr</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> <span class="token string">'a'</span><span class="token punctuation">)</span> <span class="token keyword">print</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span>y <span class="token operator">=</span> <span class="token builtin">getattr</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> <span class="token string">"b"</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment"># 第三个参数是默认值，不存在该属性则将y设置为默认值，</span><span class="token comment"># 注意y是int型数据！！！</span><span class="token keyword">print</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token builtin">setattr</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> <span class="token string">'a'</span><span class="token punctuation">,</span> y<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>a<span class="token punctuation">)</span><span class="token comment"># 6</span><span class="token comment"># 1</span><span class="token comment"># 2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="类外定义属性"><a href="#类外定义属性" class="headerlink" title="类外定义属性"></a>类外定义属性</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">fruits</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> price<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>price <span class="token operator">=</span> priceobj<span class="token operator">=</span>fruits<span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span>obj<span class="token punctuation">.</span>quantity<span class="token operator">=</span><span class="token number">10</span>obj<span class="token punctuation">.</span>bags<span class="token operator">=</span><span class="token number">2</span><span class="token keyword">print</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span>quantity<span class="token operator">+</span><span class="token builtin">len</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span>__dict__<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment"># 13</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Python运算符重载："><a href="#Python运算符重载：" class="headerlink" title="Python运算符重载："></a>Python运算符重载：</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python">Suppose i <span class="token keyword">is</span> <span class="token number">5</span> <span class="token keyword">and</span> j <span class="token keyword">is</span> <span class="token number">4</span><span class="token punctuation">,</span> i <span class="token operator">*</span> j <span class="token keyword">is</span> same <span class="token keyword">as</span> ______<span class="token punctuation">.</span>A<span class="token punctuation">.</span> i<span class="token punctuation">.</span>__mul<span class="token punctuation">(</span>j<span class="token punctuation">)</span>B<span class="token punctuation">.</span> i<span class="token punctuation">.</span>__mul__<span class="token punctuation">(</span>j<span class="token punctuation">)</span>C<span class="token punctuation">.</span> i<span class="token punctuation">.</span>__Mul<span class="token punctuation">(</span>j<span class="token punctuation">)</span>D<span class="token punctuation">.</span> i<span class="token punctuation">.</span>__MUL<span class="token punctuation">(</span>j<span class="token punctuation">)</span>我的答案<span class="token punctuation">:</span> B<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python">If a <span class="token keyword">class</span> <span class="token class-name">defines</span> the __str__<span class="token punctuation">(</span>self<span class="token punctuation">)</span> method<span class="token punctuation">,</span> <span class="token keyword">for</span> an <span class="token builtin">object</span> obj <span class="token keyword">for</span> the <span class="token keyword">class</span><span class="token punctuation">,</span> you can use which command to invoke the __str__ method<span class="token punctuation">.</span>A<span class="token punctuation">.</span> obj<span class="token punctuation">.</span>__str__<span class="token punctuation">(</span><span class="token punctuation">)</span>B<span class="token punctuation">.</span> <span class="token builtin">str</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span>C<span class="token punctuation">.</span> <span class="token keyword">print</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span>D<span class="token punctuation">.</span> <span class="token builtin">all</span> of the mentioned我的答案<span class="token punctuation">:</span> D<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 实现自己的复数类型，运算符重载</span><span class="token keyword">class</span> <span class="token class-name">MyComplex</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>real<span class="token punctuation">,</span>image<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>real <span class="token operator">=</span> real        self<span class="token punctuation">.</span>image <span class="token operator">=</span> image    <span class="token keyword">def</span> <span class="token function">__add__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>other<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> MyComplex<span class="token punctuation">(</span>self<span class="token punctuation">.</span>real<span class="token operator">+</span>other<span class="token punctuation">.</span>real<span class="token punctuation">,</span>self<span class="token punctuation">.</span>image<span class="token operator">+</span>other<span class="token punctuation">.</span>image<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">__sub__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>other<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> MyComplex<span class="token punctuation">(</span>self<span class="token punctuation">.</span>real<span class="token operator">-</span>other<span class="token punctuation">.</span>real<span class="token punctuation">,</span>self<span class="token punctuation">.</span>image<span class="token operator">-</span>other<span class="token punctuation">.</span>image<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">__mul__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> other<span class="token punctuation">)</span><span class="token punctuation">:</span>        re <span class="token operator">=</span> self<span class="token punctuation">.</span>real<span class="token operator">*</span>other<span class="token punctuation">.</span>real<span class="token operator">-</span>self<span class="token punctuation">.</span>image<span class="token operator">*</span>other<span class="token punctuation">.</span>image        im <span class="token operator">=</span> self<span class="token punctuation">.</span>real<span class="token operator">*</span>other<span class="token punctuation">.</span>real<span class="token operator">-</span>self<span class="token punctuation">.</span>image<span class="token operator">*</span>other<span class="token punctuation">.</span>image        <span class="token keyword">return</span> MyComplex<span class="token punctuation">(</span>re<span class="token punctuation">,</span>im<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">__str__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>image<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">:</span>                       <span class="token keyword">return</span> <span class="token builtin">str</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>real<span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">'+'</span><span class="token operator">+</span><span class="token builtin">str</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>image<span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">'j'</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token builtin">str</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>real<span class="token punctuation">)</span><span class="token operator">+</span><span class="token builtin">str</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>image<span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">'j'</span><span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    c1 <span class="token operator">=</span> MyComplex<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>c1<span class="token punctuation">)</span>    c2 <span class="token operator">=</span> MyComplex<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        op <span class="token operator">=</span> <span class="token builtin">input</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> op <span class="token operator">==</span> <span class="token string">'+'</span><span class="token punctuation">:</span>            <span class="token keyword">print</span><span class="token punctuation">(</span>c1<span class="token operator">+</span>c2<span class="token punctuation">)</span>        <span class="token keyword">elif</span> op <span class="token operator">==</span> <span class="token string">'-'</span><span class="token punctuation">:</span>            <span class="token keyword">print</span><span class="token punctuation">(</span>c1<span class="token operator">-</span>c2<span class="token punctuation">)</span>        <span class="token keyword">elif</span> op <span class="token operator">==</span> <span class="token string">'*'</span><span class="token punctuation">:</span>            <span class="token keyword">print</span><span class="token punctuation">(</span>c1<span class="token operator">*</span>c2<span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token keyword">break</span><span class="token keyword">if</span> __name__<span class="token operator">==</span><span class="token string">"__main__"</span><span class="token punctuation">:</span>main<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="类的方法doc-输出注释"><a href="#类的方法doc-输出注释" class="headerlink" title="类的方法doc(输出注释)"></a>类的方法<strong>doc</strong>(输出注释)</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># What will be the output of the following Python code?</span><span class="token keyword">class</span> <span class="token class-name">stud</span><span class="token punctuation">:</span>    <span class="token string">'Base class for all students'</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> roll_no<span class="token punctuation">,</span> grade<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>roll_no <span class="token operator">=</span> roll_no        self<span class="token punctuation">.</span>grade <span class="token operator">=</span> grade    <span class="token keyword">def</span> <span class="token function">display</span> <span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Roll no : "</span><span class="token punctuation">,</span> self<span class="token punctuation">.</span>roll_no<span class="token punctuation">,</span> <span class="token string">", Grade: "</span><span class="token punctuation">,</span> self<span class="token punctuation">.</span>grade<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>stud<span class="token punctuation">.</span>__doc__<span class="token punctuation">)</span>A<span class="token punctuation">.</span> Exception <span class="token keyword">is</span> thrownB<span class="token punctuation">.</span> __main__C<span class="token punctuation">.</span> Nothing <span class="token keyword">is</span> displayedD<span class="token punctuation">.</span> Base <span class="token keyword">class</span> <span class="token class-name">for</span> <span class="token builtin">all</span> students我的答案<span class="token punctuation">:</span> D<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="类的方法name："><a href="#类的方法name：" class="headerlink" title="类的方法name："></a>类的方法<strong>name</strong>：</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python">What does <span class="token keyword">print</span><span class="token punctuation">(</span>Test<span class="token punctuation">.</span>__name__<span class="token punctuation">)</span> display <span class="token punctuation">(</span>assuming Test <span class="token keyword">is</span> the name of the <span class="token keyword">class</span><span class="token punctuation">)</span>?A<span class="token punctuation">.</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>B<span class="token punctuation">.</span> Exception <span class="token keyword">is</span> thrownC<span class="token punctuation">.</span> TestD<span class="token punctuation">.</span> __main__我的答案<span class="token punctuation">:</span> C<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="变量作用域："><a href="#变量作用域：" class="headerlink" title="变量作用域： "></a><strong>变量作用域： </strong></h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">add</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span>k<span class="token punctuation">)</span><span class="token punctuation">:</span>     c<span class="token punctuation">.</span>test <span class="token operator">+=</span> <span class="token number">1</span>     k <span class="token operator">+=</span> <span class="token number">2</span> <span class="token keyword">class</span> <span class="token class-name">A</span><span class="token punctuation">:</span>     <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>         self<span class="token punctuation">.</span>test <span class="token operator">=</span> <span class="token number">0</span> a<span class="token operator">=</span>A<span class="token punctuation">(</span><span class="token punctuation">)</span> k<span class="token operator">=</span><span class="token number">0</span> add<span class="token punctuation">(</span>a<span class="token punctuation">,</span>k<span class="token punctuation">)</span> <span class="token keyword">print</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span>test<span class="token punctuation">,</span> k<span class="token punctuation">)</span> A<span class="token punctuation">.</span> <span class="token number">0</span> <span class="token number">0</span>B<span class="token punctuation">.</span> <span class="token number">1</span> <span class="token number">0</span>C<span class="token punctuation">.</span> <span class="token number">0</span> <span class="token number">2</span>D<span class="token punctuation">.</span> <span class="token number">1</span> <span class="token number">2</span>我的答案<span class="token punctuation">:</span> B<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="set的详细用法"><a href="#set的详细用法" class="headerlink" title="set的详细用法"></a>set的详细用法</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">s <span class="token operator">=</span> set<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment"># 将集合初始化为空的</span><span class="token comment"># 不能是 s=&#123;&#125;,这里s树dict类型</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><a href="https://www.cnblogs.com/whatisfantasy/p/5956775.html">​​​​​​​Python基本数据类型之set - morra - 博客园 (cnblogs.com)<br><img src="https://csdnimg.cn/release/blog_editor_html/release2.1.3/ckeditor/plugins/CsdnLink/icons/icon-default.png?t=M4AD" alt=""><br><a href="https://www.cnblogs.com/whatisfantasy/p/5956775.html">https://www.cnblogs.com/whatisfantasy/p/5956775.html</a></a></p><h2 id="Generation"><a href="#Generation" class="headerlink" title="Generation"></a>Generation</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">fib</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">:</span>    n<span class="token punctuation">,</span>a<span class="token punctuation">,</span>b<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span>    <span class="token keyword">while</span> n<span class="token operator">&lt;</span>x<span class="token punctuation">:</span>        <span class="token keyword">yield</span> b        a<span class="token punctuation">,</span>b<span class="token operator">=</span>b<span class="token punctuation">,</span>a<span class="token operator">+</span>b        n<span class="token operator">+=</span><span class="token number">1</span>    <span class="token keyword">return</span> b<span class="token comment"># print()</span><span class="token keyword">for</span> i <span class="token keyword">in</span> fib<span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token comment"># 1</span><span class="token comment"># 2</span><span class="token comment"># 3</span><span class="token comment"># 5</span><span class="token comment"># 8</span><span class="token comment"># 13</span><span class="token comment"># 21</span><span class="token comment"># 34</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017318207388128">生成器 - 廖雪峰的官方网站研究互联网产品和技术，提供原创中文精品教程<br><img src="https://csdnimg.cn/release/blog_editor_html/release2.1.3/ckeditor/plugins/CsdnLink/icons/icon-default.png?t=M4AD" alt=""><br><a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017318207388128">https://www.liaoxuefeng.com/wiki/1016959663602400/1017318207388128</a></a><a href="https://www.geeksforgeeks.org/generators-in-python/">Generators in Python - GeeksforGeeks<br><img src="https://csdnimg.cn/release/blog_editor_html/release2.1.3/ckeditor/plugins/CsdnLink/icons/icon-default.png?t=M4AD" alt=""><br><a href="https://www.geeksforgeeks.org/generators-in-python/">https://www.geeksforgeeks.org/generators-in-python/</a></a></p><h2 id="字符串是不可变类型"><a href="#字符串是不可变类型" class="headerlink" title="字符串是不可变类型"></a>字符串是不可变类型</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token punctuation">(</span><span class="token string">'ab'</span><span class="token punctuation">,</span> <span class="token string">'cd'</span><span class="token punctuation">,</span> <span class="token string">'efcdgh'</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> x<span class="token operator">=</span><span class="token string">'abcd'</span><span class="token operator">>></span><span class="token operator">></span> a<span class="token operator">=</span>x<span class="token punctuation">.</span>upper<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> x<span class="token string">'abcd'</span><span class="token operator">>></span><span class="token operator">></span> a<span class="token string">'ABCD'</span><span class="token operator">>></span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PAT 1054 求平均值</title>
      <link href="/2023/06/20/patbasiclevelpractice-zhong-wen-1054-qiu-ping-jun-zhi/"/>
      <url>/2023/06/20/patbasiclevelpractice-zhong-wen-1054-qiu-ping-jun-zhi/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="PAT-1054-求平均值"><a href="#PAT-1054-求平均值" class="headerlink" title="PAT 1054 求平均值"></a>PAT 1054 求平均值</h1><p>分数 20</p><h3 id="题目简介："><a href="#题目简介：" class="headerlink" title="题目简介："></a>题目简介：</h3><p>本题的基本要求非常简单：给定 N 个实数，计算它们的平均值。但复杂的是有些输入数据可能是非法的。一个“合法”的输入是 [−1000,1000] 区间内的实数，并且最多精确到小数点后 2 位。当你计算平均值的时候，不能把那些非法的数据算在内。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入第一行给出正整数 N（≤100）。随后一行给出 N 个实数，数字间以一个空格分隔。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>对每个非法输入，在一行中输出 <code>ERROR: X is not a legal number</code>，其中 <code>X</code> 是输入。最后在一行中输出结果：<code>The average of K numbers is Y</code>，其中 <code>K</code> 是合法输入的个数，<code>Y</code> 是它们的平均值，精确到小数点后 2 位。如果平均值无法计算，则用 <code>Undefined</code> 替换 <code>Y</code>。如果 <code>K</code> 为 1，则输出 <code>The average of 1 number is Y</code>。</p><h3 id="输入样例-1："><a href="#输入样例-1：" class="headerlink" title="输入样例 1："></a>输入样例 1：</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">7</span><span class="token number">5</span> <span class="token parameter variable">-3.2</span> aaa <span class="token number">9999</span> <span class="token number">2.3</span>.4 <span class="token number">7.123</span> <span class="token number">2.35</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="输出样例-1："><a href="#输出样例-1：" class="headerlink" title="输出样例 1："></a>输出样例 1：</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ERROR: aaa is not a legal numberERROR: <span class="token number">9999</span> is not a legal numberERROR: <span class="token number">2.3</span>.4 is not a legal numberERROR: <span class="token number">7.123</span> is not a legal numberThe average of <span class="token number">3</span> numbers is <span class="token number">1.38</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="输入样例-2："><a href="#输入样例-2：" class="headerlink" title="输入样例 2："></a>输入样例 2：</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">2</span>aaa <span class="token parameter variable">-9999</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="输出样例-2："><a href="#输出样例-2：" class="headerlink" title="输出样例 2："></a>输出样例 2：</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ERROR: aaa is not a legal numberERROR: <span class="token parameter variable">-9999</span> is not a legal numberThe average of <span class="token number">0</span> numbers is Undefined<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>代码长度限制        16 KB；时间限制        400 ms；内存限制        64 MB；</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstdio></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> n<span class="token punctuation">,</span> cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> a<span class="token punctuation">[</span><span class="token number">50</span><span class="token punctuation">]</span><span class="token punctuation">,</span> b<span class="token punctuation">[</span><span class="token number">50</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">double</span> temp <span class="token operator">=</span> <span class="token number">0.0</span><span class="token punctuation">,</span> sum <span class="token operator">=</span> <span class="token number">0.0</span><span class="token punctuation">;</span>    cin <span class="token operator">>></span> n<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">sscanf</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> <span class="token string">"%lf"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>temp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//从a读出，并以%lf的格式转为int类型，a->temp。</span>        <span class="token function">sprintf</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span> <span class="token string">"%.2f"</span><span class="token punctuation">,</span>temp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//将temp保留两位小数后输出到b中，而不是控制台。</span>        <span class="token keyword">int</span> flag <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token function">strlen</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">!=</span> b<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> flag <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//看看a是不是两位小数以内</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>flag <span class="token operator">||</span> temp <span class="token operator">&lt;</span> <span class="token operator">-</span><span class="token number">1000</span> <span class="token operator">||</span> temp <span class="token operator">></span> <span class="token number">1000</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"ERROR: %s is not a legal number\n"</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">continue</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            sum <span class="token operator">+=</span> temp<span class="token punctuation">;</span>            cnt<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>cnt <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"The average of 1 number is %.2f"</span><span class="token punctuation">,</span> sum<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>cnt <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"The average of %d numbers is %.2f"</span><span class="token punctuation">,</span> cnt<span class="token punctuation">,</span> sum <span class="token operator">/</span> cnt<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"The average of 0 numbers is Undefined"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="分析：使用sprintf和sscanf函数"><a href="#分析：使用sprintf和sscanf函数" class="headerlink" title="分析：使用sprintf和sscanf函数~"></a>分析：使用sprintf和sscanf函数~</h3><p>char str[128];</p><p>int num = -150;</p><p>int num2;</p><p>//数字转字符串，和printf的区别是不输出到屏幕上，而是输出到字符串里</p><p>sprintf(str, “%d”, num);</p><p>//字符串转数字，和scanf的区别是不从键盘读，而是从字符串里读</p><p>sscanf(str, “%d”, &amp;num2);</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 法学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PAT 1028 人口普查</title>
      <link href="/2023/06/20/patbasiclevelpractice-zhong-wen-1028-ren-kou-pu-cha/"/>
      <url>/2023/06/20/patbasiclevelpractice-zhong-wen-1028-ren-kou-pu-cha/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="PAT-1028-人口普查"><a href="#PAT-1028-人口普查" class="headerlink" title="PAT 1028 人口普查"></a>PAT 1028 人口普查</h2><h3 id="题目简介："><a href="#题目简介：" class="headerlink" title="题目简介："></a>题目简介：</h3><p>某城镇进行人口普查，得到了全体居民的生日。现请你写个程序，找出镇上最年长和最年轻的人。这里确保每个输入的日期都是合法的，但不一定是合理的——假设已知镇上没有超过 200 岁的老人，而今天是 2014 年 9 月 6 日，所以超过 200 岁的生日和未出生的生日都是不合理的，应该被过滤掉。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在第一行给出正整数 N，取值在(0,105]；随后 N 行，每行给出 1 个人的姓名（由不超过 5 个英文字母组成的字符串）、以及按 <code>yyyy/mm/dd</code>（即年/月/日）格式给出的生日。题目保证最年长和最年轻的人没有并列。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>在一行中顺序输出有效生日的个数、最年长人和最年轻人的姓名，其间以空格分隔。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">5</span>John <span class="token number">2001</span>/05/12Tom <span class="token number">1814</span>/09/06Ann <span class="token number">2121</span>/01/30James <span class="token number">1814</span>/09/05Steve <span class="token number">1967</span>/11/20<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">3</span> Tom John<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>代码长度限制        16 KB；        时间限制        200 ms；内存限制        64 MB。</p><h3 id="解析："><a href="#解析：" class="headerlink" title="解析："></a>解析：</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstdlib></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;algorithm></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">peo</span><span class="token punctuation">&#123;</span>    string name<span class="token punctuation">;</span>    <span class="token keyword">int</span> year<span class="token punctuation">;</span>    <span class="token keyword">int</span> month<span class="token punctuation">;</span>    <span class="token keyword">int</span> day<span class="token punctuation">;</span>    <span class="token function">peo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span>    <span class="token function">name</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">year</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">month</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">day</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token function">peo</span><span class="token punctuation">(</span>string _name<span class="token punctuation">,</span> <span class="token keyword">int</span> _year<span class="token punctuation">,</span> <span class="token keyword">int</span> _month<span class="token punctuation">,</span> <span class="token keyword">int</span> _day<span class="token punctuation">)</span><span class="token operator">:</span>    <span class="token function">name</span><span class="token punctuation">(</span>_name<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">year</span><span class="token punctuation">(</span>_year<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">month</span><span class="token punctuation">(</span>_month<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">day</span><span class="token punctuation">(</span>_day<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">bool</span> <span class="token function">cmp</span><span class="token punctuation">(</span>peo p1<span class="token punctuation">,</span> peo p2<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>p1<span class="token punctuation">.</span>year<span class="token operator">!=</span>p2<span class="token punctuation">.</span>year<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> p1<span class="token punctuation">.</span>year<span class="token operator">&lt;</span>p2<span class="token punctuation">.</span>year<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>p1<span class="token punctuation">.</span>month<span class="token operator">!=</span>p2<span class="token punctuation">.</span>month<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> p1<span class="token punctuation">.</span>month<span class="token operator">&lt;</span>p2<span class="token punctuation">.</span>month<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>p1<span class="token punctuation">.</span>day<span class="token operator">!=</span>p2<span class="token punctuation">.</span>day<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> p1<span class="token punctuation">.</span>day<span class="token operator">&lt;</span>p2<span class="token punctuation">.</span>day<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> n<span class="token punctuation">;</span>    cin<span class="token operator">>></span>n<span class="token punctuation">;</span>    vector<span class="token operator">&lt;</span>peo<span class="token operator">></span> v<span class="token punctuation">;</span><span class="token comment">//如果想使用v(n)来初始化大小，必须自己定义默认构造函数</span>    <span class="token comment">//我不知到为什么使用vector&lt;peo> v(n)初始化之后，输出的v[0].name是几个空格，而且v.size()是3，没有变大</span>    peo <span class="token function">max</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">,</span> <span class="token number">2014</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//最大日期</span>    peo <span class="token function">min</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">,</span> <span class="token number">1814</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//最小日期</span>    string name<span class="token punctuation">,</span> bir<span class="token punctuation">;</span>    <span class="token keyword">int</span> sum<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//     peo p2("max", 2014, 9, 7);</span><span class="token comment">//     peo p3("min", 1814, 9, 5);</span><span class="token comment">//     cout&lt;&lt;cmp(p2, max)&lt;&lt;" "&lt;&lt;cmp(min, p3)&lt;&lt;endl;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        cin<span class="token operator">>></span>name<span class="token operator">>></span>bir<span class="token punctuation">;</span>        <span class="token keyword">int</span> y<span class="token operator">=</span><span class="token function">strtod</span><span class="token punctuation">(</span>bir<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> m<span class="token operator">=</span><span class="token function">strtod</span><span class="token punctuation">(</span>bir<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> d<span class="token operator">=</span><span class="token function">strtod</span><span class="token punctuation">(</span>bir<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        peo <span class="token function">p1</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> y<span class="token punctuation">,</span> m<span class="token punctuation">,</span> d<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">cmp</span><span class="token punctuation">(</span>p1<span class="token punctuation">,</span> max<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">cmp</span><span class="token punctuation">(</span>min<span class="token punctuation">,</span> p1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//处在最大，最小之间。</span>            v<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>p1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//自动扩容</span>            sum<span class="token operator">++</span><span class="token punctuation">;</span><span class="token comment">//记录总数</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">sort</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> v<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> cmp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//自定义排序</span><span class="token comment">//     for(int i=0; i&lt;v.size(); i++)&#123;</span><span class="token comment">//         cout&lt;&lt;v[i].name&lt;&lt;" ";</span><span class="token comment">//     &#125;</span><span class="token comment">//     cout&lt;&lt;endl;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>v<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">//注意v的size，否则引发段错误，意思就是非法访问了内存。</span>        cout<span class="token operator">&lt;&lt;</span>sum<span class="token operator">&lt;&lt;</span><span class="token string">" "</span><span class="token operator">&lt;&lt;</span>v<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>name<span class="token operator">&lt;&lt;</span><span class="token string">" "</span><span class="token operator">&lt;&lt;</span>v<span class="token punctuation">[</span>v<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>name<span class="token punctuation">;</span>    <span class="token keyword">else</span><span class="token punctuation">&#123;</span>        cout<span class="token operator">&lt;&lt;</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Oracle数据库的基础</title>
      <link href="/2023/06/20/oracle-shu-ju-ku-de-ji-chu/"/>
      <url>/2023/06/20/oracle-shu-ju-ku-de-ji-chu/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="小知识点"><a href="#小知识点" class="headerlink" title="小知识点"></a>小知识点</h1><h2 id="1、dec"><a href="#1、dec" class="headerlink" title="1、dec"></a>1、dec</h2><p>Oracle 数据类型：decimal | dec (presicion，scale) p是精度，代表有效位数，scale表示小数部分的范围，比如dec(8, 2)代表8位整数部分，2位小数部分。</p><h2 id="2、nvl"><a href="#2、nvl" class="headerlink" title="2、nvl"></a>2、nvl</h2><p>语法</p><p>NVL(eExpression1, eExpression2)</p><p>从两个表达式返回一个非 null 值。</p><p>参数</p><p>eExpression1, eExpression2</p><p>如果 eExpression1 的计算结果为 null 值，则eExpression2。如果 eExpression1 的计算结果不是 null 值，则返回 eExpression1。eExpression1 和 eExpression2 可以是任意一种数据类型。如果 eExpression1 与 eExpression2 的结果皆为 null 值，则 NVL( ) 返回 .NULL.</p><h2 id="3、minus"><a href="#3、minus" class="headerlink" title="3、minus"></a>3、minus</h2><p>“minus”直接翻译为中文是“减”的意思，在Oracle中也是用来做减法操作的，只不过它不是传统意义上对数字的减法，而是对查询结果集的减法。 A minus B就意味着将结果集A去除结果集B中所包含的所有记录后的结果，即在A中存在，而在B中不存在的记录。</p><h2 id="4、连接join"><a href="#4、连接join" class="headerlink" title="4、连接join"></a>4、连接join</h2><p><a href="https://blog.csdn.net/lightningmn/article/details/52805457">各种join的详细简单的解释</a></p><h2 id="5、数据库设计范式"><a href="#5、数据库设计范式" class="headerlink" title="5、数据库设计范式"></a>5、数据库设计范式</h2><h3 id="数据库设计第一范式：（设计出没有数据冗余和数据维护异常的数据库结构）"><a href="#数据库设计第一范式：（设计出没有数据冗余和数据维护异常的数据库结构）" class="headerlink" title="数据库设计第一范式：（设计出没有数据冗余和数据维护异常的数据库结构）"></a>数据库设计第一范式：（设计出没有数据冗余和数据维护异常的数据库结构）</h3><p>1、数据库表中的所有字段都只具有单一属性</p><p>2、单一属性的列是由基本的数据类型所构成的</p><p>3、设计出来的表都是简单的二维表</p><h3 id="数据库设计第二范式："><a href="#数据库设计第二范式：" class="headerlink" title="数据库设计第二范式："></a>数据库设计第二范式：</h3><p>要求一个表中只具有一个业务主键，也就是说符合第二范式的表中不能存在非主键列对只对部分主键的依赖关系</p><h3 id="数据库设计第三范式："><a href="#数据库设计第三范式：" class="headerlink" title="数据库设计第三范式："></a>数据库设计第三范式：</h3><p>指每一个非主属性既不部分依赖于也不传递依赖于业务主键，也就是在第二范式的基础上消除了非主键属性对主键的传递依赖</p><h1 id="数据库概念"><a href="#数据库概念" class="headerlink" title="数据库概念"></a>数据库概念</h1><p>长期储存在计算机内，有组织，可共享的大量数据的集合，就是数据库</p><p>数据库管理系统，（DBMS，databace mangement system），用于创建操作和管理数据库的应用程序</p><p>:xx,dnmcg2IR</p><p>数据库用来管理数据，QQ为什么能这么厉害，就是因为他有很多数据，这些数据是商业机密，使用数据库存储数据占用存储空间小，并且查询数据快Alter TABLE XS ADD ENG CHAR(20); —添加新的列</p><p><img src="https://img-blog.csdnimg.cn/15e4006db5584c11b08101a50cb98bfa.png" alt=""></p><h1 id="数据库操作语言"><a href="#数据库操作语言" class="headerlink" title="数据库操作语言"></a>数据库操作语言</h1><p><img src="https://img-blog.csdnimg.cn/09d8361536ab4cb38ed17e0299698244.png" alt=""></p><p><img src="https://img-blog.csdnimg.cn/33e3ef2a636d4fb58cf0b625aa5bd9c7.png" alt=""></p><h1 id="关系的基本概念"><a href="#关系的基本概念" class="headerlink" title="关系的基本概念"></a>关系的基本概念</h1><p><img src="https://img-blog.csdnimg.cn/c2df04e0503c423aa999b03861a20362.png" alt=""></p><p><img src="https://img-blog.csdnimg.cn/039fd6a233844267a107fa07024aa4f0.png" alt=""></p><p><img src="https://img-blog.csdnimg.cn/ea7ac41a57374271a169b6adfd48f5bd.png" alt=""></p><p>自己的某一个属性（或属性集合）在其他表中是主码，则在自己表中这个属性（或属性集合）是外码</p><h1 id="实体完整性"><a href="#实体完整性" class="headerlink" title="实体完整性"></a>实体完整性</h1><p>实体完整性：（primary key）不能是空值，不能重复</p><p><img src="https://img-blog.csdnimg.cn/8302813b572c481b801a2869363a4d4a.png" alt=""></p><h1 id="参照完整性：（foreign-key）可以是空值，"><a href="#参照完整性：（foreign-key）可以是空值，" class="headerlink" title="参照完整性：（foreign key）可以是空值，"></a>参照完整性：（foreign key）可以是空值，</h1><p><img src="https://img-blog.csdnimg.cn/8fdabac448584a039ed135d6eba7c81f.png" alt=""></p><p><img src="https://img-blog.csdnimg.cn/dff81e2cc37748e188ed3ebf4ffd7cf2.png" alt=""></p><p>select id)</p><p>from xs</p><p>where to_char(birthday,’yyyy-mm-dd’) =’2002-06-28’;</p><p>将日期转化成char类型</p><h1 id="一些函数控制字符"><a href="#一些函数控制字符" class="headerlink" title="一些函数控制字符"></a>一些函数控制字符</h1><p><img src="https://img-blog.csdnimg.cn/fb0f9125543d4da5bc2b768a0e552eb9.png" alt=""></p><h1 id="dual"><a href="#dual" class="headerlink" title="dual"></a>dual</h1><p><img src="https://img-blog.csdnimg.cn/94b6e9c83d014a889e77de691d9e3670.png" alt=""></p><p>dual是一个一行一列的虚拟表，常用来计算表达式</p><p><img src="https://img-blog.csdnimg.cn/038b7d1d14df47278f4c8e2a3ca2eb5f.png" alt=""></p><h1 id="desc关键字"><a href="#desc关键字" class="headerlink" title="desc关键字"></a>desc关键字</h1><p>desc 查看表的结构，</p><p><img src="https://img-blog.csdnimg.cn/fafe7f4917d545d58157d142942bda99.png" alt=""></p><p>Alter TABLE XS ADD ENG CHAR(20); —添加新的列</p><p>UPDATE XS SET ENG=’ENGLISH’ WHERE DEPT=’计算机’;将dept=计算机的ENG改为‘english’ SELECT SNAME, LOWER(ENG) AS LOW_ENG—将eng属性改为小写，重新命名成LOW_ENG,函数LOWER</p><p>FROM XS WHERE DEPT=’计算机’;</p><p>commit; —&gt;提交数据</p><p>  rollback; —&gt;回滚数据</p><p>select * from user_tables;—查询用户下的所有表</p><h1 id="having和-where的区别："><a href="#having和-where的区别：" class="headerlink" title="having和 where的区别："></a>having和 where的区别：</h1><p>where在数据分组前进行过滤，having在数据分组过后进行过滤，</p><p>使用having时应该结合Group by语句，where 用于标准的行级过滤</p><h1 id="2022-3-9"><a href="#2022-3-9" class="headerlink" title="2022 3-9"></a>2022 3-9</h1><pre class="line-numbers language-none"><code class="language-none">--2022 3-9create table stu(SNO CHAR(6) PRIMARY KEY,SNAME VARCHAR2(10) UNIQUE,DEPT VARCHAR2(20) NOT NULL,SEX VARCHAR2(4) DEFAULT(&#39;男&#39;),TOTALCREDIT NUMBER(3, 0) CHECK(TOTALCREDIT&gt;&#x3D;0));insert into stu values (&#39;100001&#39;,&#39;hzy&#39;, &#39;jsj&#39;, &#39;女&#39;, &#39;100&#39;);insert into stu values (&#39;100001&#39;,&#39;hzz&#39;, &#39;jsj&#39;, &#39;女&#39;, &#39;100&#39;);insert into stu(sno,dept) values(&#39;111&#39;,&#39;rjgc&#39;);select * from stu;update stu set sname&#x3D;&#39;hjj&#39; where sno&#x3D;&#39;111&#39;;select * from stu;alter table stu modify sname varchar2(20);alter table stu modify sno char(10);alter table stu add nativeplace varchar2(20);alter table stu drop column nativeplace;alter table stu drop CONSTRAINT SYS_c007069;alter table stu add constraint stu_sname_unique unique(sname);create table stu1asselect * from stu;drop table stu1;insert into stu values(&#39;100002&#39;, &#39;张三&#39;,  &#39;计算机&#39;,&#39;男&#39;, &#39;10&#39;);--INSERT INTO stu(sno, )update stuset sex&#x3D;sex+10;update stuset dept&#x3D;&#39;软件工程&#39;where sname&#x3D;&#39;张三&#39;;delete from stuwhere TOTALCREDIT is null;commit;rollback;select * from xs;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/fa5a15a3bf3b4f3b81e3065b1f7c73f2.png" alt=""></p><h1 id="小知识点："><a href="#小知识点：" class="headerlink" title="小知识点："></a>小知识点：</h1><p>利用已有数据表建立一个新表，但不复制数据:</p><p>create TABLE S1</p><p>AS</p><p>SELECT * FROM STUDENT WHERE 1=0;</p><p><img src="https://img-blog.csdnimg.cn/4f2d9b6cd537477d862f33a6a762ab1a.png" alt=""></p><p>UPDATE STU SET TOTALCREDIT=NVL(TOTALCREDIT, 0)+2;</p><p>NVL(TOTALCREDIT, 0):如果totalcredit不是空，就用原来的值，是空，就用0来代替；</p><p>FROM ZLGC WHERE CATEGORY=’课程思政示范课程’ AND COUNT(CATEGORY)&gt;50 GROUP BY SCHOOL,CATEGORY ORDER BY COUNT(CATEGORY) DESC</p><p>ERROR: ORA-00934: 此处不允许使用分组函数</p><p><img src="https://img-blog.csdnimg.cn/682e669c3da14131afbd5fbd801f7673.png" alt=""></p><p>要使用having 来过滤分组</p><h1 id="2022-3-19数据库实验心得"><a href="#2022-3-19数据库实验心得" class="headerlink" title="2022-3-19数据库实验心得"></a>2022-3-19数据库实验心得</h1><p>在本次实验中，我遇到的问题首先是1-1题目中extract函数的使用，通过从网上查询知道了，我学习到该函数的作用是将年份从date中分离出来单独计算从而得到年龄，第二个问题是2-4题目中过滤学生人数小于3的的语句，不能在group by 语句前面加where来过滤，如果使用了，错误信息是这样的，</p><p><img src="https://img-blog.csdnimg.cn/2bc12af0dac646d285de4421a091a22e.png" alt=""></p><p>查阅资料后学习到了，有group by 语句时where中不能使用聚合函数来过滤数据，此时只能使用having语句，并且having语句只能跟在group by 语句后面。这两个问题是我在本次实验中遇到的最大的难题，解决了之后，真的学习到了很多。</p><p>在本次实验中，我首先在创建user用户时就遇到了，用户名或角色名是不存在的问题，然后我先想着改一下用户名为users，结果成功了，后来才从老师那里得知是用户过期了的原因，要重新编辑用户信息才可以。</p><p>然后我在1-4题目中遇到了对设置组合主键，外键操作的不熟练问题，还有就是对于alter table tablename add colname VARCHAR(20)（添加列）;alter table tablename drop column colname（删除列）;alter table tablename drop constraint SYS_C007120;（去除限制）add constraint UQ_CNAME UNIQUE(CNAME)（添加限制）;这几个操作的不熟练，最后遇到的问题是赋值一表的结构到一个新表（不复制数据），从网上查阅资料后，知道了</p><p>最关键的一步是：SELECT * FROM STUDENT WHERE 1=0;设置一个不可能的条件，选择之后，就不会剩下数据了。解决了这些问题后，有很大的收获。</p><h1 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h1><p>里面存储的是SQL语句，不是查询结果</p><p>创建视图后不显示结果，要通过select语句来查询</p><p><img src="https://img-blog.csdnimg.cn/9293cda35f98419d99478094baa9258e.png" alt=""></p><p><img src="https://img-blog.csdnimg.cn/91378483b1f242bdb11607af8c751e13.png" alt=""></p><p>视图的作用：简化查询语句</p><p><img src="https://img-blog.csdnimg.cn/144c129584974adb8aafe47ccc35adff.png" alt=""></p><p>有些视图可以更新，有些不可以</p><p>SELECT * FROM A NATURAL JOIN B WHERE B.B = A.B;</p><p><img src="https://img-blog.csdnimg.cn/92bb37464bbb4673a0be9fbc733367b5.png" alt=""></p><h1 id="联结表"><a href="#联结表" class="headerlink" title="联结表"></a>联结表</h1><p>sql的left join 、right join 、inner join之间的区别</p><p>　　left join(左联接) 返回包括左表中的所有记录和右表中联结字段相等的记录 </p><p>　　right join(右联接) 返回包括右表中的所有记录和左表中联结字段相等的记录</p><p>　　inner join(等值连接) 只返回两个表中联结字段相等的行</p><pre class="line-numbers language-none"><code class="language-none">左连接SELECT *FROM student  # 主表（不会受到影响）LEFT JOIN score  # 辅表（只有满足条件的才会显示）ON student.ID &#x3D; score.SID右连接SELECT *FROM student  # 主表（只有满足条件的才会显示）RIGHT JOIN score  # 辅表（不会受到影响）ON student.ID &#x3D; score.SID全连接（是个笛卡尔积？）SELECT *FROM studentFULL JOIN scoreselect sname, cname, tname, grade--自连接  ：只返回两张表连接列的匹配项。--以下三种查询结果一样。select * from student s inner join class c on s.classid&#x3D;c.id; select * from student s join class c on s.classid&#x3D;c.id;select * from student s,class c where s.classid&#x3D;c.id;--笛卡儿乘积连接 ：即不加任何条件，达到 M*N 的结果集。--以下两种查询结果一样。select * from student s cross join class c;select * from student,class;--加上条件，产生跟自连接一样的结果。select * from student s cross join class c where s.classid&#x3D;c.id;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>自然连接要注意：</p><p>SELECT * FROM A NATURAL JOIN B WHERE B.B = A.B;</p><p>SELECT * FROM A NATURAL JOIN B on B.B = A.B;</p><p>这两种方法都会报错，不能有限制条件。因为自然连接它自动的进行了等值比较，所以不需要加上限制条件让他们的连接起来，自然连接是一种特殊的等值连接。</p><p><img src="https://img-blog.csdnimg.cn/17a828df928a41c88f0cf77da8c419ed.png" alt=""></p><h1 id="自然连接与等值连接的区别："><a href="#自然连接与等值连接的区别：" class="headerlink" title="自然连接与等值连接的区别："></a>自然连接与等值连接的区别：</h1><p><a href="https://zhidao.baidu.com/question/429546959.html">sql server 等值连接和自然连接的 用法_百度知道 (baidu.com)</a></p><p>SELECT * FROM A, B WHERE A.B=B.B;</p><p>这是等值连接，相同的属性列会保存</p><p>自然连接是一种特殊的等值内连接，它是由系统根据两表的同名字段自动作等值比较的内连接，不需要用ON关键字指定连接条件</p><p><img src="https://img-blog.csdnimg.cn/f05ca09c4af44eac8406ba1c77d55cbf.png" alt=""></p><p>SELECT * FROM A NATURAL JOIN B ;</p><p>这是自然连接，自然连接是一种将相同属性列删除的等值连接</p><p><img src="https://img-blog.csdnimg.cn/05a3412b170c479cb9d6558842859bd2.png" alt=""></p><p>自然连接四个表 </p><pre class="line-numbers language-none"><code class="language-none">FROM STUDENT NATURAL JOIN SCORE NATURAL JOIN COURSE NATURAL JOIN TEACH WHERE COURSE.CNAME&#x3D;&#39;数学分析&#39; and TEACH.TNAME&#x3D;&#39;严敏&#39;;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="ANY-ALL"><a href="#ANY-ALL" class="headerlink" title="ANY ALL"></a>ANY ALL</h1><p><img src="https://img-blog.csdnimg.cn/4f1fe1ece8444b5caf81e7aca6e9244e.png" alt=""></p><p><a href="https://blog.csdn.net/zl111_1/article/details/54980639">ANY ALL的区别</a></p><p>总结成一句话就是：all 是满足所有的， and and and；any 是满足其中一个就可以，or or or</p><h1 id="2022-实验三总结"><a href="#2022-实验三总结" class="headerlink" title="2022-实验三总结"></a>2022-实验三总结</h1><p>在这次实验过程中遇到的问题就很多了，首先第一题就来了一个下马威，分不清三种连接的区别，搞得无从下手，最后自己弄了两个表才弄懂了前两个的区别，如下图：等值连接相同的属性会保留，而自然连接就会将它们合并，自然连接是一种特殊的等值连接，终于理解了，自己找了几个小时。还有一个就是join后面总是忘掉加上on条件，报了三四次缺少关键字错误才发现，我学会了，做这种题目时要首先弄清楚概念就很好下手了。然后就是left join 、right join、full join ，区分这几个，首先区分：主表（不会受到影响）， 辅表（只有满足条件的才会显示），left join 左为主表，右辅表；right join 则相反，最后的not exists的双重否定，更是搞得稀里糊涂，现在还是有点不明白。每一次实验都是一次不错的成长。</p><p>数据放到表中，表再放到库中</p><p>表中的列相当于类中的属性， 每一行相当于对象</p><p><img src="https://img-blog.csdnimg.cn/8be32587e3dc49f88d283b41c11d4537.png" alt=""></p><p>‘%’会过滤掉空值：</p><p>SELECT * FROM XS;</p><p>SELECT * FROM XS WHERE REMARKS LIKE ‘%’;</p><h1 id="2022-3-30"><a href="#2022-3-30" class="headerlink" title="2022-3-30"></a>2022-3-30</h1><pre class="line-numbers language-none"><code class="language-none">--2022-3-30create index idx_xs_sname on xs(sname);--索引只创建，不自己使用，由系统调用select * FROM XS WHERE SNAME LIKE &#39;_%&#39;;--视图：安全（设置用户权限），简化使用，保存的是查询语句--视图(VIEW)也被称作虚表，即虚拟的表，是一组数据的逻辑表示,其本质是对应于一条SELECT语句，--结果集被赋予一个名字，即视图名字。视图本身并不包含任何数据，它只包含映射到基表的一个查询语句，--当基表数据发生变化，视图数据也随之变化。SELECT * FROM XS WHERE DEPT&#x3D;&#39;计算机&#39;;--创建视图--计算区分度SELECT count (DISTINCT(SNAME))&#x2F;count(*) FROM XS;--计算区分度--WITH CHECK OPTION 子句强制所有数据修改语句均根据视图执行，--以符合定义视图的 SELECT 语句中所设的条件。--WITH CHECK OPTION的作用?--1.对于update,有with check option，要保证update后，数据要被视图查询出来；--2.对于delete,有无with check option都一样；--4.对于insert,有with check option，要保证insert后，数据要被视图查询出来；--5.对于没有where 子句的视图，使用with check option是多余的。 SELECT *FROM XS;CREATE VIEW DEPT3ASSELECT *FROM XS WHERE TOTALCREDIT&gt;70 WITH CHECK OPTION;UPDATE DEPT3SET TOTALCREDIT&#x3D;60WHERE SNAME&#x3D;&#39;林一帆&#39;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="PL-SQL"><a href="#PL-SQL" class="headerlink" title="PL/SQL:"></a>PL/SQL:</h1><p>PL/SQL也是一种程序语言，叫做过程化SQL语言（Procedural Language/SQL）。PL/SQL是Oracle数据库对SQL语句的扩展。在普通SQL语句的使用上增加了编程语言的特点，所以PL/SQL就是把数据操作和查询语句组织在PL/SQL代码的过程性单元中，通过逻辑判断、循环等操作实现复杂的功能或者计算的程序语言。PL/SQL是Oracle对标准数据库语言SQL的过程化扩充，它将数据库技术和过程化程序设计语言联系起来（通俗的说，SQL与编程语言的混血儿），是一种应用开发语言，可使用循环，分支处理数据，将SQL的数据操纵功能与过程化语言数据处理功能结合起来.PL/SQL的使用，使SQL成为一种高级程序设计语言，支持高级语言的块操作，条件判断，循环语句，嵌套等，与数据库核心的数据类型集成，使SQL 的程序设计效率更高.</p><h1 id="select-选择了一些列之后，如果里面有聚合函数，后面一定要有group函数否则会报错，原因如下："><a href="#select-选择了一些列之后，如果里面有聚合函数，后面一定要有group函数否则会报错，原因如下：" class="headerlink" title="select 选择了一些列之后，如果里面有聚合函数，后面一定要有group函数否则会报错，原因如下："></a>select 选择了一些列之后，如果里面有聚合函数，后面一定要有group函数否则会报错，原因如下：</h1><p>最近写SQL的时候，有遇到过报出 ORA-00937的问题。</p><p>解释：</p><p>select 列表项中除了包含聚合函数外，还包含了表的某些列，那么你将必须使用group by语句，否则语法通不过。</p><p>例如：</p><p>SQL&gt;</p><p>1 select deptno,job,avg(sal)</p><p>2 from emp</p><p>3 ;</p><p>ERROR 位于第 1 行:</p><p>ORA-00937: 非单组分组函数</p><p>其实这里也非常容易理解，你既然指定了聚合函数，又同时制定了其他列，还想不按照指定的列来分组，你到底想让oracle怎么做呢？</p><p>这根本就得不出结果。就像你需要统计班上男女生的人数，但是又不能分组，只能在一条数据里表示出来，怎么能办得到呢？</p><p>所以这里的group by是必须的。</p><p>上面的错误纠正为：</p><p>select deptno,job,avg(sal) from emp group by deptno,job;</p><p>就OK了</p><p>原文链接：<a href="https://blog.csdn.net/linwei_1029/article/details/5868082">聚合函数与列同时选择，需要Group</a></p><pre class="line-numbers language-none"><code class="language-none">create sequence table1_idminvalue 1             --自增字段最小值nomaxvalue           --最大值 没有就算nomaxvalueincrement by 1      --每次增值1start with 1           --起始值nocache;             --不缓存CREATE SEQUENCE TABLE_ID--创建顺序表MINVALUE 1--最小值NOMAXVALUE--无最大值INCREMENT BY 1--递增量START WITH 1--起始值NOCACHE;--无缓存--第三步：创建触发器create or replace trigger SCORE1triggerbefore insert on SCORE1 for each rowbeginselect table1_id.nextval into:new.sid from dual;end SCORE1trigger;Mysql中：create table UserTable (USERID INT(4) PRIMARY KEY AUTO_INCREMENT NOT NULL,UNAME VARCHAR(20) NOT NULL,UPASSWARD VARCHAR(20) NOT NULL)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="2022-4-2实验四总结"><a href="#2022-4-2实验四总结" class="headerlink" title="2022-4-2实验四总结"></a>2022-4-2实验四总结</h1><p> 在本次实验中，我首先遇到的问题是创建视图时，带上WITH CHECK OPTION选项与不带的区别：如果根据视图来更改数据，一定要符合创建视图的时候的where 的条件。第二个是创建两个字段的视图 grade_avg_view，select 选择了一些列之后，如果里面有聚合函数，后面一定要有group函数否则会报错。最后一个是设置自增型的主键，在mysql中使用AUTO_INCREMENT 可以直接创建，但是在Oracle中要先创建一个递增序列，然后再创建一个触发器才可以。</p><h1 id="索引，范式和锁"><a href="#索引，范式和锁" class="headerlink" title="索引，范式和锁"></a>索引，范式和锁</h1><p>索引：每个表如果设置了主键就会有有一个主键索引，在Mysql中，使用的时InnoDB引擎，每一个索引就是一颗B+树，也可以创建非主键索引，二级索引，二级索引和主键索引的不同之处在于其叶子节点上保存的值不一样，表中所有字段的值都被完整的保存在主键索引的叶子节点上，但是二级索引的叶子节点只保存对应主键的值。这里的叶子节点上只保存了主键的值，所以还需要通过获得的主键 ID 值再回到主键索引上查出所有字段的值，这个过程称作回表。</p><ul><li>数据库方面，能会基本的增删改查即可，外带一些基本概念，比如事务怎么处理，JDBC里批处理怎么处理。</li></ul><p><img src="https://img-blog.csdnimg.cn/10a6d9b39c07447986018076661b827f.png" alt=""></p><p>创建表时，凡是能通过计算出来的字段都不要把它当成属性列；</p><h1 id="创建函数、过程"><a href="#创建函数、过程" class="headerlink" title="创建函数、过程"></a>创建函数、过程</h1><p>存储过程不一定要有返回值，函数一定要有</p><p>注意存储过程in out inout 三种参数类型，而函数只有in</p><p> 创建函数：</p><pre class="line-numbers language-none"><code class="language-none">CREATE OR REPLACE FUNCTION COUNT_CREDIT(STUNO in VARCHAR2) RETURN NUMBERASCRED NUMBER:&#x3D;0;TOTAL_CRED NUMBER:&#x3D;0;BEGINFOR STUCUR IN(SELECT SNO, CNO, GRADE FROM cj WHERE SNO&#x3D;STUNO AND GRADE&gt;&#x3D;60) LOOPSELECT CREDIT INTO CRED FROM KC WHERE CNO&#x3D;STUCUR.CNO;TOTAL_CRED:&#x3D;TOTAL_CRED+CRED;END LOOP;RETURN TOTAL_CRED;END COUNT_CREDIT;作业create or replace function count_credit(stuno in varchar2) return varchar2as cred number:&#x3D;0;total_cred number:&#x3D;0;begin  for stucur in(select sno, cno, grade from score where sno&#x3D;stuno and grade &gt;60) loop    select credit into cred from course where cno&#x3D;stucur.cno;    total_cred:&#x3D;total_cred+cred;  end loop;  return total_cred;end count_credit;函数的执行：1、select COUNT_CREDIT(&#39;96001&#39;) as total_credit from dual;2、variable a number(10, 0)--声明变量begin:a:&#x3D;COUNT_CREDIT(&#39;96001&#39;);end;&#x2F;后面加上一句：print a;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>创建过程：</p><pre class="line-numbers language-none"><code class="language-none">create or replace procedure count_credi(stusno in varchar2 , creditj out number )--warning：in outascred number:&#x3D;0;total_cred number:&#x3D;0;beginfor cjcur in (select * from cj where sno&#x3D; stusno) loopselect credit into cred from kc where cno&#x3D;cjcur.cno;total_cred:&#x3D;total_cred+cred*cjcur.grade;end loop;creditj:&#x3D;total_cred&#x2F;count_credit(stusno);end count_credi;作业create or replace procedure pro_findname(tmpname in VARCHAR2) asbegin  for stucur in(select sno,sname from student where sname like tmpname ) loop   dbms_output.put_line(stucur.sno || &#39;&#39; ||stucur.sname);--   end loop;  null;end pro_findname;set serveroutput off1、set serveroutput onbegin  pro_findname(&#39;%马%&#39;);end;&#x2F;2、exec pro_findname(&#39;%马%&#39;);--注意这里的调用时使用%，而不是在存储过程中<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>触发器：</p><p>触发器的用法</p><p>触发器与存储过程和函数不同，函数和存储过程需要用户显示调用，触发器时在某个事件发生时，自动的隐式的完成，所以叫触发或者点火（firing）</p><pre class="line-numbers language-none"><code class="language-none">create or replace trigger sum_credit after insert on  scorefor each rowbegin  update student   set TOTALCREDIT&#x3D;TOTALCREDIT+(select credit from course where cno&#x3D;:new.cno)  where sno&#x3D;:new.sno and :new.grade&gt;60;  null;end;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>触发器的语法 </p><pre class="line-numbers language-none"><code class="language-none">create trigger &lt;触发器名称&gt;&#123; before | after&#125;          # 之前或者之后出发insert | update | delete   # 指明了激活触发程序的语句的类型on &lt;表名&gt;                   # 操作哪张表for each row  # 触发器的执行间隔，for each row--通知触发器每隔一行执行一次动作，--而不是对整个表执行一次。&lt;触发器SQL语句&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="dbms-output-put-line的用法"><a href="#dbms-output-put-line的用法" class="headerlink" title="dbms_output.put_line的用法"></a>dbms_output.put_line的用法</h1><p>涉及到的知识点如下： 1、enable：在serveroutput on的情况下，用来使dbms_output生效(默认即打开) 2、disable：在serveroutput on的情况下，用来使dbms_output失效 3、put：将内容写到内存，等到put_line时一起输出 4、put_line：不用多说了，输出字符 5、new_line：作为一行的结束，可以理解为写入buffer时的换行符 6、get_line(value, index)：获取缓冲区的单行信息 7、get_lines(array, index)：以数组形式来获取缓冲区的多行信息</p><p>oracle系统包—-dbms_output用法</p><p><a href="https://blog.51cto.com/u_15127666/3474569">博客</a></p><h1 id="E-R图转关系模式"><a href="#E-R图转关系模式" class="headerlink" title="E-R图转关系模式"></a>E-R图转关系模式</h1><p><img src="https://img-blog.csdnimg.cn/ac4a564dfda445f3a03983b6da03a28f.png" alt=""></p><p>转为关系模式</p><p><img src="https://img-blog.csdnimg.cn/ab43348e9ad3416c88a04333ed7af6bb.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql索引优化</title>
      <link href="/2023/06/20/mysql-suo-yin-you-hua/"/>
      <url>/2023/06/20/mysql-suo-yin-you-hua/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="Mysql索引分类"><a href="#Mysql索引分类" class="headerlink" title="Mysql索引分类"></a>Mysql索引分类</h2><p><img src="https://img-blog.csdnimg.cn/06214fd7ae2040dd973af7b6316b1b2b.png" alt=""></p><p><img src="https://img-blog.csdnimg.cn/c5213620e0dc448fbbd9df27f2c50d79.png" alt=""></p><p><img src="https://img-blog.csdnimg.cn/98e3fa0f9b404b729ad2742866740cec.png" alt=""></p><h2 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h2><p><img src="https://img-blog.csdnimg.cn/7f070dcd225941d5afd2f0a97bc4fa62.png" alt=""></p><p><img src="https://img-blog.csdnimg.cn/d0d2640627a045aa91f9a3f8f8188103.png" alt=""></p><p><img src="https://img-blog.csdnimg.cn/99282b1cdb584c9aaec1e7d8091c1580.png" alt=""></p><p>查看执行计划：possible keys，key，主要看table以后的数据</p><p><img src="https://img-blog.csdnimg.cn/4863bb8d00b549509f3f5bafb2576da9.png" alt=""></p><p><img src="https://img-blog.csdnimg.cn/c41ba2a28fb742fdae0759e134356ec0.png" alt=""></p><p>越往下越差。</p><p><img src="https://img-blog.csdnimg.cn/8adbddf6b3e04a629c24466bfb0a20d2.png" alt=""></p><p><img src="https://img-blog.csdnimg.cn/6427916d35e345da89a12ae2e9a023a2.png" alt=""></p><h2 id="优化策略"><a href="#优化策略" class="headerlink" title="优化策略"></a>优化策略</h2><p><img src="https://img-blog.csdnimg.cn/d2f5b7a5b20c4130904b1d9b6e50fc1e.png" alt=""></p><p><img src="https://img-blog.csdnimg.cn/4d23b7cc5a77485999f555d3a220b2d6.png" alt=""></p><p><img src="https://img-blog.csdnimg.cn/48f4227505d746778fe0ce3aa3486c91.png" alt=""></p><p><img src="https://img-blog.csdnimg.cn/9ff64e5768d240d1acc3bdc07fb9bcea.png" alt=""></p><p><img src="https://img-blog.csdnimg.cn/79bd0d750c0a4409add7fd5ff8ed7f2b.png" alt=""></p><p><img src="https://img-blog.csdnimg.cn/c51c0ab7f5904e8ca6e1b5b9e7163f16.png" alt=""></p><p><img src="https://img-blog.csdnimg.cn/1f84cfcf848d435ba26e2535fc0d06f3.png" alt=""></p><p><img src="https://img-blog.csdnimg.cn/ee16ab87fe264f0ebb6adb9d76621ed1.png" alt=""></p><p><img src="https://img-blog.csdnimg.cn/ddb9ac0d7565479aa30a7216c826a333.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maven基础</title>
      <link href="/2023/06/20/maven-ji-chu/"/>
      <url>/2023/06/20/maven-ji-chu/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="Maven简介"><a href="#Maven简介" class="headerlink" title="Maven简介"></a>Maven简介</h2><p><img src="https://img-blog.csdnimg.cn/b7e371e0409a48a2822253737d342140.png" alt=""></p><p> 简要来说就是将几个不同的软件下面本来都不同的目录结构都用统一的目录结构，让所有的IDE在建立Maven项目的时候都使用同一个标准，构建流程也是相同的。</p><p><strong>其中最厉害的还是依赖管理机制：</strong>依赖管理机制就是我们之前在使用一个包的时候要去手动下载和添加，利用Maven可以使用定位坐标来直接导入jar包，非常的方便</p><p><img src="https://img-blog.csdnimg.cn/b6eb56ff047c42c4893b43aa54b2ff4f.png" alt=""></p><p>当你写好了定位之后，他就会在电脑上面安装的Maven里面的仓库找到对应的jar包。 </p><p><img src="https://img-blog.csdnimg.cn/52a27bf0247849708341e4b847764e1a.png" alt=""></p><p>仓库也分为了好多种，如果本地仓库没有jar，就会去中央仓库下载（比较慢），中央仓库的东西都是开源的jar包， </p><p><img src="https://img-blog.csdnimg.cn/8449d1dc5e5e4fc798c0e06ca3b20cb0.png" alt=""></p><p>Idea下配置Maven： </p><p><img src="https://img-blog.csdnimg.cn/d943c8d86f67496292e53a518a55dec1.png" alt=""></p><p>Maven坐标 </p><p><img src="https://img-blog.csdnimg.cn/555413f1792e47fca958ce8a0a491c15.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux网络编程</title>
      <link href="/2023/06/20/linux-wang-luo-bian-cheng/"/>
      <url>/2023/06/20/linux-wang-luo-bian-cheng/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="网络通信结构"><a href="#网络通信结构" class="headerlink" title="网络通信结构"></a>网络通信结构</h1><h2 id="IP端格式"><a href="#IP端格式" class="headerlink" title="IP端格式"></a>IP端格式</h2><p><img src="https://img-blog.csdnimg.cn/b42480313f464402a487678706b27b3d.png" alt=""></p><p><img src="https://img-blog.csdnimg.cn/569097a03d034a9fa5084f418e0e380c.png" alt=""></p><h2 id="C-S和B-S模式"><a href="#C-S和B-S模式" class="headerlink" title="C/S和B/S模式"></a>C/S和B/S模式</h2><p><img src="https://img-blog.csdnimg.cn/7dc13a914cfd48519e368a14e0302f6f.png" alt=""></p><h2 id="网络字节序转换函数"><a href="#网络字节序转换函数" class="headerlink" title="网络字节序转换函数"></a>网络字节序转换函数</h2><p>在通信过程中，套接字是成对出现的</p><p><img src="https://img-blog.csdnimg.cn/cb2a5edf6a0f423ca87e4688e45f48fa.png" alt=""></p><h2 id="inet-pton函数"><a href="#inet-pton函数" class="headerlink" title="inet_pton函数"></a>inet_pton函数</h2><p>IP地址开始是点分十进制形式的，是一个字符串，如192.168.1.100，所以要将它转换为网络字节序地址需要这个inet_pton函数：本地字节序—&gt;网络字节序</p><p><img src="https://img-blog.csdnimg.cn/9e082d53710a4a6b9802705c0edda703.png" alt=""></p><h2 id="时间轮"><a href="#时间轮" class="headerlink" title="时间轮"></a>时间轮</h2><p>回到时间轮定时器，它主要解决的是升序链表插入效率比较低的问题，根据相关链表算法的理论，因为在有序链表插入节点的时间复杂度为O(n)，而且是单链表，意味着链表越长，插一个节点所要找到合适位置的时间开销就会越大，这样下来，时间效率是比较低的。</p><p>  时间轮定时器算法有点hash的思想，插入节点是采用【取模+头插法】的方式，将插入的平均时间复杂度控制器到了O(1)，极大节省了时间开销。</p><p>  不过呢，升序链表定时器虽然在插入时间复杂度上为O(n)，但是在处理超时定时器时遍历链表的效率还是要比时间轮定时器好的，时间轮定时器需要将对应槽上的链表从头到尾全部判断一次，而链表则是从头开始处理，一旦遇到未超时的，则直接结束遍历就好。但综合效率来说，时间轮还是比升序链表好很多的。</p><p><img src="https://img-blog.csdnimg.cn/c7eba5257da249c8a8da1db985dd0916.png" alt=""></p><h2 id="Socket：C-S模式，client-server"><a href="#Socket：C-S模式，client-server" class="headerlink" title="Socket：C/S模式，client server"></a>Socket：C/S模式，client server</h2><p><a href="https://www.cnblogs.com/skynet/archive/2010/12/12/1903949.html">Linux Socket编程</a></p><h2 id="socket函数"><a href="#socket函数" class="headerlink" title="socket函数"></a>socket函数</h2><p>int socket(int domain, int type, int protocol);</p><p>domain是协议族，type指的是socket的类型，protocol：指定协议。</p><p>第一个参数只能填AF_INET，第二个参数只能填SOCK_STREAM，第三个参数只能填0。</p><p>除非系统资料耗尽，socket函数一般不会返回失败。</p><p>不要忽略任何一个警告(socklen_t*) &amp;socklen）</p><h2 id="perror-const-char-str"><a href="#perror-const-char-str" class="headerlink" title="perror(const char* str)"></a>perror(const char* str)</h2><p>先输出str: ，再输出错误信息</p><h2 id="INADDR-ANY"><a href="#INADDR-ANY" class="headerlink" title="INADDR_ANY"></a>INADDR_ANY</h2><p>说明指定的是任意的ip地址</p><h2 id="函数调用流程"><a href="#函数调用流程" class="headerlink" title="函数调用流程"></a>函数调用流程</h2><p>服务端函数调用的流程</p><p>socket-&gt;bind-&gt;listen-&gt;accept-&gt;recv/send-&gt;close</p><p>客户端函数调用的流程</p><p>socket-&gt;connect-&gt;send/recv-&gt;close</p><p>其中send/recv可以进行多次交互。</p><p>无论是客户端还是服务端都要创建socket</p><h2 id="万恶的结构体sockaddr、sockaddr-in、in-addr、hostent"><a href="#万恶的结构体sockaddr、sockaddr-in、in-addr、hostent" class="headerlink" title="万恶的结构体sockaddr、sockaddr_in、in_addr、hostent"></a>万恶的结构体sockaddr、sockaddr_in、in_addr、hostent</h2><p><img src="https://img-blog.csdnimg.cn/f78938e3d83141988c8f3b6371c8a80e.png" alt=""></p><h2 id="hostent"><a href="#hostent" class="headerlink" title="hostent"></a>hostent</h2><p><img src="https://img-blog.csdnimg.cn/ff2528fdc17143f7ab6d721e18c1dc52.png" alt=""></p><p><img src="https://img-blog.csdnimg.cn/9d3c88331c9b4e5e9aaf9c202eb00c0f.png" alt=""></p><h2 id="主机字节序与网络字节序"><a href="#主机字节序与网络字节序" class="headerlink" title="主机字节序与网络字节序"></a>主机字节序与网络字节序</h2><p><img src="https://img-blog.csdnimg.cn/87aae97487c84854845b85d137496729.png" alt=""></p><h1 id="网络通信相关函数"><a href="#网络通信相关函数" class="headerlink" title="网络通信相关函数"></a>网络通信相关函数</h1><h2 id="listen、accept、connect函数之间的关系"><a href="#listen、accept、connect函数之间的关系" class="headerlink" title="listen、accept、connect函数之间的关系"></a>listen、accept、connect函数之间的关系</h2><p><img src="https://img-blog.csdnimg.cn/91644dd71fbb42c596571f99c751de7f.png" alt=""></p><h2 id="listen函数"><a href="#listen函数" class="headerlink" title="listen函数"></a>listen函数</h2><p>listen(listenfd, 5);//把socket设置为监听模式，第二个参数比较复杂</p><p>如果在listen前面加上sleep，结果发现不能连接上</p><p><img src="https://img-blog.csdnimg.cn/60b5d714084e40749789d72c343a75e5.png" alt=""></p><p><img src="https://img-blog.csdnimg.cn/38205cc98a4f48699893c9cc4c6a4fe9.png" alt=""></p><p>如果在listen后面加上sleep，可以连接上</p><p><img src="https://img-blog.csdnimg.cn/b27ad15f8405418382c1756d9a823917.png" alt=""></p><p><img src="https://img-blog.csdnimg.cn/7efce7d888a04777834be5d6300b13f4.png" alt=""></p><p>原因是：服务端在调用listen之前，客户端不能向服务端发起连接请求。</p><h2 id="connect函数"><a href="#connect函数" class="headerlink" title="connect函数"></a>connect函数</h2><p>connect(sockfd, (struct sockaddr *)&amp;servaddr,sizeof(servaddr))</p><p>向服务端发起连接请求</p><h2 id="accept函数"><a href="#accept函数" class="headerlink" title="accept函数"></a>accept函数</h2><p>clientfd=accept(listenfd,(struct sockaddr <em>)&amp;clientaddr,(socklen_t</em>)&amp;socklen);</p><p>三个客户端连接，accept是从连接的一个队列里面取出来，如果队列里面没有，会阻塞。</p><p><img src="https://img-blog.csdnimg.cn/436858fc94da46ac91a1db2b44266a15.png" alt=""></p><p>把这个用死循环，才可以多客户端连接</p><p><img src="https://img-blog.csdnimg.cn/905a883a82f3493991a9ec73d60e45ce.png" alt=""></p><h2 id="TCP的三次握手"><a href="#TCP的三次握手" class="headerlink" title="TCP的三次握手"></a>TCP的三次握手</h2><p><img src="https://img-blog.csdnimg.cn/4b9ec7c9fe1c4c5ea0f4fbc608c9eca0.png" alt=""></p><p>使用netstat -na | more命令查询端口的连接状态，</p><p>在listen后面睡眠1000秒，此时启动服务端，就可以查看到ESTABLISHED状态</p><p><img src="https://img-blog.csdnimg.cn/ab553db304b04e9c87fc4e03a045060a.png" alt=""></p><h2 id="send、和recv函数"><a href="#send、和recv函数" class="headerlink" title="send、和recv函数"></a>send、和recv函数</h2><p><a href="https://www.cnblogs.com/jianqiang2010/archive/2010/08/20/1804598.html">Socket send函数和recv函数详解 - 世道 - 博客园</a></p><p>int send(Socket s, const char* buf, int len, int flags);</p><p>int recv(Socket s, char * buf, int len, int flags);</p><p>都需要通过socket套接字来实现数据的接受与发送，而不是通过send、recv函数来实现。</p><p>其实这两个函数也有不成功的时候，当缓冲区满了之后，就不能正常的接收了。</p><p>在发送端使用正常代码，注释掉接受的代码，只用来发送</p><p>客户端注释掉发送的代码，只用来接受，而且在接受后面</p><p>usleep(10000);//睡眠微秒，结果在接受了八万多条数据之后，缓冲区满了，send函数在发送端阻塞了，等客户端又取出了一些数据之后才继续接受数据。</p><p><img src="https://img-blog.csdnimg.cn/fa9d57ae968c438c82427ff6fcf17ca7.png" alt=""></p><p><img src="https://img-blog.csdnimg.cn/66f5ddb4a1504994ad1f402cee4d207e.png" alt=""></p><h2 id="TCP报文分包和粘包"><a href="#TCP报文分包和粘包" class="headerlink" title="TCP报文分包和粘包"></a>TCP报文分包和粘包</h2><p><img src="https://img-blog.csdnimg.cn/73501f88e76741b98b6e5a1b4d07a22b.png" alt=""></p><p>粘包：粘包是指TCP协议中，发送方发送的若干包数据到接收方接收时粘成一包，从接收缓冲区看，后一包的数据的头紧接着前一包数据的尾。TCP是面向字节流的协议，就是没有界限的一串数据，本没有“包”的概念，“粘包”和“拆包”一说是为了有助于形象地理解这两种现象。为什么 UDP没有粘包由于UDP有消息保护边界，不会发生粘包拆包问题，因此粘包拆包问题只发生在TCP协议中。</p><p>对于粘包和拆包问题，常见的解决方案有四种：</p><ul><li>1）发送端将每个包都封装成固定的长度，比如100字节大小。如果不足100字节可通过补0或空等进行填充到指定长度；</li><li>2）发送端在每个包的末尾使用固定的分隔符，例如\r\n。如果发生拆包需等待多个包发送过来之后再找到其中的\r\n进行合并；例如，FTP协议；</li><li>3）将消息分为头部和消息体，头部中保存整个消息的长度，只有读取到足够长度的消息之后才算是读到了一个完整的消息；</li><li>4）通过自定义协议进行粘包和拆包的处理。</li></ul><p>第三种方法是最常用的方法。</p><h2 id="Writen、Readn函数：freecplus封装的报文格式"><a href="#Writen、Readn函数：freecplus封装的报文格式" class="headerlink" title="Writen、Readn函数：freecplus封装的报文格式"></a>Writen、Readn函数：freecplus封装的报文格式</h2><p>这两个函数指的是recv函数和send函数都存在读取的数据报文不完整的情况</p><p><img src="https://img-blog.csdnimg.cn/48750a9aa42f4398a9ecd86cdc031e84.png" alt=""></p><p><img src="https://img-blog.csdnimg.cn/db81aff3f9fd43468f773859e672ffd4.png" alt=""></p><h2 id="TcpWrite、TcpRead：freecplus封装的报文格式"><a href="#TcpWrite、TcpRead：freecplus封装的报文格式" class="headerlink" title="TcpWrite、TcpRead：freecplus封装的报文格式"></a>TcpWrite、TcpRead：freecplus封装的报文格式</h2><p><img src="https://img-blog.csdnimg.cn/6264f37e6f624fcc831e1f7911d55935.png" alt=""></p><p>报文长度+报文内容，这个就是Tcp粘包的一种最常见的解决方法。</p><p>这两个函数的参数的详细解释：</p><p><img src="https://img-blog.csdnimg.cn/78be6cf7cff9412fbb9389d3b8f46d86.png" alt=""></p><h1 id="多线程基础"><a href="#多线程基础" class="headerlink" title="多线程基础"></a>多线程基础</h1><h2 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h2><p><a href="https://blog.csdn.net/qq_34827674/article/details/107678226?app_version=5.7.0&amp;code=app_1562916241&amp;csdn_share_tail=%7B%22type%22%3A%22blog%22%2C%22rType%22%3A%22article%22%2C%22rId%22%3A%22107678226%22%2C%22source%22%3A%22m0_67623521%22%7D&amp;uLinkId=usr1mkqgl919blen&amp;utm_source=app">进程间通信</a></p><p><img src="https://img-blog.csdnimg.cn/bd5ffdf56f9a48f4ad79ad566ff4a382.png" alt=""></p><p><a href="https://www.freecplus.net/d95f4eaf18eb46d19b82383519126dec.html">Linux进程间通信</a></p><p>六种方式，前两者不经常使用，共享内存没有加锁的机制，所以经常与信号灯结合一起来使用，在高性能的网络服务端程序中，可以用共享内存作为的数据缓存（cache）。</p><h2 id="避免僵尸进程"><a href="#避免僵尸进程" class="headerlink" title="避免僵尸进程"></a>避免僵尸进程</h2><p><a href="https://zh.m.wikipedia.org/zh-cn/%E7%88%B6%E8%BF%9B%E7%A8%8B">僵尸进程、孤儿进程</a>，<a href="https://www.cnblogs.com/anker/p/3271773.html">两种进程的解决办法、分别模拟产生</a></p><p><strong>僵尸进程：</strong>进程退出的时候，unix将该进程的所有资源释放，但是仍然为其保留一定的信息，包括进程号（process identify），退出状态，运行时间。这个是一种机制，可以让父进程任何时候想知道子进程的状态信息的时候都可以调出来。这些信息的资源需要直到父进程调用wait/waitpid来取信息的时候才释放，但是如果父进程不去调用wait/waitpid，它的进程号就会一直占用，如果大量的产生僵尸进程，将因为没有可用的进程号而导致系统不能产生新的进程. 此即为僵尸进程的危害，应当避免。</p><p><strong>孤儿进程</strong>是没有父进程的进程，孤儿进程这个重任就落到了init进程身上，init进程就好像是一个民政局，专门负责处理孤儿进程的善后工作。每当出现一个孤儿进程的时候，内核就把孤儿进程的父进程设置为init，而init进程会循环地wait()它的已经退出的子进程。这样，当一个孤儿进程凄凉地结束了其生命周期的时候，init进程就会代表党和政府出面处理它的一切善后工作。因此孤儿进程并不会有什么危害。</p><p>两种解决方式：</p><p><img src="https://img-blog.csdnimg.cn/096e5fdce86547a3892667ff067a130a.png" alt=""></p><p><img src="https://img-blog.csdnimg.cn/65ae655429574b4da4de465797be3996.png" alt=""></p><p><img src="https://img-blog.csdnimg.cn/af2aeb7866444e1196f7b7ea5a9e9a96.png" alt=""></p><p>僵尸进程是指系统将进程退出的信息保存下来，此时占用一个进程编号，除非调用wait/waitpid，将其释放，否则如果出现过多的僵尸进程会将进程号使用完，孤儿进程是指该进程没有父进程，从而被init进程管理，可以回收资源。</p><p>我后面才知道没有模拟出僵尸进程的原因，需要多个客户端连接，使用多进程或者多线程，多进程需要fork函数才可以实现，</p><p><img src="https://img-blog.csdnimg.cn/489863e0c4c644c9b870b9506346a632.png" alt=""></p><p>有标志的进程就是僵尸进程。</p><p>如果按Ctrl+c终止book250后，父进程退出，僵尸进程随之消失。</p><p>有时使用ctrl+c的命令结束主进程是不对的，需要kill+pid。</p><h2 id="linux多进程：fork函数"><a href="#linux多进程：fork函数" class="headerlink" title="linux多进程：fork函数"></a>linux多进程：fork函数</h2><p>进程是操作系统进行资源分配和调度的一个基本单位。</p><p>fork调用后，子进程与父进程是否共享变量：</p><p><a href="https://blog.csdn.net/weixin_39578364/article/details/78995433">fork调用后，子进程与父进程是否共享变量_浅浅的i的博客-CSDN博客</a></p><p>不会真的共享变量，虽然地址是一样的，但是这个地址是给程序员看的虚拟地址，真正通过内核映射到实际的物理地址是不一样的。</p><p>fork多个子进程：</p><p><a href="https://blog.csdn.net/weixin_42929607/article/details/116426096">fork创建多个子进程_XV_的博客-CSDN博客_fork多个子进程</a></p><h2 id="Linux信号的使用"><a href="#Linux信号的使用" class="headerlink" title="Linux信号的使用"></a>Linux信号的使用</h2><p><a href="https://www.freecplus.net/eec5c39aa63b45ad946f1cc08134d9f9.html">Linux信号 (freecplus.net)</a></p><p>当服务程序运行在后台的时候，直接使用Ctrl+c让程序直接退出是不好的，因为程序突然退出，还有资源没有释放，这个时候signal函数就起作用了。</p><p>使用信号函数：sighandler_t signal(int signum, sighandler_t handler);</p><p>第一个参数是指signum是信号的编号，第二个参数是指处理信号的函数（可以在里面编写释放资源的代码）。</p><p>不需要清楚返回值。</p><p>程序员关心的信号有三个：SIGINT、SIGTERM和SIGKILL。</p><p>按Ctrl+c，发出SIGINT信号，信号编号是2。</p><p>采用“kill 进程编号”或“killall 程序名”，发出的是SIGTERM信号，编号是15。</p><p>采用“kill -9 进程编号”，发出的是SIGKILL信号，编号是9，此信号不能被忽略，也无法捕获，程序将突然死亡。</p><p>所以，程序员只要设置SIGINT和SIGTERM两个信号的处理函数就可以了，这两个信号可以使用同一个处理函数，函数的代码是释放资源。</p><p>demo:signal.cpp</p><p><img src="https://img-blog.csdnimg.cn/3b97ff370226457a81df802f3ea26e9d.png" alt=""></p><h2 id="Linux共享内存的函数"><a href="#Linux共享内存的函数" class="headerlink" title="Linux共享内存的函数"></a>Linux共享内存的函数</h2><p><a href="https://www.freecplus.net/6cb9ad02d7d64d6eb2f8e241b1158aed.html">共享内存</a></p><p>头文件：#include <sys/ipc.h> #include <sys/shm.h></p><p>1、shmget：获取或创建共享内存</p><p>2、shmat：把共享内存连接到当前进程的地址空间</p><p>3、shmdt：该函数用于将共享内存从当前进程中分离，相当于shmat函数的反操作。</p><p>4、shmctl：删除共享内存</p><p>要使用ipcs -m查看共享内存的信息</p><p>一旦运行了程序，使用 ipcrm -m shmid，来删除共享内存，否则会一直存在</p><h2 id="Linux多线程"><a href="#Linux多线程" class="headerlink" title="Linux多线程"></a>Linux多线程</h2><p><a href="https://www.freecplus.net/c893ece166b94df4b2e185fa6f1c920c.html">多线程的函数使用、以及多线程socket</a></p><p>在Linux下，采用pthread_create函数来创建一个新的线程，函数声明：</p><p>函数声明：int pthread_create(pthread_t <em>thread, const pthread_attr_t </em>attr,void <em>(</em>start_routine) (void <em>), void </em>arg);</p><h1 id="编译与链接"><a href="#编译与链接" class="headerlink" title="编译与链接"></a>编译与链接</h1><h2 id="动态库与静态库"><a href="#动态库与静态库" class="headerlink" title="动态库与静态库"></a>动态库与静态库</h2><p><a href="https://www.cnblogs.com/skynet/p/3372855.html">C++静态库与动态库 </a></p><p>在使用的时候，都是尽量的在使用动态库，因为静态库占用空间大，静态库是将所有相关的目标文件与牵涉到的函数库被链接合成一个可执行文件，其中一个文件修改，整个项目都要重新编译以及用户也要重新下载（最大的缺点）。</p><h2 id="argc与argv"><a href="#argc与argv" class="headerlink" title="argc与argv"></a>argc与argv</h2><p>./在终端运行代码时，加入的参数存储在argc、argv中，argc是参数的个数，argv是参数的值</p><h2 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h2><p><a href="https://www.ruanyifeng.com/blog/2015/02/make.html">Makefile</a>， Makefile用于自动化编译过程，将整个编译由编写好的Makefile规则来自动编译，现在也由更方便的工具，如CMake（编写编译链，自动生成Makefile文件）。</p><h2 id="GDB的简单使用"><a href="#GDB的简单使用" class="headerlink" title="GDB的简单使用"></a>GDB的简单使用</h2><p>首先g++中加入-g参数，然后file+可执行文件的名字，run，b，c，一直使用n，最后使用quit退出。如果需要设置参数使用set args</p><p><img src="https://img-blog.csdnimg.cn/0174c5ac5f254dde91e3d18f7611c9f2.png" alt=""></p><p><img src="https://img-blog.csdnimg.cn/1b5ea4464d5e40f383b54505ca5a0781.png" alt=""></p><p>例子：</p><p><a href="https://juejin.cn/post/6984368713940074532">GDB的例子</a>，通过测试了两个易错的面试题， int a[5]={0,1,2,3,4},&amp;a+1的地址是a+1的地址，即数组的后面一个位置（想象成二维数组）</p><h2 id="Tcp长连接与短连接"><a href="#Tcp长连接与短连接" class="headerlink" title="Tcp长连接与短连接"></a>Tcp长连接与短连接</h2><p>长连接：建立了一次连接之后需要长时间的保持住，双方需要互相发送检测的包，</p><p>流程：三次握手建立连接—》传输数据—》保持连接(心跳)—》发送数据—》保持连接(心跳)……—》4次挥手断开连接。</p><p>短连接：建立一次连接，发送完数据之后就断开连接。</p><p>流程：3次握手建立连接—》传输数据—》4次挥手断开连接。</p><p>由于在建立连接与断开连接的过程中要消耗资源和时间的，所以在不同的场景需要使用不同的方式。</p><p>对于服务器来说，服务器里的这些个长连接其实很有数据库连接池的味道，大家都是为了节省连接重复利用嘛。</p><p><a href="https://segmentfault.com/a/1190000021696056">（史上最通俗！）http请求怎样实现TCP长连接，以及长轮询和短轮询的区别。</a></p><p>长轮询和短轮询（针对淘宝的库存量的显示的场景）</p><h2 id="网络服务性能测试"><a href="#网络服务性能测试" class="headerlink" title="网络服务性能测试"></a>网络服务性能测试</h2><p>主要的性能指标：</p><p>1、服务端的并发能力</p><p>2、服务端的业务处理能力</p><p>3、客户端接收响应的时效</p><p>4、网络带宽</p><h2 id="I-O复用"><a href="#I-O复用" class="headerlink" title="I/O复用"></a>I/O复用</h2><p><a href="https://juejin.cn/post/6882984260672847879">彻底理解 IO 多路复用实现机制</a></p><p>有三种模式：select、poll、epoll，各有适合的应用场景。</p><p>env | grep LANG//查看使用的编码格式</p><p><a href="https://www.51cto.com/article/702199.html">彻底搞懂 Select / Poll / Epoll，就这篇了！</a></p><h2 id="select"><a href="#select" class="headerlink" title="select"></a>select</h2><p>socket的集合fd_set用于存放多个socket，使用select来阻塞程序，而不是在分别的recv、read、send、accept阻塞。</p><p><img src="https://img-blog.csdnimg.cn/a5c7ef0fd1444f0d959e868e18fe1595.png" alt=""></p><p>在tcpSelect.cpp中while(1)循环里面fd_set使用的是temp_set，因为会改变原来的read_set，只做了一个基本的了解，时间可以的话要在听一遍。</p><p><img src="https://img-blog.csdnimg.cn/7b2a3663acfd43b5a21287cc400d72ed.png" alt=""></p><h2 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h2><p>优化了参数的设置，较为简单，但是不能跨平台，效率与select差不多</p><p><img src="https://img-blog.csdnimg.cn/76d6df755d374959bb6be762dbd502d0.png" alt=""></p><p>不需要备份fd_set,原因就在结构体pollfd中，有一个revent（return event）作为备份。</p><p><img src="https://img-blog.csdnimg.cn/ad85870369e744798eb795f92bf37520.png" alt=""></p><h2 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h2><p>结构体</p><p><img src="https://img-blog.csdnimg.cn/50a5bc0052f043aa9f29307cae802f95.png" alt=""></p><h2 id="ET和LT"><a href="#ET和LT" class="headerlink" title="ET和LT"></a>ET和LT</h2><p><img src="https://img-blog.csdnimg.cn/75df840aa325426d984f3916715a5e26.png" alt=""></p><p>测试水平触发：</p><ul><li>事件没有处理：int xx=0; 作为计数器，指定xx=2的时候continue，然后这个事件就没有处理，看看epoll的处理方式（默认是水平触发，所以会立即报告）。</li><li>事件只处理了一般：read函数sizeof(buffer)，设置成小于它的数字，这个时候缓冲区就会剩余数据没有处理完，epoll也会立即处理完。</li></ul><p>一样的测试方法：</p><p><img src="https://img-blog.csdnimg.cn/e97712c241c6488d82e362321b3c93b7.png" alt=""></p><p>需要将accept函数设置为非阻塞的模式setnoblocking</p><h1 id="参考内容"><a href="#参考内容" class="headerlink" title="参考内容"></a>参考内容</h1><p>【1】<a href="https://www.freecplus.net/index.html">C语言技术网 - 首页</a></p><p>【2】<a href="https://www.bilibili.com/video/BV11Z4y157RY">C/C++网络编程，从socket到epoll_哔哩哔哩_bilibili</a></p><p>【3】<a href="https://www.freecplus.net/0047ac4059b14d52bcc1d4df6ae8bb83.html">网络通信基础socket</a></p><p>【4】<strong>上面的大部分代码都改自于</strong><a href="https://www.freecplus.net/0047ac4059b14d52bcc1d4df6ae8bb83.html">网络通信基础socket</a></p>]]></content>
      
      
      <categories>
          
          <category> 网络通信杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux网络编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java中switch的高级用法</title>
      <link href="/2023/06/20/java-zhong-switch-de-gao-ji-yong-fa/"/>
      <url>/2023/06/20/java-zhong-switch-de-gao-ji-yong-fa/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="switch语句的用法"><a href="#switch语句的用法" class="headerlink" title="switch语句的用法"></a>switch语句的用法</h2><h3 id="用法一："><a href="#用法一：" class="headerlink" title="用法一："></a><strong>用法一：</strong></h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">String</span> fruit <span class="token operator">=</span> <span class="token string">"apple"</span><span class="token punctuation">;</span>        <span class="token keyword">switch</span> <span class="token punctuation">(</span>fruit<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">case</span> <span class="token string">"apple"</span><span class="token operator">:</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Selected apple"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> <span class="token string">"pear"</span><span class="token operator">:</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Selected pear"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> <span class="token string">"mango"</span><span class="token operator">:</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Selected mango"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">default</span><span class="token operator">:</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"No fruit selected"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意点：要记得写break（case语句具有穿透效应，如果不写的话，后面的会继续执行）；要记得写default（都不匹配的情况）；</p><h3 id="简洁的用法："><a href="#简洁的用法：" class="headerlink" title="简洁的用法："></a><strong>简洁的用法：</strong></h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">public class Main<span class="token punctuation">&#123;</span>    public static void main<span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        String <span class="token assign-left variable">fruit</span><span class="token operator">=</span><span class="token string">"ban"</span><span class="token punctuation">;</span>        switch <span class="token punctuation">(</span>fruit<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">case</span> <span class="token string">"apple"</span>-<span class="token operator">></span>System.out.println<span class="token punctuation">(</span><span class="token string">"select a"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">case</span> <span class="token string">"banana"</span>-<span class="token operator">></span>System.out.println<span class="token punctuation">(</span><span class="token string">"select b"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">case</span> <span class="token string">"mango"</span>-<span class="token operator">></span>System.out.println<span class="token punctuation">(</span><span class="token string">"select mango"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            default -<span class="token operator">></span>System.out.println<span class="token punctuation">(</span><span class="token string">"select none"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        // System.out.println<span class="token punctuation">(</span><span class="token string">"哈哈哈"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>直接使用箭头来表示switch的返回值，没有了写很多break的繁琐</p><p>这种简介的写法还可以直接返回值：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">public class Main <span class="token punctuation">&#123;</span>    public static void main<span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        String fruit <span class="token operator">=</span> <span class="token string">"a"</span><span class="token punctuation">;</span>        int option <span class="token operator">=</span> switch <span class="token punctuation">(</span>fruit<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">case</span> <span class="token string">"a"</span> -<span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">case</span> <span class="token string">"p"</span>, <span class="token string">"m"</span> -<span class="token operator">></span> <span class="token number">2</span><span class="token punctuation">;</span>            default -<span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">;</span> // 注意使用赋值语句要以<span class="token punctuation">;</span>结束        System.out.println<span class="token punctuation">(</span><span class="token string">"opt = "</span> + option<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="使用yield来返回值："><a href="#使用yield来返回值：" class="headerlink" title="使用yield来返回值："></a><strong>使用yield来返回值：</strong></h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">public class Main <span class="token punctuation">&#123;</span>    public static void main<span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        String fruit <span class="token operator">=</span> <span class="token string">"orange"</span><span class="token punctuation">;</span>        int opt <span class="token operator">=</span> switch <span class="token punctuation">(</span>fruit<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">case</span> <span class="token string">"apple"</span> -<span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">case</span> <span class="token string">"pear"</span>, <span class="token string">"mango"</span> -<span class="token operator">></span> <span class="token number">2</span><span class="token punctuation">;</span>            default -<span class="token operator">></span> <span class="token punctuation">&#123;</span>                int code <span class="token operator">=</span> fruit.hashCode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                yield code<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>        String <span class="token assign-left variable">c</span><span class="token operator">=</span><span class="token string">"a"</span><span class="token punctuation">;</span>        System.out.println<span class="token punctuation">(</span>c.hashCode<span class="token punctuation">(</span><span class="token punctuation">))</span><span class="token punctuation">;</span>        System.out.println<span class="token punctuation">(</span><span class="token string">"opt = "</span> + opt<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>说明：</strong>其中使用了String的hashcode方法，<strong>这个方法是以31为权，每一位为字符的ASCII值进行运算，用自然溢出来等效取模，得到一个不容易重复的数字，</strong>hashcode源码如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">public int <span class="token function-name function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    int h <span class="token operator">=</span> <span class="token builtin class-name">hash</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>h <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> value.length <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        char val<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> value<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>int i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> value.length<span class="token punctuation">;</span> i++<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            h <span class="token operator">=</span> <span class="token number">31</span> * h + val<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token builtin class-name">hash</span> <span class="token operator">=</span> h<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token builtin class-name">return</span> h<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后还使用了yield来返回值，注意<strong>只有switch使用-&gt;的简洁写法才可以使用yield返回值。</strong></p><h2 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a><strong>参考资料：</strong></h2><p><a href="https://blog.csdn.net/claram/article/details/53770830?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=java%20string%E7%9A%84hashcode%E6%96%B9%E6%B3%95&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-2-53770830.142%5Ev13%5Epc_search_result_control_group,157%5Ev14%5Enew_3&amp;spm=1018.2226.3001.4187">Java编程：String 类中 hashCode() 方法详解_志波同学的博客-CSDN博客_string.hashcode()</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java知识要点</title>
      <link href="/2023/06/20/java-zhi-shi-yao-dian/"/>
      <url>/2023/06/20/java-zhi-shi-yao-dian/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="第1章-Java概述"><a href="#第1章-Java概述" class="headerlink" title="第1章 Java概述"></a>第1章 Java概述</h1><p>重要特性：</p><p><strong>Write Once Run Anyway</strong></p><p>简单性：相比C++移除指针、运算符重载、多重继承等，垃圾自动回收。</p><p>平台无关性：Java引进虚拟机（JVM，Java Virtual Machine）概念。</p><p>安全性：没有指针，内存由系统分配。</p><p>动态转载：类运行时是动态装载的。</p><p>编译过程：<br><img src="https://img-blog.csdnimg.cn/fa3f9661e063421d96d0a8c57d16ff19.png" alt=""></p><p>JRE： Java Runtime Environment JDK：Java Development Kit</p><p>JRE和JDK的区别：<a href="https://www.cnblogs.com/mark5/p/11063047.html">https://www.cnblogs.com/mark5/p/11063047.html</a></p><h1 id="第2章-Java语言基础"><a href="#第2章-Java语言基础" class="headerlink" title="第2章 Java语言基础"></a>第2章 Java语言基础</h1><p>数据类型名称位长字节型byte8短整型short16整型int32长整型long64单精度型float32双精度型double64字符型char16布尔型boolean1</p><p>数据输入：类<code>Scanner</code>，<code>import java.util.Scanner</code>;<br>方法nextBoolean()nextDouble()nextFloat()nextInt()nextLine()next()</p><h1 id="第3章-程序流程控制"><a href="#第3章-程序流程控制" class="headerlink" title="第3章 程序流程控制"></a>第3章 程序流程控制</h1><p>声明多维数组：int array[][]，int[][] array</p><p><strong>和其他高级编程语言不同，Java多维数组不必须是规则矩阵形式。</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">12</span><span class="token punctuation">;</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">111</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>a<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> j<span class="token operator">&lt;</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token string">"\t"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>数组复制：<code>System.arraycopy(src, srcPos, dest, destPos, length);</code>；</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span> array<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>i<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> array1<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> array1<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">:</span>array1<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token string">"\t"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>数组排序：<code>import java.util.Random; import static java.util.Arrays.sort;</code>；</p><p>Random的使用：<a href="http://c.biancheng.net/view/867.html">http://c.biancheng.net/view/867.html</a></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Random</span> r <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> array<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>r<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">100</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">sort</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//Arrays类中的sort()使用的是“经过调优的快速排序法”</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>array<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>array<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token string">"\t"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="第4章-类与对象"><a href="#第4章-类与对象" class="headerlink" title="第4章.类与对象"></a>第4章.类与对象</h1><p>用关键字<strong>static修饰</strong>的方法称为类方法，又称为静态方法。不用static修饰的方法称为实例方法，又称为对象方法。</p><p><strong>类方法只能操作类变量，不能操作实例变量。</strong></p><p>Java的值传递还是引用传递：<a href="https://www.jianshu.com/p/457bfc91df79，https://www.javadude.com/articles/passbyvalue.htm">https://www.jianshu.com/p/457bfc91df79，https://www.javadude.com/articles/passbyvalue.htm</a></p><p>“primitives are passed by value, objects are passed by reference”.</p><p>java常用的包：<strong>看看就行了</strong><br>序号包名功能描述1java.langjava的核心类库，包含了运行java程序必不可少的系统类，如基本数据类型、基本数学函数、字符串处理、线程、异常处理类等，系统缺省加载这个包。2java.iojava语言的标准输入/输出类库，如基本输入/输出流、文件输入/输出、过滤输入/输出流等等。3java.utilJava的实用工具类库Java.util包。在这个包中，Java提供了一些实用的方法和数据结构。例如，Java提供日期(Data)类、日历(Calendar)类4java.awt.image处理和操纵来自于网上的图片的java工具类库。5java.net实现网络功能的类库有Socket类、ServerSocket类。6java.awt构建图形用户界面(GUI)的类库，低级绘图操作Graphics类，图形界面组件和布局管理7java.awt.eventGUI事件处理包 。8java.sql实现JDBC的类库。</p><p>import的使用：当定义包后，<strong>在同一个包中的类是默认隐式导入的。</strong>但如果一个类访问来自另一个包中的类，则前者必须显示通过import语句导入后者后才能使用。</p><p>基本类型的封装类：<strong>使用范型数据的时候只能使用封装的类。</strong><br>原始类型封装类静态的常用方法booleanBooleanBoolean.parseBoolean(String str)charCharacterisDigit(char ch);isLetter(char ch);isLowerCase(char ch);toLowerCase(char ch)byteByteByte.parseByte(String str)shortShortShort.parseShort(String str)intIntegerInteger.parseInt(String str)longLongLong.parseLong(String str)floatFloatFloat.parseFloat(String str)doubleDoubleDouble.parseDouble(String str)</p><h1 id="第5章面向对象高级特性"><a href="#第5章面向对象高级特性" class="headerlink" title="第5章面向对象高级特性"></a>第5章面向对象高级特性</h1><p>实操：<a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1255943520012800">https://www.liaoxuefeng.com/wiki/1252599548343744/1255943520012800</a></p><p>下面都是概念</p><p>需要掌握的知识点：</p><ul><li>继承（extends）+ 关键字this和super+ final关键字+ 转型和多态+ 抽象类（abstract class ）和接口（interface）+ 内部类+ 匿名对象和类+ 异常类+ 泛型类</li></ul><p><strong>转型与多态：</strong></p><ul><li>上转型：子类对象到父类对象的类型转换，即把创建的子类对象放到父类的对象变量中，该过程是自动完成的，有些像基本类型的自动类型转换。 +  下转型：父类对象到子类对象的转换，必须使用强制转换。 +  多态：是指同一个操作被不同类型对象调用时可能产生不同的行为。 </li></ul><p><strong>final关键字：</strong></p><p>final的本义是“最终”，final可以修饰变量、一般方法和类 。</p><p>final修饰变量，表示变量一旦获取了初始值就不能被修改；</p><p>final修饰方法，表示该方法在派生子类中不能被重写，只能引用；</p><p>final修饰类，表示该类不能派生出子类。</p><p><strong>抽象类（abstract class ）和接口（interface）：</strong></p><p>相同点有：</p><ul><li>都包含抽象方法，这些方法在继承抽象类或实现接口的类中都要具体实现，<strong>如果有一个不实现，该类就是抽象类，还是不能创建实例对象。</strong> +  抽象类和接口都包含抽象方法，不能用new创建对象实例，两者都可以通过上转型对象或接口回调方式实现多态机制。 </li></ul><p>不同点有：</p><ul><li>声明方式不同，接口使用interface关键字，而抽象类使用abstract class关键字。 +  成员变量不同，接口中只能有静态常量，而抽象类中不受限制。 +  成员方法不同，接口中的方法均是public abstract；而抽象类中抽象方法必须加上修饰符abstract。另外，接口中不能定义静态方法，而抽象类可以。 </li></ul><p><strong>内部类：</strong></p><p>如果一个类A的内部定义了一个类B，那么类A称为外部类或外嵌类，而类B称为内部类或内嵌类 。</p><p><strong>匿名对象和类：</strong></p><p>new 类名（[实参列表]）{//；类体</p><p>继承“类名”的子类</p><p>}</p><p>对象只能使用一次。</p><p><strong>异常：</strong></p><p>try catch final（<strong>final块一定会执行</strong>）</p><p>常用异常类：</p><p>空指针异常类：NullPointerException</p><p>类型强制转换异常：ClassCastException</p><p>数组负下标异常：NegativeArrayException</p><p>数组下标越界异常：ArrayIndexOutOfBoundsException</p><h1 id="第6章-OOP程序设计的基本原则"><a href="#第6章-OOP程序设计的基本原则" class="headerlink" title="第6章.OOP程序设计的基本原则"></a>第6章.OOP程序设计的基本原则</h1><p>知识点：了解就行</p><ul><li>对象的抽象+ 单一职责原则+ 迪米特原则+ 接口隔离原则+ 开放-封闭原则+ 里氏替换原则+ 合成/聚合复用原则</li></ul><h1 id="第7章-常用类"><a href="#第7章-常用类" class="headerlink" title="第7章 常用类"></a>第7章 常用类</h1><p>常用的方法在java.md里面有。</p><p>知识点：</p><ul><li>String类+ StringBuffer类+ String类与StringBuffer类比较+ StringTokenizer类+ 日期类（Date、Calendar）</li></ul><p><strong>String类和StringBuffer类：</strong></p><p>String类定义字符串<strong>常量</strong>对象，可以直接定义，也可以用构造方法定义。StringBuffer类对象必须使用构造方法定义。</p><p>String的内容<strong>一旦声明不可改变</strong>，如果要改变，改变的是String的引用地址。</p><p>用StringBuffer创建的字符串对象<strong>可以修改</strong>。并且所有的修改都直接发生在包含该字符串的缓冲区上。</p><p><strong>日期类（Date、Calendar）：</strong></p><p>Date类可以得到一个完整的日期，但是日期格式不符合平常看到的格式，时间也不能精确到毫秒，要想按照用户自己的格式显示时间可以使用Calender类完成操作。Date类取得的时间是一个正确的时间，但显示格式不符合习惯，可以利用DateFormat类进行格式化。</p><p>Calender可以将取得的时间精确到毫秒，但是此类是抽象类，要想使用抽象类，必须依靠对象的多态性，通过子类进行父类得实例化操作，其子类是GregorianCalender，在Calender中提供了部分常量，分别表示日期的各个数字。</p><h1 id="第8章-图形界面设计"><a href="#第8章-图形界面设计" class="headerlink" title="第8章 图形界面设计"></a>第8章 图形界面设计</h1><p>不考，java swing</p><h1 id="第9章-Java输入和输出"><a href="#第9章-Java输入和输出" class="headerlink" title="第9章 Java输入和输出"></a>第9章 Java输入和输出</h1><p>知识点：代码见java.md</p><ul><li>文件操作：File+ 字节流：InputStream和OutputStream+ 字符流：Reader和Writer</li></ul><h1 id="第10章多线程"><a href="#第10章多线程" class="headerlink" title="第10章多线程"></a>第10章多线程</h1><p>见Java.md：Java并发编程、wait、notify、notifyAll，JDBC</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java继承</title>
      <link href="/2023/06/20/java-ji-cheng/"/>
      <url>/2023/06/20/java-ji-cheng/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Student</span> s <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">"hahaha"</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">89</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">protected</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>    <span class="token keyword">protected</span> <span class="token keyword">int</span> age<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token keyword">int</span> age<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token keyword">extends</span> <span class="token class-name">Person</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">protected</span> <span class="token keyword">int</span> score<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token keyword">int</span> age<span class="token punctuation">,</span> <span class="token keyword">int</span> score<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>score <span class="token operator">=</span> score<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的代码编译会出错，原因是父类没有合适的构造方法来调用初始化三个参数的构造函数。</p><p>在继承的时候，如果不显式指定父类的构造方法，会自动调用super()方法；</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token keyword">extends</span> <span class="token class-name">Person</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">protected</span> <span class="token keyword">int</span> score<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token keyword">int</span> age<span class="token punctuation">,</span> <span class="token keyword">int</span> score<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> age<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>score <span class="token operator">=</span> score<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>改为这样就可以运行了。</p><h2 id="阻止继承"><a href="#阻止继承" class="headerlink" title="阻止继承"></a>阻止继承</h2><h3 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h3><p><strong>1、sealed关键字：</strong>下面的就是说明了Person只可以由Man，和Woman两个类继承，不可以随便继承</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">public sealed class Person permits Man, Women <span class="token punctuation">&#123;</span>    <span class="token punctuation">..</span>.<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>2、 final关键字：</strong>Man是最后的儿子，他不可以被其他类继承。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">public final class Man extends Penson<span class="token punctuation">&#123;</span>    <span class="token punctuation">..</span>.<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="向上转型（upcasting）"><a href="#向上转型（upcasting）" class="headerlink" title="向上转型（upcasting）"></a>向上转型（upcasting）</h2><p>比如上面的Person：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Person</span> p<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Student</span> stu <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Person</span> p1<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// upcasting, ok</span><span class="token class-name">Object</span> ob1<span class="token operator">=</span>p<span class="token punctuation">;</span> <span class="token comment">// upcasting, ok</span><span class="token class-name">Object</span> ob2<span class="token operator">=</span>stu<span class="token punctuation">;</span> <span class="token comment">// upcasting, ok</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这种指向是可以的，父类指向子类（反过来是不可以的）。</p><p><strong>注意：上面的例子的继承树是这样子的：Student&gt;Person&gt;object（所以叫做向上转型），在java中所有的类都是继承于object。</strong></p><h2 id="向下转型（downcasting）"><a href="#向下转型（downcasting）" class="headerlink" title="向下转型（downcasting）"></a>向下转型（downcasting）</h2><p>例子：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Person</span> p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// upcasting, ok</span><span class="token class-name">Person</span> p2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Student</span> stu1 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Student</span><span class="token punctuation">)</span> p1<span class="token punctuation">;</span> <span class="token comment">// ok</span><span class="token class-name">Student</span> stu2 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Student</span><span class="token punctuation">)</span> p2<span class="token punctuation">;</span> <span class="token comment">// runtime error! ClassCastException!</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="instanceof操作符"><a href="#instanceof操作符" class="headerlink" title="instanceof操作符"></a><code>instanceof</code>操作符</h2><p>为了避免向下转型出错，Java提供了<code>instanceof</code>操作符，可以先判断一个实例究竟是不是某种类型：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Person p <span class="token operator">=</span> new Person<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System.out.println<span class="token punctuation">(</span>p instanceof Person<span class="token punctuation">)</span><span class="token punctuation">;</span> // <span class="token boolean">true</span>System.out.println<span class="token punctuation">(</span>p instanceof Student<span class="token punctuation">)</span><span class="token punctuation">;</span> // <span class="token boolean">false</span>Student s <span class="token operator">=</span> new Student<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System.out.println<span class="token punctuation">(</span>s instanceof Person<span class="token punctuation">)</span><span class="token punctuation">;</span> // <span class="token boolean">true</span>System.out.println<span class="token punctuation">(</span>s instanceof Student<span class="token punctuation">)</span><span class="token punctuation">;</span> // <span class="token boolean">true</span>Student n <span class="token operator">=</span> null<span class="token punctuation">;</span>System.out.println<span class="token punctuation">(</span>n instanceof Student<span class="token punctuation">)</span><span class="token punctuation">;</span> // <span class="token boolean">false</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>instanceof</code>实际上判断一个变量所指向的实例是否是指定类型，或者这个类型的子类。如果一个引用变量为<code>null</code>，那么对任何<code>instanceof</code>的判断都为<code>false</code>。</p><p>利用<code>instanceof</code>，在向下转型前可以先判断：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Person p <span class="token operator">=</span> new Student<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>p instanceof Student<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    // 只有判断成功才会向下转型:    Student s <span class="token operator">=</span> <span class="token punctuation">(</span>Student<span class="token punctuation">)</span> p<span class="token punctuation">;</span> // 一定会成功<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础之args参数（命令行参数）</title>
      <link href="/2023/06/20/java-ji-chu-zhi-args-can-shu-ming-ling-xing-can-shu/"/>
      <url>/2023/06/20/java-ji-chu-zhi-args-can-shu-ming-ling-xing-can-shu/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="String-args"><a href="#String-args" class="headerlink" title="String[] args"></a>String[] args</h2><p>Java程序的入口是main方法，而且main方法要接受一个<strong>命令行参数</strong>，它是一个String[]数组，这个命令由JVM接受用户并且传给main方法。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// System.out.println(args[0]);</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">String</span> arg <span class="token operator">:</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token string">"-version"</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"v 1.0"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们可以利用这个参数来打印java -version，实现的效果就是打印v 1.0；</p><p>要利用args参数要在<strong>终端窗口</strong>运行：</p><p>1、首先在Main.java的目录下打开终端</p><p>2、输入命令：<strong>javac Main.java</strong>，生成Main.class</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ javac Main.java<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>3、再次输入命令：<strong>java Main -version，</strong>就可以打印v 1.0，这里就相当于执行的时候给Main传入了参数-version给args。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">java</span> Main <span class="token parameter variable">-version</span><span class="token function">v</span> <span class="token number">1.0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这个是<strong>我的终端</strong>下的运行情况。 </p><p><img src="https://img-blog.csdnimg.cn/2f9aa7269d614bd09e74476911b10ce6.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java的输入和输出</title>
      <link href="/2023/06/20/java-de-shu-ru-he-shu-chu/"/>
      <url>/2023/06/20/java-de-shu-ru-he-shu-chu/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><p><strong>写在前面：</strong></p><p>最近在切换平台来记录我的学习，而且马上期末考试了，复习的任务有点重，要抓紧复习，所以写博客的时间大大减少了。But I will continue to study. </p><p>1、在java代码中总是出现System.out.println(xxx);其实println是print line的缩写，表示的意思是输出并且换行。</p><p>2、如果输出后不想换行，可以使用print();</p><h2 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h2><p>1、由于计算机能看懂的我们不一定可以看懂所以就有了格式化的输出，让我们很好的知道输出的是什么。</p><p>（1）使用println来实现格式化输出。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token number">12800000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//输出：1.28E7</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>（2）还有可以使用像c语言类似的函数printf(“%?\n”,xxx)；</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span><span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">double</span> pi<span class="token operator">=</span><span class="token number">3.141592654</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%.2f\n"</span><span class="token punctuation">,</span> pi<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//显示2位小数,3.14</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%.5f\n"</span><span class="token punctuation">,</span> pi<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//显示5位小数,3.14159</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>格式化输出</strong><br><strong>占位符**</strong>说明**%d格式化输出整数%x格式化输出16进制数%f格式化输出浮点数%e格式化输出以科学计数法表示的数%s格式化输出字符串</p><p>详细的格式化参数可以去参考JDK文档<a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Formatter.html#syntax">java.util.Formatter</a>。</p><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><p>输入对比输出就比较复杂了，我们直接看一个例子</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Scanner</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span><span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token class-name">Scanner</span> scanner <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Scanner</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//创建Scanner对象</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Input your name: "</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//打印提示</span>        <span class="token class-name">String</span> name <span class="token operator">=</span> scanner<span class="token punctuation">.</span><span class="token function">nextLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//读取一行并获取字符串保存在name变量中</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Input your age: "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> age <span class="token operator">=</span> scanner<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//读取一行并保存信息在age中</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Hi, %s, you are %d\n"</span><span class="token punctuation">,</span> name<span class="token punctuation">,</span> age<span class="token punctuation">)</span><span class="token punctuation">;</span>格式化输出    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>首先，我们通过<code>import</code>语句导入<code>java.util.Scanner</code>，<code>import</code>是导入某个类的语句，必须放到Java源代码的开头，现在我还没有学习到。</p><p>然后，创建<code>Scanner</code>对象并传入<code>System.in</code>。<code>System.out</code>代表标准输出流，而<code>System.in</code>代表标准输入流。直接使用<code>System.in</code>读取用户输入虽然是可以的，但需要更复杂的代码，而通过<code>Scanner</code>就可以简化后续的代码。</p><p>有了<code>Scanner</code>对象后，要读取用户输入的字符串，使用<code>scanner.nextLine()</code>，要读取用户输入的整数，使用<code>scanner.nextInt()</code>。<code>Scanner</code>会自动转换数据类型，因此不必手动转换。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript知识点(根据例子来学习)</title>
      <link href="/2023/06/20/javascript-zhi-shi-dian-gen-ju-li-zi-lai-xue-xi/"/>
      <url>/2023/06/20/javascript-zhi-shi-dian-gen-ju-li-zi-lai-xue-xi/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="立即执行函数"><a href="#立即执行函数" class="headerlink" title="立即执行函数"></a>立即执行函数</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token punctuation">(</span><span class="token function">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>document<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">"通常将匿名函数与事件处理程序一起使用"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="input标签、rowspan"><a href="#input标签、rowspan" class="headerlink" title="input标签、rowspan"></a>input标签、rowspan</h2><pre class="line-numbers language-none"><code class="language-none">&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;meta charset&#x3D;&quot;utf-8&quot;&gt;    &lt;title&gt;shiyan&lt;&#x2F;title&gt;    &lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;.&#x2F;page1.css&quot;&gt;&lt;&#x2F;head&gt;&lt;body&gt;    id 前台拿数据，name 后台拿数据    时间：&lt;input type&#x3D;&quot;time&quot; placeholder&#x3D;&quot;请输入时间&quot; autofocus&gt;&lt;br&gt;    日期：&lt;input type&#x3D;&quot;date&quot; placeholder&#x3D;&quot;请输入日期&quot;&gt;&lt;br&gt;    数字：&lt;input type&#x3D;&quot;number&quot; placeholder&#x3D;&quot;输入数字&quot; value&#x3D;&quot;0&quot; max&#x3D;&quot;100&quot; min&#x3D;&quot;-100&quot; step&#x3D;&quot;20&quot;&gt;&lt;br&gt;    日期时间:&lt;input type&#x3D;&quot;datetime_local&quot; placeholder&#x3D;&quot;日期时间&quot;&gt;    搜索：&lt;input type&#x3D;&quot;search&quot; required pattern&#x3D;&quot;[0-9][a-z]&#123;2&#125;&quot;&gt;!!!!!!!!!!!!!!    邮箱：&lt;input type&#x3D;&quot;email&quot;&gt;    网址：&lt;input type&#x3D;&quot;url&quot;&gt;    滑块：&lt;input type&#x3D;&quot;range&quot;&gt;    颜色：&lt;input type&#x3D;&quot;color&quot;&gt;    音频:loop autopaly, muted    (10.21)：&lt;audio src&#x3D;&quot;&quot; controls&gt;&lt;&#x2F;audio&gt;    视频：    &lt;video src&#x3D;&quot;&quot; controls&gt;&lt;&#x2F;video&gt;    &lt;table border&#x3D;&quot;1&quot; &gt;        &lt;tr&gt;            &lt;th&gt;分类&lt;&#x2F;th&gt;            &lt;th&gt;技能&lt;&#x2F;th&gt;            &lt;th&gt;分数&lt;&#x2F;th&gt;        &lt;&#x2F;tr&gt;        &lt;tr&gt;            &lt;td rowspan&#x3D;&quot;3&quot;&gt;编程语言&lt;&#x2F;td&gt;            &lt;td&gt;JavaScript&lt;&#x2F;td&gt;            &lt;td&gt;8&lt;&#x2F;td&gt;        &lt;&#x2F;tr&gt;        &lt;tr&gt;            &lt;td&gt;C++&lt;&#x2F;td&gt;            &lt;td&gt;7&lt;&#x2F;td&gt;        &lt;&#x2F;tr&gt;        &lt;tr&gt;            &lt;td&gt;Swift&lt;&#x2F;td&gt;            &lt;td&gt;8&lt;&#x2F;td&gt;        &lt;&#x2F;tr&gt;        &lt;tr&gt;            &lt;td rowspan&#x3D;&quot;2&quot;&gt;产品设计&lt;&#x2F;td&gt;            &lt;td&gt;PhotoShop&lt;&#x2F;td&gt;            &lt;td&gt;6&lt;&#x2F;td&gt;        &lt;&#x2F;tr&gt;        &lt;tr&gt;            &lt;td&gt;Axure&lt;&#x2F;td&gt;            &lt;td&gt;5&lt;&#x2F;td&gt;        &lt;&#x2F;tr&gt;        &lt;tr&gt;            &lt;td rowspan&#x3D;&quot;2&quot;&gt;销售&lt;&#x2F;td&gt;            &lt;td&gt;社交媒体&lt;&#x2F;td&gt;            &lt;td&gt;3&lt;&#x2F;td&gt;        &lt;&#x2F;tr&gt;        &lt;tr&gt;            &lt;td&gt;C++&lt;&#x2F;td&gt;            &lt;td&gt;7&lt;&#x2F;td&gt;        &lt;&#x2F;tr&gt;    &lt;&#x2F;table&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="选择器、伪类选择器a-hover"><a href="#选择器、伪类选择器a-hover" class="headerlink" title="选择器、伪类选择器a:hover"></a>选择器、伪类选择器a:hover</h2><pre class="line-numbers language-none"><code class="language-none">&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;style&gt;        p &#123;            background-color: orange;        &#125;        #p2 &#123;            color: red;            background-color: cadetblue;        &#125;        .para &#123;            color: blue;        &#125;        p.para2 &#123;            color: aliceblue;        &#125;        #div h2&#123;            color:aqua;            background:gray;        &#125;        &#x2F;* 未访问前 *&#x2F;        a:link&#123;            color:pink;        &#125;        &#x2F;* 访问以后 *&#x2F;        a:visited&#123;            color:aqua;        &#125;        &#x2F;* 鼠标悬停 *&#x2F;        a:hover&#123;            color:firebrick;            font-size: 30px;        &#125;        &#x2F;* 点中时 *&#x2F;        a:active&#123;            color:red;        &#125;            &lt;&#x2F;style&gt;&lt;&#x2F;head&gt;&lt;body&gt;        &lt;p id&#x3D;&quot;p1&quot;&gt;这是一个段落&lt;&#x2F;p&gt;    &lt;hr&gt;    &lt;p class&#x3D;&quot;para&quot; id&#x3D;&quot;p2&quot;&gt;这是第二个段落&lt;&#x2F;p&gt;    &lt;hr&gt;    &lt;p class&#x3D;&quot;para2&quot;&gt;这是三个段落&lt;&#x2F;p&gt;    &lt;div id&#x3D;&quot;div&quot;&gt;        &lt;h2&gt;标题1&lt;&#x2F;h2&gt;        &lt;h2&gt;标题1&lt;&#x2F;h2&gt;        &lt;h2&gt;标题1&lt;&#x2F;h2&gt;        &lt;h2&gt;标题1&lt;&#x2F;h2&gt;    &lt;&#x2F;div&gt;    &lt;a href&#x3D;&quot;https:&#x2F;&#x2F;www.baidu.com&quot;&gt;百度链接&lt;&#x2F;a&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><pre class="line-numbers language-none"><code class="language-none">&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset&#x3D;&quot;utf-8&quot;&gt;&lt;title&gt;&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;函数1、函数定义 与调用2、函数参数 、arguments3、return 返回值 结束4、作用域  ：全局变量 、局部变量&lt;br&gt;&lt;button name&#x3D;&quot;button&quot; id&#x3D;&#39;btn1&#39;&gt;点击&lt;&#x2F;button&gt;&lt;br&gt;&lt;br&gt;&lt;script&gt;&#x2F;&#x2F;1 定义 方法1 &#x2F;&#x2F; document.write(&quot;123&quot;);&#x2F;&#x2F;方法2  函数表达式  (匿名函数)var w&#x3D;function()&#123;document.write(&quot;通常将匿名函数与事件处理程序一起使用&quot;)&#125;&#x2F;&#x2F; w();&#x2F;&#x2F; document.write(&quot;123&quot;)&#x2F;&#x2F;通常将匿名函数与事件处理程序一起使用btn1.onlick&#x3D;function()&#123;w();&#125;;&#x2F;&#x2F;自调用函数-立即执行函数(function()&#123;document.write(&quot;通常将匿名函数与事件处理程序一起使用&quot;)&#125;)();document.write(&quot;&lt;br&gt;&quot;)&#x2F;&#x2F;2 函数参数  直接写形参名字function write(name1, name)&#123;document.write(&quot;hello,&quot;+name1+&quot;&lt;br&gt;&quot;);document.write(&quot;hello,&quot;+name+&quot;&lt;br&gt;&quot;);&#125;write(123,23)&#x2F;&#x2F;实参个数多于形参:只出现前面的&#x2F;&#x2F; write(1,2,3,4)&#x2F;&#x2F;实参少于形参:出现undefined&#x2F;&#x2F; write(123)&#x2F;&#x2F; arguments 对象&#x2F;&#x2F; 函数有一个名为 arguments 的内置对象。实参赋给形参使用这个参数来接收.&#x2F;&#x2F;arguments 对象类似于数组的结构（可以遍历，可以用下标访问）。&#x2F;&#x2F;如果函数调用的参数太多，则可以使用 arguments 对象来得到这些参数。function f(a, b)&#123;&#x2F;&#x2F; document.write(arguments.length+&quot;&lt;br&gt;&quot;)&#x2F;&#x2F; document.write(arguments[0]+&quot;&lt;br&gt;&quot;)&#x2F;&#x2F; document.write(arguments[1]+&quot;&lt;br&gt;&quot;)&#x2F;&#x2F; document.write(arguments[3])var max&#x3D;arguments[0]for(var i&#x3D;1; i&lt;arguments.length; i++)&#123;if(arguments[i]&gt;max)max&#x3D;arguments[i]&#125;document.write(max)&#125;f(1,2,234,3)document.write(&quot;&lt;br&gt;&quot;)var m &#x3D; new Map([[1, &#39;x&#39;], [2, &#39;y&#39;], [3, &#39;z&#39;]]);m.forEach(function (value, key, map) &#123;document.write(value+key+map+&quot;&lt;br&gt;&quot;);&#125;);&lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h2><pre class="line-numbers language-none"><code class="language-none">&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset&#x3D;&quot;utf-8&quot;&gt;&lt;title&gt;&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;JavaScript 中，变量的作用域有 全局作用域 和 局部作用域 两种。1、全局变量   函数外定义的变量   没有用 var定义的变量(let)   window对象定义的变量(window.c&#x3D;1)2、局部变量  函数内用var定义的变量              形参变量的生命周期全局变量活得和您的应用程序（窗口、网页）一样久。局部变量活得不长。它们在函数调用时创建，在函数完成后被删除。&lt;script&gt;&#x2F;&#x2F;1  全局变量var str1&#x3D;&quot; 1我是全局&quot;document.write(str1)function fn1()&#123;var str2&#x3D;&quot;我是局部&quot;  &#x2F;&#x2F;2  局部变量  使用var在函数内部定义的变量let s&#x3D;&quot;123&quot;&#125;fn1();console.log(str1);&#x2F;&#x2F; console.log(s);&#x2F;&#x2F;6  以下程序运行结果是:&#x2F;&#x2F;对Js而言，只要变量是在同一个范围（函数）里，就视为已经声明，&#x2F;&#x2F;哪怕是在变量声明前就使用&#x2F;* var num1&#x3D;10;function fn2()&#123;&#x2F;&#x2F;因为num1是局部的 fn1内部的。所以提升到fn1函数最前面声明console.log(num1);&#x2F;&#x2F;输出？undefinedvar num1&#x3D;20;&#125;fn2()*&#x2F;var a&#x3D;&quot;1111&quot;function fn3()&#123;console.log(a);var a&#x3D;&quot;2222&quot;console.log(a);&#125;fn3();&lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="获取元素"><a href="#获取元素" class="headerlink" title="获取元素"></a>获取元素</h2><pre class="line-numbers language-none"><code class="language-none">&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset&#x3D;&quot;utf-8&quot;&gt;&lt;title&gt;&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;查找元素方法：1 通过 id 查找元素&lt;br&gt;&lt;p id&#x3D;&quot;intro&quot;&gt;Hello!&lt;&#x2F;p&gt;&lt;button name&#x3D;&quot;button&quot; id&#x3D;&#39;btn0&#39;&gt;确定&lt;&#x2F;button&gt;&lt;script&gt;var p &#x3D; document.getElementById(&quot;para&quot;);&#x2F;&#x2F; document.write();var btn0 &#x3D; document.getElementById(&quot;btn0&quot;);btn0.click &#x3D; function () &#123;document.write(&quot;nihao&quot;);&#125;&lt;&#x2F;script&gt;&lt;hr&gt;2、通过标签名查找元素&lt;br&gt;&lt;ul&gt;&lt;li&gt;【#回应何时开学#】&lt;&#x2F;li&gt;&lt;li&gt;【#回应何时开学#】&lt;&#x2F;li&gt;&lt;li&gt;【#回应何时开学#】&lt;&#x2F;li&gt;&lt;li&gt;【#回应何时开学#】&lt;&#x2F;li&gt;&lt;li&gt;【#回应何时开学#】&lt;&#x2F;li&gt;&lt;li&gt;【#回应何时开学#】&lt;&#x2F;li&gt;&lt;&#x2F;ul&gt;&lt;script&gt;var lis &#x3D; document.getElementsByTagName(&#39;li&#39;);console.log(lis);for (var i &#x3D; 0; i &lt; lis.length; i++) &#123;if (i % 2 &#x3D;&#x3D; 0) &#123;lis[i].style.background &#x3D; &quot;blue&quot;;&#125;&#125;&lt;&#x2F;script&gt;&lt;hr&gt;3 html5新增的 通过 CSS 选择器查找 HTML 元素:&lt;br&gt;querySelectorAll() 方法 :查找匹配指定 CSS 选择器（id、类名、标签等）的所有 HTML 元素&lt;br&gt;querySelector() 方法 :查找匹配指定 CSS 选择器的第一个 HTML 元素&lt;br&gt;&lt;p id&#x3D;&quot;p1&quot;&gt;Hello!&lt;&#x2F;p&gt;&lt;button name&#x3D;&quot;button&quot; id&#x3D;&#39;btn1&#39;&gt;确定&lt;&#x2F;button&gt;&lt;p class&#x3D;&quot;imp&quot;&gt;Hello!&lt;&#x2F;p&gt;&lt;p class&#x3D;&quot;imp&quot;&gt;world!&lt;&#x2F;p&gt;&lt;script&gt;&#x2F;&#x2F;querySelectorAll() 方法  获得class为imp的元素   .不能少var p1 &#x3D; document.querySelectorAll(&#39;.imp&#39;)console.log(p1)&#x2F;&#x2F;querySelector（）方法   获得id为btn1的元素 #不能少var p2 &#x3D; document.querySelector(&#39;#btn1&#39;)console.log(p2)var ps &#x3D; document.querySelectorAll(&quot;.imp&quot;);console.log(ps);ps[1].innerHTML &#x3D; &quot;123456789&quot;;&lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><pre class="line-numbers language-none"><code class="language-none">&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset&#x3D;&quot;utf-8&quot;&gt;&lt;title&gt;面向对象&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;1、什么是JavaScript对象？对象是有(属性)和(方法)的集合。2、创建对象的三种方式：&lt;br&gt;01、使用new object()方式&lt;script&gt;&#x2F;&#x2F;创建var person &#x3D; new Object();&#x2F;&#x2F; console.log(person)&#x2F;&#x2F; console.log(typeof(person))&#x2F;&#x2F;设置属性和方法 person.name&#x3D;&quot;123&quot;person.age &#x3D; 18;&#x2F;&#x2F;设置方法 person.say&#x3D;function()&#123;console.log(&quot;say&quot;)&#125;&#x2F;&#x2F;访问属性&#x2F;&#x2F; console.log(person.name)&#x2F;&#x2F; console.log(person.age)&#x2F;&#x2F;调用方法&#x2F;&#x2F; person.say()&lt;&#x2F;script&gt;&lt;br&gt; 01 使用字面量定义var 对象&#x3D;&#123;&#x2F;&#x2F;键值对的形式  键 属性名 ：值 属性值，属性名 ：值，&#x2F;&#x2F;方法 冒号后面跟着一个匿名函数。方法:function()&#123;&#125;&#125;&lt;script&gt;var person &#x3D; &#123;name:&quot;123&quot;,age:123,say:function()&#123;console.log(&quot;say&quot;)&#125;&#125;&#x2F;&#x2F; person.say()&lt;&#x2F;script&gt;&lt;br&gt;3、使用自定义的构造函数声明多个类型特点一致的对象&#x2F;&#x2F;构造函数的语法格式：&#x2F;&#x2F; function 构造函数名()&#123;&#x2F;&#x2F; this.属性&#x3D;值;&#x2F;&#x2F; this.方法&#x3D;function()&#123;&#125;&#x2F;&#x2F; &#125;&#x2F;&#x2F;new 构造函数名(); 函数名首字母要大写&lt;script&gt;&#x2F;&#x2F;1创建构造函数function Person(name, age)&#123;&#x2F;&#x2F; console.log(this);this.name &#x3D; name;this.age &#x3D; age;this.say&#x3D;function()&#123;console.log(&quot;say&quot;)&#125;&#125;&#x2F;&#x2F;2通过构造函数new对象var p1 &#x3D; new Person(&quot;hzy&quot;, 18)var p2 &#x3D; new Person(&quot;hhh&quot;, 21)&#x2F;&#x2F; console.log(p1.say())&#x2F;&#x2F; p2.say()&#x2F;&#x2F;3属性访问访问2:[&#39;属性名&#39;]&#x2F;&#x2F; console.log(p1[&#39;name&#39;])&#x2F;&#x2F;01什么时候 必须用[&#39;属性名&#39;]&#x2F;&#x2F;属性名里包含特殊字符:var obj&#x3D;&#123;&#125;obj[&#39;content-type&#39;]&#x3D;&#39;text&#x2F;css&#39;&#x2F;&#x2F; obj.c-c&#x3D;&#39;123&#39;&#x2F;&#x2F;错误&#x2F;&#x2F;属性名不确定var Name&#x3D;&#39;123&#39;obj.Name&#x3D;20;&#x2F;&#x2F; console.log(obj.Name)&#x2F;&#x2F; for in 遍历属性&#x2F;&#x2F;for(变量 in 对象)&#123;&#x2F;&#x2F;&#125;&#x2F;&#x2F; for(var i in obj)&#123;&#x2F;&#x2F; console.log(&#39;&#x3D;&#x3D;&#x3D;&#x3D;&#39;, i, obj.i)&#x2F;&#x2F;undefine&#x2F;&#x2F; console.log(&#39;&#x3D;&#x3D;&#x3D;&#x3D;&#39;, i, obj[i])&#x2F;&#x2F; &#125;&lt;&#x2F;script&gt;4、相关问题-对象赋值与引用内存：栈：局部变量  全局变量堆：对象&lt;script&gt;&#x2F;&#x2F;01基本数据类型 在内存中的存储var a&#x3D;10var b&#x3D;ab&#x3D;20;console.log(a)&lt;&#x2F;script&gt;&lt;script&gt;&#x2F;&#x2F;02复杂数据类型 在内存中存储var obj1&#x3D;&#123;name:&quot;Tom&quot;&#125;var obj2&#x3D;obj1obj1.name&#x3D;&#39;123&#39;console.log(obj2.name)&lt;&#x2F;script&gt;&lt;script&gt;&#x2F;&#x2F;03基本数据类型作为函数参数&lt;&#x2F;script&gt;&lt;script&gt;&#x2F;&#x2F;04复杂数据类型作为函数参数&lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Math库"><a href="#Math库" class="headerlink" title="Math库"></a>Math库</h2><pre class="line-numbers language-none"><code class="language-none">&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset&#x3D;&quot;utf-8&quot;&gt;&lt;title&gt;&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;Math 对象Math 对象用于执行数学任务。&lt;br&gt;使用 Math 的属性和方法的语法：&lt;br&gt;var pi_value&#x3D;Math.PI;var sqrt_value&#x3D;Math.sqrt(15);&lt;br&gt;&lt;br&gt;&lt;hr&gt;&lt;script&gt;var i;i&#x3D;Math.round(5&#x2F;2) &#x2F;&#x2F;四舍五入&#x2F;&#x2F;取整 向下取整i&#x3D;Math.floor(5&#x2F;2)&#x2F;&#x2F;绝对值Math.abs(-100)&#x2F;&#x2F;随机数 0-1之间i&#x3D;Math.random()&#x2F;&#x2F;产生0-10之间的随机数？i&#x3D;Math.random()*10&#x2F;&#x2F;产生5-10之间的随机数？i&#x3D;Math.random()*5+5&#x2F;&#x2F;公式：取x到y之间的随机数:;&#x2F;&#x2F;Math.random()*(y-x)+x&#x2F;&#x2F;问题：如何产生0到10之间的随机整数？&#x2F;&#x2F;方法：先产生0-    之间的随机数 然后        .document.write(i);&#x2F;&#x2F;alert(i);&#x2F;*练习  写一个随机点菜的小程序1 创建一个数组 2 随机产生数组下标3 将下标对应的数组元素 输出来.js中定义数组:var arr&#x3D;[&quot;鱼头豆腐&quot;,&quot;红烧排骨&quot;,&quot;土豆丝&quot;,&quot;西红柿鸡蛋汤&quot;,&quot;鸦片鱼头&quot;,&quot;小鸡炖蘑菇&quot;]*&#x2F;&lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h2><pre class="line-numbers language-none"><code class="language-none">&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset&#x3D;&quot;utf-8&quot;&gt;&lt;title&gt;&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;1、静态成员&lt;script&gt;function Person(name, age) &#123;this.name &#x3D; name;this.age &#x3D; age;&#x2F;&#x2F;静态属性 类名.属性if (!Person.count) &#123;Person.count &#x3D; 0;&#125;Person.count++;&#125;&#x2F;*设置一个属性 计算创建出多少对象  需要静态成员-判定在构造函数上的属性和方法*&#x2F;Person.print &#x3D; function()&#123;alert(&quot;创建了&quot;+Person.count+&quot;对象&quot;)&#125;var p1&#x3D;new Person(&#39;qwe&#39;, 123)var p2 &#x3D; new Person(&#39;qw&#39;, 1)console.log(Person.count)Person.print()&lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="特殊的引用类型：Boolean、Number-和-String"><a href="#特殊的引用类型：Boolean、Number-和-String" class="headerlink" title="特殊的引用类型：Boolean、Number 和 String"></a>特殊的引用类型：Boolean、Number 和 String</h2><pre class="line-numbers language-none"><code class="language-none">&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset&#x3D;&quot;utf-8&quot;&gt;&lt;title&gt;&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;为了便于操作基本类型值，js还提供了 3 个特殊的引用类型：Boolean、Number 和 String。Number 对象：基本包装类型  提供数字的对象（包括整数、浮点数等）1、NaN属性：非数字（(Not a Number)。）2、isNaN（）函数：判断是否为非数字3、toString()：把数字转为字符串4、把变量转换为数值这三种 JavaScript 方法可用于将变量转换为数字：Number() 方法  可用于把其他类型转换为数值parseInt() 方法 解析一段字符串并返回整型数值。允许空格。只返回首个数字：parseFloat() 方法  解析一段字符串并返回数值。允许空格。只返回首个数字：&lt;br&gt;&lt;br&gt;&lt;hr&gt;&lt;br&gt;&lt;script&gt;&#x2F;&#x2F;1 NaN属性&#x2F;&#x2F;document.writeln(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&lt;br&gt;&quot;)&#x2F;&#x2F;2  isNaN 判断是否为非数字&#x2F;&#x2F;3、toString()：把数字转为字符串&#x2F;&#x2F;n不是数字吗？怎么会有方法&#x2F;&#x2F; 4 Number() 方法  可用于把 其它类型转换为数值    &#x2F;&#x2F;布尔类型    &#x2F;&#x2F;数字组成的字符串&#x2F;&#x2F;日期对象 &#x2F;&#x2F;字母+数字字符串 &#x2F;&#x2F;5 parseInt() 方法 解析一段字符串并返回整型数值。允许空格。只返回首个数字&lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="静态成员-1"><a href="#静态成员-1" class="headerlink" title="静态成员"></a>静态成员</h2><pre class="line-numbers language-none"><code class="language-none">&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset&#x3D;&quot;utf-8&quot;&gt;&lt;title&gt;&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;1、静态成员&lt;script&gt;function Person(name, age) &#123;this.name &#x3D; name;this.age &#x3D; age;&#x2F;&#x2F;静态属性 类名.属性if (!Person.count) &#123;Person.count &#x3D; 0;&#125;Person.count++;&#125;&#x2F;*设置一个属性 计算创建出多少对象  需要静态成员-判定在构造函数上的属性和方法*&#x2F;Person.print &#x3D; function()&#123;alert(&quot;创建了&quot;+Person.count+&quot;对象&quot;)&#125;var p1&#x3D;new Person(&#39;qwe&#39;, 123)var p2 &#x3D; new Person(&#39;qw&#39;, 1)console.log(Person.count)Person.print()&lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="原型prototype"><a href="#原型prototype" class="headerlink" title="原型prototype"></a>原型prototype</h2><pre class="line-numbers language-none"><code class="language-none">&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset&#x3D;&quot;utf-8&quot;&gt;&lt;title&gt;&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;2、构造函数问题：存在浪费内存空间问题&lt;script&gt;function Person(name,age)&#123;this.name&#x3D;name;this.age&#x3D;age;this.say&#x3D;function()&#123;console.log(&#39;hello&#39;);&#125;&#125;&#x2F;&#x2F;浪费内存空间问题var p1 &#x3D; new Person(&#39;abc&#39;, 123)var p2 &#x3D; new Person(&#39;ab&#39;, 12)&#x2F;&#x2F; console.log(p1)&#x2F;&#x2F; console.log(p2)&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;严格相等&#x2F;&#x2F;如果两个值都引用同一个对象或是函数，那么相等，否则不相等&#x2F;&#x2F; console.log(p1.say&#x3D;&#x3D;&#x3D;p2.say)&lt;&#x2F;script&gt;3 构造函数原型prototype 通过原型来实现所有对象共享方法。&lt;script&gt;function Person(name,age)&#123;this.name&#x3D;name;this.age&#x3D;age;&#125;&#x2F;&#x2F;每个构造函数 都有一个prototype属性,指向另外一个对象.console.dir(Person)&#x2F;&#x2F;我们可以把共有的方法,直接定义在prototype对象上,让所有对象实例共享.&#x2F;&#x2F;通过原型添加方法Person.prototype.say &#x3D; function()&#123;alert(&quot;hello&quot;)&#125;var p1&#x3D;new Person(&quot;tom&quot;,10);var p2&#x3D;new Person(&quot;jerry&quot;,10);console.log(p1.say&#x3D;&#x3D;&#x3D;p2.say)&lt;&#x2F;script&gt;&lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="基于原型链的继承"><a href="#基于原型链的继承" class="headerlink" title="基于原型链的继承"></a>基于原型链的继承</h2><pre class="line-numbers language-none"><code class="language-none">&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset&#x3D;&quot;utf-8&quot;&gt;&lt;title&gt;&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;1 基于原型链的继承&lt;script&gt;function Person(age)&#123;this.age&#x3D;age&#125;Person.prototype.say&#x3D;function()&#123;alert(&#39;hello world&#39;);&#125;function Student()&#123;&#125;&#x2F;&#x2F;继承&#x2F;&#x2F;1 构造父类的实例var p1&#x3D;new Person(20)&#x2F;&#x2F;2 设置为子类的原型对象Student.prototype&#x3D;p1问题：Student.prototype.constructor指向哪个构造函数&#x2F;&#x2F; console.log(Student.prototype.constructor&#x3D;&#x3D;&#x3D;p1.constructor)&#x2F;&#x2F;3 修复子类函数原型的constructor指针即可Student.prototype.constructor&#x3D;Student;var stu1&#x3D;new Student()&#x2F;&#x2F; stu1.say()&#x2F;&#x2F; console.log(stu1.age)&lt;&#x2F;script&gt;&lt;br&gt;2 存在问题：实例共享引用类型，新创建的对象都有“玩游戏”这个变量，如p1、p2&lt;script&gt;function Parent() &#123;  this.newArr &#x3D; [&quot;唱歌&quot;, &quot;跑步&quot;];&#125;function Child() &#123;  this.name &#x3D; &quot;abc&quot;;&#125;Child.prototype &#x3D; new Parent()Child.prototype.constructor &#x3D; Child&#x2F;&#x2F; 对于属性不希望继承var p1 &#x3D; new Child()p1.newArr.push(&quot;玩游戏&quot;)&#x2F;&#x2F; console.log(p1.newArr);&#x2F;&#x2F;&#x2F;var p2 &#x3D; new Child();&#x2F;&#x2F; console.log(p2.newArr)&lt;&#x2F;script&gt;&lt;br&gt;3 call函数&lt;script&gt;&#x2F;&#x2F;call函数var demo1&#x3D;&#123;name:&#39;好人:&#39;,showABC:function(param1,param2)&#123;console.log(this.name,param1,param2)&#125;&#125;demo1.showABC(&#39;张三&#39;,&#39;李四&#39;)var demo2&#x3D;&#123;name:&#39;坏人&#39;&#125;&#x2F;&#x2F;call来让demo2对象 借用demo1的showABC方法demo1.showABC.call(demo2, &quot;1&quot;, &#39;2&#39;)&lt;&#x2F;script&gt;&lt;br&gt;4 利用构造函数继承属性&lt;script&gt;function Father(uname,age)&#123;this.uname&#x3D;uname;this.age&#x3D;age;console.log(uname, age)&#125;&#x2F;&#x2F; Son想要继承Father的属性function Son(name, age)&#123;Father.call(this, name, age)&#125;console.log(Son(12, 2))&lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="对象原型proto"><a href="#对象原型proto" class="headerlink" title="对象原型proto"></a>对象原型proto</h2><pre class="line-numbers language-none"><code class="language-none">&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset&#x3D;&quot;utf-8&quot;&gt;&lt;title&gt;&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;4 对象原型__proto__请问为什么对象 可以访问原型里的方法？原因：每个对象都有一个属性__proto__指向原型prototype,所以可以使用原型对象里的方法&lt;script&gt;function Person(name,age)&#123;this.name&#x3D;name;this.age&#x3D;age;&#125;Person.prototype.sayHello &#x3D; function()&#123;alert(&quot;Hello&quot;)&#125;var p1&#x3D;new Person(&quot;tom&quot;,10);var p2&#x3D;new Person(&quot;jerry&quot;,10);&#x2F;&#x2F; 输出__proto__属性&#x2F;&#x2F; console.log(p1.__proto__)&#x2F;&#x2F; console.log(p1.__proto__&#x3D;&#x3D;&#x3D;p2.__proto__)&lt;&#x2F;script&gt;&lt;br&gt;5 原型对象的constructor构造函数原型对象里面都有一个属性constructor属性,constructor我们称为构造函数因为它指回构造函数本身.&lt;script&gt;&#x2F;&#x2F; console.log(Person.prototype.constructor)&#x2F;&#x2F;有时候 我们需要用写代码让constructor指向原来的构造函数Person.prototype &#x3D; &#123;eat: function()&#123;&#125;,study:function()&#123;&#125;,toString:function()&#123;&#125;&#125;&#x2F;&#x2F; Person.prototype.toString &#x3D; function()&#123;&#x2F;&#x2F; alert(&quot;alert&quot;)&#x2F;&#x2F; &#125;&#x2F;&#x2F;打印 constructor指向了?&#x2F;&#x2F; consoel.log(Person.prototype.constructor)&#x2F;&#x2F;可以手动让constructor指向原来的构造函数&#x2F;&#x2F; 父亲的父亲的父亲&#x2F;&#x2F; null 继承console.log(p1.__proto__.toString()&#x3D;&#x3D;&#x3D;p1.__proto__.__proto__.toString())console.log(p1.__proto__.__proto__.toString())&lt;&#x2F;script&gt;&lt;br&gt;6 原型对象的应用  扩展内置对象方法  数组也有原型对象&lt;script&gt;Array.prototype.sun &#x3D; function()&#123;var sum&#x3D;0for(var i&#x3D;0; i&gt;this.length; i++)&#123;sum+&#x3D;i;&#125;console.log(&#39;sum: &#39;+sum)return sum&#125;var arr &#x3D; [1, 2, 3, 4, 5]console.log(arr.__proto__)&lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="ES6的类"><a href="#ES6的类" class="headerlink" title="ES6的类"></a>ES6的类</h2><pre class="line-numbers language-none"><code class="language-none">&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;    &lt;title&gt;上课&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;    1、箭头函数    &lt;script&gt;        var fn &#x3D; function()&#123;            console.log(&quot;1&quot;)        &#125;        var fn1&#x3D;()&#x3D;&gt;&#123;            console.log(&quot;fn1&quot;)        &#125;        &#x2F;&#x2F; fn()        &#x2F;&#x2F; fn1()    &lt;&#x2F;script&gt;    &lt;br&gt;    2、es6中标准的类    &lt;script&gt;        class Person&#123;            name&#x3D;&quot;23&quot;            age&#x3D;&quot;20&quot;            &#x2F;&#x2F; say&#x3D;function()&#123;            &#x2F;&#x2F;     console.log(name, age)            &#x2F;&#x2F; &#125;            &#x2F;&#x2F;将函数直接添加到原型Prototype上面            say()&#123;                console.log(name, age)            &#125;        &#125;        var p1 &#x3D; new Person()        &#x2F;&#x2F; console.log(p1)        &#x2F;&#x2F; console.log(p1.prototype&#x3D;&#x3D;&#x3D;p1.__proto__)    &lt;&#x2F;script&gt;    &lt;br&gt;    3、静态成员    &lt;script&gt;        class Student&#123;            name&#x3D;&quot;2&quot;            static count&#x3D;0            static doCount()&#123;                if(!Student.count)&#123;                    Student.count&#x3D;0                &#125;                Student.count++                console.log(&quot;当前对象的个数是&quot;+Student.count)            &#125;        &#125;        var s1 &#x3D; new Student();        &#x2F;&#x2F; Student.doCount()        var s1&#x3D;new Student();        &#x2F;&#x2F; Student.doCount()        &#x2F;&#x2F; console.log(s1&#x3D;&#x3D;&#x3D;s1)    &lt;&#x2F;script&gt;    &lt;br&gt;    4、类中的构造函数    &lt;script&gt;        class Teacher&#123;            &#x2F;&#x2F; name&#x3D;&quot;tea&quot;            &#x2F;&#x2F; age&#x3D;999            &#x2F;&#x2F;私有属性 #+属性名            #name            #age            getAge()&#123;                return this.#age            &#125;            set age(age)&#123;                if(age&gt;0 &amp;&amp; age&lt;200)                    this.#age&#x3D;age                else                    console.log(&quot;数据错误&quot;)            &#125;            get name()&#123;                return this.#name            &#125;            set name(name)&#123;                this.#name&#x3D;name            &#125;            constructor(name, age)&#123;&#x2F;&#x2F;可以不用写属性                this.#name&#x3D;name                this.#age&#x3D;age            &#125;            &#x2F;&#x2F; Uncaught SyntaxError: A class may only have one constructor            &#x2F;&#x2F; constructor(name, age, ls)&#123;            &#x2F;&#x2F;     this.name&#x3D;name            &#x2F;&#x2F;     this.age&#x3D;age            &#x2F;&#x2F;     this.ls &#x3D; ls            &#x2F;&#x2F; &#125;            say()&#123;                console.log(this.name, this.age, this.#name, this.#age)&#x2F;&#x2F;            &#125;        &#125;        var t1 &#x3D; new Teacher(&quot;t&quot;, 123, &quot;2&quot;,&#39;23&#39;)        &#x2F;&#x2F; console.log(t1.getAge())        &#x2F;&#x2F; t1.say()        &#x2F;&#x2F; t1.age&#x3D;10        &#x2F;&#x2F; t1.say()        &#x2F;&#x2F; console.log(t1.age2)    &lt;&#x2F;script&gt;    &lt;br&gt;    5、继承    &lt;script&gt;        class S extends Teacher&#123;            constructor(name, age)&#123;                super(name, age)                            &#125;            say()&#123;                console.log(this.age)            &#125;        &#125;        var s &#x3D; new S(&#39;2&#39;, &#39;3&#39;)        &#x2F;&#x2F; s.say()        console.log(S.prototype)        console.log(S.__proto__)        console.log(S.__proto__.__proto__)        console.log(S.__proto__.__proto__.__proto__)        console.log(S.__proto__.__proto__.__proto__.__proto__)    &lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h2><pre class="line-numbers language-none"><code class="language-none">&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset&#x3D;&quot;utf-8&quot;&gt;&lt;title&gt;&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;BOM:浏览器对象模型 window对象 顶级对象1、window对象的方法：setInterval(调用函数，毫秒数)  定时器方法可按照指定的周期（以毫秒计）来调用函数或计算表达式。注意：调用函数有3中写法：  函数        函数名       字符串（&#39;函数名（）&#39;）&lt;br&gt;&lt;script&gt;&#x2F;&#x2F;1 函数 js函数可以作为参数&#x2F;&#x2F;window可以省略&#x2F;&#x2F; setInterval(function()&#123;&#x2F;&#x2F; console.log(&quot;hello&quot;)&#x2F;&#x2F; &#125;, 3000)&#x2F;&#x2F;2 函数名function sayHello()&#123;alert(&#39;hello&#39;);&#125;&#x2F;&#x2F; setInterval(sayHello, 3000)&#x2F;&#x2F;3 字符串（&#39;函数名（）&#39;)var tid &#x3D; setInterval(&quot;alert(&#39;hello&#39;)&quot;, 3000)&lt;&#x2F;script&gt;2、取消定时器： clearInterval() 由 setInterval() 返回的 ID 值可用作 clearInterval() 方法的参数。&lt;br&gt;&lt;button id&#x3D;&#39;btn1&#39;&gt;开启&lt;&#x2F;button&gt;&lt;button id&#x3D;&#39;btn2&#39;&gt;关闭&lt;&#x2F;button&gt;&lt;script&gt;var btn2&#x3D;document.getElementById(&quot;btn2&quot;);var btn1&#x3D;document.querySelector()btn2.onclick&#x3D;function()&#123;clearInterval(tid)&#125;&lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="函数中this指针"><a href="#函数中this指针" class="headerlink" title="函数中this指针"></a>函数中this指针</h2><pre class="line-numbers language-none"><code class="language-none">&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset&#x3D;&quot;utf-8&quot;&gt;&lt;title&gt;&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;1、this是什么？函数中的this指函数的实际调用对象。&lt;hr&gt;&lt;script&gt;&#x2F;&#x2F; console.log(this)&#x2F;&#x2F; var obj&#x3D;&#123;name:&quot;123&quot;&#125;&#x2F;&#x2F; obj.fn &#x3D; function()&#123;&#x2F;&#x2F; console.log(this)&#x2F;&#x2F; console.log(this.name)&#x2F;&#x2F; &#125;&#x2F;&#x2F; &#x2F;&#x2F; obj.fn()&#x2F;&#x2F; &#x2F;&#x2F; setTimeout(obj.fn, 1000)&#x2F;&#x2F; console.log(typeof(obj))&lt;&#x2F;script&gt;2、箭头函数的this箭头函数没有自己的this,它的this是外层作用域的this&lt;hr&gt;&lt;script&gt;function fn1()&#123;console.log(&quot;fn1-&quot;,this);&#125;var fn2&#x3D;()&#x3D;&gt;&#123;console.log(&quot;fn2&quot;,this);&#125;&#x2F;&#x2F; fn1()&#x2F;&#x2F; fn2()var obj1&#x3D;&#123;name:&quot;124&quot;,fn1,fn2,fn3:()&#x3D;&gt;&#123;console.log(this)&#125;&#125;&#x2F;&#x2F; obj1.fn1()&#x2F;&#x2F;类的this&#x2F;&#x2F; obj1.fn2()&#x2F;&#x2F;外部的window&#x2F;&#x2F; obj1.fn3()&#x2F;&#x2F;同样也是外部的windowvar obj2&#x3D;&#123;obj1&#125;console.log(obj2.obj1.fn1())console.log(obj2.obj1.fn2())console.log(obj2.obj1.fn3())&lt;&#x2F;script&gt;3、 函数是Function类的实例可以通过new Function动态创建函数对象。&lt;script&gt;var add&#x3D; new Function(&quot;x&quot;, &quot;y&quot;, &quot;return x+y&quot;)console.log(add(1, 2))&lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><pre class="line-numbers language-none"><code class="language-none">&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset&#x3D;&quot;utf-8&quot;&gt;&lt;title&gt;&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;1、js中函数可以作为参数传递&lt;br&gt;&lt;script&gt;function say (str) &#123;alert(str);&#125;&#x2F;&#x2F;01方法函数作为参数&#x2F;&#x2F; 高阶函数function fn(fun, str)&#123;fun(str)&#125;&#x2F;&#x2F; fn(say, &quot;123&quot;)&#x2F;&#x2F; setInterval(say, 3000, &quot;1&quot;)&#x2F;&#x2F;02直接将匿名函数作为参数传递给fn1方法&#x2F;&#x2F; fn(function(str)&#123;&#x2F;&#x2F; alert(str)&#x2F;&#x2F; &#125;, &quot;1111111&quot;)&lt;&#x2F;script&gt;&lt;br&gt;2、函数作为返回值&lt;script&gt;&#x2F;*希望test1函数执行时，可以记录一条日志开闭原则：对扩展开放，对修改关闭在不修改原函数的基础上，增加此功能。可以通过函数作为返回值 来动态生成一个新函数*&#x2F;function test1()&#123;var str&#x3D;&quot;heollo&quot;console.log(str)&#125;function outer(fun)&#123;return ()&#x3D;&gt;&#123;console.log(&quot;添加日志------------&quot;)fun()&#125;&#x2F;&#x2F;返回值是函数&#125;outer(test1)&#x2F;&#x2F;返回值是函数var f1&#x3D;outer(test1)&#x2F;&#x2F;接受返回值f1()&lt;&#x2F;script&gt;3、什么高阶函数&lt;br&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><pre class="line-numbers language-none"><code class="language-none">&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset&#x3D;&quot;utf-8&quot;&gt;&lt;title&gt;&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;闭包01 什么是闭包：函数A中 有一个函数B，函数B中可以访问函数A中定义的变量或者数据，此时就形成了闭包。02 闭包的功能： 使函数内部的变量在函数执行完后，仍然存活在内存中（延长了局部变量的生命周期）让函数外部可以操作函数内部的数据&lt;script&gt;&#x2F;&#x2F;1定义一个闭包function A()&#123;var num&#x3D;123function B()&#123;console.log(num)&#125;B()&#125;&#x2F;&#x2F; A()&#x2F;&#x2F;打断点之后会出现，Closure (A)，闭包&#x2F;&#x2F; console.log(num)&#x2F;&#x2F;2 在f1 外部来访问n;function f1()&#123;var n&#x3D;10return function()&#123;console.log(n)return n;&#125;&#125;&#x2F;&#x2F; console.log(n);&#x2F;&#x2F;console.log(&quot;函数外 输出局部变量n的值：&quot;+ );&#x2F;*闭包的功能： 使函数内部的变量在函数执行完后，仍然存活在内存中（延长了局部变量的生命周期）让函数外部可以操作函数内部的数据*&#x2F;&#x2F;&#x2F;3 函数执行完后 局部变量就自动释放了 ？为什么还能访问？var f2&#x3D;f1()f2()&#x2F;&#x2F;延长了n的作用周期&lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="闭包案例"><a href="#闭包案例" class="headerlink" title="闭包案例"></a>闭包案例</h2><pre class="line-numbers language-none"><code class="language-none">&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset&#x3D;&quot;utf-8&quot;&gt;&lt;title&gt;&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;1、案例一&lt;br&gt;&lt;script&gt;&#x2F;*function f1()&#123;var num&#x3D;10;num++;console.log(num);&#125;&#x2F;&#x2F;运行结果是？f1()  &#x2F;&#x2F;11f1()  &#x2F;&#x2F;11 12f1()*&#x2F;&lt;&#x2F;script&gt;如何实现累加？-闭包&lt;script&gt;function f2() &#123;var n &#x3D; 10return function () &#123;n++return n&#125;&#125;var ff &#x3D; f2()&#x2F;&#x2F; console.log(ff())&#x2F;&#x2F; console.log(ff())&#x2F;&#x2F; console.log(ff())&lt;&#x2F;script&gt;&lt;hr&gt;2、案例二：下来3个按钮，点击其中一个，提示&quot;点击的是第n个按钮&quot;：&lt;br&gt;&lt;button&gt;桔子1&lt;&#x2F;button&gt;&lt;button&gt;苹果2&lt;&#x2F;button&gt;&lt;button&gt;梨子3&lt;&#x2F;button&gt;&lt;script&gt;&#x2F;&#x2F;html5 通过css选择器获得页面元素var btns &#x3D; document.querySelectorAll(&quot;button&quot;)&#x2F;&#x2F; console.log(btns)&#x2F;&#x2F; for(var i&#x3D;0; i&lt;btns.length; i++)&#123;&#x2F;&#x2F; btns[i].index&#x3D;i+1;&#x2F;&#x2F; &#x2F;&#x2F; 注册事件&#x2F;&#x2F; btns[i].οnclick&#x3D;function()&#123;&#x2F;&#x2F; alert(&quot;点击了第&quot;+this.index+&quot;个按钮&quot;)&#x2F;&#x2F; &#125;&#x2F;&#x2F; &#125;&#x2F;&#x2F; console.log(i)&#x2F;&#x2F;闭包来获得按钮的索引for (var i &#x3D; 0; i &lt; btns.length; i++) &#123;(function (index) &#123;btns[index].onclick &#x3D; function () &#123;alert(&quot;点击了第&quot; + (index+1) + &quot;个按钮&quot;)&#125;&#125;)(i + 1);&#125;&lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>闭包：实现可以持续分别点赞。</p><pre class="line-numbers language-none"><code class="language-none">&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;meta charset&#x3D;&quot;utf-8&quot;&gt;    &lt;title&gt;&lt;&#x2F;title&gt;    &lt;style&gt;        h1&#123;            color: aquamarine;        &#125;    &lt;&#x2F;style&gt;&lt;&#x2F;head&gt;&lt;body&gt;    3、案例三&lt;hr&gt;    &lt;h1&gt;请给下列新闻投票&lt;&#x2F;h1&gt;    &lt;ul&gt;        &lt;li&gt;北京冬奥会火种抵达北京&lt;button&gt;投票&lt;&#x2F;button&gt;&lt;&#x2F;li&gt;        &lt;li&gt;31省区市新增本土确诊17例。&lt;button&gt;投票&lt;&#x2F;button&gt;&lt;&#x2F;li&gt;        &lt;li&gt;互联网公司校招名额大幅增加 核心岗位首次开放&lt;button&gt;投票&lt;&#x2F;button&gt;&lt;&#x2F;li&gt;        &lt;li&gt;多地取暖用煤价格涨超2倍&lt;button&gt;投票&lt;&#x2F;button&gt;&lt;&#x2F;li&gt;    &lt;&#x2F;ul&gt;    &lt;script&gt;        var count &#x3D; new Array()        count[0]&#x3D;0        count[1]&#x3D;0        count[2]&#x3D;0        count[3]&#x3D;0        var buttons &#x3D; document.querySelectorAll(&quot;button&quot;)        &#x2F;&#x2F; 闭包方法1        &#x2F;&#x2F; function clickCount(i)&#123;        &#x2F;&#x2F;     var n&#x3D;count[i];        &#x2F;&#x2F;     return function add()&#123;        &#x2F;&#x2F;         count[i]++;        &#x2F;&#x2F;         n++;        &#x2F;&#x2F;         return n        &#x2F;&#x2F;     &#125;        &#x2F;&#x2F; &#125;        &#x2F;&#x2F; for(var i&#x3D;0; i&lt;buttons.length; i++)&#123;        &#x2F;&#x2F;     let add1&#x3D;clickCount(i)        &#x2F;&#x2F;     buttons[i].οnclick&#x3D;function()&#123;        &#x2F;&#x2F;         this.innerHTML&#x3D;add1()+&quot;票&quot;        &#x2F;&#x2F;     &#125;        &#x2F;&#x2F; &#125;        &#x2F;&#x2F; 闭包方法2        &#x2F;&#x2F; for(var i&#x3D;0; i&lt;buttons.length; i++)&#123;        &#x2F;&#x2F;     (function(i)&#123;        &#x2F;&#x2F;         var n&#x3D;0        &#x2F;&#x2F;         buttons[i].οnclick&#x3D;function()&#123;        &#x2F;&#x2F;             n++        &#x2F;&#x2F;             this.innerHTML&#x3D;n+&quot;票&quot;        &#x2F;&#x2F;         &#125;        &#x2F;&#x2F;     &#125;)(i)        &#x2F;&#x2F; &#125;        &#x2F;&#x2F; 闭包方法3        for(var i&#x3D;0, j&#x3D;1; i&lt;buttons.length; i++)&#123;            (function(num)&#123;                buttons[i].onclick&#x3D;function()&#123;                    this.innerHTML&#x3D;num+&quot;票&quot;                    num++;                &#125;            &#125;)(j)        &#125;    &lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><pre class="line-numbers language-none"><code class="language-none">&lt;script&gt;        var rex &#x3D; new RegExp(&#x2F;abc&#x2F;);        var f1&#x3D;rex.test(&#39;abc&#39;)        var f2&#x3D;rex.test(&quot;abcdd&quot;)        console.log(f1, f2)        var reg&#x3D;&#x2F;abb&#x2F;        var s&#x3D;reg.exec(&#39;abbbbb&#39;)&#x2F;&#x2F;搜索字符串并且返回已找到的文本        console.log(s)        var rg&#x3D;&#x2F;[a-z]&#x2F;        var reg&#x3D;&#x2F;[a-zA-Z]&#123;2&#125;&#x2F;        var s&#x3D;reg.exec(&#39;a1a1v1b&#39;)        console.log(s)        var reg&#x3D;&#x2F;[zo*]&#x2F; &#x2F;&#x2F;贪婪模式 ?结束贪婪模式        var reg&#x3D;&#x2F;a&#123;3&#125;$&#x2F;        var reg&#x3D;&#x2F;s&#x2F;        var s&#x3D;reg.exec(&quot;vaaa&quot;)        console.log(s)    &lt;&#x2F;script&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="事件监听"><a href="#事件监听" class="headerlink" title="事件监听"></a>事件监听</h2><pre class="line-numbers language-none"><code class="language-none">&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset&#x3D;&quot;utf-8&quot;&gt;&lt;title&gt;&lt;&#x2F;title&gt;&lt;style&gt;#div1 &#123;width: 200px;height: 200px;background: beige;&#125;&lt;&#x2F;style&gt;&lt;&#x2F;head&gt;&lt;body&gt;1、event事件对象：是浏览器在事件触发时所创建的对象。这个对象封装了事件相关的各种信息。-通过事件对象 可以获取事件的各种信息。&lt;hr&gt;2、Dom中存在着多种不同类型的时间对象-他们的父对象都是Event&lt;hr&gt;&lt;div id&#x3D;&#39;div1&#39;&gt;&lt;&#x2F;div&gt;&lt;br&gt;&lt;button id&#x3D;&#39;btn1&#39;&gt;按钮1&lt;&#x2F;button&gt;&lt;script&gt;var div1 &#x3D; document.getElementById(&#39;div1&#39;);var div1 &#x3D; document.getElementById(&quot;div1&quot;)var btn1 &#x3D; document.getElementById(&quot;btn1&quot;)&#x2F;&#x2F; console.log(div1, btn1)div1.onclick&#x3D;function(event)&#123;&#x2F;&#x2F; console.log(event)&#x2F;&#x2F;target 触发事件的对象console.log(event.target)&#x2F;&#x2F;this&#x2F;&#x2F; console.log(this)div1.textContext&#x3D;event.clientX+&quot;  &quot;+event.clientY&#125;&#x2F;&#x2F;事件的另外一种方式:监听事件 绑定多个方法btn1.addEventListener(&#39;click&#39;, function()&#123;alert(&quot;1234&quot;)&#125;)btn1.addEventListener(&#39;click&#39;, function()&#123;alert(&quot;12345&quot;)&#125;)&lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h2><pre class="line-numbers language-none"><code class="language-none">&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset&#x3D;&quot;utf-8&quot;&gt;&lt;title&gt;&lt;&#x2F;title&gt;&lt;style&gt;#div1 &#123;width: 300px;height: 300px;background: red;&#125;#div2&#123;width: 200px;height:100px;background-color: aqua;&#125;&lt;&#x2F;style&gt;&lt;&#x2F;head&gt;&lt;body&gt;3、 事件冒泡:(bubble)是指事件向上传导当元素的事件被触发后，其父元素上的相同事件也同时触发。事件冒泡的存在简化了代码的编写，但是有时我们并不希望冒泡存在。取消事件冒泡：event.stopPropagation()&lt;div id&#x3D;&#39;div1&#39;&gt;&lt;div id&#x3D;&quot;div2&quot;&gt;&lt;&#x2F;div&gt;&lt;&#x2F;div&gt;&lt;br&gt;&lt;script&gt;var div1 &#x3D; document.getElementById(&#39;div1&#39;);div1.onclick &#x3D; function (ev) &#123;alert(&quot;div1&quot;)&#125;var div2 &#x3D; document.getElementById(&#39;div2&#39;);div2.onclick &#x3D; function (ev) &#123;&#x2F;&#x2F; 取消默认行为ev.stopPropagation()alert(&quot;div123&quot;)&#125;&lt;&#x2F;script&gt;4 取消默认行为。&lt;a id&#x3D;&#39;a1&#39; href&#x3D;&quot;https:&#x2F;&#x2F;www.ahut.edu.cn&quot;&gt;安工大&lt;&#x2F;a&gt;&lt;script&gt;var a1 &#x3D; document.getElementById(&#39;a1&#39;);a1.onclick&#x3D;function(ev)&#123;alert(&quot;安工大&quot;)&#x2F;&#x2F;取消跳转的默认行为&#x2F;&#x2F; 1.return false&#x2F;&#x2F; 2.ev.preventDefault()&#125;&lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="实现光标跟随效果"><a href="#实现光标跟随效果" class="headerlink" title="实现光标跟随效果"></a>实现光标跟随效果</h2><pre class="line-numbers language-none"><code class="language-none">&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;  &lt;meta charset&#x3D;&quot;utf-8&quot;&gt;  &lt;title&gt;实验四&lt;&#x2F;title&gt;  &lt;style&gt;    div &#123;      width: 20px;      height: 20px;      background-color: bisque;      position: absolute;    &#125;  &lt;&#x2F;style&gt;&lt;&#x2F;head&gt;&lt;body&gt;  &lt;div class&#x3D;&quot;div&quot;&gt;&lt;&#x2F;div&gt;  &lt;div class&#x3D;&quot;div&quot;&gt;&lt;&#x2F;div&gt;  &lt;div class&#x3D;&quot;div&quot;&gt;&lt;&#x2F;div&gt;  &lt;div class&#x3D;&quot;div&quot;&gt;&lt;&#x2F;div&gt;  &lt;div class&#x3D;&quot;div&quot;&gt;&lt;&#x2F;div&gt;  &lt;div class&#x3D;&quot;div&quot;&gt;&lt;&#x2F;div&gt;  &lt;div class&#x3D;&quot;div&quot;&gt;&lt;&#x2F;div&gt;  &lt;div class&#x3D;&quot;div&quot;&gt;&lt;&#x2F;div&gt;  &lt;div class&#x3D;&quot;div&quot;&gt;&lt;&#x2F;div&gt;  &lt;div class&#x3D;&quot;div&quot;&gt;&lt;&#x2F;div&gt;  &lt;div class&#x3D;&quot;div&quot;&gt;&lt;&#x2F;div&gt;  &lt;div class&#x3D;&quot;div&quot;&gt;&lt;&#x2F;div&gt;  &lt;div class&#x3D;&quot;div&quot;&gt;&lt;&#x2F;div&gt;  &lt;div class&#x3D;&quot;div&quot;&gt;&lt;&#x2F;div&gt;  &lt;div class&#x3D;&quot;div&quot;&gt;&lt;&#x2F;div&gt;  &lt;div class&#x3D;&quot;div&quot;&gt;&lt;&#x2F;div&gt;  &lt;script&gt;    var divs&#x3D;document.querySelectorAll(&quot;.div&quot;)     &#x2F;&#x2F; console.log(divs.length)    document.onmousemove &#x3D; function (ev) &#123;        divs[0].style.left&#x3D;ev.clientX+&quot;px&quot;      divs[0].style.top&#x3D;ev.clientY+&quot;px&quot;      for(var i&#x3D;15; i&gt;0; i--)&#123;        divs[i].style.left&#x3D;divs[i-1].style.left        divs[i].style.top&#x3D;divs[i-1].style.top      &#125;      &#x2F;&#x2F; for(var i&#x3D;1; i&lt;16; i++)&#123;      &#x2F;&#x2F;   divs[i].style.left&#x3D;divs[i-1].style.left      &#x2F;&#x2F;   divs[i].style.top&#x3D;divs[i-1].style.top      &#x2F;&#x2F; &#125;    &#125;    &lt;&#x2F;script&gt;  解题思路：    1. 多个div跟随光标，第一个div的位置 始终是 光标移动到的位置。    2. 第二个div，当移动的过程中，会到第一个div之前的位置，第三个div 会到第二个div 之前的位置。    3.前一个div的位置赋给当前的div  :  obj.offsetTop 指 obj 相对于父元素上侧位置，整型     obj.offsetLeft 指 obj 相对于父元素左侧位置，整型             4.最后开始，在第一个div 还没移动的时候，第10个去到第9个，第9个去到第8个的位置......最后再把第一个移动到光标的位置。    标签: JS&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>I/O多路复用（select/poll/epoll）</title>
      <link href="/2023/06/20/io-duo-lu-fu-yong-selectpollepoll/"/>
      <url>/2023/06/20/io-duo-lu-fu-yong-selectpollepoll/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h2><p>这三种模式是为了在一个线程下面尽可能多的管理很多个socket。这三种模式在不同的需求下，有着各自的优势，select和poll差不多，但并不一定是说epoll是最好的。比如我们就写个简单的几个client连接下的情况，这个时候用select就很香，代码更少一点，如果是在真实的生产环境下，肯定是用epoll好。</p><h2 id="select"><a href="#select" class="headerlink" title="select"></a>select</h2><p>select管理多个socket的fd（文件描述符，通过这个可以找到socket），在这期间select会监听所有的socket。如果没有一个socket有事件发生，这个线程会让出cpu的阻塞等待，即让该线程可以去做别的事情。如果使用普通的conncet()、accept()、recv()或recvfrom()这种函数，如果没有事件发生，就必须要阻塞，直到事件发生。</p><p>如果有事件发生，select会在他的睡眠队列里设置一个entry，当 socket 接收到网卡的数据后，就会去它的睡眠队列里遍历 entry，调用 entry 设置的 callback 方法，这个 callback 方法里就能唤醒 select !</p><p><strong>select函数原型：</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/select.h></span></span><span class="token keyword">struct</span> <span class="token class-name">timeval</span> <span class="token punctuation">&#123;</span>    time_t      tv_sec<span class="token punctuation">;</span>         <span class="token comment">/* seconds */</span>    suseconds_t tv_usec<span class="token punctuation">;</span>        <span class="token comment">/* microseconds */</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">select</span><span class="token punctuation">(</span><span class="token keyword">int</span> nfds<span class="token punctuation">,</span> fd_set <span class="token operator">*</span>readfds<span class="token punctuation">,</span> fd_set <span class="token operator">*</span>writefds<span class="token punctuation">,</span>           fd_set <span class="token operator">*</span>exceptfds<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">timeval</span> <span class="token operator">*</span> timeout<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> <strong>参数介绍：</strong></p><ul><li><p>nfds：委托给内核处理的后面三个fd_set的最大值+1，也是遍历的时候的最大值。+ readfds：传入内核处理文件描述符的读集合，内核只需要检测这些文件描述符的读缓冲区。 </p></li><li><p>传入传出参数</p></li><li><p>writefds：传入内核处理文件描述符的读集合，内核只需要检测这些文件描述符的写缓冲区。 </p></li><li><p>传入传出参数</p></li><li><p>exceptfds：文件描述符的集合，内核检测集合中文件描述符是否有异常状态 </p></li><li><p>传入传出参数</p></li><li><p>timeout：设置超时的时间，可以强制操作select()函数的阻塞状态。 </p></li><li><p>NULL：没有事件就会一直阻塞。+ 秒数：等待时间。+ 0：不等待。</p></li></ul><p><strong>返回值：</strong></p><ul><li>-1：函数调用失败了+ 0：监听的所有的socket_fd里面没有发生事件的socket_fd。+ &gt;0：返回已经就绪的socket_fd。</li></ul><p><strong>与fd_set配合的操作函数：</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 将文件描述符fd从set中删除，即把set中fd对应的标志位置0</span><span class="token keyword">void</span> <span class="token function">FD_CLR</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> fd_set<span class="token operator">*</span> set<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 将文件描述符fd添加到set中，即把set中fd对应的标志位置1</span><span class="token keyword">void</span> <span class="token function">FD_SET</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> fd_set<span class="token operator">*</span> set<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 判断文件描述符fd是否在set中，即判断文件描述符fd在set中的标志位是否为1</span><span class="token keyword">void</span> <span class="token function">FD_ISSET</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> fd_set<span class="token operator">*</span> set<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 清空set，即全部置0，用于初始化set</span><span class="token keyword">void</span> <span class="token function">FD_ZERO</span><span class="token punctuation">(</span>fd_set<span class="token operator">*</span> set<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注：fd_set 是一个128个字节的数组（位图Bitmap），128*8=1024 bit，在操作fd_set的时候，实际上操作的是每一位bit，置0还是置1，与内核中的文件描述符表的每一位都对应。</p><ul><li>0代表不检测这个文件描述符的状态（读缓冲区，写缓冲区等）+ 1代表检测这个文件描述符的状态（读缓冲区，写缓冲区等）</li></ul><p><strong>从这里可以看出select的缺点：</strong></p><ul><li>具有O(n)的无差别轮询复杂度，需要一直遍历1024位fd_set的各个位的状态+ 每次select都需要将fd_set拷贝到内核空间，开销比较大+ 需要轮询fd_set，消耗时间多+ 能够检测的最大文件描述符是1024个，这个在内核写死了</li></ul><h2 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h2><p>相对于【select】，它不使用【Bitmap】来保存已经连接的文件描述符，使用的是链表来管理，没有了1024的限制，当然还会受到系统文件描述符限制。</p><p><strong>poll的函数原型：</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;poll.h></span></span><span class="token comment">// 每个委托poll检测的fd都对应这样一个结构体</span><span class="token keyword">struct</span> <span class="token class-name">pollfd</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span>   fd<span class="token punctuation">;</span>         <span class="token comment">/* 委托内核检测的文件描述符 */</span>    <span class="token keyword">short</span> events<span class="token punctuation">;</span>     <span class="token comment">/* 委托内核检测文件描述符的什么事件 */</span>    <span class="token keyword">short</span> revents<span class="token punctuation">;</span>    <span class="token comment">/* 文件描述符实际发生的事件 -> 传出 */</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">pollfd</span> myfd<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">poll</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">pollfd</span> <span class="token operator">*</span>fds<span class="token punctuation">,</span> nfds_t nfds<span class="token punctuation">,</span> <span class="token keyword">int</span> timeout<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>函数参数介绍：</strong></p><ul><li><p>fds: 这是一个 struct pollfd 类型的数组，里边存储了待检测的文件描述符的信息，这个数组中有三个成员： </p></li><li><p>fd：委托内核检测的文件描述符+ events：委托内核检测的 fd 事件（输入、输出、错误），每一个事件有多个取值+ revents：这是一个<strong>传出参数</strong>，数据由内核写入，存储内核检测之后的结果 </p></li><li><p>读事件：POLLIN+ 写事件：POLLOUT+ 错误事件：POLLERR</p></li><li><p>nfds: 这是第一个参数数组中最后一个有效元素的下标 + 1（也可以指定参数 1 数组的元素总个数）+ timeout: 指定 poll 函数的阻塞时长 </p></li><li><p>-1：一直阻塞，直到检测的集合中有就绪的文件描述符（有事件产生）解除阻塞+ 0：不阻塞，不管检测集合中有没有已就绪的文件描述符，函数马上返回+ 大于 0：阻塞指定的毫秒（ms）数之后，解除阻塞</p></li></ul><p><strong>函数返回值：</strong></p><ul><li>失败： 返回 - 1+ 成功：返回一个大于 0 的整数，表示检测的集合中已就绪的文件描述符的总个数</li></ul><p><strong>操作函数：</strong></p><ul><li>只需要poll函数：revent中包含了这个文件描述符的事件</li></ul><p><strong>从上面可以总结出poll的特点：</strong></p><ul><li><p>对比select，使用起来更加方便（将相关的文件描述符封装到了pollfd中），但是不能跨平台，只能在Linux平台 </p></li><li><p>events参数对应select中的readfds、writefds、exceptfds的传入状态+ revents参数对应select中的readfds、writefds、exceptfds的传出状态</p></li><li>与select相差不大，需要的时间复杂度一样</li></ul><h2 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h2><p><strong>epoll的操作函数：</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/epoll.h></span></span><span class="token comment">// 创建epoll实例，通过一棵红黑树管理待检测集合</span><span class="token keyword">int</span> <span class="token function">epoll_create</span><span class="token punctuation">(</span><span class="token keyword">int</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">epoll_create1</span><span class="token punctuation">(</span><span class="token keyword">int</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//flag可以是::EPOLL_CLOEXEC</span><span class="token comment">// 管理红黑树上的文件描述符(添加、修改、删除)</span><span class="token keyword">int</span> <span class="token function">epoll_ctl</span><span class="token punctuation">(</span><span class="token keyword">int</span> epfd<span class="token punctuation">,</span> <span class="token keyword">int</span> op<span class="token punctuation">,</span> <span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">epoll_event</span> <span class="token operator">*</span>event<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 检测epoll树中是否有就绪的文件描述符</span><span class="token keyword">int</span> <span class="token function">epoll_wait</span><span class="token punctuation">(</span><span class="token keyword">int</span> epfd<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">epoll_event</span> <span class="token operator">*</span> events<span class="token punctuation">,</span> <span class="token keyword">int</span> maxevents<span class="token punctuation">,</span> <span class="token keyword">int</span> timeout<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在select/poll中低效的原因之一是它们将“添加/修改任务列表”与“等待任务列表”放在一起处理。在大部分情况下，需要监听的socket比较确定，这个时候检测去任务列表是多余的。epoll将两个步骤分开，epoll_ctl用来管理任务列表，并且使用的是红黑树结构，这种结构有利于增加、删除或修改，然后用epoll_wait检测任务列表（文件描述符）是否有事件发生，这样实现了解耦，效率大大提高。</p><p><strong>epoll_create(int size):</strong></p><ul><li><p>参数：一般指定为大于0的数就可以+ 返回值： </p></li><li><p>失败：-1，创建错误+ 成功：一个文件描述符，通过这个就可以访问epoll实例</p></li><li>用法：int epfd = epoll_create(100);</li></ul><p><strong>epoll_create1(int flags):</strong></p><ul><li>参数：flags 可以设置为0 或者EPOLL_CLOEXEC，为0时函数表现与epoll_create一致，设置为EPOLL_CLOEXEC标志与open 时的O_CLOEXEC 标志类似，即进程被替换时会关闭文件描述符。+ 返回值：与epoll_create类似</li></ul><p><strong>epoll_ctl(int epfd, int op, int fd, struct epoll_event *event):</strong></p><ul><li><p>参数： </p></li><li><p>epfd是epoll_crate的返回值，操作epoll实例+ op是一个枚举值，控制函数执行什么类型的操作 </p></li><li><p>EPOLL_CTL_ADD：添加一个fd+ EPOLL_CTL_DEL：删除一个fd+ EPOLL_CTL_MOD：修改一个fd</p></li><li><p>fd是文件描述符，即要添加 / 修改 / 删除的文件描述符+ event是epoll 事件，用来修饰第三个参数对应的文件描述符的，指定检测这个文件描述符的什么事件 </p></li><li><p>events：委托 epoll 检测的事件 </p></li><li><p>EPOLLIN：读事件，接收数据，检测读缓冲区，如果有数据该文件描述符就绪+ EPOLLOUT：写事件，发送数据，检测写缓冲区，如果可写该文件描述符就绪+ EPOLLERR：异常事件</p></li><li>data：用户数据变量，这是一个联合体类型，通常情况下使用里边的 fd 成员，用于存储待检测的文件描述符的值，在调用 epoll_wait() 函数的时候这个值会被传出。</li></ul><p><strong>看一下epoll_ctl的epoll_event结构体：</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 联合体, 多个变量共用同一块内存        </span><span class="token keyword">typedef</span> <span class="token keyword">union</span> epoll_data <span class="token punctuation">&#123;</span> <span class="token keyword">void</span>        <span class="token operator">*</span>ptr<span class="token punctuation">;</span><span class="token keyword">int</span>          fd<span class="token punctuation">;</span><span class="token comment">// 通常情况下使用这个成员, 和epoll_ctl的第三个参数相同即可</span><span class="token keyword">uint32_t</span>     u32<span class="token punctuation">;</span><span class="token keyword">uint64_t</span>     u64<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> epoll_data_t<span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">epoll_event</span> <span class="token punctuation">&#123;</span><span class="token keyword">uint32_t</span>     events<span class="token punctuation">;</span>      <span class="token comment">/* Epoll events */</span>epoll_data_t data<span class="token punctuation">;</span>        <span class="token comment">/* User data variable */</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">epoll_ctl</span><span class="token punctuation">(</span><span class="token keyword">int</span> epfd<span class="token punctuation">,</span> <span class="token keyword">int</span> op<span class="token punctuation">,</span> <span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">epoll_event</span> <span class="token operator">*</span>event<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout); </strong></p><ul><li><p>函数参数： </p></li><li><p>epfd：epoll_create () 函数的返回值，通过这个参数找到 epoll 实例+ events：传出参数，这是一个结构体数组的地址，里边存储了已就绪的文件描述符的信息+ maxevents：修饰第二个参数，结构体数组的容量（元素个数）+ timeout：如果检测的 epoll 实例中没有已就绪的文件描述符，该函数阻塞的时长，单位 ms 毫秒 </p></li><li><p>0：函数不阻塞，不管 epoll 实例中有没有就绪的文件描述符，函数被调用后都直接返回+ 大于 0：如果 epoll 实例中没有已就绪的文件描述符，函数阻塞对应的毫秒数再返回+ -1：函数一直阻塞，直到 epoll 实例中有已就绪的文件描述符之后才解除阻塞</p></li><li><p>函数返回值： </p></li><li><p>成功： </p></li><li><p>等于 0：函数是阻塞被强制解除了，没有检测到满足条件的文件描述符+ 大于 0：检测到的已就绪的文件描述符的总个数</p></li><li>失败：返回 - 1</li></ul><p><strong>epoll的两种模式 LT 和 ET</strong></p><p>二者的差异在于 level-trigger 模式下只要某个socket处于 readable/writable 状态，无论什么时候进行 epoll_wait 都会返回该 socket；而 edge-trigger 模式下只有某个 socket 从 unreadable 变为 readable 或从unwritable 变为 writable 时，epoll_wait 才会返回该 socket。</p><p>所以, 在epoll的ET模式下, 正确的读写方式为:</p><p>读: 只要可读, 就一直读, 直到返回0, 或者 errno = EAGAIN</p><p>写: 只要可写, 就一直写, 直到数据发送完, 或者 errno = EAGAIN</p><p>Wikipedia：<a href="https://en.wikipedia.org/wiki/Epoll">https://en.wikipedia.org/wiki/Epoll</a></p><p>Man手册：<a href="https://man7.org/linux/man-pages/man7/epoll.7.html">epoll(7) - Linux manual page</a></p><p>Epoll详细解释系列：<a href="https://zhuanlan.zhihu.com/p/63179839">如果这篇文章说不清epoll的本质，那就过来掐死我吧！ （1） - 知乎</a></p><p><a href="https://zhuanlan.zhihu.com/p/64138532">如果这篇文章说不清epoll的本质，那就过来掐死我吧！ （2） - 知乎</a></p><p><a href="https://zhuanlan.zhihu.com/p/64138532">如果这篇文章说不清epoll的本质，那就过来掐死我吧！ （2） - 知乎</a></p><p><a href="https://subingwen.cn/linux/epoll/">IO多路转接（复用）之epoll | 爱编程的大丙</a></p>]]></content>
      
      
      <categories>
          
          <category> c++进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Idea通过jdbc连接Mysql8.0，JDBC的API使用</title>
      <link href="/2023/06/20/idea-tong-guo-jdbc-lian-jie-mysql80jdbc-de-api-shi-yong/"/>
      <url>/2023/06/20/idea-tong-guo-jdbc-lian-jie-mysql80jdbc-de-api-shi-yong/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="首先下载jar包，点击下面的官网链接下载"><a href="#首先下载jar包，点击下面的官网链接下载" class="headerlink" title="首先下载jar包，点击下面的官网链接下载"></a>首先下载jar包，点击下面的官网链接下载</h2><p><a href="https://dev.mysql.com/downloads/connector/j/">MySQL :: Download Connector/J</a></p><p>下载完成后记得在项目里面Add as library。</p><p>JDBC的步骤：</p><p><img src="https://img-blog.csdnimg.cn/41851a67bdf347999af145599d9fabdc.png" alt=""></p><h2 id="连接的代码：（Mysql5-0以后，可以省略注册驱动那一步）"><a href="#连接的代码：（Mysql5-0以后，可以省略注册驱动那一步）" class="headerlink" title="连接的代码：（Mysql5.0以后，可以省略注册驱动那一步）"></a>连接的代码：（Mysql5.0以后，可以省略注册驱动那一步）</h2><p>jar包里面包含了注册的代码</p><p><img src="https://img-blog.csdnimg.cn/015df4e78e544fbcb38112d8c41a184d.png" alt=""></p><p><img src="https://img-blog.csdnimg.cn/3eb5653027484d63afddee0f7f8246fe.png" alt=""></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>itheima<span class="token punctuation">.</span>jdbc</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>sql<span class="token punctuation">.</span></span><span class="token class-name">Connection</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>sql<span class="token punctuation">.</span></span><span class="token class-name">DriverManager</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>sql<span class="token punctuation">.</span></span><span class="token class-name">Statement</span></span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">JDBCDemo</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span><span class="token punctuation">&#123;</span>        <span class="token comment">//注册驱动</span><span class="token comment">//        Class.forName("com.mysql.cj.jdbc.Driver");</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"哈哈哈"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//        String url="jdbc:mysql://localhost:3306/student&amp;ussl=false";</span>        <span class="token class-name">String</span> url <span class="token operator">=</span> <span class="token string">"jdbc:mysql://localhost:3306/student?useSSL=false&amp;serverTimezone=UTC"</span><span class="token punctuation">;</span>        <span class="token class-name">String</span> username<span class="token operator">=</span><span class="token string">"root"</span><span class="token punctuation">;</span>        <span class="token class-name">String</span> password<span class="token operator">=</span><span class="token string">"123456"</span><span class="token punctuation">;</span>        <span class="token comment">//获取连接</span>        <span class="token class-name">Connection</span> connection <span class="token operator">=</span> <span class="token class-name">DriverManager</span><span class="token punctuation">.</span><span class="token function">getConnection</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span> username<span class="token punctuation">,</span> password<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">String</span> sql <span class="token operator">=</span> <span class="token string">"select * from admin"</span><span class="token punctuation">;</span>        <span class="token comment">//获取执行对象</span>        <span class="token class-name">Statement</span> stat <span class="token operator">=</span> connection<span class="token punctuation">.</span><span class="token function">createStatement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">boolean</span> execute <span class="token operator">=</span> stat<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>sql<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//        while()</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>execute<span class="token punctuation">)</span><span class="token punctuation">;</span>        stat<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        connection<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 打印成功的信息 </p><p><img src="https://img-blog.csdnimg.cn/f63449695f6f49f59f89c957546fb42f.png" alt=""></p><h2 id="DriverManager"><a href="#DriverManager" class="headerlink" title="DriverManager"></a>DriverManager</h2><p><img src="https://img-blog.csdnimg.cn/cfcb67744b31484b91eddf993e349246.png" alt=""></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Class</span><span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"com.mysql.cj.jdbc.Driver"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p> 这个是最常见的注册驱动的方法，但是要注意版本（<strong>尤其注意cj加与不加</strong>）。</p><p>另外一种注册驱动的方法：</p><p><strong>System.setProperty(“jdbc.drivers”,”com.mysql.jdbc.Driver”);</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">setProperty</span><span class="token punctuation">(</span><span class="token string">"jdbc.driver"</span><span class="token punctuation">,</span><span class="token string">"com.mysql.jdbc.Driver"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//系统属性指定数据库驱动  </span><span class="token class-name">String</span> url<span class="token operator">=</span><span class="token string">"jdbc:mysql://localhost:3306/databasename"</span><span class="token punctuation">;</span><span class="token comment">//数据库连接子协议  </span><span class="token class-name">Connection</span> conn<span class="token operator">=</span><span class="token class-name">DriverManager</span><span class="token punctuation">.</span><span class="token function">getConnection</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span><span class="token string">"username"</span><span class="token punctuation">,</span><span class="token string">"password"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>可以同时导入多个jdbc驱动，中间用冒号“：”分开</p><p>比如System.setProperty(“jdbc.drivers”,”XXXDriver:XXXDriver:XXXDriver”);</p><p>这样就一次注册了三个数据库驱动</p><h2 id="事务处理"><a href="#事务处理" class="headerlink" title="事务处理"></a>事务处理</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>itheima<span class="token punctuation">.</span>jdbc</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>sql<span class="token punctuation">.</span></span><span class="token class-name">Connection</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>sql<span class="token punctuation">.</span></span><span class="token class-name">DriverManager</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>sql<span class="token punctuation">.</span></span><span class="token class-name">SQLException</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>sql<span class="token punctuation">.</span></span><span class="token class-name">Statement</span></span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">JDBCDemo</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span><span class="token punctuation">&#123;</span>        <span class="token comment">//注册驱动</span><span class="token comment">//        Class.forName("com.mysql.cj.jdbc.Driver");</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"哈哈哈"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//        String url="jdbc:mysql://localhost:3306/student&amp;ussl=false";</span>        <span class="token class-name">String</span> url <span class="token operator">=</span> <span class="token string">"jdbc:mysql://localhost:3306/student?useSSL=false&amp;serverTimezone=UTC"</span><span class="token punctuation">;</span>        <span class="token class-name">String</span> username<span class="token operator">=</span><span class="token string">"root"</span><span class="token punctuation">;</span>        <span class="token class-name">String</span> password<span class="token operator">=</span><span class="token string">"123456"</span><span class="token punctuation">;</span>        <span class="token comment">//获取连接</span>        <span class="token class-name">Connection</span> connection <span class="token operator">=</span> <span class="token class-name">DriverManager</span><span class="token punctuation">.</span><span class="token function">getConnection</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span> username<span class="token punctuation">,</span> password<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">String</span> sql0<span class="token operator">=</span><span class="token string">"update admin set password=123456 where id=1"</span><span class="token punctuation">;</span>        <span class="token class-name">String</span> sql <span class="token operator">=</span> <span class="token string">"update admin set password=12345 where id=2"</span><span class="token punctuation">;</span>        <span class="token comment">//获取执行对象</span>        <span class="token class-name">Statement</span> stat <span class="token operator">=</span> connection<span class="token punctuation">.</span><span class="token function">createStatement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        connection<span class="token punctuation">.</span><span class="token function">setAutoCommit</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//执行sql</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> count1 <span class="token operator">=</span> stat<span class="token punctuation">.</span><span class="token function">executeUpdate</span><span class="token punctuation">(</span>sql0<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>count1<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token operator">/</span><span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> count2 <span class="token operator">=</span> stat<span class="token punctuation">.</span><span class="token function">executeUpdate</span><span class="token punctuation">(</span>sql<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>count2<span class="token punctuation">)</span><span class="token punctuation">;</span>            connection<span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            connection<span class="token punctuation">.</span><span class="token function">rollback</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        stat<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        connection<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里故意抛出1/0的错误，看看是否执行了roolback()，结果证明是正确的。try块里面的数据都没有成功执行，回滚了。 </p><h2 id="Statement"><a href="#Statement" class="headerlink" title="Statement"></a>Statement</h2><p><img src="https://img-blog.csdnimg.cn/63dabf743f204232b8e37a00d024b8e4.png" alt=""></p><p><img src="https://img-blog.csdnimg.cn/9a999cd5dd264ed6953a3da5a6190ddf.png" alt=""></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>itheima<span class="token punctuation">.</span>jdbc</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>sql<span class="token punctuation">.</span></span><span class="token operator">*</span></span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">JDBCDemo</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span><span class="token punctuation">&#123;</span>        <span class="token comment">//注册驱动</span>        <span class="token comment">//Class.forName("com.mysql.cj.jdbc.Driver");</span>        <span class="token comment">//String url="jdbc:mysql://localhost:3306/student&amp;ussl=false";</span>        <span class="token class-name">String</span> url <span class="token operator">=</span> <span class="token string">"jdbc:mysql://localhost:3306/student?useSSL=false&amp;serverTimezone=UTC"</span><span class="token punctuation">;</span>        <span class="token class-name">String</span> username<span class="token operator">=</span><span class="token string">"root"</span><span class="token punctuation">;</span>        <span class="token class-name">String</span> password<span class="token operator">=</span><span class="token string">"123456"</span><span class="token punctuation">;</span>        <span class="token comment">//获取连接</span>        <span class="token class-name">Connection</span> connection <span class="token operator">=</span> <span class="token class-name">DriverManager</span><span class="token punctuation">.</span><span class="token function">getConnection</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span> username<span class="token punctuation">,</span> password<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">String</span> sql0<span class="token operator">=</span><span class="token string">"select * from admin"</span><span class="token punctuation">;</span><span class="token comment">//        String sql = "update admin set password=12345 where id=2";</span>        <span class="token comment">//获取执行对象</span>        <span class="token class-name">Statement</span> stat <span class="token operator">=</span> connection<span class="token punctuation">.</span><span class="token function">createStatement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">ResultSet</span> res<span class="token operator">=</span>stat<span class="token punctuation">.</span><span class="token function">executeQuery</span><span class="token punctuation">(</span>sql0<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>res<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//            Account a=new Account();</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"id="</span> <span class="token operator">+</span> res<span class="token punctuation">.</span><span class="token function">getInt</span><span class="token punctuation">(</span><span class="token string">"id"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"name="</span> <span class="token operator">+</span> res<span class="token punctuation">.</span><span class="token function">getString</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"password="</span> <span class="token operator">+</span> res<span class="token punctuation">.</span><span class="token function">getString</span><span class="token punctuation">(</span><span class="token string">"password"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">long</span> now <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>now<span class="token punctuation">)</span><span class="token punctuation">;</span>        res<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        stat<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        connection<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">boolean</span> <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">SQLException</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>注意ResultSet （结果集）的next的方法返回值是boolean类型，表示还有数据的话即输出来。</p><h2 id="PrepareStatement"><a href="#PrepareStatement" class="headerlink" title="PrepareStatement"></a>PrepareStatement</h2><p>作用：预编译SQL语句并且执行，预防SQL注入问题，继承于Statement。</p><p>SQL注入问题：通过操作事先设置好的SQL语句，用以达到执行代码对服务器进行攻击的方法。</p><p>常见的就是如下图所示的代码，只要输入的密码是下面那种情况的，都可以登录成功，不管你有没有那个用户名。</p><p><img src="https://img-blog.csdnimg.cn/6fbed2f983824e34be0cbd9724212d5f.png" alt=""></p><p> 演示：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>itheima<span class="token punctuation">.</span>jdbc</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">com<span class="token punctuation">.</span>mysql<span class="token punctuation">.</span>cj<span class="token punctuation">.</span>protocol<span class="token punctuation">.</span></span><span class="token class-name">Resultset</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>sql<span class="token punctuation">.</span></span><span class="token operator">*</span></span><span class="token punctuation">;</span><span class="token comment">/** * 模拟SQL注入问题 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">JDBCDemo</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span><span class="token punctuation">&#123;</span><span class="token comment">//        String url = "jdbc:mysql://localhost:3306/student?useSSL=false&amp;serverTimezone=UTC";</span>        <span class="token class-name">String</span> url <span class="token operator">=</span> <span class="token string">"jdbc:mysql://localhost:3306/student?useSSL=false&amp;serverTimezone=UTC"</span><span class="token punctuation">;</span>        <span class="token class-name">String</span> user <span class="token operator">=</span> <span class="token string">"root"</span><span class="token punctuation">;</span>        <span class="token class-name">String</span> pwd <span class="token operator">=</span> <span class="token string">"123456"</span><span class="token punctuation">;</span>        <span class="token class-name">Connection</span> conn <span class="token operator">=</span> <span class="token class-name">DriverManager</span><span class="token punctuation">.</span><span class="token function">getConnection</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span> user<span class="token punctuation">,</span> pwd<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">String</span> name<span class="token operator">=</span><span class="token string">"124"</span><span class="token punctuation">;</span>        <span class="token class-name">String</span> pas <span class="token operator">=</span> <span class="token string">"' or '1' = '1"</span><span class="token punctuation">;</span>        <span class="token class-name">String</span> sql <span class="token operator">=</span> <span class="token string">"select * from admin where name='"</span><span class="token operator">+</span>name<span class="token operator">+</span><span class="token string">"' and password = '"</span><span class="token operator">+</span>pas<span class="token operator">+</span><span class="token string">"'"</span><span class="token punctuation">;</span>        <span class="token class-name">Statement</span> stat <span class="token operator">=</span> conn<span class="token punctuation">.</span><span class="token function">createStatement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">ResultSet</span> res <span class="token operator">=</span> stat<span class="token punctuation">.</span><span class="token function">executeQuery</span><span class="token punctuation">(</span>sql<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>res<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token class-name">String</span> id<span class="token operator">=</span> res<span class="token punctuation">.</span><span class="token function">getString</span><span class="token punctuation">(</span><span class="token string">"id"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">String</span> name1 <span class="token operator">=</span> res<span class="token punctuation">.</span><span class="token function">getString</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">String</span> pass <span class="token operator">=</span> res<span class="token punctuation">.</span><span class="token function">getString</span><span class="token punctuation">(</span><span class="token string">"password"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            a<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token operator">=</span>id<span class="token punctuation">;</span>            a<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token operator">=</span>name1<span class="token punctuation">;</span>            a<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token operator">=</span>pass<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>a<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        res<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        stat<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        conn<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 输出结果：</p><p><img src="https://img-blog.csdnimg.cn/e56976874cea4e399b3e5768c33a3389.png" alt=""></p><p> 数据库里面的数据：</p><p><img src="https://img-blog.csdnimg.cn/c2fd18457e304f66bcadcdabbbf7310f.png" alt=""></p><p> 明明是密码错误，怎么会输出数据呢？</p><p>我们打印一下sql语句：</p><pre class="line-numbers language-none"><code class="language-none">select * from admin where name&#x3D;&#39;124&#39; and password &#x3D; &#39;&#39; or &#39;1&#39; &#x3D; &#39;1&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>原来where的条件一直显示为真，所以相当于：</p><pre class="line-numbers language-none"><code class="language-none">select * from admin<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>解决办法： </p><p><img src="https://img-blog.csdnimg.cn/8b5e0cddfb03400da4d6b240d73f290b.png" alt=""></p><p> 示例：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>itheima<span class="token punctuation">.</span>jdbc</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">com<span class="token punctuation">.</span>mysql<span class="token punctuation">.</span>cj<span class="token punctuation">.</span>protocol<span class="token punctuation">.</span></span><span class="token class-name">Resultset</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>sql<span class="token punctuation">.</span></span><span class="token operator">*</span></span><span class="token punctuation">;</span><span class="token comment">/** * 模拟SQL注入问题 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">JDBCDemo</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span><span class="token punctuation">&#123;</span><span class="token comment">//        String url = "jdbc:mysql://localhost:3306/student?useSSL=false&amp;serverTimezone=UTC";</span>        <span class="token class-name">String</span> url <span class="token operator">=</span> <span class="token string">"jdbc:mysql://localhost:3306/student?useSSL=false&amp;serverTimezone=UTC"</span><span class="token punctuation">;</span>        <span class="token class-name">String</span> user <span class="token operator">=</span> <span class="token string">"root"</span><span class="token punctuation">;</span>        <span class="token class-name">String</span> pwd <span class="token operator">=</span> <span class="token string">"123456"</span><span class="token punctuation">;</span>        <span class="token class-name">Connection</span> conn <span class="token operator">=</span> <span class="token class-name">DriverManager</span><span class="token punctuation">.</span><span class="token function">getConnection</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span> user<span class="token punctuation">,</span> pwd<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">String</span> name<span class="token operator">=</span><span class="token string">"124"</span><span class="token punctuation">;</span>        <span class="token class-name">String</span> pas <span class="token operator">=</span> <span class="token string">"' or '1' = '1"</span><span class="token punctuation">;</span>        <span class="token class-name">String</span> sql <span class="token operator">=</span> <span class="token string">"select * from admin where name=? and password =?"</span><span class="token punctuation">;</span>        <span class="token class-name">PreparedStatement</span> stat <span class="token operator">=</span> conn<span class="token punctuation">.</span><span class="token function">prepareStatement</span><span class="token punctuation">(</span>sql<span class="token punctuation">)</span><span class="token punctuation">;</span>        stat<span class="token punctuation">.</span><span class="token function">setString</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>        stat<span class="token punctuation">.</span><span class="token function">setString</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> pas<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">ResultSet</span> res <span class="token operator">=</span> stat<span class="token punctuation">.</span><span class="token function">executeQuery</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>res<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token class-name">String</span> id<span class="token operator">=</span> res<span class="token punctuation">.</span><span class="token function">getString</span><span class="token punctuation">(</span><span class="token string">"id"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">String</span> name1 <span class="token operator">=</span> res<span class="token punctuation">.</span><span class="token function">getString</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">String</span> pass <span class="token operator">=</span> res<span class="token punctuation">.</span><span class="token function">getString</span><span class="token punctuation">(</span><span class="token string">"password"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            a<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token operator">=</span>id<span class="token punctuation">;</span>            a<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token operator">=</span>name1<span class="token punctuation">;</span>            a<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token operator">=</span>pass<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>sql<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>a<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        res<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        stat<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        conn<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行结果：</p><p><img src="https://img-blog.csdnimg.cn/061484020c594aceb11c8dbfcde8279b.png" alt=""></p><p> 使用? 号当作sql的占位符就可以完美解决SQL注入的问题。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>idea连接安装在虚拟机ubuntu的redis</title>
      <link href="/2023/06/20/idea-lian-jie-an-zhuang-zai-xu-ni-ji-ubuntu-de-redis/"/>
      <url>/2023/06/20/idea-lian-jie-an-zhuang-zai-xu-ni-ji-ubuntu-de-redis/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="Redis的安装与开启"><a href="#Redis的安装与开启" class="headerlink" title="Redis的安装与开启"></a>Redis的安装与开启</h1><h3 id="1、Redis数据库安装过程"><a href="#1、Redis数据库安装过程" class="headerlink" title="1、Redis数据库安装过程"></a>1、Redis数据库安装过程</h3><pre><code>打开虚拟机（Ubuntu）</code></pre><h3 id="2、安装-redis"><a href="#2、安装-redis" class="headerlink" title="2、安装 redis"></a>2、安装 redis</h3><pre class="line-numbers language-none"><code class="language-none">$ sudo apt-get update     $ sudo apt-get install redis-server<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="3、启动redis"><a href="#3、启动redis" class="headerlink" title="3、启动redis"></a>3、启动redis</h3><pre class="line-numbers language-none"><code class="language-none">$ sudo service redis-server restart<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="4、查看运行状态"><a href="#4、查看运行状态" class="headerlink" title="4、查看运行状态"></a>4、查看运行状态</h3><pre class="line-numbers language-none"><code class="language-none">$ sudo ps -aux|grep redis<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/5ce600e5203e4b17895c781a5969d401.png" alt=""></p><h3 id="5、进入-redis-客户端"><a href="#5、进入-redis-客户端" class="headerlink" title="5、进入 redis 客户端"></a>5、进入 redis 客户端</h3><pre class="line-numbers language-none"><code class="language-none">$ redis-cli<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id=""><a href="#" class="headerlink" title=" "></a> </h1><p><img src="https://img-blog.csdnimg.cn/0b5e0f06166c48e888a0ded798a0ae33.png" alt=""></p><h1 id="Redis数据库Java连接"><a href="#Redis数据库Java连接" class="headerlink" title="Redis数据库Java连接"></a>Redis数据库Java连接</h1><h3 id="1、查找redis-conf文件位置"><a href="#1、查找redis-conf文件位置" class="headerlink" title="1、查找redis.conf文件位置"></a>1、查找redis.conf文件位置</h3><pre class="line-numbers language-none"><code class="language-none">$ whereis redis.conf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="2、修改文件配置项"><a href="#2、修改文件配置项" class="headerlink" title="2、修改文件配置项"></a>2、修改文件配置项</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">cd</span> /etc/redis$ <span class="token function">vim</span> redis.conf<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="1、注释掉bind"><a href="#1、注释掉bind" class="headerlink" title="1、注释掉bind"></a>1、注释掉bind</h3><p><img src="https://img-blog.csdnimg.cn/a41dbfca34894caa80793bc51e4936f9.png" alt=""></p><p>在56行前面加个#，注释掉 </p><h3 id="2、找到protected-mode设置为no"><a href="#2、找到protected-mode设置为no" class="headerlink" title="2、找到protected-mode设置为no"></a>2、找到protected-mode设置为no</h3><p><img src="https://img-blog.csdnimg.cn/c2fdf41cd5d54ddba9e1412f17026ffa.png" alt=""></p><p>把88行最后的 yes改为no。</p><h3 id="3、添加auth的密码"><a href="#3、添加auth的密码" class="headerlink" title="3、添加auth的密码"></a>3、添加auth的密码</h3><p><img src="https://img-blog.csdnimg.cn/d6029e1f6ff14dbbb72e9d3d44d06af6.png" alt=""></p><p>加上requirepass 123456 这一行</p><h3 id="4、安装防火墙"><a href="#4、安装防火墙" class="headerlink" title="4、安装防火墙"></a>4、安装防火墙</h3><p><a href="https://www.cnblogs.com/RedStand/p/13228346.html#:~:text=1%EF%BC%9A%20sudo%20apt%20install%20firewalld%20%2F%2F%E5%AE%89%E8%A3%85%E9%98%B2%E7%81%AB%E5%A2%99%202%EF%BC%9Asudo%20firewall-cmd,systemctl%20reload%20firewalld%20%2F%2F%E9%87%8D%E5%90%AF%E9%98%B2%E7%81%AB%E5%A2%99%205%EF%BC%9Asudo%20firewall-cmd%20--list-all%20%2F%2F%E6%9F%A5%E7%9C%8B%E9%98%B2%E7%81%AB%E5%A2%99%E5%88%97%E8%A1%A8">Ubuntu防火墙安装与配置 - 红色立场 - 博客园</a></p><p><a href="https://www.cnblogs.com/Adoni/p/12887983.html#:~:text=2.%E5%BC%80%E5%90%AF6379%E7%AB%AF%E5%8F%A3%20%5Broot%40vm-centos-%201%20data%5D%23%20firewall-cmd%20--zone%3D%20public,--add-port%3D%206379%20%2Ftcp%20--%20permanent%20%23%E6%98%BE%E7%A4%BA%20success%203.%E9%87%8D%E5%90%AF%E9%98%B2%E7%81%AB%E5%A2%99">Centos7开启6379端口 - 前线码农 - 博客园</a></p><h3 id="5、重启虚拟机"><a href="#5、重启虚拟机" class="headerlink" title="5、重启虚拟机"></a>5、重启虚拟机</h3><h3 id="6、启动redis"><a href="#6、启动redis" class="headerlink" title="6、启动redis"></a>6、启动redis</h3><h3 id="7、新建maven项目（Windows环境下）"><a href="#7、新建maven项目（Windows环境下）" class="headerlink" title="7、新建maven项目（Windows环境下）"></a>7、新建maven项目（Windows环境下）</h3><p>pom.xml文件</p><pre class="line-numbers language-none"><code class="language-none">&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;redis.clients&lt;&#x2F;groupId&gt;        &lt;artifactId&gt;jedis&lt;&#x2F;artifactId&gt;        &lt;version&gt;3.0.0&lt;&#x2F;version&gt;    &lt;&#x2F;dependency&gt;&lt;&#x2F;dependencies&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="测试文件："><a href="#测试文件：" class="headerlink" title="测试文件："></a>测试文件：</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">import</span> redis.clients.jedis.Jedis<span class="token punctuation">;</span>public class Main <span class="token punctuation">&#123;</span>    public static void main<span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        System.out.println<span class="token punctuation">(</span><span class="token string">"哈哈黑"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Jedis <span class="token assign-left variable">jedis</span><span class="token operator">=</span>new Jedis<span class="token punctuation">(</span><span class="token string">"自己的虚拟机上面的地址"</span>, <span class="token number">6379</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        jedis.auth<span class="token punctuation">(</span><span class="token string">"123456"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String <span class="token assign-left variable">v</span><span class="token operator">=</span>jedis.ping<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System.out.println<span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="运行结果："><a href="#运行结果：" class="headerlink" title="运行结果："></a>运行结果：</h2><p><img src="https://img-blog.csdnimg.cn/bbc8b0ff2abe4456a47f1b4183168282.png" alt=""></p><p>至此连接成功了，其他的操作也可以自己试一试了 </p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HyperLogLog（关于基数统计）</title>
      <link href="/2023/06/20/hyperloglog-guan-yu-ji-shu-tong-ji/"/>
      <url>/2023/06/20/hyperloglog-guan-yu-ji-shu-tong-ji/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>今天在复习Redis的一种在Redis 2.8.9 版本更新的结构的时候，知道了这个数据结构是基于一种优秀的算法HyperLogLog，基数统计算法（简单来说就是统计集合中的元素数量，但是对比set有了很大的优化），就去了解了一下这种算法的精妙之处。</p><h2 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h2><p>这种数据结构在Redis这种NoSQL型数据库中可以非常省内存的去统计各种计数，比如注册 IP 数、每日访问 IP 数、页面实时UV、在线用户数，共同好友数等。这个是应用场景。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">127.0</span>.0.1:6379<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">></span> PFADD k1 a b c d <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">4</span> <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">4</span> <span class="token number">5</span><span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span><span class="token number">127.0</span>.0.1:6379<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">></span> PFCOUNT k1<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">9</span><span class="token number">127.0</span>.0.1:6379<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">></span> PFADD k2 a b c d <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span><span class="token number">127.0</span>.0.1:6379<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">></span> PFMERGE k1 k2OK<span class="token number">127.0</span>.0.1:6379<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">></span> PFCOUNT k1<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">9</span><span class="token number">127.0</span>.0.1:6379<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">></span> PFADD k2 a b c <span class="token number">5</span> <span class="token number">6</span> <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">4</span><span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span><span class="token number">127.0</span>.0.1:6379<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">></span> PFCOUNT k2<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">10</span><span class="token number">127.0</span>.0.1:6379<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">></span> keys *<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"k2"</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">"k1"</span><span class="token number">127.0</span>.0.1:6379<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">></span> PFCOUNT k2<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">10</span><span class="token number">127.0</span>.0.1:6379<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">></span> PFCOUNT k1<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">9</span><span class="token number">127.0</span>.0.1:6379<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">></span> PFMERGE k1 k2 OK<span class="token number">127.0</span>.0.1:6379<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">></span> PFCOUNT k1<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">10</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从上面的示例可以看出，有三个操作：PFADD、PFCOUNT、PFMERGE。</p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>1、使用少量内存就可以统计大量的数据，比如在Redis 中一个键为12K，就可以统计2^64的数据量。</p><p>2、统计存在一定的误差，误差率整体较低，标准误差为 0.81%（但是对于一些有一定容错率的业务场景，如IP统计、在线用户数等，这种误差是可以忽略不计的）；</p><p>3、误差可以被设置辅助计算因子进行降低。</p><p>原理：来自于一篇论文<a href="http://algo.inria.fr/flajolet/Publications/FlFuGaMe07.pdf">http://algo.inria.fr/flajolet/Publications/FlFuGaMe07.pdf</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.zhihu.com/column/p/26015890">关于基数统计 - 知乎</a></p><p><a href="https://pdai.tech/md/db/nosql-redis/db-redis-data-type-special.html#hyperloglogs%E5%9F%BA%E6%95%B0%E7%BB%9F%E8%AE%A1">Redis入门 - 数据类型：3种特殊类型详解 | Java 全栈知识体系</a></p><p><a href="https://www.cnblogs.com/traditional/p/13326391.html">11. 优秀的基数统计算法—HyperLogLog - 古明地盆 - 博客园</a></p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++_中explicit的作用及用法</title>
      <link href="/2023/06/20/c-zhong-explicit-de-zuo-yong-ji-yong-fa/"/>
      <url>/2023/06/20/c-zhong-explicit-de-zuo-yong-ji-yong-fa/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p><strong>目录</strong></p><p><a href="#%C2%A0C%2B%2Bexplicit%EF%BC%88%E5%AE%98%E7%BD%91%E7%9A%84%E8%AF%B4%E6%B3%95%EF%BC%89"> C++explicit（官网的说法）</a></p><p><a href="#C%2B%2Bexplicit%20%E6%B8%85%E6%A5%9A%E7%9A%84%E8%AF%B4%E6%B3%95%EF%BC%88%E5%BB%BA%E8%AE%AE%E8%8B%B1%E6%96%87%E4%B8%8D%E5%A5%BD%E7%9A%84%E4%BB%8E%E8%BF%99%E9%87%8C%E5%BC%80%E5%A7%8B%E9%A3%9F%E7%94%A8%E5%93%A6%EF%BC%89">C++explicit 清楚的说法（建议英文不好的从这里开始食用哦）</a></p><p><a href="#C%2B%2Bexplicit%E4%BD%BF%E7%94%A8%E7%9A%84%E4%BE%8B%E5%AD%90%EF%BC%88%E5%BB%BA%E8%AE%AE%E5%96%9C%E6%AC%A2%E8%87%AA%E5%B7%B1%E6%95%B2%E4%BB%A3%E7%A0%81%E5%AE%9E%E9%AA%8C%E7%9A%84%E4%BB%8E%E8%BF%99%E9%87%8C%E5%BC%80%E5%A7%8B%E9%A3%9F%E7%94%A8%E5%93%A6%EF%BC%89">C++explicit使用的例子（建议喜欢自己敲代码实验的从这里开始食用哦）</a></p><p><a href="#%E6%80%BB%E7%BB%93">总结</a></p><h2 id="C-explicit（官网的说法）"><a href="#C-explicit（官网的说法）" class="headerlink" title="C++explicit（官网的说法）"></a>C++explicit（官网的说法）</h2><p><code>explicit</code> specifier：<a href="https://en.cppreference.com/w/cpp/language/explicit">explicit specifier - cppreference.com</a><br><code>**explicit**</code>(1)<code>**explicit (**</code> expression <code>**)**</code>(2)(since C++20)<br>expression-<a href="https://en.cppreference.com/w/cpp/language/constant_expression#Converted_constant_expression">contextually converted constant expression of type bool</a></p><p> 1) Specifies that a constructor or conversion function (since C++11) or deduction guide (since C++17) is explicit, that is, it cannot be used for implicit conversions and copy-initialization.</p><p>翻译：指定构造函数或转换函数 (C++11 起) 或推导指南 (C++17 起) 是显式的，也就是说，它不能用于隐式转换和复制初始化。</p><p>2) The explicit specifier may be used with a constant expression. The function is explicit if and only if that constant expression evaluates to true.</p><p>(since C++20) 翻译：显式说明符可以与常量表达式一起使用。当且仅当该常量表达式的计算结果为真时，该函数才是显式的。 </p><p>The explicit specifier may only appear within the decl-specifier-seq of the declaration of a constructor or conversion function (since C++11) within its class definition.</p><p>翻译：显式说明符只能出现在其类定义中的构造函数或转换函数（C++11 起）声明的 decl-specifier-seq 中。</p><h2 id="C-explicit-清楚的说法（建议英文不好的从这里开始食用哦）"><a href="#C-explicit-清楚的说法（建议英文不好的从这里开始食用哦）" class="headerlink" title="C++explicit 清楚的说法（建议英文不好的从这里开始食用哦）"></a>C++explicit 清楚的说法（建议英文不好的从这里开始食用哦）</h2><p><strong>explicit作用:</strong> 在C++中，explicit关键字用来修饰类的构造函数，被修饰的构造函数的类，不能发生相应的隐式类型转换，只能以显式的方式进行类型转换。</p><p><strong>explicit使用注意事项:</strong>       （1）explicit 关键字只能用于类内部的构造函数声明上。</p><pre><code>  （2） explicit 关键字作用于单个参数的构造函数。* 在C++中，explicit关键字用来修饰类的构造函数，被修饰的构造函数的类，不能发生相应的隐式类型转换</code></pre><h2 id="C-explicit使用的例子（建议喜欢自己敲代码实验的从这里开始食用哦）"><a href="#C-explicit使用的例子（建议喜欢自己敲代码实验的从这里开始食用哦）" class="headerlink" title="C++explicit使用的例子（建议喜欢自己敲代码实验的从这里开始食用哦）"></a>C++explicit使用的例子（建议喜欢自己敲代码实验的从这里开始食用哦）</h2><p> 例子</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;bits/stdc++.h></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Circle</span><span class="token punctuation">&#123;</span>    <span class="token keyword">public</span><span class="token operator">:</span>        <span class="token function">Circle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>        <span class="token function">Circle</span><span class="token punctuation">(</span><span class="token keyword">double</span> _a<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">a</span><span class="token punctuation">(</span>_a<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>        <span class="token function">Circle</span><span class="token punctuation">(</span><span class="token keyword">int</span> _b<span class="token punctuation">,</span> <span class="token keyword">int</span> _c<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">b</span><span class="token punctuation">(</span>_b<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">c</span><span class="token punctuation">(</span>_c<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>         <span class="token function">Circle</span><span class="token punctuation">(</span><span class="token keyword">const</span> Circle<span class="token operator">&amp;</span> A<span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            a<span class="token operator">=</span>A<span class="token punctuation">.</span>a<span class="token punctuation">;</span> b<span class="token operator">=</span>A<span class="token punctuation">.</span>b<span class="token punctuation">;</span> c<span class="token operator">=</span>A<span class="token punctuation">.</span>c<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">void</span> <span class="token function">Print</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            cout<span class="token operator">&lt;&lt;</span>a<span class="token operator">&lt;&lt;</span><span class="token string">" "</span><span class="token operator">&lt;&lt;</span>b<span class="token operator">&lt;&lt;</span><span class="token string">" "</span><span class="token operator">&lt;&lt;</span>c<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token keyword">private</span><span class="token operator">:</span>        <span class="token keyword">double</span> a<span class="token punctuation">;</span>        <span class="token keyword">int</span> b<span class="token punctuation">;</span>        <span class="token keyword">int</span> c<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Circle1</span><span class="token punctuation">&#123;</span>    <span class="token keyword">public</span><span class="token operator">:</span>        <span class="token function">Circle1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>        <span class="token keyword">explicit</span> <span class="token function">Circle1</span><span class="token punctuation">(</span><span class="token keyword">double</span> _a<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">a</span><span class="token punctuation">(</span>_a<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>        <span class="token keyword">explicit</span> <span class="token function">Circle1</span><span class="token punctuation">(</span><span class="token keyword">int</span> _b<span class="token punctuation">,</span> <span class="token keyword">int</span> _c<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">b</span><span class="token punctuation">(</span>_b<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">c</span><span class="token punctuation">(</span>_c<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>        <span class="token keyword">explicit</span> <span class="token function">Circle1</span><span class="token punctuation">(</span><span class="token keyword">const</span> Circle1<span class="token operator">&amp;</span> A<span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            a<span class="token operator">=</span>A<span class="token punctuation">.</span>a<span class="token punctuation">;</span> b<span class="token operator">=</span>A<span class="token punctuation">.</span>b<span class="token punctuation">;</span> c<span class="token operator">=</span>A<span class="token punctuation">.</span>c<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">void</span> <span class="token function">Print</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            cout<span class="token operator">&lt;&lt;</span>a<span class="token operator">&lt;&lt;</span><span class="token string">" "</span><span class="token operator">&lt;&lt;</span>b<span class="token operator">&lt;&lt;</span><span class="token string">" "</span><span class="token operator">&lt;&lt;</span>c<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token keyword">private</span><span class="token operator">:</span>        <span class="token keyword">double</span> a<span class="token punctuation">;</span>        <span class="token keyword">int</span> b<span class="token punctuation">;</span>        <span class="token keyword">int</span> c<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    Circle <span class="token function">q1</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Circle <span class="token function">w1</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    q1<span class="token punctuation">.</span><span class="token function">Print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    w1<span class="token punctuation">.</span><span class="token function">Print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">//隐式调用, 不会报错</span>    Circle q2 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">// just like Circle q(1); 调用的是Circle(double _a)</span>    Circle w2 <span class="token operator">=</span> <span class="token number">1.0</span><span class="token punctuation">;</span><span class="token comment">// just like Circle q(1.0); 调用的是Circle(double _a)</span>    Circle e <span class="token operator">=</span> q2<span class="token punctuation">;</span><span class="token comment">// 调用的是Circle(const Circle&amp; A)</span>            <span class="token comment">//隐式调用，会报错，注意Circle1()的构造函数，都有explicit</span>    <span class="token comment">// Circle1 q3 = 1;</span>    <span class="token comment">// Circle1 w3 = 1.0;</span>    <span class="token comment">// Circle1 e1 = q3;</span>    <span class="token comment">// 以上三行都会报错。</span>     <span class="token comment">//显式调用，都不会有问题</span>    Circle1 <span class="token function">q3</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Circle1 <span class="token function">w3</span><span class="token punctuation">(</span><span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Circle1 <span class="token function">e1</span><span class="token punctuation">(</span>q3<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面三行的报错信息：（这个是我原来在另外一个账号写的博客，现在账号转移到这个了）</p><p><img src="https://img-blog.csdnimg.cn/597541d462a9453d918bbb4657e54c68.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5aSc54yr56iL5bqP54y_,size_16,color_FFFFFF,t_70,g_se,x_16" alt=""></p><p><img src="https://img-blog.csdnimg.cn/ea541e17239346b9abf52c487615d072.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5aSc54yr56iL5bqP54y_,size_17,color_FFFFFF,t_70,g_se,x_16" alt=""></p><p><img src="https://img-blog.csdnimg.cn/583c79b46bd24c49953bb1a84ba525b1.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5aSc54yr56iL5bqP54y_,size_14,color_FFFFFF,t_70,g_se,x_16" alt=""></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p> explicit可以抑制内置类型隐式转换，所以在类的构造函数中，最好尽可能多用explicit关键字，防止不必要的隐式转换。  </p>]]></content>
      
      
      <categories>
          
          <category> c++基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++：前置++和后置++的运算符重载、红黑树的概念、static关键字</title>
      <link href="/2023/06/20/c-qian-zhi-he-hou-zhi-de-yun-suan-fu-chong-zai-hong-hei-shu-de-gai-nian-static-guan-jian-zi/"/>
      <url>/2023/06/20/c-qian-zhi-he-hou-zhi-de-yun-suan-fu-chong-zai-hong-hei-shu-de-gai-nian-static-guan-jian-zi/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="前置-和后置-的运算符重载"><a href="#前置-和后置-的运算符重载" class="headerlink" title="前置++和后置++的运算符重载"></a>前置++和后置++的运算符重载</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>     <span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span> <span class="token keyword">class</span> <span class="token class-name">Interge</span><span class="token punctuation">&#123;</span>     <span class="token keyword">int</span> a<span class="token punctuation">;</span> <span class="token keyword">public</span><span class="token operator">:</span>     <span class="token function">Interge</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">a</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>     <span class="token keyword">int</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">&#123;</span>         <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token operator">-></span>a<span class="token punctuation">;</span>     <span class="token punctuation">&#125;</span>     Interge<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">++</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>         <span class="token keyword">this</span><span class="token operator">-></span>a<span class="token operator">++</span><span class="token punctuation">;</span>         <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>     <span class="token punctuation">&#125;</span>     Interge <span class="token keyword">operator</span><span class="token operator">++</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>         Interge temp<span class="token operator">=</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>         <span class="token keyword">this</span><span class="token operator">-></span>a<span class="token operator">++</span><span class="token punctuation">;</span>         <span class="token keyword">return</span> temp<span class="token punctuation">;</span>     <span class="token punctuation">&#125;</span> ​ <span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>     Interge <span class="token function">i</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">int</span> a<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>     cout<span class="token operator">&lt;&lt;</span>a<span class="token operator">++</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>     cout<span class="token operator">&lt;&lt;</span>i<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>     <span class="token comment">// i++;</span>     cout<span class="token operator">&lt;&lt;</span>i<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>     i<span class="token operator">++</span><span class="token operator">++</span><span class="token punctuation">;</span>     <span class="token comment">// ++i;</span>     cout<span class="token operator">&lt;&lt;</span>i<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>     <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><p><strong>红黑树的特性</strong>:<strong>（1）每个节点或者是黑色，或者是红色。**</strong>（2）根节点是黑色。<strong><strong>（3）每个叶子节点（NIL）是黑色。 [注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！]</strong></strong>（4）如果一个节点是红色的，则它的子节点必须是黑色的。<strong>**（5）从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。</strong></p><p><strong>红黑树的应用</strong></p><p>红黑树的应用比较广泛，主要是用它来存储有序的数据，它的时间复杂度是O(log2n)，效率非常之高。<strong>例如，Java集合中的<a href="http://www.cnblogs.com/skywang12345/p/3311268.html">TreeSet</a>和<a href="http://www.cnblogs.com/skywang12345/p/3310928.html">TreeMap</a>，C++ STL中的set、map，以及Linux虚拟内存的管理，都是通过红黑树去实现的。</strong></p><h2 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h2><p>总的来说</p><ul><li>（1）修饰变量，static 修饰的静态局部变量只执行初始化一次，延长了局部变量的生命周期，直到程序运行结束以后才释放。 +  （2）修饰全局变量：全局变量只能在本文件中访问，不能在其它文件中访问， <strong>extern 外部声明</strong>也不可以。 +  （3）修饰一个函数，则这个函数的只能在本文件中调用，不能被其他文件调用。static 修饰的变量存放在全局数据区的静态变量区，包括全局静态变量和局部静态变量，都在全局数据区分配内存。初始化的时候自动初始化为 0。 +  （4）不想被释放的时候，可以使用static修饰。比如修饰函数中存放在栈空间的数组，如果不想让这个数组在函数调用结束释放可以使用 static 修饰。 +  （5）考虑到数据安全性（当程序想要使用全局变量的时候应该先考虑使用 static）。 </li></ul>]]></content>
      
      
      <categories>
          
          <category> c++基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++内存模型、编译过程、gcc命令</title>
      <link href="/2023/06/20/c-nei-cun-mo-xing-bian-yi-guo-cheng-gcc-ming-ling/"/>
      <url>/2023/06/20/c-nei-cun-mo-xing-bian-yi-guo-cheng-gcc-ming-ling/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="c-内存模型"><a href="#c-内存模型" class="headerlink" title="c++内存模型"></a>c++内存模型</h2><p>1、源代码区：存储代码的区域（类似jvm里的方法区） 2、静态区：存储<strong>静态</strong>变量和<strong>全局变量</strong>的区域（类似jvm里的方法区里的方法区） 3、栈区：存储<strong>局部变量</strong>和<strong>参数</strong>的内存区域，<strong>由系统开辟、由系统回收的内存区域</strong> 4、堆区：<strong>程序员开辟</strong>的一块内存区域用来存储对象的区域，由<strong>用户开辟和回收</strong>的内存区域。 5、常量区(字面值区)：存储const常量 指针变量能指向那些区域： 栈区、堆区、静态区、常量区、代码区</p><p><img src="https://img-blog.csdnimg.cn/aacad79859a442289a42a7b8467a614b.png" alt=""></p><p>堆区和栈区的注意点：</p><p>1、栈是向下增长，而堆是向上增长。</p><p>2、栈由系统管理，没有内存碎片，每个元素之间都是连续的；堆区存储的是程序员new出来的变量，是动态开辟的。</p><h2 id="c-编译过程"><a href="#c-编译过程" class="headerlink" title="c++编译过程"></a>c++编译过程</h2><ul><li><strong>编译预处理</strong>+ <strong>编译、优化阶段</strong>+ <strong>汇编</strong>+ <strong>链接</strong></li></ul><p><strong>链接过程</strong></p><p>主要是解决在一个文件中引用了另外的一个文件中变量或函数的问题，它将有关的目标文件彼此相连接，使得所有的这些目标文件成为一个能够被操作系统装入执行的统一整体。</p><p>在《编译原理》中我们可以了解到一个编译器对程序代码的编译主要分为下面几个过程：a) 词法分析 b) 语法分析 c) 语义分析 d) 中间代码生成 e) 代码优化 f) 目标代码生成 g) 符号表管理 h) 将多个步骤组合成趟 i) 编译器构造工具</p><h2 id="GCC编译过程"><a href="#GCC编译过程" class="headerlink" title="GCC编译过程"></a>GCC编译过程</h2><p><img src="https://img-blog.csdnimg.cn/img_convert/83d6486e62afc8830623c71b51a32dc1.png" alt=""></p><p>在Linux下使用的gcc编译器将上面几个过程捆绑在一起，简化我们的使用，但是我们依然可以通过指定不同的参数，来分别执行各个过程：<br>命令（-o后面都是自己指定的文件名字）工作内容gcc -E hello.c -o hello.i预处理gcc -S hello.c -o hello.s编译gcc hello.s -o hello.o汇编gcc hello.o -o hello链接</p><p>1.cpp的内容</p><p><img src="https://img-blog.csdnimg.cn/37e54de88a0442949d95bfd5983d6a6c.png" alt=""></p><p>执行预处理命令后： （文件名是1.cpp）</p><p><img src="https://img-blog.csdnimg.cn/a54b46b64e934fc7ab827dff5d873618.png" alt=""></p><p>一步编译运行： </p><p><img src="https://img-blog.csdnimg.cn/72c6d674b3784babb0f0d7fdc3e8fcaf.png" alt=""></p><h2 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h2><p><a href="https://paul.pub/cpp-memory-model/">C++ 内存模型</a></p><p><a href="https://www3.ntu.edu.sg/home/ehchua/programming/cpp/gcc_make.html">GCC and Make - A Tutorial on how to compile, link and build C/C++ applications</a></p><p><a href="https://blog.csdn.net/Hongwei_1990/article/details/84558733">C/C++ 编译流程（预处理、编译、汇编、链接）_deepwater_zone的博客-CSDN博客</a></p>]]></content>
      
      
      <categories>
          
          <category> c++基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++_多线程：原子操作atomic</title>
      <link href="/2023/06/20/c-duo-xian-cheng-yuan-zi-cao-zuo-atomic/"/>
      <url>/2023/06/20/c-duo-xian-cheng-yuan-zi-cao-zuo-atomic/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="原子操作atomic"><a href="#原子操作atomic" class="headerlink" title="原子操作atomic"></a>原子操作atomic</h2><p><a href="https://juejin.cn/post/7086226046931959838">C++ 多线程：原子类型</a></p><p>有两个线程，一个要写数据，一个读数据，如果不加锁，可能会造成读写值混乱，使用<code>std::mutex</code>程序执行不会导致混乱，<strong>但是每一次循环都要加锁解锁是的程序开销很大。</strong> 为了提高性能，C++11提供了原子类型(<code>std::atomic&lt;T&gt;</code>)，它提供了多线程间的原子操作，可以把原子操作理解成一种： <strong>不需要用到互斥量加锁（无锁）技术的多线程并发编程方式。</strong> 它定义在<code>&lt;atomic&gt;</code>头文件中，原子类型是封装了一个值的类型，它的访问保证不会导致数据的竞争，并且可以用于在不同的线程之间同步内存访问。从效率上来说，原子操作要比互斥量的方式效率要高。</p><p><strong>atomic类型原子操作宣告C++11来到了多线程和并行编程的时代。</strong> 相对于偏于底层的<code>pthread</code>库，C++通过定义原子类型的方式，轻松地化解了互斥访问共享数据的难题。</p><p>atomic的两个方法：load()//读取数据 store()//存储数据 fetch_add(val)//加法 fetch_sub(val)//减法 exchange()</p><p>可以用在指针对象上，但是只表示指针是原子类型，指针指向的数据不一定是，atomic<int *> ptr;</p><p>关于load、store的例子：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// atomic::load/store example</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span>       <span class="token comment">// std::cout</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;atomic></span>         <span class="token comment">// std::atomic, std::memory_order_relaxed</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;thread></span>         <span class="token comment">// std::thread</span></span>std<span class="token double-colon punctuation">::</span>atomic<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">foo</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">set_foo</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  foo<span class="token punctuation">.</span><span class="token function">store</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>memory_order_relaxed<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// set value atomically</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">print_foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">int</span> x<span class="token punctuation">;</span>  <span class="token keyword">do</span> <span class="token punctuation">&#123;</span>    x <span class="token operator">=</span> foo<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>memory_order_relaxed<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// get value atomically</span>  <span class="token punctuation">&#125;</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>x<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"foo: "</span> <span class="token operator">&lt;&lt;</span> x <span class="token operator">&lt;&lt;</span> <span class="token char">'\n'</span><span class="token punctuation">;</span>  <span class="token comment">// 10</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  std<span class="token double-colon punctuation">::</span>thread <span class="token function">first</span> <span class="token punctuation">(</span>print_foo<span class="token punctuation">)</span><span class="token punctuation">;</span>  std<span class="token double-colon punctuation">::</span>thread <span class="token function">second</span> <span class="token punctuation">(</span>set_foo<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  first<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  second<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> c++基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSDN_博客导出工具,_用于将_CSDN_博客导出为_Markdown_/_PDF</title>
      <link href="/2023/06/20/csdn-bo-ke-dao-chu-gong-ju-yong-yu-jiang-csdn-bo-ke-dao-chu-wei-markdownpdf/"/>
      <url>/2023/06/20/csdn-bo-ke-dao-chu-gong-ju-yong-yu-jiang-csdn-bo-ke-dao-chu-wei-markdownpdf/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="CSDNExporter"><a href="#CSDNExporter" class="headerlink" title="CSDNExporter"></a>CSDNExporter</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>CSDN 博客导出工具, 用于将 CSDN 博客导出为 Markdown / PDF 格式. 比较赞的地方在于, 它 不仅支持一篇博文的导出, 还支持将某个类目下的博文批量导出, 以及将导出的多篇博文汇总为 一篇, 以便用于全局搜索, 具体效果可以查看 .</p><h2 id="运行脚本"><a href="#运行脚本" class="headerlink" title="运行脚本"></a>运行脚本</h2><ul><li>Linux系统运行 启动脚本为 <code>./run.sh</code>, 使用 <code>chmod +x run.sh</code> 增加其可执行权限;(并没有测试)</li><li>Windows系统启动 启动脚本为<code>run.bat</code>, 双击打开或者在cmd中运行<code>run.bat</code>。</li></ul><h2 id="修改的地方"><a href="#修改的地方" class="headerlink" title="修改的地方"></a>修改的地方</h2><p>1、将下载的博客的图片分开保存在title…assets文件中，博客中有图片的时候才会创建图片目录，只会创建一次</p><p>utils.py 增加了一个参数title</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> html<span class="token punctuation">,</span> title<span class="token punctuation">,</span> is_win<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    self<span class="token punctuation">.</span>html <span class="token operator">=</span> html    self<span class="token punctuation">.</span>soup <span class="token operator">=</span> BeautifulSoup<span class="token punctuation">(</span>html<span class="token punctuation">,</span> <span class="token string">'html.parser'</span><span class="token punctuation">)</span>    self<span class="token punctuation">.</span>outputs <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    self<span class="token punctuation">.</span>fig_dir <span class="token operator">=</span> <span class="token string-interpolation"><span class="token string">f'./figures/</span><span class="token interpolation"><span class="token punctuation">&#123;</span>title<span class="token punctuation">&#125;</span></span><span class="token string">'</span></span><span class="token operator">+</span><span class="token string">'.assets'</span>    self<span class="token punctuation">.</span>pre <span class="token operator">=</span> <span class="token boolean">False</span>    self<span class="token punctuation">.</span>equ_inline <span class="token operator">=</span> <span class="token boolean">False</span>    self<span class="token punctuation">.</span>is_win <span class="token operator">=</span> is_win    self<span class="token punctuation">.</span>recursive<span class="token punctuation">(</span>self<span class="token punctuation">.</span>soup<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>recursive(self, soup):</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">recursive</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> soup<span class="token punctuation">)</span><span class="token punctuation">:</span>    …………    <span class="token keyword">elif</span> tag <span class="token operator">==</span> <span class="token string">'img'</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token keyword">not</span> exists<span class="token punctuation">(</span>self<span class="token punctuation">.</span>fig_dir<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment"># 博客中有图片的时候才会创建图片目录，只会创建一次</span>            os<span class="token punctuation">.</span>makedirs<span class="token punctuation">(</span>self<span class="token punctuation">.</span>fig_dir<span class="token punctuation">)</span>    …………<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2、输入用户名就可以直接找到的用户的博客专栏，拿到所有专栏下面的文章</p><p>run.bat 先将所有的categories保存在userName.txt中</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token keyword">if</span> %download_category% <span class="token operator">==</span> <span class="token string">"true"</span> <span class="token punctuation">(</span>  <span class="token builtin class-name">echo</span> <span class="token string">"Obtain blog directory link: save in userName.txt........"</span>  python <span class="token parameter variable">-u</span> link.py %userName%<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>再读取userName.txt文件的链接</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token keyword">for</span> /f <span class="token string">"tokens=* delims="</span> %%a <span class="token keyword">in</span> <span class="token punctuation">(</span>m0_67623521.txt<span class="token punctuation">)</span> <span class="token keyword">do</span> <span class="token punctuation">(</span>  <span class="token builtin class-name">echo</span> %%a  <span class="token keyword">if</span> %download_category% <span class="token operator">==</span> <span class="token string">"true"</span> <span class="token punctuation">(</span>      <span class="token builtin class-name">echo</span> <span class="token string">"Download a category"</span>      python <span class="token parameter variable">-u</span> main.py ^          <span class="token parameter variable">--category_url</span> %%a ^          <span class="token parameter variable">--start_page</span> %start_page% ^          <span class="token parameter variable">--page_num</span> %page_num% ^          <span class="token parameter variable">--markdown_dir</span> %markdown_dir% ^          <span class="token parameter variable">--pdf_dir</span> %pdf_dir% ^          <span class="token parameter variable">--combine_together</span> ^          <span class="token parameter variable">--to_pdf</span> ^          <span class="token parameter variable">--is_win</span> <span class="token number">1</span>          @REM <span class="token parameter variable">--with_title</span> ^          @REM <span class="token parameter variable">--rm_cache</span>   <span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>link.py</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">user <span class="token operator">=</span> sys<span class="token punctuation">.</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token comment"># 拿到命令行下的用户名参数</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将连接写入文件</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">for</span> li <span class="token keyword">in</span> lis<span class="token punctuation">:</span>    <span class="token comment"># print("####")</span>    url <span class="token operator">=</span> li<span class="token punctuation">.</span>find<span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>attrs<span class="token punctuation">[</span><span class="token string">'href'</span><span class="token punctuation">]</span>    title <span class="token operator">=</span> li<span class="token punctuation">.</span>find<span class="token punctuation">(</span><span class="token string">"span"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>attrs<span class="token punctuation">[</span><span class="token string">'title'</span><span class="token punctuation">]</span>    titles<span class="token punctuation">.</span>append<span class="token punctuation">(</span>title<span class="token punctuation">)</span>    infos<span class="token punctuation">[</span>title<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token string">"url"</span><span class="token punctuation">:</span>url<span class="token punctuation">&#125;</span>    <span class="token comment"># print("[+]"+title+url)</span>    <span class="token keyword">with</span> <span class="token builtin">open</span><span class="token punctuation">(</span>user<span class="token operator">+</span><span class="token string">'.txt'</span><span class="token punctuation">,</span><span class="token string">'a+'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> f<span class="token punctuation">:</span>    <span class="token comment">#设置文件对象</span>        f<span class="token punctuation">.</span>write<span class="token punctuation">(</span>url<span class="token punctuation">)</span>        f<span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">'\n'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>另外要说明的是:</p><ul><li>安装必要的 Python 库, 如 <code>httpx</code>, <code>requests</code>, <code>BeautifulSoup</code>, <code>bs4</code>;</li><li>为了解析图片链接, 需要安装 <a href="https://aria2.github.io/">aria2</a>, 并保证能在命令行启动;</li><li>为了转换为 PDF, 需要安装 <a href="https://pandoc.org/">Pandoc</a>，(博主该功能我并没有测试)。</li><li>该博客导出工具再我的需求下就是拿到md文件，现在的功能我还是比较满意</li></ul><h2 id="对于安装aria2的问题"><a href="#对于安装aria2的问题" class="headerlink" title="对于安装aria2的问题"></a>对于安装aria2的问题</h2><p>我参考了以下博文：</p><p><a href="https://blog.csdn.net/weizuer123/article/details/127411328">电脑Windows安装Aria2配置详细教程全能的下载神器</a></p><p><a href="https://www.bilibili.com/read/cv21314846?from=search">Aria2小白入门级部署</a></p><p><a href="https://tomford1986.blogspot.com/2018/01/aria2.html">超简单的Aria2使用教程</a></p><p><a href="https://controlnet.space/2021/06/08/note/aria2-setup/">Aria2傻瓜安装部署指南</a></p><p><a href="http://aria2c.com/usage.html">Aria2 &amp; YAAW 使用说明</a></p><p>如果想要下载配置好的aria2，可以在CSDN私聊<a href="https://blog.csdn.net/m0_67623521?type=blog">我的博客</a> 。</p><h2 id="Author"><a href="#Author" class="headerlink" title="Author"></a>Author</h2><p><a href="https://github.com/allenmirac/CSDNExporter">allenmirac-CSDNExporter</a></p><h1 id="巨人的肩膀"><a href="#巨人的肩膀" class="headerlink" title="巨人的肩膀"></a>巨人的肩膀</h1><p><a href="https://github.com/axzml/CSDNExporter">axzml-CSDNExporter</a></p><p><a href="https://blog.csdn.net/Eric_1993/article/details/104772437">导出 CSDN 博客至 Markdown 或 PDF 格式 (近乎完美)</a></p><p><a href="https://blog.csdn.net/qq_53381910/article/details/130816856">获取指定博主所有专栏链接及博文链接</a></p>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CPP指针的种类以及区别</title>
      <link href="/2023/06/20/cpp-zhi-zhen-de-chong-lei-yi-ji-qu-bie/"/>
      <url>/2023/06/20/cpp-zhi-zhen-de-chong-lei-yi-ji-qu-bie/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="CPP指针"><a href="#CPP指针" class="headerlink" title="CPP指针"></a>CPP指针</h1><h2 id="空指针"><a href="#空指针" class="headerlink" title="空指针"></a>空指针</h2><p>在C和C++中，用0和<code>NULL</code>都可以表示空指针</p><p>空指针误操作的后果：如果对空指针解引用，程序会崩溃，<strong>如果对空指针使用 delete 运算符，程序会忽略这个操作，不会出现异常，所以，在内存被释放之后也应该，把指针置为空指针</strong>。</p><p><strong>1、为什么空指针会出现访问异常？</strong></p><p>NULL空指针被分配的区域是一个空闲的区域，没有对应的物理空间与之对应，所以对这段空间来说，任何读操作都是非法的，并且<strong>无论何时</strong>都要保证这个区域都没有与之对应的地址（空指针区域）。</p><p><strong>2、C++ 11 的 nullptr</strong></p><p>由于 使用 0 和 <code>NULL</code> 表示空指针会出现歧义，C++ 11 推荐使用 <code>nullptr</code> ，也就是 <code>(void *)0</code>。</p><p><strong>注意：</strong> 在 Linux 平台下，要使用<code>nullptr</code>编译需要加上 <code>-std=C++11</code>参数</p><h2 id="野指针"><a href="#野指针" class="headerlink" title="野指针"></a>野指针</h2><p>指针只申明，但未初始化，就会出现，<code>int* p</code>，此时p就是野指针。</p><p><strong>规避方法：</strong> 1）指针在定义的时候，如果没地方指，就初始化为 <code>nullptr</code> 。 2）动态分配的内存被释放后，将其置为 <code>nullptr</code> 。 3）不要返回局部变量的地址。 <strong>注意：</strong> 野指针的危害比空指针要大很多，在程序中，如果访问野指针，可能会造成程序的崩溃。是<strong>可能，不是一定（因为你也不知道它初始化到底指向了哪里）</strong>，程序的表现是不稳定，增加了调试程序的难度。</p><h2 id="指针与数组名的区别"><a href="#指针与数组名的区别" class="headerlink" title="指针与数组名的区别"></a>指针与数组名的区别</h2><p>指针是一个地址占4个字节，而数组名是一种数据结构，可以通过 <code>sizeof</code> 体现出来</p><pre class="line-numbers language-none"><code class="language-none">#include&lt;iostream&gt;using namespace std;int main()&#123;  int a[10];  int *a1;  cout&lt;&lt;sizeof(a)&lt;&lt;endl;&#x2F;&#x2F;40  cout&lt;&lt;sizeof(a1)&lt;&lt;endl;&#x2F;&#x2F;4&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但是有一种特殊情况，当数组名作为<strong>函数的参数</strong>来传递的时候，他的高贵的数组结构特性已经失去了，成了一个地地道道的只拥有4个字节的<strong>平民</strong>。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">func1</span><span class="token punctuation">(</span><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    cout<span class="token operator">&lt;&lt;</span><span class="token string">"sizeof(arr): "</span><span class="token operator">&lt;&lt;</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token operator">/</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        cout<span class="token operator">&lt;&lt;</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">func2</span><span class="token punctuation">(</span><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> len<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//所以一定要加上数组的长度。</span>    cout<span class="token operator">&lt;&lt;</span><span class="token string">"sizeof(arr): "</span><span class="token operator">&lt;&lt;</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        cout<span class="token operator">&lt;&lt;</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    cout<span class="token operator">&lt;&lt;</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    <span class="token function">func1</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">func2</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//20</span><span class="token comment">//sizeof(arr): 4</span><span class="token comment">//1</span><span class="token comment">//sizeof(arr): 4</span><span class="token comment">//1</span><span class="token comment">//2</span><span class="token comment">//3</span><span class="token comment">//4</span><span class="token comment">//5</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> c++进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ inline关键字</title>
      <link href="/2023/06/20/c-inline-guan-jian-zi/"/>
      <url>/2023/06/20/c-inline-guan-jian-zi/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="inline关键字"><a href="#inline关键字" class="headerlink" title="inline关键字"></a>inline关键字</h2><p>在函数声明和定义加上，使之称为内联函数。如果一些简单的函数直接在类中声明并且定义，编译器可以将其优化为内联函数。</p><p>注：内联函数可以减少函数的执行时间：原因是它可以在使用时直接进行替换（像宏一样展开），从而避免出现参数压栈、代码生成等操作，但是如果函数体过大，编译器就不会将其作为内联函数，即使加了关键字inline，同时内联函数不能递归。</p><p>inline关键字声明的函数依旧是函数，所以会有类型检查，可以消除C语言宏的一些缺点。</p><p>关键字inline必须与函数定义放在一起才能使函数成为内联函数，仅仅将inline放在函数声明前面不起任何作用。<strong>inline是一种“用于实现”的关键字，而不是一种“用于声明”的关键字。</strong></p><p><strong>示例一</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">EXAMPLE_H</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">EXAMPLE_H</span></span> <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;atomic></span></span> <span class="token comment">// function included in multiple source files must be inline</span><span class="token keyword">inline</span> <span class="token keyword">int</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token comment">// variable with external linkage included in multiple source files must be inline</span><span class="token keyword">inline</span> std<span class="token double-colon punctuation">::</span>atomic<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">counter</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"example.h"</span></span> <span class="token keyword">int</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token operator">++</span>counter<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"example.h"</span></span> <span class="token keyword">int</span> <span class="token function">b</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token operator">++</span>counter<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例二</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span>  </span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string></span>  </span> <span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span> <span class="token keyword">class</span> <span class="token class-name">Person</span><span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span><span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>string name<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token class-name">Person</span><span class="token double-colon punctuation">::</span><span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"name:"</span> <span class="token operator">&lt;&lt;</span> name <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>Person person<span class="token punctuation">;</span>person<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"Erin"</span><span class="token punctuation">;</span>person<span class="token punctuation">.</span><span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//如果将display直接在类内定义，会被自动关联为inline函数</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><h3 id="慎用-inline"><a href="#慎用-inline" class="headerlink" title="慎用 inline"></a>慎用 inline</h3><p>内联能提高函数的执行效率，为什么不把所有的函数都定义成内联函数？如果所有的函数都是内联函数，还用得着”内联”这个关键字吗？  内联是以<strong>代码膨胀（复制）</strong>为代价，仅仅省去了函数调用的开销，从而提高函数的执行效率。  如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。</p><p><strong>以下情况不宜使用内联：</strong>  </p><p>（1）如果函数体内的代码<strong>比较长</strong>，使用内联将导致<strong>内存消耗代价较高</strong>。  </p><p>（2）如果函数体内出现<strong>循环</strong>，那么执行函数体内代码的时间要比函数调用的开销大。类的构造函数和析构函数容易让人误解成使用内联更有效。要当心<strong>构造函数和析构函数可能会隐藏一些行为</strong>，如”偷偷地”执行了<strong>基类或成员对象</strong>的构造函数和析构函数。所以<strong>不要随便地将构造函数和析构函数的定义体放在类声明中</strong>。一个好的编译器将会根据函数的定义体，自动地取消不值得的内联（这进一步说明了 inline 不应该出现在函数的声明中）。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://baike.baidu.com/item/inline/10566989">百度百科-验证</a></p><p><a href="https://en.cppreference.com/w/cpp/language/inline">inline specifier - cppreference.com</a></p>]]></content>
      
      
      <categories>
          
          <category> c++基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1020._月饼_(25)-PAT乙级真题</title>
      <link href="/2023/06/20/1020-yue-bing-25pat-yi-ji-zhen-ti/"/>
      <url>/2023/06/20/1020-yue-bing-25pat-yi-ji-zhen-ti/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="1020-月饼"><a href="#1020-月饼" class="headerlink" title="1020. 月饼"></a>1020. 月饼</h2><p>月饼是中国人在中秋佳节时吃的一种传统食品，不同地区有许多不同风味的月饼。现给定所有种类月饼的库存量、总售价、以及市场的最大需求量，请你计算可以获得的最大收益是多少。</p><p>注意：销售时允许取出一部分库存。样例给出的情形是这样的：假如我们有 3 种月饼，其库存量分别为 18、15、10 万吨，总售价分别为 75、72、45 亿元。如果市场的最大需求量只有 20 万吨，那么我们最大收益策略应该是卖出全部 15 万吨第 2 种月饼、以及 5 万吨第 3 种月饼，获得 72 + 45/2 = 94.5（亿元）。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>每个输入包含一个测试用例。每个测试用例先给出一个不超过 1000 的正整数 N 表示月饼的种类数、以及不超过 500（以万吨为单位）的正整数 D 表示市场最大需求量。随后一行给出 N 个正数表示每种月饼的库存量（以万吨为单位）；最后一行给出 N 个正数表示每种月饼的总售价（以亿元为单位）。数字间以空格分隔。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>对每组测试用例，在一行中输出最大收益，以亿元为单位并精确到小数点后 2 位。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">3</span> <span class="token number">20</span><span class="token number">18</span> <span class="token number">15</span> <span class="token number">10</span><span class="token number">75</span> <span class="token number">72</span> <span class="token number">45</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">94.50</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>代码长度限制:16 KB；时间限制：150 ms；内存限制：64 MB。</p><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;algorithm></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">mooncake</span><span class="token punctuation">&#123;</span>    <span class="token keyword">float</span> num<span class="token punctuation">,</span> price<span class="token punctuation">,</span> unit<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">bool</span> <span class="token function">cmp</span><span class="token punctuation">(</span>mooncake a<span class="token punctuation">,</span> mooncake b<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> a<span class="token punctuation">.</span>unit <span class="token operator">></span> b<span class="token punctuation">.</span>unit<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> n<span class="token punctuation">,</span> need<span class="token punctuation">;</span>    cin<span class="token operator">>></span>n<span class="token operator">>></span>need<span class="token punctuation">;</span>    vector<span class="token operator">&lt;</span>mooncake<span class="token operator">></span> <span class="token function">v</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%f"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%f"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>price<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>unit <span class="token operator">=</span> v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>price<span class="token operator">/</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>num<span class="token punctuation">;</span>    <span class="token function">sort</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> v<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> cmp<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">float</span> sum<span class="token operator">=</span><span class="token number">0.0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>num<span class="token operator">&lt;=</span>need<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            sum<span class="token operator">+=</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>price<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">else</span><span class="token punctuation">&#123;</span>            sum<span class="token operator">+=</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>unit<span class="token operator">*</span>need<span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        need<span class="token operator">-=</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>num<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%.2f"</span><span class="token punctuation">,</span> sum<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 法学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1015_Reversible_Primes（20）</title>
      <link href="/2023/06/20/1015reversibleprimes20/"/>
      <url>/2023/06/20/1015reversibleprimes20/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="1015-Reversible-Primes（20）"><a href="#1015-Reversible-Primes（20）" class="headerlink" title="1015_Reversible_Primes（20）"></a>1015_Reversible_Primes（20）</h1><h3 id="Describe"><a href="#Describe" class="headerlink" title="Describe"></a>Describe</h3><p>A <strong>reversible prime</strong> in any number system is a prime whose “reverse” in that number system is also a prime. For example in the decimal system 73 is a reversible prime because its reverse 37 is also a prime.</p><p>Now given any two positive integers N (&lt;105) and D (1&lt;D≤10), you are supposed to tell if N is a reversible prime with radix D.</p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>The input file consists of several test cases. Each case occupies a line which contains two integers N and D. The input is finished by a negative N.</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, print in one line <code>Yes</code> if N is a reversible prime with radix D, or <code>No</code> if not.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">73</span> <span class="token number">10</span><span class="token number">23</span> <span class="token number">2</span><span class="token number">23</span> <span class="token number">10</span><span class="token parameter variable">-2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">YesYesNo<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>代码长度限制                        16 KB</p><p>时间限制                                400 ms</p><p>内存限制                                64 MB</p><h3 id="Code："><a href="#Code：" class="headerlink" title="Code："></a>Code：</h3><p>刚开始题目都没有看懂，总是不能理解radix是什么意思，做题目做少了（下次看到radix就想到可能需要进制的转换）我很想知道我总是最后一个测试点过不去，刚开始只得到了16分，是因为判断素数的时候没有把1考虑进去，加上之后还是只有18分😭，希望在评论区有大佬可以帮我找到错误。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdlib.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;math.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;string.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;algorithm></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;map></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;unordered_map></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;vector></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;queue></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stack></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;string></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;set></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">bool</span> <span class="token function">isPrime</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>n<span class="token operator">&lt;=</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span> i<span class="token operator">*</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//要加上=号</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>n<span class="token operator">%</span>i<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">ONLINE_JUDGE</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span></span>    <span class="token function">freopen</span><span class="token punctuation">(</span><span class="token string">"1.txt"</span><span class="token punctuation">,</span> <span class="token string">"r"</span><span class="token punctuation">,</span> <span class="token constant">stdin</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>    <span class="token comment">//加入自己的代码</span>    <span class="token keyword">long</span> <span class="token keyword">long</span> n <span class="token punctuation">,</span>d<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>cin<span class="token operator">>></span>n<span class="token operator">>></span>d<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token number">50</span><span class="token punctuation">]</span><span class="token punctuation">,</span> index<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> flag <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>n<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">isPrime</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span>            flag<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">do</span><span class="token punctuation">&#123;</span>            arr<span class="token punctuation">[</span>index<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> n<span class="token operator">%</span>d<span class="token punctuation">;</span>            n<span class="token operator">=</span>n<span class="token operator">/</span>d<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token keyword">while</span><span class="token punctuation">(</span>n<span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>index<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            n<span class="token operator">=</span>n<span class="token operator">*</span>d<span class="token operator">+</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">isPrime</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span>            flag<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>flag<span class="token operator">==</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            cout<span class="token operator">&lt;&lt;</span><span class="token string">"Yes"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>            cout<span class="token operator">&lt;&lt;</span><span class="token string">"No"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这里贴上柳神的代码，思路基本一样的。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstdio></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cmath></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">bool</span> <span class="token function">isprime</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> sqr <span class="token operator">=</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token function">sqrt</span><span class="token punctuation">(</span>n <span class="token operator">*</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> sqr<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">%</span> i <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> n<span class="token punctuation">,</span> d<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>n<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token constant">EOF</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">isprime</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"No\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">continue</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">do</span><span class="token punctuation">&#123;</span>            arr<span class="token punctuation">[</span>len<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> n <span class="token operator">%</span> d<span class="token punctuation">;</span>            n <span class="token operator">=</span> n <span class="token operator">/</span> d<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token keyword">while</span><span class="token punctuation">(</span>n <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>            n <span class="token operator">=</span> n <span class="token operator">*</span> d <span class="token operator">+</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span> <span class="token function">isprime</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token string">"Yes\n"</span> <span class="token operator">:</span> <span class="token string">"No\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 法学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1007_Maximum_Subsequence_Sum(最大连续子段和)</title>
      <link href="/2023/06/20/1007maximumsubsequencesum-zui-da-lian-xu-zi-duan-he/"/>
      <url>/2023/06/20/1007maximumsubsequencesum-zui-da-lian-xu-zi-duan-he/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="1007-Maximum-Subsequence-Sum-最大连续子段和"><a href="#1007-Maximum-Subsequence-Sum-最大连续子段和" class="headerlink" title="1007_Maximum_Subsequence_Sum(最大连续子段和)"></a>1007_Maximum_Subsequence_Sum(最大连续子段和)</h1><p>Given a sequence of K integers { N1​, N2​, …, NK​ }. A continuous subsequence is defined to be { Ni​, Ni+1​, …, Nj​ } where 1≤i≤j≤K. The Maximum Subsequence is the continuous subsequence which has the largest sum of its elements. For example, given sequence { -2, 11, -4, 13, -5, -2 }, its maximum subsequence is { 11, -4, 13 } with the largest sum being 20.</p><p>Now you are supposed to find the largest sum, together with the first and the last numbers of the maximum subsequence.</p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. Each case occupies two lines. The first line contains a positive integer K (≤10000). The second line contains K numbers, separated by a space.</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, output in one line the largest sum, together with the first and the last numbers of the maximum subsequence. The numbers must be separated by one space, but there must be no extra space at the end of a line. In case that the maximum subsequence is not unique, output the one with the smallest indices i and j (as shown by the sample case). If all the K numbers are negative, then its maximum sum is defined to be 0, and you are supposed to output the first and the last numbers of the whole sequence.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">10</span><span class="token parameter variable">-10</span> <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">4</span> <span class="token parameter variable">-5</span> <span class="token parameter variable">-23</span> <span class="token number">3</span> <span class="token number">7</span> <span class="token parameter variable">-21</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">10</span> <span class="token number">1</span> <span class="token number">4</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>代码长度限制        16 KB；时间限制        200 ms；内存限制        64 MB；</p><h3 id="大意："><a href="#大意：" class="headerlink" title="大意："></a>大意：</h3><p>求出最大的子序列的和，以及该最大和序列的首尾元素。</p><h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h3><p>利用num记录序列长度。<strong>关键点：</strong>当sum&lt;0的时候，sum要清零，因为一个小于0的子序列对最大子序列和只有坏处，加上它只会减少。</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream></span> </span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span>  </span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdlib.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;math.h></span>   </span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;string.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;algorithm></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;map></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;unordered_map></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;vector></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;queue></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stack></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;string></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;set></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>   <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">ONLINE_JUDGE</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span>    </span>    <span class="token function">freopen</span><span class="token punctuation">(</span><span class="token string">"1.txt"</span><span class="token punctuation">,</span> <span class="token string">"r"</span><span class="token punctuation">,</span> <span class="token constant">stdin</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span> </span>    <span class="token comment">//加入自己的代码</span>    <span class="token keyword">int</span> n<span class="token punctuation">;</span>    cin<span class="token operator">>></span>n<span class="token punctuation">;</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">v</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">res</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> sum<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> max<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> num<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        cin<span class="token operator">>></span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        sum<span class="token operator">+=</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        num<span class="token operator">++</span><span class="token punctuation">;</span><span class="token comment">//记录序列长度</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>sum<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            sum<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>            num<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>sum<span class="token operator">></span>max<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//最开始这里写的if导致一直有测试点不过！！！</span>            max<span class="token operator">=</span>sum<span class="token punctuation">;</span><span class="token comment">//             cout&lt;&lt;"sum:"&lt;&lt;sum&lt;&lt;endl;</span>            res<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span>v<span class="token punctuation">[</span>i<span class="token operator">-</span>num<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//+1，记得</span>            res<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>max<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        cout<span class="token operator">&lt;&lt;</span><span class="token number">0</span><span class="token operator">&lt;&lt;</span><span class="token string">" "</span><span class="token operator">&lt;&lt;</span>v<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span><span class="token string">" "</span><span class="token operator">&lt;&lt;</span>v<span class="token punctuation">[</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>        cout<span class="token operator">&lt;&lt;</span>max<span class="token operator">&lt;&lt;</span><span class="token string">" "</span><span class="token operator">&lt;&lt;</span>res<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span><span class="token string">" "</span><span class="token operator">&lt;&lt;</span>res<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 法学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/06/19/hello-world/"/>
      <url>/2023/06/19/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
